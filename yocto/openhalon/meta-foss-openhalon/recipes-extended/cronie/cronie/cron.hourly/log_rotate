#!/usr/bin/env python

# Copyright (c) 2015, 2010, 2011, 2012 Nicira, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at:
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


# This python script reads logrotate configs from DB and updates in /etc/logrotate.ovs
# Executes logrotation and transfer compressed log via tftp



import argparse
import os
import sys
import time
from time import sleep

import ovs.dirs
from ovs.db import error
from ovs.db import types
import ovs.daemon
import ovs.db.idl
import ovs.unixctl
import ovs.unixctl.server

from os import system
from commands import getoutput
import os

# ovs definitions
idl = None
# HALON_TODO: Need to pull this from the build env
def_db = 'unix:/var/run/openvswitch/db.sock'

# HALON_TODO: Need to pull these three from the build env
ovs_schema = '/usr/share/openvswitch/vswitch.ovsschema'

#vlog = ovs.vlog.Vlog("logrotate")

# Default conf file values

period = "hourly"
rotate_count = 1
remoteIP = "0"
rotate_string = "rotate " + str(rotate_count)
size_string = "10M"
target = "local"
table_name = "Open_vSwitch"
retry_max_count = 3

def readDB():

    global idl

    global period
    global remoteIP
    global size_string
    global target

    parser = argparse.ArgumentParser()

    remote = def_db
    schema_helper = ovs.db.idl.SchemaHelper(location=ovs_schema)
    schema_helper.register_columns(table_name, \
        ["logrotate_config"])

    idl = ovs.db.idl.Idl(remote, schema_helper)
    seqno = idl.change_seqno    # Sequence number when we last processed the db

    while seqno == idl.change_seqno:
            idl.run()

    if (len(idl.tables[table_name].rows) > 0):
           for ovs_rec in idl.tables[table_name].rows.itervalues():
                 logrotate_rec = dict(ovs_rec.logrotate_config)
                 print("Reading logrotate config from DB")
                 period = logrotate_rec.get('period','daily')
                 size_string = logrotate_rec.get('maxsize','10')
                 target = logrotate_rec.get('target','local')
                 remoteIP = logrotate_rec.get('ip','127.0.0.1')
    else:
           print("Using default config")

    idl.close()

def generateConfFile():
    global period
    global rotate_string
    global size_string

    size_string += 'M'
    system("rm -f /etc/logrotate.ovs")
    try:
        with open('/etc/logrotate.ovs','w') as conf_file:
            conf_file.write("/var/log/auth.log \n")
            conf_file.write("/var/log/messages \n")
            conf_file.write("{\n")
            conf_file.write("    "+ period +"\n")
            conf_file.write("    maxsize " + size_string + "\n")
            conf_file.write("    create 0664 root utmp\n")
            conf_file.write("    missingok\n")
            conf_file.write("    notifempty\n")
            conf_file.write("    "+ rotate_string+"\n")
            conf_file.write("    compress\n")
            conf_file.write("    sharedscripts\n")
            conf_file.write("    postrotate\n")
            conf_file.write("        killall -HUP rsyslogd\n")
            conf_file.write("    endscript\n")
            conf_file.write("}\n")

    except IOError:
        print("/etc/logrotate.ovs: file open failed")
        return False
    else:
        return True

# clear old compressed logs and renames rotated log files with time extension

def cleanLogfiles(path):
    system("cd " + path + "; ls *.1.gz > /tmp/compressed_files")
    try:
        with open('/tmp/compressed_files','r') as compress_file:
            for line in compress_file:
                offset = line.find('.1.gz')
                fileName = line[0:offset]
                yearSuffix = getoutput('date +"%Y"')
                system("cd " + path + ";rm -f " + fileName + "-" + yearSuffix + "*")
                timeSuffix = getoutput('date +"%Y%m%d%H"')
                system("cd " + path + ";mv " + fileName + ".1.gz " + fileName + "-" + timeSuffix + ".gz")
            compress_file.close()
        system("rm -f /tmp/compressed_files")
    except IOError:
        print("compressed file (/tmp/compressed_files): open failed")
        return False
    else:
        return True

def sendTftp(command):
    global retry_max_count
    retry = True
    retry_count = 1
    while (retry):
        output = getoutput(command)
        if 'Transfer timed out' in output:
            print("Tftp Retry: iteration " + str(retry_count) + " failed")
            if (retry_count >= retry_max_count):
                retry = False
            retry_count = retry_count + 1
        else:
            print("Tftp transfer iteration " + str(retry_count) + ": success")
            retry = False


def sendLogFiles(path):
    global remoteIP

    system("cd " + path + "; ls *.gz > /tmp/tftp_files")
    try:

        with open('/tmp/tftp_files','r') as tftp_file:
            for line in tftp_file:
                with open('/tmp/tftp_put','w') as tftp_command:
                    tftp_command.write("binary\n")
                    tftp_command.write("timeout 5\n")
                    tftp_command.write("put "+ line + "\n")
                    tftp_command.write("quit\n")
                    tftp_command.close()
                print("Sending compressed log " + line + " through tftp")
                tftp_string ="cd " + path + ";" +"tftp " + remoteIP + "< /tmp/tftp_put"
                sendTftp(tftp_string)
                system("rm -f /tmp/tftp_put")
            tftp_file.close()
        system("rm -f /tmp/tftp_files")
    except IOError:
        print("TFTP files (/tmp/tftp_put,/tmp/tftp_files): file open failed")
        return False
    else:
        return True

def main():

    readDB()

    if(generateConfFile()):
        print("Executing logrotate with generated config")
        system("logrotate /etc/logrotate.ovs")
    else:
        print("Executing logrotate with default config")
        system("logrotate /etc/logrotate_default.ovs")

    cleanLogfiles("/var/log/")


    if target == "remote":
        sendLogFiles("/var/log/")


if __name__ == '__main__':
    try:
        main()
    except SystemExit:
        # Let system.exit() calls complete normally
        raise
    except:
        print("traceback")
        sys.exit(ovs.daemon.RESTART_EXIT_CODE)
