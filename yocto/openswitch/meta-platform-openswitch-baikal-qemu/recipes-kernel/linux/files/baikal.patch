diff -rcNP linux-4.4.24/arch/mips/baikal/baikal-apb.c linux-4.4.24-baikal/arch/mips/baikal/baikal-apb.c
*** linux-4.4.24/arch/mips/baikal/baikal-apb.c	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/arch/mips/baikal/baikal-apb.c	2016-11-11 14:49:51.000000000 +0300
***************
*** 0 ****
--- 1,202 ----
+ /*
+  * Baikal-T SOC platform support code. APB Terminator driver.
+  *
+  * Copyright (C) 2014  Baikal Electronics OJSC
+  *
+  * This program is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU General Public License
+  * as published by the Free Software Foundation; either version 2
+  * of the License, or (at your option) any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; if not, write to the Free Software
+  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+  */
+ 
+ #include <linux/interrupt.h>
+ #include <linux/device.h>
+ #include <linux/module.h>
+ #include <linux/of_platform.h>
+ #include <linux/sysfs.h>
+ 
+ #define VERSION	"1.02"
+ 
+ #define BE_APB_IRQ_CTRL		0x00
+ #define BE_APB_FAULT_ADDR	0x04
+ #define BE_APB_FAULT_TEST	0x10
+ 
+ #define BE_APB_IRQ_MASK		(1 << 1)
+ #define BE_APB_IRQ_PEND		(1 << 0)
+ 
+ struct be_apb {
+ 	struct device *dev;
+ 	void __iomem *regs;
+ 	int	irq;
+ 	unsigned int count;
+ 	unsigned int addr;
+ };
+ 
+ #ifdef CONFIG_SYSFS
+ static ssize_t show_count(struct device *dev, struct device_attribute *attr, char *buf)
+ {
+ 	struct platform_device *pdev = to_platform_device(dev);
+ 	struct be_apb *apb = platform_get_drvdata(pdev);
+ 
+ 	return scnprintf(buf, PAGE_SIZE, "%u\n", apb->count);
+ }
+ static DEVICE_ATTR(errors, S_IWUSR | S_IRUGO, show_count, NULL);
+ 
+ static ssize_t show_addr(struct device *dev, struct device_attribute *attr, char *buf)
+ {
+ 	struct platform_device *pdev = to_platform_device(dev);
+ 	struct be_apb *apb = platform_get_drvdata(pdev);
+ 
+ 	return scnprintf(buf, PAGE_SIZE, "%08x\n", apb->addr);
+ }
+ static DEVICE_ATTR(addr, S_IWUSR | S_IRUGO, show_addr, NULL);
+ 
+ static ssize_t show_test(struct device *dev, struct device_attribute *attr, char *buf)
+ {
+ 	return scnprintf(buf, PAGE_SIZE, "Test APB exception\n");
+ }
+ static ssize_t store_test(struct device *dev, struct device_attribute *attr,
+                  const char *buf, size_t count)
+ {
+ 	struct platform_device *pdev = to_platform_device(dev);
+ 	struct be_apb *apb = platform_get_drvdata(pdev);
+ 	/* Dummy write */
+ 	writel(0, apb->regs + BE_APB_FAULT_TEST);
+ 	/* Never occurs */
+ 	return count;
+ }
+ static DEVICE_ATTR(test, S_IWUSR | S_IRUGO, show_test, store_test);
+ 
+ static void be_apb_sysfs_init(struct device *dev)
+ {
+ 	int ret;
+ 	/* Errors count */
+ 	ret = sysfs_create_file(&dev->kobj, &dev_attr_errors.attr);
+ 	if (ret)
+ 		return;
+ 	/* Last error address */
+ 	ret = sysfs_create_file(&dev->kobj, &dev_attr_addr.attr);
+ 	if (ret)
+ 		goto __err2;
+ 	/* Test entry */
+ 	ret = sysfs_create_file(&dev->kobj, &dev_attr_test.attr);
+ 	if (ret)
+ 		goto __err1;
+ 	return;
+ __err1:
+ 	sysfs_remove_file(&dev->kobj, &dev_attr_addr.attr);
+ __err2:
+ 	sysfs_remove_file(&dev->kobj, &dev_attr_errors.attr);
+ }
+ 
+ static void be_apb_sysfs_remove(struct device *dev)
+ {
+ 	sysfs_remove_file(&dev->kobj, &dev_attr_errors.attr);
+ 	sysfs_remove_file(&dev->kobj, &dev_attr_addr.attr);
+ 	sysfs_remove_file(&dev->kobj, &dev_attr_test.attr);
+ }
+ #else
+ static void be_apb_sysfs_init(struct device *dev) {}
+ static void be_apb_sysfs_remove(struct device *dev) {}
+ #endif
+ 
+ static irqreturn_t be_apb_irq(int irq, void *data)
+ {
+ 	struct be_apb *apb = (struct be_apb *)data;
+ 	/* Get fault address */
+ 	apb->addr = readl(apb->regs + BE_APB_FAULT_ADDR);
+ 	/* Alert */
+ 	dev_crit_ratelimited(apb->dev,
+ 		"Peripherial Bus IOMEM access error handled at %08x\n", apb->addr);
+ 	/* Increase counter (in irq handler it is atomic) */
+ 	apb->count += 1;
+ 	/* Unmask and clear IRQ */
+ 	writel(BE_APB_IRQ_MASK, apb->regs + BE_APB_IRQ_CTRL);
+ 	/* Return success */
+ 	return IRQ_HANDLED;
+ }
+ 
+ static int be_apb_probe(struct platform_device *pdev)
+ {
+ 	struct be_apb *apb;
+ 	struct resource *res;
+ 	int ret;
+ 
+ 	apb = devm_kzalloc(&pdev->dev, sizeof(*apb), GFP_KERNEL);
+ 	if (!apb)
+ 		return -ENOMEM;
+ 
+ 	apb->dev = &pdev->dev;
+ 	
+ 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+ 	apb->regs = devm_ioremap_resource(&pdev->dev, res);
+ 	if (IS_ERR(apb->regs))
+ 		return PTR_ERR(apb->regs);
+ 
+ 	/* Try to get IRQ resource */
+ 	apb->irq = platform_get_irq(pdev, 0);
+ 	if (apb->irq < 0)
+ 		return -EIO;
+ 
+ 	/* Request IRQ */
+ 	ret = request_irq(apb->irq, be_apb_irq,
+ 					IRQF_SHARED, "be-apb", (void *)apb);
+ 	if (ret)
+ 		return ret;
+ 
+ 	/* Unmask and clear IRQ */
+ 	writel(BE_APB_IRQ_MASK, apb->regs + BE_APB_IRQ_CTRL);
+ 	/* Register sysfs entries */
+ 	be_apb_sysfs_init(&pdev->dev);
+ 
+ 	dev_info(&pdev->dev, "Baikal Peripheral Bus Error handler\n");
+ 	dev_info(&pdev->dev, "Version " VERSION "\n");
+ 
+ 	return 0;
+ }
+ 
+ static int be_apb_remove(struct platform_device *pdev)
+ {
+ 	struct be_apb *apb = platform_get_drvdata(pdev);
+ 	/* Free IRQ resource */
+ 	free_irq(apb->irq, (void *)apb);
+ 	/* Free sysfs */
+ 	be_apb_sysfs_remove(apb->dev);
+ 	/* Return success */
+ 	return 0;
+ }
+ 
+ #ifdef CONFIG_OF
+ static const struct of_device_id be_apb_of_match[] = {
+ 	{ .compatible = "be,apb-ehb", },
+ 	{ /* sentinel */ }
+ };
+ MODULE_DEVICE_TABLE(of, be_apb_of_match);
+ #endif
+ 
+ static struct platform_driver be_apb_driver = {
+ 	.probe		= be_apb_probe,
+ 	.remove		= be_apb_remove,
+ 	.driver		= {
+ 		.name	= "be-apb",
+ 		.owner	= THIS_MODULE,
+ #ifdef CONFIG_OF
+ 		.of_match_table = of_match_ptr(be_apb_of_match),
+ #endif /* CONFIG_OF */
+ 	},
+ };
+ module_platform_driver(be_apb_driver);
+ MODULE_VERSION(VERSION);
+ MODULE_AUTHOR("Dmitry Dunaev <dmitry.dunaev@baikalelectronics.ru>");
+ MODULE_DESCRIPTION("Baikal Electronics APB Terminator Driver");
+ MODULE_LICENSE("Dual BSD/GPL");
+ MODULE_ALIAS("platform:be_apb");
diff -rcNP linux-4.4.24/arch/mips/baikal/baikal-axi.c linux-4.4.24-baikal/arch/mips/baikal/baikal-axi.c
*** linux-4.4.24/arch/mips/baikal/baikal-axi.c	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/arch/mips/baikal/baikal-axi.c	2016-11-11 14:49:51.000000000 +0300
***************
*** 0 ****
--- 1,233 ----
+ /*
+  * Baikal-T SOC platform support code. AXI Terminator driver.
+  *
+  * Copyright (C) 2014-2016 Baikal Electronics JSC
+  *
+  * This program is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU General Public License
+  * as published by the Free Software Foundation; either version 2
+  * of the License, or (at your option) any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; if not, write to the Free Software
+  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+  */
+ 
+ #include <linux/interrupt.h>
+ #include <linux/device.h>		/* dev_err */
+ #include <linux/module.h>
+ #include <linux/of_platform.h>	/* open firmware functioons */
+ #include <linux/sysfs.h>		/* sysfs functions */
+ 
+ #define VERSION	"1.02"
+ 
+ #define BE_AXI_ADDRL_OFS		0x00
+ #define BE_AXI_ADDRH_OFS		0x04
+ 
+ #define BE_AXI_ADDRH_MASK		0xff
+ #define BE_AXI_ADDRH_SHFT		24
+ #define BE_AXI_TYPE_MASK		0x01
+ #define BE_AXI_TYPE_SHFT		23
+ 
+ #define BE_MSG_NOERROR			"No interconnect errors detected"
+ #define BE_MSG_SLAVE_ERROR		"Slave returns internal error"
+ #define BE_MSG_DECODE_ERROR		"No slave at selected address"
+ 
+ struct be_axi {
+ 	struct device *dev;
+ 	void __iomem *regs;
+ 	int	irq;
+ 	unsigned int count;
+ 	unsigned long long addr;
+ 	unsigned int type;
+ };
+ 
+ #ifdef CONFIG_SYSFS
+ static ssize_t show_count(struct device *dev, struct device_attribute *attr, char *buf)
+ {
+ 	struct platform_device *pdev = to_platform_device(dev);
+ 	struct be_axi *axi = platform_get_drvdata(pdev);
+ 
+ 	return scnprintf(buf, PAGE_SIZE, "%u\n", axi->count);
+ }
+ static DEVICE_ATTR(count, S_IWUSR | S_IRUGO, show_count, NULL);
+ 
+ static ssize_t show_addr(struct device *dev, struct device_attribute *attr, char *buf)
+ {
+ 	struct platform_device *pdev = to_platform_device(dev);
+ 	struct be_axi *axi = platform_get_drvdata(pdev);
+ 
+ 	return scnprintf(buf, PAGE_SIZE, "%08llx\n", axi->addr);
+ }
+ static DEVICE_ATTR(addr, S_IWUSR | S_IRUGO, show_addr, NULL);
+ 
+ static ssize_t show_type(struct device *dev, struct device_attribute *attr, char *buf)
+ {
+ 	struct platform_device *pdev = to_platform_device(dev);
+ 	struct be_axi *axi = platform_get_drvdata(pdev);
+ 
+ 	if (!axi->count)
+ 		return scnprintf(buf, PAGE_SIZE, "%s\n", BE_MSG_NOERROR);
+ 	return scnprintf(buf, PAGE_SIZE, "%s\n", axi->type ? BE_MSG_DECODE_ERROR : BE_MSG_SLAVE_ERROR);
+ }
+ static DEVICE_ATTR(type, S_IWUSR | S_IRUGO, show_type, NULL);
+ 
+ static ssize_t show_test(struct device *dev, struct device_attribute *attr, char *buf)
+ {
+ 	return scnprintf(buf, PAGE_SIZE, "Test interconnect error "
+ 				"(0 - Slave internal error, 1 - No slave error)\n");
+ }
+ static ssize_t store_test(struct device *dev, struct device_attribute *attr,
+                  const char *buf, size_t count)
+ {
+ 	struct platform_device *pdev = to_platform_device(dev);
+ 	struct be_axi *axi = platform_get_drvdata(pdev);
+ 
+ 	/* Dummy byte read */
+ 	if (*buf == '0')
+ 		readb(axi->regs + BE_AXI_ADDRL_OFS);
+ 	if (*buf == '1')
+ 		readb(axi->regs + 1);
+ 	return count;
+ }
+ static DEVICE_ATTR(test, S_IWUSR | S_IRUGO, show_test, store_test);
+ 
+ static void be_axi_sysfs_init(struct device *dev)
+ {
+ 	int ret;
+ 	/* Errors count */
+ 	ret = sysfs_create_file(&dev->kobj, &dev_attr_count.attr);
+ 	if (ret)
+ 		return;
+ 	/* Last error address */
+ 	ret = sysfs_create_file(&dev->kobj, &dev_attr_addr.attr);
+ 	if (ret)
+ 		goto __err3;
+ 	/* Last error type */
+ 	ret = sysfs_create_file(&dev->kobj, &dev_attr_type.attr);
+ 	if (ret)
+ 		goto __err2;
+ 	/* Test entry */
+ 	ret = sysfs_create_file(&dev->kobj, &dev_attr_test.attr);
+ 	if (ret)
+ 		goto __err1;
+ 	return;
+ __err1:
+ 	sysfs_remove_file(&dev->kobj, &dev_attr_type.attr);
+ __err2:
+ 	sysfs_remove_file(&dev->kobj, &dev_attr_addr.attr);
+ __err3:
+ 	sysfs_remove_file(&dev->kobj, &dev_attr_count.attr);
+ }
+ 
+ static void be_axi_sysfs_remove(struct device *dev)
+ {
+ 	sysfs_remove_file(&dev->kobj, &dev_attr_count.attr);
+ 	sysfs_remove_file(&dev->kobj, &dev_attr_addr.attr);
+ 	sysfs_remove_file(&dev->kobj, &dev_attr_type.attr);
+ 	sysfs_remove_file(&dev->kobj, &dev_attr_test.attr);
+ }
+ #else
+ static void be_axi_sysfs_init(struct device *dev) {}
+ static void be_axi_sysfs_remove(struct device *dev) {}
+ #endif
+ 
+ static irqreturn_t be_axi_irq(int irq, void *data)
+ {
+ 	struct be_axi *axi = (struct be_axi *)data;
+ 	unsigned long long addr;
+ 	/* Get low part of fault address */
+ 	axi->addr = readl(axi->regs + BE_AXI_ADDRL_OFS);
+ 	/* Get high part of fault address */
+ 	addr = readl(axi->regs + BE_AXI_ADDRH_OFS);
+ 	/* Add high bits to fault address */
+ 	axi->addr |= ((addr >> BE_AXI_ADDRH_SHFT) & BE_AXI_ADDRH_MASK) << 32;
+ 	/* Get fault type */
+ 	axi->type = (addr >> BE_AXI_TYPE_SHFT) & BE_AXI_TYPE_MASK;
+ 	/* Alert */
+ 	dev_crit_ratelimited(axi->dev, "Interconnect: %s (handled at %08llx)\n",
+ 		axi->type ? BE_MSG_DECODE_ERROR : BE_MSG_SLAVE_ERROR, axi->addr);
+ 	/* Increase counter (in irq handler it is atomic) */
+ 	axi->count += 1;
+ 	/* Return success */
+ 	return IRQ_HANDLED;
+ }
+ 
+ static int be_axi_probe(struct platform_device *pdev)
+ {
+ 	struct be_axi *axi;
+ 	struct resource *res;
+ 	int ret;
+ 
+ 	axi = devm_kzalloc(&pdev->dev, sizeof(*axi), GFP_KERNEL);
+ 	if (!axi)
+ 		return -ENOMEM;
+ 
+ 	axi->dev = &pdev->dev;
+ 	
+ 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+ 	axi->regs = devm_ioremap_resource(&pdev->dev, res);
+ 	if (IS_ERR(axi->regs))
+ 		return PTR_ERR(axi->regs);
+ 
+ 	/* Try to get IRQ resource */
+ 	axi->irq = platform_get_irq(pdev, 0);
+ 	if (axi->irq < 0)
+ 		return -EIO;
+ 
+ 	/* Request IRQ */
+ 	ret = request_irq(axi->irq, be_axi_irq,
+ 			IRQF_SHARED, "be-axi", (void *)axi);
+ 	if (ret)
+ 		return ret;
+ 
+ 	/* Register sysfs entries */
+ 	be_axi_sysfs_init(&pdev->dev);
+ 
+ 	dev_info(&pdev->dev, "Baikal Interconnect Error handler\n");
+ 	dev_info(&pdev->dev, "Version " VERSION "\n");
+ 
+ 	return 0;
+ }
+ 
+ static int be_axi_remove(struct platform_device *pdev)
+ {
+ 	struct be_axi *axi = platform_get_drvdata(pdev);
+ 	/* Free IRQ resource */
+ 	free_irq(axi->irq, axi);
+ 	/* Free sysfs */
+ 	be_axi_sysfs_remove(axi->dev);
+ 	/* Return success */
+ 	return 0;
+ }
+ 
+ #ifdef CONFIG_OF
+ static const struct of_device_id be_axi_of_match[] = {
+ 	{ .compatible = "be,axi-ehb", },
+ 	{ /* sentinel */ }
+ };
+ MODULE_DEVICE_TABLE(of, be_axi_of_match);
+ #endif
+ 
+ static struct platform_driver be_axi_driver = {
+ 	.probe		= be_axi_probe,
+ 	.remove		= be_axi_remove,
+ 	.driver		= {
+ 		.name	= "be-axi",
+ 		.owner	= THIS_MODULE,
+ #ifdef CONFIG_OF
+ 		.of_match_table = of_match_ptr(be_axi_of_match),
+ #endif /* CONFIG_OF */
+ 	},
+ };
+ module_platform_driver(be_axi_driver);
+ MODULE_VERSION(VERSION);
+ MODULE_AUTHOR("Dmitry Dunaev <dmitry.dunaev@baikalelectronics.ru>");
+ MODULE_DESCRIPTION("Baikal Electronics Interconnect error handler driver");
+ MODULE_LICENSE("Dual BSD/GPL");
+ MODULE_ALIAS("platform:be_axi");
diff -rcNP linux-4.4.24/arch/mips/baikal/baikal-console.c linux-4.4.24-baikal/arch/mips/baikal/baikal-console.c
*** linux-4.4.24/arch/mips/baikal/baikal-console.c	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/arch/mips/baikal/baikal-console.c	2016-11-11 14:49:51.000000000 +0300
***************
*** 0 ****
--- 1,57 ----
+ /*
+  * Baikal-T SOC platform support code.
+  *
+  * Copyright (C) 2014-2016 Baikal Electronics JSC
+  *
+  * This program is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU General Public License
+  * as published by the Free Software Foundation; either version 2
+  * of the License, or (at your option) any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; if not, write to the Free Software
+  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+  */
+ 
+ #include <linux/init.h>
+ #include <linux/kernel.h>
+ #include <linux/sizes.h>
+ #include <linux/serial_8250.h>
+ 
+ #include <asm/io.h>
+ #include <asm/mach-baikal/hardware.h>
+ 
+ #define DW_UART_THR		0x00
+ #define DW_UART_DLL		0x00
+ #define DW_UART_FCR		0x08
+ #define DW_UART_LCR		0x0C
+ #define DW_UART_LSR		0x14
+ 
+ #define DW_UART_LSR_TEMT 	(1 << 6)
+ #define DW_UART_LSR_THRE	(1 << 5)
+ 
+ #define EARLY_CONSOLE_BASE BAIKAL_UART0_START
+ 
+ static __iomem void *uart_membase = (__iomem void *) KSEG1ADDR(EARLY_CONSOLE_BASE);
+ 
+ static inline void uart_write32(u32 val, unsigned reg)
+ {
+ 	writel(val, uart_membase + reg);
+ }
+ 
+ static inline u32 uart_read32(unsigned reg)
+ {
+ 	return readl(uart_membase + reg);
+ }
+ 
+ void prom_putchar(unsigned char ch)
+ {
+ 	while ((uart_read32(DW_UART_LSR) & DW_UART_LSR_TEMT) == 0)
+ 		;
+ 	uart_write32(ch, DW_UART_THR);
+ }
diff -rcNP linux-4.4.24/arch/mips/baikal/baikal-cpufreq.c linux-4.4.24-baikal/arch/mips/baikal/baikal-cpufreq.c
*** linux-4.4.24/arch/mips/baikal/baikal-cpufreq.c	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/arch/mips/baikal/baikal-cpufreq.c	2016-11-11 14:49:51.000000000 +0300
***************
*** 0 ****
--- 1,218 ----
+ /*
+  * Baikal-T SOC platform support code. 
+  * CPU Frequency Scaling driver.
+  *
+  * Copyright (C) 2016 Baikal Electronics JSC
+  *
+  * This program is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU General Public License
+  * as published by the Free Software Foundation; either version 2
+  * of the License, or (at your option) any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; if not, write to the Free Software
+  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+  */
+ 
+ #include <linux/clk.h>
+ #include <linux/clk-provider.h>
+ #include <linux/cpu.h>
+ #include <linux/cpufreq.h>
+ #include <linux/delay.h>
+ #include <linux/module.h>
+ #include <linux/platform_device.h>
+ #include <linux/slab.h>
+ 
+ #define VERSION	"1.01a"
+ 
+ #define PLL_FREQ_MAX	1200000	/* KHz */
+ #define PLL_FREQ_MIN	200000	/* KHz */
+ #define PLL_FREQ_STEP	25000	/* KHz */
+ 
+ struct be_cpufreq {
+ 	struct device *dev;
+ 	struct clk *clk;			/* CPU clk */
+ 	unsigned int max;			/* KHz */
+ 	unsigned int min;			/* KHz */
+ 	unsigned int latency;		/* uS  */
+ };
+ 
+ static int be_cpufreq_notifier(struct notifier_block *nb,
+ 				 unsigned long val, void *data)
+ {
+ 	struct be_cpufreq *cpufreq = (struct be_cpufreq *)data;
+ 
+ 	if (val == CPUFREQ_POSTCHANGE)
+ 		cpufreq->latency = loops_per_jiffy;
+ 
+ 	return NOTIFY_OK;
+ }
+ 
+ static struct notifier_block be_cpufreq_notifier_block = {
+ 	.notifier_call = be_cpufreq_notifier,
+ };
+ 
+ static int be_cpufreq_target(struct cpufreq_policy *policy,
+ 			       unsigned int index)
+ {
+ 	struct be_cpufreq *cpufreq = (struct be_cpufreq *)policy->driver_data;
+ 	unsigned int old_freq, new_freq;
+ 
+ 	old_freq = policy->cur;
+ 	new_freq = policy->freq_table[index].frequency;
+ 
+ 	dev_info(cpufreq->dev, "%u KHz --> %u KHz\n", old_freq, new_freq);
+ 	clk_set_rate(cpufreq->clk, new_freq * 1000);
+ 
+ 	return 0;
+ }
+ 
+ static int be_cpufreq_init(struct cpufreq_policy *policy)
+ {
+ 	struct be_cpufreq *cpufreq = (struct be_cpufreq *)policy->driver_data;
+ 	struct cpufreq_frequency_table *freq_tbl;
+ 	unsigned int steps, freq;
+ 	int i, ret ;
+ 
+ 	steps = (PLL_FREQ_MAX - PLL_FREQ_MIN) / PLL_FREQ_STEP;
+ 
+ 	freq_tbl = devm_kzalloc(cpufreq->dev, sizeof(*freq_tbl) * (steps + 1),
+ 					GFP_KERNEL);
+ 
+ 	if (!freq_tbl) {
+ 		dev_err(cpufreq->dev,
+ 			"Failed to alloc cpufreq frequency table\n");
+ 		return -ENOMEM;
+ 	}
+ 
+ 	freq = PLL_FREQ_MIN;
+ 	for (i = 0; i < steps; ++i) {
+ 		if ((freq < cpufreq->min) || (freq > cpufreq->max))
+ 			freq_tbl[i].frequency = CPUFREQ_ENTRY_INVALID;
+ 		else
+ 			freq_tbl[i].frequency = freq;
+ 		dev_info(cpufreq->dev, "CPUFreq index %d: frequency %d KHz\n", i,
+ 			freq_tbl[i].frequency);
+ 		freq += PLL_FREQ_STEP;
+ 	}
+ 	freq_tbl[steps].frequency = CPUFREQ_TABLE_END;
+ 
+ 	policy->clk = cpufreq->clk;
+ 	ret = cpufreq_generic_init(policy, freq_tbl, 0);
+ 	if (ret)
+ 		kfree(freq_tbl);
+ 
+ 	return ret;
+ }
+ 
+ static int be_cpufreq_exit(struct cpufreq_policy *policy)
+ {
+ 	kfree(policy->freq_table);
+ 	return 0;
+ }
+ 
+ static struct cpufreq_driver be_cpufreq_driver = {
+ 	.name		= "cpufreq-baikal",
+ 	.flags		= CPUFREQ_STICKY | CPUFREQ_NEED_INITIAL_FREQ_CHECK,
+ 	.verify		= cpufreq_generic_frequency_table_verify,
+ 	.target_index	= be_cpufreq_target,
+ 	.get		= cpufreq_generic_get,
+ 	.init		= be_cpufreq_init,
+ 	.exit		= be_cpufreq_exit,
+ 	.attr		= cpufreq_generic_attr,
+ };
+ 
+ static int be_cpufreq_remove(struct platform_device *pdev)
+ {
+ 	cpufreq_unregister_notifier(&be_cpufreq_notifier_block,
+ 				    CPUFREQ_TRANSITION_NOTIFIER);
+ 	cpufreq_unregister_driver(&be_cpufreq_driver);
+ 
+ 	return 0;
+ }
+ 
+ static int be_cpufreq_probe(struct platform_device *pdev)
+ {
+ 	struct be_cpufreq *cpufreq;
+ 	struct device_node *np;
+ 	struct device *dev = &pdev->dev;
+ 	int ret;
+ 
+ 	cpufreq = devm_kzalloc(&pdev->dev, sizeof(*cpufreq), GFP_KERNEL);
+ 	if (!cpufreq)
+ 		return -ENOMEM;
+ 
+ 	cpufreq->dev = dev;
+ 
+ 	cpufreq->clk = devm_clk_get(dev, "cpuclk");
+ 	if (IS_ERR(cpufreq->clk)) {
+ 		dev_err(dev, "Unable to get CPU clock\n");
+ 		return PTR_ERR(cpufreq->clk);
+ 	}
+ 
+ 	np = of_node_get(dev->of_node);
+ 	if (!np) {
+ 		dev_err(dev, "Failed to find DT node\n");
+ 		return -ENOENT;
+ 	}
+ 
+ 	if(of_property_read_u32(np, "be,clk-freq-min", &cpufreq->min))
+ 		cpufreq->min = PLL_FREQ_MIN;
+ 
+ 	if(of_property_read_u32(np, "be,clk-freq-max", &cpufreq->max))
+ 		cpufreq->max = PLL_FREQ_MAX;
+ 
+ 	be_cpufreq_driver.driver_data = (void *)cpufreq;
+ 
+ 	ret = cpufreq_register_driver(&be_cpufreq_driver);
+ 	if (ret) {
+ 		dev_err(dev, "Failed to register cpufreq driver\n");
+ 		return ret;
+ 	}
+ 
+ 	ret = cpufreq_register_notifier(&be_cpufreq_notifier_block,
+ 					CPUFREQ_TRANSITION_NOTIFIER);
+ 	if (ret) {
+ 		dev_err(dev, "Failed to register cpufreq notifier\n");
+ 		cpufreq_unregister_driver(&be_cpufreq_driver);
+ 		return ret;
+ 	}
+ 
+ 	platform_set_drvdata(pdev, cpufreq);
+ 
+ 	return 0;
+ }
+ 
+ #ifdef CONFIG_OF
+ static const struct of_device_id be_cpufreq_of_match[] = {
+ 	{ .compatible = "be,cpufreq", },
+ 	{ /* sentinel */ }
+ };
+ MODULE_DEVICE_TABLE(of, be_cpufreq_of_match);
+ #endif
+ 
+ static struct platform_driver be_cpufreq_platdrv = {
+ 	.probe		= be_cpufreq_probe,
+ 	.remove		= be_cpufreq_remove,
+ 	.driver		= {
+ 		.name	= "be-cpufreq",
+ 		.owner	= THIS_MODULE,
+ #ifdef CONFIG_OF
+ 		.of_match_table = of_match_ptr(be_cpufreq_of_match),
+ #endif /* CONFIG_OF */
+ 	},
+ 
+ };
+ 
+ module_platform_driver(be_cpufreq_platdrv);
+ 
+ MODULE_VERSION(VERSION);
+ MODULE_AUTHOR("Dmitry Dunaev <dmitry.dunaev@baikalelectronics.ru>");
+ MODULE_DESCRIPTION("Baikal CPUFreq driver");
+ MODULE_LICENSE("Dual BSD/GPL");
+ MODULE_ALIAS("platform:be_cpufreq");
diff -rcNP linux-4.4.24/arch/mips/baikal/baikal-emc.c linux-4.4.24-baikal/arch/mips/baikal/baikal-emc.c
*** linux-4.4.24/arch/mips/baikal/baikal-emc.c	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/arch/mips/baikal/baikal-emc.c	2016-11-11 14:49:51.000000000 +0300
***************
*** 0 ****
--- 1,362 ----
+ /*
+  * Baikal-T SOC platform support code. Extended memory
+  * controller driver.
+  *
+  * Copyright (C) 2016  Baikal Electronics JSC
+  *
+  * This program is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU General Public License
+  * as published by the Free Software Foundation; either version 2
+  * of the License, or (at your option) any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; if not, write to the Free Software
+  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+  */
+ 
+ #include <linux/clk.h>
+ #include <linux/device.h>
+ #include <linux/interrupt.h>
+ #include <linux/module.h>
+ #include <linux/of_platform.h>
+ #include <linux/sysfs.h>
+ 
+ #define VERSION	"1.01"
+ 
+ #define EMC_MSTR				(0x00)	/* Master Register */
+ #define EMC_STAT				(0x04)	/* Operating Mode Status Register */
+ #define EMC_ECCCFG0				(0x70)	/* ECC Configuration Register */
+ #define EMC_ECCCFG1				(0x74)	/* ECC Configuration Register */
+ #define EMC_ECCSTAT				(0x78)	/* ECC Status Register */
+ #define EMC_ECCCLR				(0x7c)	/* ECC Clear Register */
+ #define EMC_ECCERRCNT			(0x80)	/* ECC Error Counter Register */
+ #define EMC_ECCCADDR0			(0x84)	/* ECC Corrected Error Address Register 0 */
+ #define EMC_ECCCADDR1			(0x88)	/* ECC Corrected Error Address Register 1 */
+ #define EMC_ECCUADDR0			(0xa4)	/* ECC Uncorrected Error Address Register 0 */
+ #define EMC_ECCUADDR1			(0xa8)	/* ECC Uncorrected Error Address Register 1 */
+ #define EMC_CRCPARCTL0			(0xc0)	/* CRC Parity Control Register0 */
+ #define EMC_CRCPARCTL1			(0xc4)	/* CRC Parity Control Register1 */
+ #define EMC_CRCPARCTL2			(0xc8)	/* CRC Parity Control Register2 */
+ #define EMC_CRCPARSTAT			(0xcc)	/* CRC Parity Status Register */
+ 
+ #define EMC_ECCCLR_UNCORR_CNT	(1 << 3) 
+ #define EMC_ECCCLR_CORR_CNT		(1 << 2) 
+ #define EMC_ECCCLR_UNCORR_ERR	(1 << 1) 
+ #define EMC_ECCCLR_CORR_ERR		(1 << 0) 
+ 
+ #define EMC_CRCPARCTL0_CLR_CNT	(1 << 2)
+ #define EMC_CRCPARCTL0_CLR_ERR	(1 << 1)
+ #define EMC_CRCPARCTL0_EN		(1 << 0)
+ #define EMC_CRCPARCTL1_PAR_EN	(1 << 8)
+ #define EMC_CRCPARCTL1_CRC_EN	(1 << 4)
+ 
+ #define	DRAM_TYPE_DDR3			(1 << 0)
+ #define	DRAM_TYPE_MDDR			(1 << 1)
+ #define	DRAM_TYPE_LPDDR2		(1 << 2)
+ #define	DRAM_TYPE_LPDDR3		(1 << 3)
+ #define	DRAM_TYPE_DDR4			(1 << 4)
+ 
+ struct be_emc_info {
+ 	unsigned char cfg;
+ 	unsigned char ranks;
+ 	unsigned char burst;
+ 	unsigned char dqdiv;
+ 	unsigned char gdown;
+ 	unsigned char timing;
+ 	unsigned char bchop;
+ 	unsigned char bmode;
+ 	unsigned char ecc;
+ 	unsigned char type;
+ };
+ 
+ struct be_emc {
+ 	struct device *dev;
+ 	void __iomem *regs;
+ 	struct clk *clk;
+ 	int	irq_dfi, irq_ecr, irq_euc;
+ 	struct be_emc_info info;
+ };
+ 
+ #ifdef CONFIG_SYSFS
+ static ssize_t show_emc_stat(struct device *dev, struct device_attribute *attr, char *buf)
+ {
+ 	struct platform_device *pdev = to_platform_device(dev);
+ 	struct be_emc *emc = platform_get_drvdata(pdev);
+ 	unsigned int reg1, reg2;
+ 
+ 	reg1 = readl(emc->regs + EMC_CRCPARSTAT);
+ 	reg2 = readl(emc->regs + EMC_ECCERRCNT);
+ 
+ 	return scnprintf(buf, PAGE_SIZE, 
+ 				"Parity or CRC errors    : %u\n"
+ 				"Correctable ECC errors  : %u\n" 
+ 				"Uncorrectable ECC errors: %u\n", 
+ 				reg1 & 0xffff, reg2 & 0xffff, reg2 >> 16);
+ }
+ static DEVICE_ATTR(stat, S_IWUSR | S_IRUGO, show_emc_stat, NULL);
+ 
+ static ssize_t show_emc_rate(struct device *dev, struct device_attribute *attr, char *buf)
+ {
+ 	struct platform_device *pdev = to_platform_device(dev);
+ 	struct be_emc *emc = platform_get_drvdata(pdev);
+ 
+ 	return scnprintf(buf, PAGE_SIZE, "%lu\n", clk_get_rate(emc->clk));
+ }
+ static DEVICE_ATTR(rate, S_IWUSR | S_IRUGO, show_emc_rate, NULL);
+ 
+ static void be_emc_sysfs_init(struct device *dev)
+ {
+ 	int ret;
+ 
+ 	ret = sysfs_create_file(&dev->kobj, &dev_attr_stat.attr);
+ 	if (ret)
+ 		return;
+ 
+ 	ret = sysfs_create_file(&dev->kobj, &dev_attr_rate.attr);
+ 	if (ret)
+ 		goto __err;
+ __err:
+ 	sysfs_remove_file(&dev->kobj, &dev_attr_stat.attr);
+ }
+ 
+ static void be_emc_sysfs_remove(struct device *dev)
+ {
+ 	sysfs_remove_file(&dev->kobj, &dev_attr_stat.attr);
+ 	sysfs_remove_file(&dev->kobj, &dev_attr_rate.attr);
+ }
+ #else
+ static void be_emc_sysfs_init(struct device *dev) {}
+ static void be_emc_sysfs_remove(struct device *dev) {}
+ #endif
+ 
+ static irqreturn_t be_emc_irq(int irq, void *data)
+ {
+ 	struct be_emc *emc = (struct be_emc *)data;
+ 	unsigned int reg1, reg2;
+ 
+ 	if (irq == emc->irq_dfi) {
+ 		dev_crit_ratelimited(emc->dev, "Parity or CRC error is "
+ 			"detected on the DFI interface\n");
+ 
+ 		reg1 = readl(emc->regs + EMC_CRCPARCTL0);
+ 		reg1 |= EMC_CRCPARCTL0_CLR_ERR;
+ 		writel(reg1, emc->regs + EMC_CRCPARCTL0);
+ 
+ 		return IRQ_HANDLED;
+ 	}
+ 
+ 	if (irq == emc->irq_ecr) {
+ 		dev_warn_ratelimited(emc->dev, "Correctable ECC error is "
+ 			"detected\n");
+ 
+ 		reg1 = readl(emc->regs + EMC_ECCCADDR0);
+ 		reg2 = readl(emc->regs + EMC_ECCCADDR1);
+ 
+ 		dev_warn_ratelimited(emc->dev, "RANK=%d ROW=%d BGRP=%d "
+ 			"BANK=%d COL=%d\n", (reg1 >> 24) & 0x03, reg1 & 0x3ffff,
+ 			(reg2 >> 24) & 0x03, (reg2 >> 16) & 0x07, reg2 & 0x0fff);
+ 
+ 		writel(EMC_ECCCLR_CORR_ERR,	emc->regs + EMC_ECCCLR);
+ 
+ 		return IRQ_HANDLED;
+ 	}
+ 
+ 	if (irq == emc->irq_euc) {
+ 		dev_crit_ratelimited(emc->dev, "Uncorrectable ECC error is "
+ 			"detected\n");
+ 
+ 		reg1 = readl(emc->regs + EMC_ECCUADDR0);
+ 		reg2 = readl(emc->regs + EMC_ECCUADDR1);
+ 
+ 		dev_crit_ratelimited(emc->dev, "RANK=%d ROW=%d BGRP=%d "
+ 			"BANK=%d COL=%d\n", (reg1 >> 24) & 0x03, reg1 & 0x3ffff,
+ 			(reg2 >> 24) & 0x03, (reg2 >> 16) & 0x07, reg2 & 0x0fff);
+ 
+ 		writel(EMC_ECCCLR_UNCORR_ERR, emc->regs + EMC_ECCCLR);
+ 
+ 		return IRQ_HANDLED;
+ 	}
+ 
+ 	return IRQ_NONE;
+ }
+ 
+ static const char * be_emc_ddr_type(unsigned char type)
+ {
+ 	switch (type) {
+ 	case DRAM_TYPE_DDR3:
+ 		return "DDR3";
+ 	case DRAM_TYPE_MDDR:
+ 		return "mDDR";
+ 	case DRAM_TYPE_LPDDR2:
+ 		return "LPDDR2";
+ 	case DRAM_TYPE_LPDDR3:
+ 		return "LPDDR3";
+ 	case DRAM_TYPE_DDR4:
+ 		return "DDR4";
+ 	default:
+ 		return "DDR";
+ 	}
+ }
+ 
+ static void be_emc_init(struct be_emc *emc)
+ {
+ 	struct be_emc_info *info = &emc->info;
+ 	unsigned int reg;
+ 
+ 	reg = readl(emc->regs + EMC_MSTR);
+ 
+ 	info->cfg = 4 << ((reg >> 30) & 0x03);
+ 	info->ranks = (((reg >> 24) & 0x0f) + 1) >> 1;
+ 	info->burst = 1 << ((reg >> 16) & 0x0f);
+ 	info->dqdiv = 1 << ((reg >> 12) & 0x03);
+ 	info->gdown = (reg >> 11) & 0x01;
+ 	info->timing = 1 << ((reg >> 10) & 0x01);
+ 	info->bchop = (reg >> 9) & 0x01;
+ 	info->bmode = (reg >> 8) & 0x01;
+ 	info->type = reg & 0x1f;
+ 
+ 	reg = readl(emc->regs + EMC_ECCCFG0);
+ 	info->ecc = (reg & 0x07) ? 1 : 0;
+ 
+ 	dev_info(emc->dev, "%s x%d ranks:%d ecc:%s burst:%d bus:DQ/%d "
+ 		"timing:%dT bchop:%d bmode:%d\n", be_emc_ddr_type(info->type),
+ 		info->cfg, info->ranks, info->ecc ? "on":"off", 
+ 		info->burst, info->dqdiv, info->timing, info->bchop, info->bmode);
+ 	
+ 	/* Enable DFI irq and clear status */
+ 	reg = readl(emc->regs + EMC_CRCPARCTL0);
+ 	reg |= (EMC_CRCPARCTL0_CLR_CNT | EMC_CRCPARCTL0_CLR_ERR |
+ 			EMC_CRCPARCTL0_EN);
+ 	writel(reg, emc->regs + EMC_CRCPARCTL0);
+ 	wmb();
+ 
+ 	writel(EMC_ECCCLR_CORR_CNT | EMC_ECCCLR_CORR_ERR |
+ 		EMC_ECCCLR_UNCORR_CNT | EMC_ECCCLR_UNCORR_ERR,
+ 		emc->regs + EMC_ECCCLR);
+ 	wmb();
+ }
+ 
+ static int be_emc_probe(struct platform_device *pdev)
+ {
+ 	struct be_emc *emc;
+ 	struct resource *res;
+ 	int ret;
+ 
+ 	emc = devm_kzalloc(&pdev->dev, sizeof(*emc), GFP_KERNEL);
+ 	if (!emc)
+ 		return -ENOMEM;
+ 
+ 	emc->dev = &pdev->dev;
+ 
+ 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+ 	emc->regs = devm_ioremap_resource(&pdev->dev, res);
+ 	if (IS_ERR(emc->regs))
+ 		return PTR_ERR(emc->regs);
+ 
+ 	emc->clk = devm_clk_get(&pdev->dev, "ddrclk");
+ 	if (IS_ERR(emc->clk))
+ 		return PTR_ERR(emc->clk);
+ 	
+ 	clk_prepare_enable(emc->clk);
+ 
+ 	/* dfi_alert_err_intr */
+ 	emc->irq_dfi = platform_get_irq(pdev, 0);
+ 	if (emc->irq_dfi < 0)
+ 		return -EIO;
+ 
+ 	/* Request IRQ */
+ 	ret = request_irq(emc->irq_dfi, be_emc_irq,
+ 			IRQF_SHARED, "emc-dfi", (void *)emc);
+ 	if (ret)
+ 		return ret;
+ 
+ 	/* Try to get recovered error IRQ */
+ 	emc->irq_ecr = platform_get_irq(pdev, 1);
+ 	if (emc->irq_ecr < 0)
+ 		goto __main;
+ 
+ 	/* ecc_corrected_err_intr */
+ 	ret = request_irq(emc->irq_ecr, be_emc_irq,
+ 			IRQF_SHARED, "emc-ecr", (void *)emc);
+ 	if (ret)
+ 		return ret;
+ 
+ 	/* ecc_uncorrected_err_intr */
+ 	emc->irq_euc = platform_get_irq(pdev, 2);
+ 	if (emc->irq_euc < 0)
+ 		goto __main;
+ 
+ 	/* Request IRQ */
+ 	ret = request_irq(emc->irq_euc, be_emc_irq,
+ 			IRQF_SHARED, "emc-euc", (void *)emc);
+ 	if (ret)
+ 		return ret;
+ 
+ __main:
+ 	/* Report info */
+ 	dev_info(&pdev->dev, "Baikal Extended Memory controller\n");
+ 	dev_info(&pdev->dev, "Version " VERSION "\n");
+ 
+ 	be_emc_init(emc);
+ 
+ 	platform_set_drvdata(pdev, emc);
+ 
+ 	/* Register sysfs entries */
+ 	be_emc_sysfs_init(&pdev->dev);
+ 
+ 	return 0;
+ }
+ 
+ static int be_emc_remove(struct platform_device *pdev)
+ {
+ 	struct be_emc *emc = platform_get_drvdata(pdev);
+ 
+ 	if (emc->irq_dfi)
+ 		free_irq(emc->irq_dfi, (void *)emc);
+ 
+ 	if (emc->irq_ecr)
+ 		free_irq(emc->irq_ecr, (void *)emc);
+ 
+ 	if (emc->irq_euc)
+ 		free_irq(emc->irq_euc, (void *)emc);
+ 
+ 	if (emc->clk)
+ 		 devm_clk_put(emc->dev, emc->clk);
+ 
+ 	be_emc_sysfs_remove(&pdev->dev);
+ 
+ 	return 0;
+ }
+ 
+ #ifdef CONFIG_OF
+ static const struct of_device_id be_emc_of_match[] = {
+ 	{ .compatible = "be,memory-controller", },
+ 	{ .compatible = "be,emc", },
+ 	{ /* sentinel */ }
+ };
+ MODULE_DEVICE_TABLE(of, be_emc_of_match);
+ #endif
+ 
+ static struct platform_driver be_emc_driver = {
+ 	.probe		= be_emc_probe,
+ 	.remove		= be_emc_remove,
+ 	.driver		= {
+ 		.name	= "be-emc",
+ 		.owner	= THIS_MODULE,
+ #ifdef CONFIG_OF
+ 		.of_match_table = of_match_ptr(be_emc_of_match),
+ #endif /* CONFIG_OF */
+ 	},
+ };
+ 
+ module_platform_driver(be_emc_driver);
+ MODULE_VERSION(VERSION);
+ MODULE_AUTHOR("Dmitry Dunaev <dmitry.dunaev@baikalelectronics.ru>");
+ MODULE_DESCRIPTION("Baikal extended memory controller driver");
+ MODULE_LICENSE("Dual BSD/GPL");
+ MODULE_ALIAS("platform:be_emc");
diff -rcNP linux-4.4.24/arch/mips/baikal/baikal-init.c linux-4.4.24-baikal/arch/mips/baikal/baikal-init.c
*** linux-4.4.24/arch/mips/baikal/baikal-init.c	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/arch/mips/baikal/baikal-init.c	2016-11-11 14:49:51.000000000 +0300
***************
*** 0 ****
--- 1,160 ----
+ /*
+  * Baikal-T SOC platform support code.
+  *
+  * Copyright (C) 2014-2016 Baikal Electronics JSC
+  *
+  * This program is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU General Public License
+  * as published by the Free Software Foundation; either version 2
+  * of the License, or (at your option) any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; if not, write to the Free Software
+  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+  */
+ 
+ #include <linux/init.h>
+ #include <linux/string.h>
+ #include <linux/kernel.h>
+ #include <linux/bootmem.h>
+ #include <linux/pm.h>		/* pm_power_off */
+ 
+ #include <asm/fw/fw.h>
+ #include <asm/setup.h>
+ #include <asm/bootinfo.h>
+ #include <asm/mipsregs.h>
+ #include <asm/sections.h>
+ #ifdef CONFIG_SMP
+ #include <asm/smp.h>
+ #include <asm/smp-ops.h>
+ #endif
+ #include <asm/idle.h>		/* cpu_wait */
+ #include <asm/reboot.h>
+ #include <asm/mips-cm.h>
+ #include <asm/mips-cpc.h>
+ #include <asm/cacheflush.h>
+ #include <asm/traps.h>
+ #include <asm/msa.h>
+ #include <asm/cdmm.h>
+ #include <asm/idle.h>
+ 
+ #include <asm/mach-baikal/hardware.h>
+ #include <asm/mips-boards/baikal.h> /* Base GIC and GCR addresses */
+ 
+ #include "common.h"
+ 
+ #ifndef CONFIG_MIPS_CPC
+ void __iomem *mips_cpc_base;
+ #endif
+ 
+ extern void baikal_be_init(void);
+ extern int baikal_be_handler(struct pt_regs *regs, int is_fixup);
+ 
+ static void __init mips_nmi_setup(void)
+ {
+ 	void *base;
+ 	extern char except_vec_nmi;
+ 
+ 	base = (void *)(CAC_BASE + 0xa80);
+ 	memcpy(base, &except_vec_nmi, 0x80);
+ 	flush_icache_range((unsigned long)base, (unsigned long)base + 0x80);
+ }
+ 
+ static void __init mips_ejtag_setup(void)
+ {
+ 	void *base;
+ 	extern char except_vec_ejtag_debug;
+ 
+ 	base = (void *)(CAC_BASE + 0x480);
+ 	memcpy(base, &except_vec_ejtag_debug, 0x80);
+ 	flush_icache_range((unsigned long)base, (unsigned long)base + 0x80);
+ }
+ 
+ phys_addr_t __weak mips_cpc_default_phys_base(void)
+ {
+ 	return CPC_BASE_ADDR;
+ }
+ 
+ phys_addr_t __weak mips_cdmm_phys_base(void)
+ {
+ 	unsigned long reg = read_c0_config3();
+ 
+ 	if (!(reg & MIPS_CONF3_CDMM))
+ 		return 0;
+ 	reg = read_c0_cdmm() | MIPS_CDMMBASE_EN;
+ 	write_c0_cdmmbase(reg);
+ 
+ 	return (reg >> MIPS_CDMMBASE_ADDR_SHIFT) << MIPS_CDMMBASE_ADDR_START;
+ }
+ 
+ /*
+  * Initial kernel command line, usually setup by prom_init()
+  * extern char arcs_cmdline[COMMAND_LINE_SIZE];
+  *
+  * Registers a0, a1, a3 and a4 as passed to the kernel entry by firmware
+  * extern unsigned long fw_arg0, fw_arg1, fw_arg2, fw_arg3;
+  */
+ void __init prom_init(void)
+ {
+ 	unsigned long reg;
+ #ifdef CONFIG_EARLY_PRINTK_8250
+ 	setup_8250_early_printk_port(KSEG1ADDR(BAIKAL_UART0_START), 2, 1000000);
+ #endif
+ 	/* Setup power management handlers */
+ 	panic_timeout	 = 10;
+ 
+ 	/* Setup exception handlers */
+ 	board_nmi_handler_setup = mips_nmi_setup;
+ 	board_ejtag_handler_setup = mips_ejtag_setup;
+ 
+ 	/* handlers */
+ 	board_be_init = baikal_be_init;
+ 	board_be_handler = baikal_be_handler;
+ 
+ 	/* Early detection of CMP support */
+  	mips_cm_probe();
+ 	mips_cpc_probe();
+ 	/* Setup L2 prefetch */
+ 	reg = read_gcr_l2_pft_control();
+ 	/* Set page mask depending on actual page size */
+ 	reg &= ~(CM_GCR_L2_PFT_CONTROL_PAGEMASK_MSK);
+ #if defined(CONFIG_PAGE_SIZE_4KB)
+ 	/* 4K pages */
+ 	reg |= 0xFFFFF000;
+ #elif defined(CONFIG_PAGE_SIZE_8KB)
+ 	/* 8K pages */
+ 	reg |= 0xFFFFE000;
+ #elif defined(CONFIG_PAGE_SIZE_16KB)
+ 	/* 16K pages */
+ 	reg |= 0xFFFFC000;
+ #else
+ 	/* Other cases */
+ 	reg |= 0xFFFFF000;
+ #endif
+ 	pr_info("Enable data prefetch\n");
+ 	write_gcr_l2_pft_control(reg | CM_GCR_L2_PFT_CONTROL_PFTEN_MSK);
+ 	wmb();
+ 
+ 	pr_info("Enable instruction prefetch\n");
+ 	reg = read_gcr_l2_pft_control_b();
+ 	write_gcr_l2_pft_control_b(reg | CM_GCR_L2_PFT_CONTROL_PFTEN_MSK);
+ 	wmb();
+ 
+ #ifdef CONFIG_SMP
+ #ifdef CONFIG_MIPS_CPS
+ 	if (!register_cps_smp_ops())
+ 		return;
+ 	pr_warn("%s: register_cps_smp_ops failed\n", __func__);
+ #endif /* CONFIG_MIPS_CPS */
+ #endif /* CONFIG_SMP */
+ }
+ 
+ const char *get_system_type(void)
+ {
+         return "Baikal-T Generic SoC";
+ }
diff -rcNP linux-4.4.24/arch/mips/baikal/baikal-int.c linux-4.4.24-baikal/arch/mips/baikal/baikal-int.c
*** linux-4.4.24/arch/mips/baikal/baikal-int.c	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/arch/mips/baikal/baikal-int.c	2016-11-11 14:49:51.000000000 +0300
***************
*** 0 ****
--- 1,42 ----
+ /* 
+  * Baikal-T SOC platform support code.
+  *
+  * Copyright (C) 2014-2016 Baikal Electronics JSC
+  *
+  * This program is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU General Public License
+  * as published by the Free Software Foundation; either version 2
+  * of the License, or (at your option) any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; if not, write to the Free Software
+  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+  */
+ 
+ #include <linux/of.h>
+ #include <linux/irqchip.h>
+ #include <linux/irqchip/mips-gic.h>	/* GIC definitions */
+ 
+ /* Perfomance counters support */
+ int get_c0_perfcount_int(void)
+ {
+ 	return gic_get_c0_perfcount_int();
+ }
+ EXPORT_SYMBOL_GPL(get_c0_perfcount_int);
+ 
+ void __init arch_init_irq(void)
+ {
+ 	/* Init complete with devicetree */
+ 	if (of_have_populated_dt())
+ 		irqchip_init();
+ }
+ 
+ asmlinkage void plat_irq_dispatch(void)
+ {
+ 	/* Nothing to do here */
+ }
diff -rcNP linux-4.4.24/arch/mips/baikal/baikal-memory.c linux-4.4.24-baikal/arch/mips/baikal/baikal-memory.c
*** linux-4.4.24/arch/mips/baikal/baikal-memory.c	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/arch/mips/baikal/baikal-memory.c	2016-11-11 14:49:51.000000000 +0300
***************
*** 0 ****
--- 1,131 ----
+ /*
+  * Baikal-T SOC platform support code.
+  *
+  * Copyright (C) 2014-2016 Baikal Electronics JSC
+  *
+  * This program is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU General Public License
+  * as published by the Free Software Foundation; either version 2
+  * of the License, or (at your option) any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; if not, write to the Free Software
+  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+  */
+ 
+ #include <linux/init.h>
+ #include <linux/bootmem.h>
+ #include <linux/of_fdt.h>
+ 
+ #include <asm/bootinfo.h>
+ #include <asm/prom.h>
+ 
+ #include <asm/mach-baikal/hardware.h>
+ #include "common.h"
+ 
+ #include <linux/fs.h>
+ #include <linux/fcntl.h>
+ #include <linux/pci.h>
+ #include <linux/sched.h>
+ #include <asm/current.h>
+ 
+ #define BAIKAL_MMIO_MEM_START		0x08000000
+ #define BAIKAL_MMIO_MEM_END		0x1FFFFFFF
+ 
+ void __init prom_free_prom_memory(void)
+ {
+ 	/* Nothing todo here */
+ }
+ /*
+  * Platform memory detection hook called by setup_arch
+  * extern void plat_mem_setup(void);
+  */
+ void __init plat_mem_setup(void)
+ {
+ 	/* Setup dummy port segment */
+ 	set_io_port_base(CKSEG1);
+ 	if (config_enabled(CONFIG_EVA))
+ 		/* EVA should be configured in mach-baikal/kernel-init.h */
+ 		pr_info("Enhanced Virtual Addressing (EVA) activated\n");
+ 
+ #ifdef CONFIG_OF
+ 	/* Try to parse device tree */
+ 	if (!device_tree_early_init())
+ 		return;
+ #endif
+ 		/* Low memory region */
+ 	add_memory_region(BAIKAL_DRAM_START, BAIKAL_DRAM_SIZE, BOOT_MEM_RAM);
+ #ifdef CONFIG_HIGHMEM
+ 		/* High memory region */
+ 	add_memory_region(BAIKAL_HIGHMEM_START, BAIKAL_HIGHMEM_SIZE, BOOT_MEM_RAM);
+ #endif
+ }
+ 
+ #ifdef CONFIG_CPU_SUPPORTS_UNCACHED_ACCELERATED
+ /* override of arch/mips/mm/cache.c: __uncached_access */
+ int __uncached_access(struct file *file, unsigned long addr)
+ {
+ 	if (file->f_flags & O_DSYNC)
+ 		return 1;
+ 
+ 	return addr >= __pa(high_memory) ||
+ 		((addr >= BAIKAL_MMIO_MEM_START) &&
+ 		 (addr < BAIKAL_MMIO_MEM_END));
+ }
+ 
+ static unsigned long uca_start, uca_end;
+ 
+ pgprot_t phys_mem_access_prot(struct file *file, unsigned long pfn,
+ 			      unsigned long size, pgprot_t vma_prot)
+ {
+ 	unsigned long offset = pfn << PAGE_SHIFT;
+ 	unsigned long end = offset + size;
+ 
+ 	if (__uncached_access(file, offset)) {
+ 		if (uca_start && (offset >= uca_start) &&
+ 		    (end <= uca_end))
+ 			return __pgprot((pgprot_val(vma_prot) &
+ 					 ~_CACHE_MASK) |
+ 					_CACHE_UNCACHED_ACCELERATED);
+ 		else
+ 			return pgprot_noncached(vma_prot);
+ 	}
+ 	return vma_prot;
+ }
+ 
+ int /* __init*/ baikal_find_vga_mem_init(void)
+ {
+ 	struct pci_dev *dev = 0;
+ 	struct resource *r;
+ 	int idx;
+ 
+ 	if (uca_start)
+ 		return 0;
+ 
+ 	for_each_pci_dev(dev) {
+ 		if ((dev->class >> 16) == PCI_BASE_CLASS_DISPLAY) {
+ 			for (idx = 0; idx < PCI_NUM_RESOURCES; idx++) {
+ 				r = &dev->resource[idx];
+ 				if (!r->start && r->end)
+ 					continue;
+ 				if (r->flags & IORESOURCE_IO)
+ 					continue;
+ 				if (r->flags & IORESOURCE_MEM) {
+ 					uca_start = r->start;
+ 					uca_end = r->end;
+ 					return 0;
+ 				}
+ 			}
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ late_initcall(baikal_find_vga_mem_init);
+ #endif /* !CONFIG_CPU_SUPPORTS_UNCACHED_ACCELERATED */
diff -rcNP linux-4.4.24/arch/mips/baikal/baikal-of.c linux-4.4.24-baikal/arch/mips/baikal/baikal-of.c
*** linux-4.4.24/arch/mips/baikal/baikal-of.c	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/arch/mips/baikal/baikal-of.c	2016-11-11 14:49:51.000000000 +0300
***************
*** 0 ****
--- 1,134 ----
+ /*
+  * Baikal-T SOC platform support code.
+  *
+  * Copyright (C) 2014-2016 Baikal Electronics JSC
+  *
+  * This program is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU General Public License
+  * as published by the Free Software Foundation; either version 2
+  * of the License, or (at your option) any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; if not, write to the Free Software
+  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+  */
+ 
+ #include <linux/of_fdt.h>
+ #include <linux/of_platform.h>
+ #include <linux/of_address.h>
+ #include <linux/sys_soc.h>
+ #include <linux/slab.h>
+ 
+ #include <asm/fw/fw.h>
+ #include <asm/prom.h>
+ 
+ #include "common.h"
+ 
+ static char mips_revision[16] = "Unknown";
+ static char mips_soc_id[16]   = "Unknown";
+ 
+ __iomem void *plat_of_remap_node(const char *node)
+ {
+ 	struct resource res;
+ 	struct device_node *np;
+ 
+ 	np = of_find_compatible_node(NULL, NULL, node);
+ 	if (!np)
+ 		panic("Failed to find %s node", node);
+ 
+ 	if (of_address_to_resource(np, 0, &res))
+ 		panic("Failed to get resource for %s", node);
+ 
+ 	if ((request_mem_region(res.start,
+ 				resource_size(&res),
+ 				res.name) < 0))
+ 		panic("Failed to request resources for %s", node);
+ 
+ 	return ioremap_nocache(res.start, resource_size(&res));
+ }
+ 
+ void __init device_tree_init(void)
+ {
+ 	/* Set machine name */
+ 	mips_set_machine_name(of_flat_dt_get_machine_name());
+ 
+ 	/* Restore tree model and copy into kernel memory */
+ 	unflatten_and_copy_device_tree();
+ }
+ 
+ int __init device_tree_early_init(void)
+ {
+ 	/* Assume that device tree blob ptr in fw_arg3 */
+ 	void *fdt = config_enabled(CONFIG_BUILTIN_DTB) ?
+ 						__dtb_start : phys_to_virt(fw_arg3);
+ 	/* UHI boot support */
+ 	if ((int)fw_arg0 == -2)
+ 		fdt = phys_to_virt(fw_arg1);
+ 
+ 	if ((unsigned long)fdt < PAGE_OFFSET) {
+ 		pr_err("Device tree blob address < PAGE_OFFSET\n");
+ 		goto no_dtb;
+ 	}
+ 
+ 	if (!early_init_dt_scan(fdt))
+ 		goto no_dtb;
+ 
+ 	/* Inform about initial device tree location */
+ 	pr_info("Machine device tree at: 0x%p\n", fdt);
+ 
+ 	/* Copy device tree command line to arcitecture command line */
+ 	strlcpy(arcs_cmdline, boot_command_line, COMMAND_LINE_SIZE);
+ 	return 0;
+ 
+ no_dtb:
+ 		pr_warn("No valid device tree found, continuing without\n");
+ #ifndef CONFIG_CMDLINE_OVERRIDE
+ 		/* Init command line from bootloader */
+ 		fw_init_cmdline();
+ #endif
+ 	return -1;
+ }
+ 
+ static int __init plat_of_setup(void)
+ {
+ 	struct soc_device_attribute *soc_dev_attr;
+ 	struct soc_device *soc_dev;
+ 	struct device *parent = NULL;
+ 	unsigned int cpuid = current_cpu_data.processor_id;
+ 
+ 	if (unlikely(!of_have_populated_dt()))
+ 		return 0;
+ 
+ 	soc_dev_attr = kzalloc(sizeof(*soc_dev_attr), GFP_KERNEL);
+ 	if (!soc_dev_attr)
+ 		goto populate;
+ 	/* SoC attributes */
+ 	soc_dev_attr->machine	= mips_get_machine_name();
+ 	soc_dev_attr->family	= get_system_type();
+ 	soc_dev_attr->revision	= mips_revision;
+ 	soc_dev_attr->soc_id	= mips_soc_id;
+ 	/* Populate SoC-specific attributes */
+ 	snprintf(mips_revision, 15, "%u.%u", (cpuid >> 5) & 0x07,
+ 		cpuid & 0x07);
+ 	snprintf(mips_soc_id, 15, "0x%08X",
+ 		readl(phys_to_virt(BAIKAL_BOOT_CTRL_DRID)));
+ 	/* Register SoC device */
+ 	soc_dev = soc_device_register(soc_dev_attr);
+ 	if (IS_ERR(soc_dev)) {
+ 		kfree(soc_dev_attr);
+ 		goto populate;
+ 	}
+ 	/* SoC platform device is parent for all */
+ 	parent = soc_device_to_device(soc_dev);
+ populate:
+ 	if (of_platform_populate(NULL, of_default_bus_match_table, NULL, parent))
+ 		panic("Failed to populate device tree");
+ 
+ 	return 0;
+ }
+ arch_initcall(plat_of_setup);
diff -rcNP linux-4.4.24/arch/mips/baikal/baikal-setup.c linux-4.4.24-baikal/arch/mips/baikal/baikal-setup.c
*** linux-4.4.24/arch/mips/baikal/baikal-setup.c	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/arch/mips/baikal/baikal-setup.c	2016-11-11 14:49:51.000000000 +0300
***************
*** 0 ****
--- 1,178 ----
+ /*
+  * Baikal-T SOC platform support code.
+  *
+  * Copyright (C) 2014-2016 Baikal Electronics JSC
+  *
+  * This program is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU General Public License
+  * as published by the Free Software Foundation; either version 2
+  * of the License, or (at your option) any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; if not, write to the Free Software
+  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+  */
+ 
+ #include <linux/init.h>
+ #include <linux/pci.h>
+ 
+ #include <asm/mips-cm.h>            /* Coherence manager */
+ #include <asm/traps.h>
+ #include <asm/mach-baikal/hardware.h>
+ #include <asm/mips-boards/generic.h>
+ 
+ #include "common.h"              /* Common Baikal definitions */
+ 
+ static void __init plat_setup_iocoherency(void)
+ {
+    if (mips_cm_numiocu() != 0) {
+       pr_info("CMP IOCU detected\n");
+ 
+    if (coherentio)
+          pr_info("Hardware DMA cache coherency enabled\n");
+       else
+          pr_info("Hardware DMA cache coherency disabled\n");
+    }
+ }
+ 
+ static int __init baikal_platform_setup(void)
+ {
+ #ifdef CONFIG_PCI
+    /* PCI init */
+    mips_pcibios_init();
+ #endif
+    /* Setup IO Coherency */
+    plat_setup_iocoherency();
+    /* No critical actions - always return success */
+    return 0;
+ }
+ late_initcall(baikal_platform_setup);
+ 
+ void baikal_be_init(void)
+ {
+    /* Could change CM error mask register. */
+ }
+ 
+ static char *tr[8] = {
+    "mem",   "gcr",   "gic",   "mmio",
+    "0x04", "0x05", "0x06", "0x07"
+ };
+ 
+ static char *mcmd[32] = {
+    [0x00] = "0x00",
+    [0x01] = "Legacy Write",
+    [0x02] = "Legacy Read",
+    [0x03] = "0x03",
+    [0x04] = "0x04",
+    [0x05] = "0x05",
+    [0x06] = "0x06",
+    [0x07] = "0x07",
+    [0x08] = "Coherent Read Own",
+    [0x09] = "Coherent Read Share",
+    [0x0a] = "Coherent Read Discard",
+    [0x0b] = "Coherent Ready Share Always",
+    [0x0c] = "Coherent Upgrade",
+    [0x0d] = "Coherent Writeback",
+    [0x0e] = "0x0e",
+    [0x0f] = "0x0f",
+    [0x10] = "Coherent Copyback",
+    [0x11] = "Coherent Copyback Invalidate",
+    [0x12] = "Coherent Invalidate",
+    [0x13] = "Coherent Write Invalidate",
+    [0x14] = "Coherent Completion Sync",
+    [0x15] = "0x15",
+    [0x16] = "0x16",
+    [0x17] = "0x17",
+    [0x18] = "0x18",
+    [0x19] = "0x19",
+    [0x1a] = "0x1a",
+    [0x1b] = "0x1b",
+    [0x1c] = "0x1c",
+    [0x1d] = "0x1d",
+    [0x1e] = "0x1e",
+    [0x1f] = "0x1f"
+ };
+ 
+ static char *core[8] = {
+    "Invalid/OK",  "Invalid/Data",
+    "Shared/OK",   "Shared/Data",
+    "Modified/OK", "Modified/Data",
+    "Exclusive/OK", "Exclusive/Data"
+ };
+ 
+ static char *causes[32] = {
+    "None", "GC_WR_ERR", "GC_RD_ERR", "COH_WR_ERR",
+    "COH_RD_ERR", "MMIO_WR_ERR", "MMIO_RD_ERR", "0x07",
+    "0x08", "0x09", "0x0a", "0x0b",
+    "0x0c", "0x0d", "0x0e", "0x0f",
+    "0x10", "0x11", "0x12", "0x13",
+    "0x14", "0x15", "0x16", "INTVN_WR_ERR",
+    "INTVN_RD_ERR", "0x19", "0x1a", "0x1b",
+    "0x1c", "0x1d", "0x1e", "0x1f"
+ };
+ 
+ int baikal_be_handler(struct pt_regs *regs, int is_fixup)
+ {
+    /* This duplicates the handling in do_be which seems wrong */
+    int retval = is_fixup ? MIPS_BE_FIXUP : MIPS_BE_FATAL;
+ 
+    if (mips_cm_present()) {
+       unsigned long cm_error = read_gcr_error_cause();
+       unsigned long cm_addr = read_gcr_error_addr();
+       unsigned long cm_other = read_gcr_error_mult();
+       unsigned long cause, ocause;
+       char buf[256];
+ 
+       cause = cm_error & CM_GCR_ERROR_CAUSE_ERRTYPE_MSK;
+       if (cause != 0) {
+          cause >>= CM_GCR_ERROR_CAUSE_ERRTYPE_SHF;
+          if (cause < 16) {
+             unsigned long cca_bits = (cm_error >> 15) & 7;
+             unsigned long tr_bits = (cm_error >> 12) & 7;
+             unsigned long cmd_bits = (cm_error >> 7) & 0x1f;
+             unsigned long stag_bits = (cm_error >> 3) & 15;
+             unsigned long sport_bits = (cm_error >> 0) & 7;
+ 
+             snprintf(buf, sizeof(buf),
+                 "CCA=%lu TR=%s MCmd=%s STag=%lu "
+                 "SPort=%lu\n",
+                 cca_bits, tr[tr_bits], mcmd[cmd_bits],
+                 stag_bits, sport_bits);
+          } else {
+             /* glob state & sresp together */
+             unsigned long c3_bits = (cm_error >> 18) & 7;
+             unsigned long c2_bits = (cm_error >> 15) & 7;
+             unsigned long c1_bits = (cm_error >> 12) & 7;
+             unsigned long c0_bits = (cm_error >> 9) & 7;
+             unsigned long sc_bit = (cm_error >> 8) & 1;
+             unsigned long cmd_bits = (cm_error >> 3) & 0x1f;
+             unsigned long sport_bits = (cm_error >> 0) & 7;
+             snprintf(buf, sizeof(buf),
+                 "C3=%s C2=%s C1=%s C0=%s SC=%s "
+                 "MCmd=%s SPort=%lu\n",
+                 core[c3_bits], core[c2_bits],
+                 core[c1_bits], core[c0_bits],
+                 sc_bit ? "True" : "False",
+                 mcmd[cmd_bits], sport_bits);
+          }
+ 
+          ocause = (cm_other & CM_GCR_ERROR_MULT_ERR2ND_MSK) >>
+              CM_GCR_ERROR_MULT_ERR2ND_SHF;
+ 
+          pr_err("CM_ERROR=%08lx %s <%s>\n", cm_error,
+                 causes[cause], buf);
+          pr_err("CM_ADDR =%08lx\n", cm_addr);
+          pr_err("CM_OTHER=%08lx %s\n", cm_other, causes[ocause]);
+ 
+          /* reprime cause register */
+          write_gcr_error_cause(0);
+       }
+    }
+ 
+    return retval;
+ }
diff -rcNP linux-4.4.24/arch/mips/baikal/baikal-time.c linux-4.4.24-baikal/arch/mips/baikal/baikal-time.c
*** linux-4.4.24/arch/mips/baikal/baikal-time.c	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/arch/mips/baikal/baikal-time.c	2016-11-11 14:49:51.000000000 +0300
***************
*** 0 ****
--- 1,96 ----
+ /*
+  * Baikal-T SOC platform support code.
+  *
+  * Copyright (C) 2014-2016 Baikal Electronics JSC
+  *
+  * This program is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU General Public License
+  * as published by the Free Software Foundation; either version 2
+  * of the License, or (at your option) any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; if not, write to the Free Software
+  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+  */
+ 
+ #include <linux/init.h>
+ #include <linux/sched_clock.h>
+ #include <linux/clk-provider.h>		/* of_clk_init */
+ #include <linux/clocksource.h> 		/* clocksource_of_init */
+ #include <linux/clk.h>			/* of_clk_get */
+ #include <linux/of.h>
+ #include <linux/irqchip/mips-gic.h>
+ 
+ #include <asm/bootinfo.h>
+ #include <asm/time.h>
+ 
+ #include <linux/irqchip/mips-gic.h>
+ #include <asm/mach-baikal/hardware.h>
+ #include "common.h"
+ 
+ static unsigned long __init plat_get_dev_clk(const char *name)
+ {
+ 	struct device_node *np;
+ 	struct clk *clk;
+ 	int ret;
+ 
+ 	/* Get node */
+ 	np = of_find_compatible_node(NULL, NULL, name);
+ 	if (!np)
+ 		return 0;
+ 
+ 	/* Get node clock index 0 */
+ 	clk = of_clk_get(np, 0);
+ 	if (IS_ERR(clk))
+ 		return 0;
+ 
+ 	/* Prepare and enable clock */
+ 	ret = clk_prepare_enable(clk);
+ 	if (!ret)
+ 		return clk_get_rate(clk);
+ 
+ 	if (of_property_read_u32(np, "clock-frequency", &ret))
+ 		return 0;
+ 
+ 	return ret;
+ }
+ 
+ /*
+  * Platform timers initialization
+  */
+ void __init plat_time_init(void)
+ {
+ 	/* Init system clocks */
+ 	of_clk_init(NULL);
+ 
+ 	if (!of_have_populated_dt())
+ 		pr_info("No device tree!!!!\n");
+ 
+ 	/* Init clocksources */
+ 	clocksource_probe();
+ 
+ 	/* Set architectural timer frequency */
+ 	mips_hpt_frequency = plat_get_dev_clk("mti,p5600");
+ 
+ 	/* Check frequency */
+ 	if (!mips_hpt_frequency) {
+ 		pr_warn("No CPU clock frequency defined.\n");
+ 		mips_hpt_frequency = CPU_FREQ / CPU_CLK_DIV;
+ 	}
+ 
+ 	/* Report CPU clock frequency */
+ 	pr_info("CPU timer frequency: %u MHz\n",
+ 		(unsigned int)(mips_hpt_frequency / 1000000));
+ 
+ 	/*
+ 	 * Use deterministic values for initial counter interrupt
+ 	 * so that calibrate delay avoids encountering a counter wrap.
+ 	 */
+ 	write_c0_count(0);
+ 	write_c0_compare(0xffff);
+ }
diff -rcNP linux-4.4.24/arch/mips/baikal/baikal-wdt.c linux-4.4.24-baikal/arch/mips/baikal/baikal-wdt.c
*** linux-4.4.24/arch/mips/baikal/baikal-wdt.c	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/arch/mips/baikal/baikal-wdt.c	2016-11-11 14:49:51.000000000 +0300
***************
*** 0 ****
--- 1,250 ----
+ /*
+  * Baikal-T SOC platform support code. AXI Terminator driver.
+  *
+  * Copyright (C) 2014-2016 Baikal Electronics JSC
+  * 
+  * Author:
+  *   Dmitry Dunaev <dmitry.dunaev@baikalelectronics.ru>
+  *
+  * This program is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU General Public License
+  * as published by the Free Software Foundation; either version 2
+  * of the License, or (at your option) any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; if not, write to the Free Software
+  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+  */
+ 
+ #include <linux/device.h>
+ #include <linux/delay.h>
+ #include <linux/clk.h>
+ #include <linux/clockchips.h>
+ #include <linux/cpu.h>
+ #include <linux/err.h>
+ #include <linux/fs.h>
+ #include <linux/io.h>
+ #include <linux/init.h>
+ #include <linux/interrupt.h>
+ #include <linux/irqchip/mips-gic.h>
+ #include <linux/kernel.h>
+ #include <linux/module.h>
+ #include <linux/notifier.h>
+ #include <linux/of_irq.h>
+ #include <linux/of.h>
+ #include <linux/percpu.h>
+ #include <linux/platform_device.h>
+ #include <linux/smp.h>
+ 
+ #define VERSION			"1.01"
+ #define WDT_SECONDS		30
+ #define WDT_TIMEOUT		(HZ / 2)
+ #define WDT_MODE_DEF	GIC_WD_CTRL_TYPE_PIT
+ 
+ struct {
+ 	struct clk			*clk;
+ 	unsigned int 		irq;
+ 	unsigned int 		freq;
+ 	unsigned int 		next;
+ 	unsigned int 		initial;
+ } be_wdt;
+ 
+ static inline void be_wdt_set_next_heartbeat(void)
+ {
+ 	be_wdt.next = jiffies + WDT_SECONDS * HZ;
+ }
+ 
+ static void be_wdt_update(void *data)
+ {
+ 	gic_write_wd_initial(be_wdt.initial);	
+ }
+ 
+ static void be_wdt_keepalive(void)
+ {
+ 	on_each_cpu(be_wdt_update, NULL, 1);
+ }
+ 
+ static irqreturn_t be_wdt_interrupt(int irq, void *dev_id)
+ {
+ 	be_wdt_update(NULL);
+ 
+ 	return IRQ_HANDLED;
+ }
+ 
+ struct irqaction be_wdt_irqaction = {
+ 	.handler = be_wdt_interrupt,
+ 	.flags = IRQF_PERCPU | IRQF_TIMER,
+ 	.name = "watchdog",
+ };
+ 
+ static void be_wdt_mode(void *data)
+ {
+ 	unsigned int *mode = (unsigned int *)data;
+ 	gic_write_wd_ctrl(*mode);
+ }
+ 
+ static void be_wdt_enable(void *data)
+ {
+ 	unsigned int mode = gic_read_wd_ctrl();
+ 
+ 	mode = WDT_MODE_DEF << GIC_WD_CTRL_TYPE_SHFT;
+ 	mode |=  GIC_WD_CTRL_WAIT_MSK | GIC_WD_CTRL_START_MSK;
+ 
+ 	enable_percpu_irq(be_wdt.irq, IRQ_TYPE_NONE);
+ 	on_each_cpu(be_wdt_mode, (void *)&mode, 1);
+ }
+ 
+ static void be_wdt_disable(void *data)
+ {
+ 	unsigned int mode = gic_read_wd_ctrl();
+ 
+ 	mode &=  ~GIC_WD_CTRL_START_MSK;
+ 
+ 	disable_percpu_irq(be_wdt.irq);
+ 	on_each_cpu(be_wdt_mode, (void *)&mode, 1);
+ }
+ 
+ static int be_wdt_cpu_notifier(struct notifier_block *nb, unsigned long action,
+ 				void *data)
+ {
+ 	switch (action & ~CPU_TASKS_FROZEN) {
+ 	case CPU_STARTING:
+ 		be_wdt_enable(data);
+ 		break;
+ 	case CPU_DYING:
+ 		be_wdt_disable(data);
+ 		break;
+ 	}
+ 
+ 	return NOTIFY_OK;
+ }
+ 
+ static struct notifier_block be_wdt_cpu_nb = {
+ 	.notifier_call = be_wdt_cpu_notifier,
+ };
+ 
+ static const char * be_wdt_mode_str(unsigned int mode)
+ {
+ 	switch (mode) {
+ 	case GIC_WD_CTRL_TYPE_SC:
+ 		return "Secondary Count";
+ 	case GIC_WD_CTRL_TYPE_OT:
+ 		return "One Tick";
+ 	case GIC_WD_CTRL_TYPE_PIT:
+ 		return "Programm Interval";
+ 	default:
+ 		return "Unknown Mode";
+ 	}
+ }
+ 
+ static int be_wdt_drv_probe(struct platform_device *pdev)
+ {
+ 	int ret;
+ 
+ 	be_wdt.clk = devm_clk_get(&pdev->dev, NULL);
+ 	if (IS_ERR(be_wdt.clk))
+ 		return PTR_ERR(be_wdt.clk);
+ 
+ 	ret = clk_prepare_enable(be_wdt.clk);
+ 	if (ret)
+ 		return ret;
+ 	be_wdt.freq = clk_get_rate(be_wdt.clk);
+ 
+ 	be_wdt.irq = platform_get_irq(pdev, 0);
+ 	if (be_wdt.irq < 0)
+ 		goto err_clk;
+ 
+ 	be_wdt_irqaction.percpu_dev_id = (void *)&be_wdt;
+ 	ret = setup_percpu_irq(be_wdt.irq, &be_wdt_irqaction);
+ 	if (ret < 0)
+ 		goto err_irq;
+ 
+ 	ret = register_cpu_notifier(&be_wdt_cpu_nb);
+ 	if (ret < 0)
+ 		dev_warn(&pdev->dev, "Unable to register CPU notifier\n");
+ 
+ 	be_wdt.initial = WDT_SECONDS * 10000000 / be_wdt.freq;
+ 	be_wdt_set_next_heartbeat();
+ 
+ 	dev_info(&pdev->dev, "Baikal Electronics GIC Watchdog Driver\n");
+ 	dev_info(&pdev->dev, "Version " VERSION "\n");
+ 	dev_info(&pdev->dev, "Mode: %s Timer\n", be_wdt_mode_str(WDT_MODE_DEF));
+ 
+ 	return 0;
+ 
+ err_irq:
+ 	remove_percpu_irq(be_wdt.irq, &be_wdt_irqaction);
+ err_clk:
+ 	clk_disable_unprepare(be_wdt.clk);
+ 
+ 	return ret;
+ }
+ 
+ static int be_wdt_drv_remove(struct platform_device *pdev)
+ {
+ 	clk_disable_unprepare(be_wdt.clk);
+ 
+ 	disable_percpu_irq(be_wdt.irq);
+ 
+ 	remove_percpu_irq(be_wdt.irq, &be_wdt_irqaction);
+ 
+ 	return 0;
+ }
+ 
+ #ifdef CONFIG_PM_SLEEP
+ static int be_wdt_suspend(struct device *dev)
+ {
+ 	clk_disable_unprepare(be_wdt.clk);
+ 
+ 	return 0;
+ }
+ 
+ static int be_wdt_resume(struct device *dev)
+ {
+ 	int ret;
+ 
+ 	ret = clk_prepare_enable(be_wdt.clk);
+ 
+ 	if (ret)
+ 		return ret;
+ 
+ 	be_wdt_keepalive();
+ 
+ 	return 0;
+ }
+ 
+ static SIMPLE_DEV_PM_OPS(be_wdt_pm_ops, be_wdt_suspend, be_wdt_resume);
+ #endif /* CONFIG_PM_SLEEP */
+ 
+ #ifdef CONFIG_OF
+ static const struct of_device_id be_wdt_of_match[] = {
+ 	{ .compatible = "be,gic-wdt", },
+ 	{ /* sentinel */ }
+ };
+ MODULE_DEVICE_TABLE(of, be_wdt_of_match);
+ #endif
+ 
+ static struct platform_driver be_wdt_driver = {
+ 	.probe		= be_wdt_drv_probe,
+ 	.remove		= be_wdt_drv_remove,
+ 	.driver		= {
+ 		.name	= "be-wdt",
+ 		.of_match_table = of_match_ptr(be_wdt_of_match),
+ #ifdef CONFIG_PM_SLEEP
+ 		.pm	= &be_wdt_pm_ops,
+ #endif
+ 	},
+ };
+ 
+ module_platform_driver(be_wdt_driver);
+ 
+ MODULE_VERSION(VERSION);
+ MODULE_AUTHOR("Dmitry Dunaev <dmitry.dunaev@baikalelectronics.ru>");
+ MODULE_DESCRIPTION("Baikal Electronics GIC Watchdog Driver");
+ MODULE_LICENSE("Dual BSD/GPL");
+ MODULE_ALIAS("platform:be_wdt");
diff -rcNP linux-4.4.24/arch/mips/baikal/common.h linux-4.4.24-baikal/arch/mips/baikal/common.h
*** linux-4.4.24/arch/mips/baikal/common.h	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/arch/mips/baikal/common.h	2016-11-11 14:49:51.000000000 +0300
***************
*** 0 ****
--- 1,30 ----
+ /*
+  * Baikal-T SOC platform support code.
+  *
+  * Copyright (C) 2014-2016 Baikal Electronics JSC
+  *
+  * This program is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU General Public License
+  * as published by the Free Software Foundation; either version 2
+  * of the License, or (at your option) any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; if not, write to the Free Software
+  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+  */
+ 
+ #ifndef __BAIKAL_COMMON_H
+ #define __BAIKAL_COMMON_H
+ 
+ #define CPU_FREQ		600000000
+ #define CPU_CLK_DIV		2
+ 
+ extern __iomem void *plat_of_remap_node(const char *node);
+ extern int device_tree_early_init(void);
+ 
+ #endif /* __BAIKAL_COMMON_H */
\ В конце файла нет новой строки
diff -rcNP linux-4.4.24/arch/mips/baikal/Kconfig linux-4.4.24-baikal/arch/mips/baikal/Kconfig
*** linux-4.4.24/arch/mips/baikal/Kconfig	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/arch/mips/baikal/Kconfig	2016-11-11 14:49:51.000000000 +0300
***************
*** 0 ****
--- 1,419 ----
+ # 
+ # Baikal-T SOC platform support code.
+ #
+ # Copyright (C) 2014-2016 Baikal Electronics JSC
+ # 
+ # Author:
+ #   Dmitry Dunaev <dmitry.dunaev@baikalelectronics.ru>
+ #
+ # This program is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU General Public License
+ # as published by the Free Software Foundation; either version 2
+ # of the License, or (at your option) any later version.
+ #
+ # This program is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ # GNU General Public License for more details.
+ #
+ # You should have received a copy of the GNU General Public License
+ # along with this program; if not, write to the Free Software
+ # Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ #
+ 
+ if MIPS_BAIKAL
+ 
+ choice
+         prompt "Baikal CPU Support"
+         default ARCH_BAIKAL
+ 
+ config ARCH_BAIKAL
+ bool "BAIKAL-T MIPS CPU"
+     select OF_EARLY_FLATTREE
+     select GENERIC_SCHED_CLOCK
+     select NO_IOPORT
+     select SOC_BUS
+ 
+ help
+   Baikal-T (MIPS32 P5600) SoC based systems
+ 
+ endchoice
+ 
+ if ARCH_BAIKAL
+ 
+ choice
+         prompt "Baikal-T Support Boards"
+         default MACH_BAIKAL_BFK
+ 
+ config MACH_BAIKAL_BFK
+ bool "Baikal-T BFK board"
+ 
+     # Hardware features
+     select HW_HAS_PCI
+     select HW_PERF_EVENTS
+ 
+     # Errata set
+     select PAGE_SIZE_16KB
+ 
+     # Common
+     select PHYLIB
+     select DEBUG_LL
+     select TIMER_GENERIC
+     select ARCH_WANT_OPTIONAL_GPIOLIB
+     select SYS_HAS_CPU_MIPS32_R5
+ 
+     # HW perfomance counters
+     select HAVE_PERF_EVENTS
+     select PERF_EVENTS
+     select HW_PERF_EVENTS
+ 
+     # Clock source
+     select COMMON_CLK_BAIKAL
+     select WDT_MIPS_GIC
+ 
+     # Serial UART
+     select SERIAL_8250
+     select SERIAL_8250_CONSOLE
+     select SERIAL_8250_EXTENDED
+     select SERIAL_8250_DW
+ 
+     # WatchDog
+     select DW_WATCHDOG
+ 
+     # Timers
+     select CLKSRC_OF
+     select DW_APB_TIMER
+     select DW_APB_TIMER_OF
+ 
+     # I2C Bus support
+     select I2C_DESIGNWARE_CORE
+     select I2C_DESIGNWARE_PLATFORM
+ 
+     # GPIO support
+     select GPIOLIB
+     select OF_GPIO
+     select GPIO_SYSFS
+     select GPIO_DWAPB
+     select GPIO_GENERIC
+ 
+     # Gigabit Ethernet support
+     select STMMAC_ETH
+     select STMMAC_PLATFORM
+     select STMMAC_DEBUG_FS
+ 
+     # SPI bus support
+     select SPI_DESIGNWARE
+     select SPI_DW_MMIO
+ 
+     # USB Support
+     select USB_DWC3
+     select USB_DWC3_HOST
+     select USB_DWC3_BAIKAL
+     select USB_PHY
+ 
+     # DTB select
+     select DTB_BAIKAL_BFK
+ 
+ config MACH_BAIKAL_BFK2
+ bool "Baikal-T BFK2 board"
+ 
+     # Hardware features
+     select HW_HAS_PCI
+     select HW_PERF_EVENTS
+ 
+     # Errata set
+     select PAGE_SIZE_16KB
+ 
+     # Common
+     select PHYLIB
+     select DEBUG_LL
+     select TIMER_GENERIC
+     select ARCH_WANT_OPTIONAL_GPIOLIB
+     select SYS_HAS_CPU_MIPS32_R5
+ 
+     # HW perfomance counters
+     select HAVE_PERF_EVENTS
+     select PERF_EVENTS
+     select HW_PERF_EVENTS
+ 
+     # Clock source
+     select COMMON_CLK_BAIKAL
+     select WDT_MIPS_GIC
+ 
+     # Serial UART
+     select SERIAL_8250
+     select SERIAL_8250_CONSOLE
+     select SERIAL_8250_EXTENDED
+     select SERIAL_8250_DW
+ 
+     # WatchDog
+     select DW_WATCHDOG
+ 
+     # Timers
+     select CLKSRC_OF
+     select DW_APB_TIMER
+     select DW_APB_TIMER_OF
+ 
+     # I2C Bus support
+     select I2C_DESIGNWARE_CORE
+     select I2C_DESIGNWARE_PLATFORM
+ 
+     # GPIO support
+     select GPIOLIB
+     select OF_GPIO
+     select GPIO_SYSFS
+     select GPIO_DWAPB
+     select GPIO_GENERIC
+ 
+     # Gigabit Ethernet support
+     select STMMAC_ETH
+     select STMMAC_PLATFORM
+     select STMMAC_DEBUG_FS
+ 
+     # SPI bus support
+     select SPI_DESIGNWARE
+     select SPI_DW_MMIO
+ 
+     # USB Support
+     select USB_DWC3
+     select USB_DWC3_HOST
+     select USB_DWC3_BAIKAL
+     select USB_PHY
+ 
+     # DTB select
+     select DTB_BAIKAL_BFK2
+ 
+ config MACH_BAIKAL_MODULE
+ bool "Baikal-T Module board"
+ 
+     # Hardware features
+     select HW_HAS_PCI
+     select HW_PERF_EVENTS
+ 
+     # Errata set
+     select PAGE_SIZE_16KB
+ 
+     # Common
+     select PHYLIB
+     select DEBUG_LL
+     select TIMER_GENERIC
+     select ARCH_WANT_OPTIONAL_GPIOLIB
+     select SYS_HAS_CPU_MIPS32_R5
+ 
+     # HW perfomance counters
+     select HAVE_PERF_EVENTS
+     select PERF_EVENTS
+     select HW_PERF_EVENTS
+ 
+     # Clock source
+     select COMMON_CLK_BAIKAL
+ 
+     # Serial UART
+     select SERIAL_8250
+     select SERIAL_8250_CONSOLE
+     select SERIAL_8250_EXTENDED
+     select SERIAL_8250_DW
+ 
+     # WatchDog
+     select DW_WATCHDOG
+ 
+     # Timers
+     select CLKSRC_OF
+     select DW_APB_TIMER
+     select DW_APB_TIMER_OF
+ 
+     # I2C Bus support
+     select I2C_DESIGNWARE_CORE
+     select I2C_DESIGNWARE_PLATFORM
+ 
+     # GPIO support
+     select GPIOLIB
+     select OF_GPIO
+     select GPIO_SYSFS
+     select GPIO_DWAPB
+     select GPIO_GENERIC
+ 
+     # Gigabit Ethernet support
+     select STMMAC_ETH
+     select STMMAC_PLATFORM
+     select STMMAC_DEBUG_FS
+ 
+     # SPI bus support
+     select SPI_DESIGNWARE
+     select SPI_DW_MMIO
+ 
+     # USB Support
+     select USB_DWC3
+     select USB_DWC3_HOST
+     select USB_DWC3_BAIKAL
+     select USB_PHY
+ 
+     # DTB select
+     select DTB_BAIKAL_MODULE
+ 
+ help
+   Machine support for Baikal-T SOC family
+ 
+ config MACH_BAIKAL_QEMU
+ bool "Baikal-T QEMU simulator"
+ 
+     # Errata set 
+     select PAGE_SIZE_16KB
+ 
+     # Common
+     select PHYLIB
+     select DEBUG_LL
+     select TIMER_GENERIC
+     select ARCH_WANT_OPTIONAL_GPIOLIB
+ 
+     # Clock source
+     select COMMON_CLK_BAIKAL
+ 
+     # Serial UART
+     select SERIAL_8250
+     select SERIAL_8250_CONSOLE
+     select SERIAL_8250_EXTENDED
+     select SERIAL_8250_DW
+ 
+     # WatchDog
+     select DW_WATCHDOG
+ 
+     # Timers
+     select CLKSRC_OF
+     select DW_APB_TIMER
+     select DW_APB_TIMER_OF
+ 
+     # I2C Bus support
+     select I2C_DESIGNWARE_CORE
+     select I2C_DESIGNWARE_PLATFORM
+ 
+     # GPIO support
+     select GPIOLIB
+     select OF_GPIO
+     select GPIO_SYSFS
+     select GPIO_DWAPB
+     select GPIO_GENERIC
+ 
+     # Gigabit Ethernet support
+     select STMMAC_ETH
+     select STMMAC_PLATFORM
+     select STMMAC_DEBUG_FS
+ 
+     # SPI bus support
+     select SPI_DESIGNWARE
+     select SPI_DW_MMIO
+ 
+     # DTB select
+     select DTB_BAIKAL_QEMU
+ 
+ config MACH_BAIKAL_FPGA
+ bool "Baikal-T FPGA board"
+ 
+     # Errata set 
+     select PAGE_SIZE_16KB
+ 
+     # Common
+     select DEBUG_LL
+     select TIMER_GENERIC
+ 
+     # Serial UART
+     select SERIAL_8250
+     select SERIAL_8250_CONSOLE
+     select SERIAL_8250_EXTENDED
+     select SERIAL_8250_DW
+ 
+     # Timers
+     select CLKSRC_OF
+     select DW_APB_TIMER
+     select DW_APB_TIMER_OF
+ 
+     # DTB select
+     select DTB_BAIKAL_FPGA
+ 
+ endchoice
+ 
+ choice
+         prompt "Baikal Board configs"
+         default DTB_BAIKAL
+ 
+ config DTB_BAIKAL
+     bool "Baikal-T generic board"
+     help
+       Generic device tree for common boards
+       based on Baikal-T SOC family. Contains
+       only devices included in basic SOC
+       configuration.
+ 
+ config DTB_BAIKAL_BFK
+     bool "Baikal-T BFK board"
+     help
+       Device tree for BFK boards (for versions 1.0, 1.5, 1.6)
+       based on Baikal-T SOC.
+ 
+ config DTB_BAIKAL_BFK2
+     bool "Baikal-T BFK2 board"
+     help
+       Device tree for BFK2 boards (for versions 2.x)
+       based on Baikal-T SOC.
+ 
+ config DTB_BAIKAL_MODULE
+     bool "Baikal-T 'Module' board"
+     help
+       Device tree for Baikal-T 'Module' board.
+       Common device configuration.
+ 
+ config DTB_BAIKAL_QEMU
+     bool "Baikal-T QEMU simulator"
+     help
+       Device tree for QEMU simulator.
+ 
+ config DTB_BAIKAL_FPGA
+     bool "Baikal-T FPGA board"
+     help
+       Device tree for Baikal-T FPGA prototype.
+       Simple device configuration.
+ 
+ help
+   Select device tree for Baikal-T SOC based board
+ endchoice
+ 
+ menuconfig BAIKAL_ERRATA
+ bool "Baikal SoC Errata Fix"
+ help
+   Select this option if you want to fix known Baikal Errata
+ 
+ if BAIKAL_ERRATA
+ 
+ config BAIKAL_ERRATA_XGMAC
+     bool "Fix for MMD Devices in package registers swap in XGMAC"
+     help
+       Fix for MMD Devices in package registers swap in XGMAC in
+       early Baikal-T SoCs
+ 
+       If unsure, say Y.
+ 
+ config BAIKAL_ERRATA_GMAC
+     bool "Fix for GMAC block speed 10/100M"
+     help
+       Fix for GMAC block speed 10/100M in early Baikal-T SoCs
+ 
+       If unsure, say N.
+ 
+ config BAIKAL_ERRATA_GBE_PHY_MICREL
+     bool "Fix for Micrel PHY RX delay on BFK board"
+     help
+       Fix for Micrel PHY RX delay on early revisions of BFK board (v1.0)
+ 
+       If unsure, say N.
+ 
+ endif # BAIKAL_ERRATA
+ endif # ARCH_BAIKAL
+ endif # MACH_BAIKAL
+ 
+ config SYS_HAS_CPU_MIPS32_R5
+     bool
+     default n
+ 
+ config WDT_MIPS_GIC
+     bool
+     default n
diff -rcNP linux-4.4.24/arch/mips/baikal/Makefile linux-4.4.24-baikal/arch/mips/baikal/Makefile
*** linux-4.4.24/arch/mips/baikal/Makefile	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/arch/mips/baikal/Makefile	2016-11-11 14:49:51.000000000 +0300
***************
*** 0 ****
--- 1,30 ----
+ # 
+ # Baikal-T SOC platform support code.
+ #
+ # Copyright (C) 2014-2016 Baikal Electronics JSC
+ #
+ # This program is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU General Public License
+ # as published by the Free Software Foundation; either version 2
+ # of the License, or (at your option) any later version.
+ #
+ # This program is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ # GNU General Public License for more details.
+ #
+ # You should have received a copy of the GNU General Public License
+ # along with this program; if not, write to the Free Software
+ # Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ #
+ 
+ cflags-y += -I$(srctree)/arch/mips/include/asm/mach-baikal
+ 
+ obj-y				:= baikal-init.o baikal-int.o baikal-memory.o \
+ 				   baikal-setup.o baikal-time.o \
+ 				   baikal-apb.o baikal-axi.o baikal-emc.o
+ 
+ obj-$(CONFIG_EARLY_PRINTK)	+= baikal-console.o
+ obj-$(CONFIG_OF)		+= baikal-of.o
+ obj-$(CONFIG_CPU_FREQ)		+= baikal-cpufreq.o
+ obj-$(CONFIG_WDT_MIPS_GIC)	+= baikal-wdt.o
\ В конце файла нет новой строки
diff -rcNP linux-4.4.24/arch/mips/baikal/Platform linux-4.4.24-baikal/arch/mips/baikal/Platform
*** linux-4.4.24/arch/mips/baikal/Platform	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/arch/mips/baikal/Platform	2016-11-11 14:49:51.000000000 +0300
***************
*** 0 ****
--- 1,30 ----
+ # 
+ # Baikal-T SOC platform support code.
+ #
+ # Copyright (C) 2014-2016 Baikal Electronics JSC
+ #
+ # This program is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU General Public License
+ # as published by the Free Software Foundation; either version 2
+ # of the License, or (at your option) any later version.
+ #
+ # This program is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ # GNU General Public License for more details.
+ #
+ # You should have received a copy of the GNU General Public License
+ # along with this program; if not, write to the Free Software
+ # Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ #
+ 
+ platform-$(CONFIG_MIPS_BAIKAL)	+= baikal/
+ cflags-$(CONFIG_MIPS_BAIKAL)	+= -I$(srctree)/arch/mips/include/asm/mach-baikal
+ cflags-$(CONFIG_CPU_MIPS32_R5)	+= -mfp64 -Wa,-mmsa -mips32r5 -mtune=p5600
+ ifdef CONFIG_KVM_GUEST
+     load-$(CONFIG_MIPS_BAIKAL)	+= 0x0000000040100000
+ else
+     load-$(CONFIG_MIPS_BAIKAL)	+= 0xffffffff80100000
+ endif
+ all-$(CONFIG_MIPS_BAIKAL)	:= $(COMPRESSION_FNAME).bin
+ 
diff -rcNP linux-4.4.24/arch/mips/boot/dts/baikal/baikal_bfk2.dts linux-4.4.24-baikal/arch/mips/boot/dts/baikal/baikal_bfk2.dts
*** linux-4.4.24/arch/mips/boot/dts/baikal/baikal_bfk2.dts	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/arch/mips/boot/dts/baikal/baikal_bfk2.dts	2016-11-11 14:49:51.000000000 +0300
***************
*** 0 ****
--- 1,516 ----
+ /*
+  * Baikal-T BFK2 board device tree.
+  *
+  * Copyright (C) 2014-2016  Baikal Electronics JSC
+  *
+  * This program is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU General Public License
+  * as published by the Free Software Foundation; either version 2
+  * of the License, or (at your option) any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; if not, write to the Free Software
+  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+  */
+ 
+ #include <dt-bindings/interrupt-controller/mips-gic.h>
+ #include <dt-bindings/gpio/gpio.h>
+ 
+ /dts-v1/;
+ 
+ /include/ "baikal_t1_clocks.dtsi"
+ 
+ / {
+ 	model = "Baikal-T BFK2 Board";
+ 	compatible = "baikal,mips";
+ 	#address-cells = <1>;
+ 	#size-cells = <1>;
+ 	interrupt-parent = <&gic>;
+ 
+ 	aliases {
+ 		gic = &gic;
+ 		serial0 = &uart0;
+ 		serial1 = &uart1;
+ 		i2c0 = &i2c0;
+ 		i2c1 = &i2c1;
+ 		ssi0 = &spi0;
+ 		ssi1 = &spi1;
+ 		ethernet0 = &gmac0;
+ 		ethernet1 = &gmac1;
+ /*		ethernet2 = &xgmac; */
+ 		mdio-gpio0 = &mdio0;
+ 	};
+ 
+ 	chosen {
+ 		bootargs = "root=/dev/ram rw console=ttyS0,38400 earlyprintk=uart8250,mmio32,0x1F04A000,38400 nohtw";
+ 		linux,initrd-start = <0x01000000>;
+ 		linux,initrd-end   = <0x02000000>;
+ 	};
+ 
+ 	cpus {
+ 		#address-cells = <1>;
+ 		#size-cells = <0>;
+ 
+ 		CPU0: cpu@0 {
+ 			device_type = "cpu";
+ 			compatible = "mti,p5600";
+ 			reg = <0x0>;
+ 			clocks = <&cpu_clk 0>;
+ 			clock-names = "cpuclk";
+ 		};
+ 
+ 		CPU1: cpu@1 {
+ 			device_type = "cpu";
+ 			compatible = "mti,p5600";
+ 			reg = <0x1>;
+ 			clocks = <&cpu_clk 0>;
+ 			clock-names = "cpuclk";
+ 		};
+ 	};
+ 
+ 	memory {
+ 		device_type = "memory";
+ 		reg = <0x00000000 0x08000000>,
+ 		      <0x20000000 0xC0000000>;
+ 	};
+ 
+ 	gic: gic@1BDC0000 {
+ 		compatible = "mti,gic";
+ 		reg = <0x1BDC0000 0x20000>;
+ 
+ 		interrupt-controller;
+ 		#interrupt-cells = <3>;
+ 
+ 		timer:timer {
+ 			compatible = "mti,gic-timer";
+ 			interrupts = <GIC_LOCAL 1 IRQ_TYPE_NONE>;
+ 			clock-frequency = <600000000>;
+ 			clocks = <&gic_clk 0>;
+ 			clock-names = "gicclk";
+ 		};
+ 	};
+ 	axi {
+ 		compatible = "simple-bus";
+ 		#address-cells = <1>;
+ 		#size-cells = <1>;
+ 		interrupt-parent = <&gic>;
+ 
+ 		ranges;
+ 
+ 		gic_wdt:gic_wdt {
+ 			compatible = "be,gic-wdt";
+ 			interrupts = <GIC_LOCAL 0 IRQ_TYPE_NONE>;
+ 			clock-frequency = <600000000>;
+ 			clocks = <&gic_clk 0>;
+ 			clock-names = "gicclk";
+ 		};
+ 
+ 		dma: dma@1f041000 {
+ 			compatible = "snps,dma-spear1340";
+ 			reg = <0x1f041000 0x1000>;
+ 			interrupts = <GIC_SHARED 56 IRQ_TYPE_LEVEL_HIGH>;
+ 			dma-channels = <8>;
+ 			dma-requests = <16>;
+ 			dma-masters = <2>;
+ 			#dma-cells = <3>;
+ 			chan_allocation_order = <1>;
+ 			chan_priority = <1>;
+ 			block_size = <0xfff>;
+ 			data_width = <3 3 0 0>;
+ 			clocks = <&dma_clk 0>;
+ 			clock-names = "hclk";
+ 		};
+ 
+ 		sata@1F050000 {
+ 			interrupt-parent = <&gic>;
+ 			compatible = "snps,dwc-ahci", "generic-ahci";
+ 			reg = <0x1F050000 0x2000>;
+ 			interrupts = <GIC_SHARED 64 IRQ_TYPE_LEVEL_HIGH>;
+ 			ports-implemented = <3>;
+ 			clocks = <&sata_clk 0>;
+ 			clock-names = "sataclk";
+ 		};
+ 
+ 		mdio0: be-mdio {
+ 			compatible = "be,mdio-gpio";
+ 			#address-cells = <1>;
+ 			#size-cells = <0>;
+ 			mdc-pin = <&porta 9 GPIO_ACTIVE_HIGH>;
+ 			mdio-pin = <&porta 11 GPIO_ACTIVE_HIGH>;
+ 			clocks = <&gpio_clk 0>;
+ 			clock-names = "gpioclk";
+ 
+ 			mv_ch0:88X2222@0C {
+ 				compatible = "marvell,88x2222", "ethernet-phy-ieee802.3-c45";
+ 				reg = <0x0C>;
+ 				phy-mode = "xgmii";
+ 				mv,line-mode = <0>; /* 10GBASE-R (0x71) */
+ 				mv,host-mode = <0>; /* 10GBASE-R (0x71) */
+ 			};
+ 
+ 			mv_ch1:88X2222@0D {
+ 				compatible = "marvell,88x2222", "ethernet-phy-ieee802.3-c45";
+ 				reg = <0x0D>;
+ 				phy-mode = "xgmii";
+ 				mv,line-mode = <0>; /* 10GBASE-R (0x71) */
+ 				mv,host-mode = <0>; /* 10GBASE-R (0x71) */
+ 			};
+ 
+ 			mv_ch2:88X2222@0E {
+ 				compatible = "marvell,88x2222", "ethernet-phy-ieee802.3-c45";
+ 				reg = <0x0E>;
+ 				phy-mode = "xgmii";
+ 				mv,line-mode = <0>; /* 10GBASE-R (0x71) */
+ 				mv,host-mode = <0>; /* 10GBASE-R (0x71) */
+ 			};
+ 
+ 			mv_ch3:88X2222@0F {
+ 				compatible = "marvell,88x2222", "ethernet-phy-ieee802.3-c45";
+ 				reg = <0x0F>;
+ 				phy-mode = "xgmii";
+ 				mv,line-mode = <0>; /* 10GBASE-R (0x71) */
+ 				mv,host-mode = <0>; /* 10GBASE-R (0x71) */
+ 			};
+ 		};
+ 
+ /*
+ 
+ 		xgbe_phy: xgbe_phy@1F05D000 {
+ 			compatible = "be,xgbe-phy", "ethernet-phy-ieee802.3-c45";
+ 			reg = <0x1F05D000 0x1000>;
+ 			phy-handle = <&mv_ch0>;
+ 			phy-mode = "xgmii";
+ 			clocks = <&div_156m 0>;
+ 			clock-names = "xgbe_clk";
+ 			be,speed-set = <1>;
+ 			be,mode-set = <0>;
+ 			be,external-clock;
+ 		};
+ 
+ 		xgmac: eth0@1F054000 {
+ 			compatible = "be,baikal-xgbe";
+ 			reg = <0x1F054000 0x4000>,
+ 			      <0x1F05D000 0x1000>;
+ 			interrupt-parent = <&gic>;
+ 			interrupts = <GIC_SHARED 80 IRQ_TYPE_LEVEL_HIGH>;
+ 			clocks = <&xgmac_dma 0>, <&xgmac_ptp 0>;
+ 			clock-names = "dma_clk", "ptp_clk";
+ 			phy-handle = <&xgbe_phy>;
+ 			phy-mode = "xgmii";
+ 			mac-address = [ 00 20 13 ba 1c a1 ];
+ 			local-mac-address = [ 00 20 13 ba 1c a1 ];
+ 		};
+ */
+ 
+ 		gmac0: eth1@1F05E000 {
+ 			compatible = "be,dwmac", "snps,dwmac-3.710", "snps,dwmac";
+ 			reg = <0x1F05E000 0x2000>;
+ 			interrupt-parent = <&gic>;
+ 			interrupts = <GIC_SHARED 72 IRQ_TYPE_LEVEL_HIGH>;
+ 			interrupt-names = "macirq";
+ 			phy-mode = "rgmii";
+ 			clocks = <&gmac0_clk 0>;
+ 			clock-names = "stmmaceth";
+ 			mac-address = [ 7a 72 6c 4a 7a 07 ];
+ 			local-mac-address = [ 7a 72 6c 4a 7a 07 ];
+ 			txd0-skew-ps = <0>;
+ 			txd1-skew-ps = <0>;
+ 			txd2-skew-ps = <0>;
+ 			txd3-skew-ps = <0>;
+ 			txc-skew-ps  = <0xff>;
+ 		};
+ 
+ 		gmac1: eth2@1F060000 {
+ 			compatible = "be,dwmac", "snps,dwmac-3.710", "snps,dwmac";
+ 			reg = <0x1F060000 0x2000>;
+ 			interrupt-parent = <&gic>;
+ 			interrupts = <GIC_SHARED 73 IRQ_TYPE_LEVEL_HIGH>;
+ 			interrupt-names = "macirq";
+ 			phy-mode = "rgmii";
+ 			clocks = <&gmac1_clk 0>;
+ 			clock-names = "stmmaceth";
+ 			mac-address = [ 7a 72 6c 4a 7b 07 ];
+ 			local-mac-address = [ 7a 72 6c 4a 7b 07 ];
+ 			txd0-skew-ps = <0>;
+ 			txd1-skew-ps = <0>;
+ 			txd2-skew-ps = <0>;
+ 			txd3-skew-ps = <0>;
+ 			txc-skew-ps  = <0xff>;
+ 		};
+ 
+ 		usb3: usb@1F04D050 {
+ 			compatible = "be,baikal-dwc3";
+ 
+ 			reg = <0x1F04D050 0x0004>;
+ 			interrupts = <GIC_SHARED 69 IRQ_TYPE_LEVEL_HIGH>;
+ 
+ 			#address-cells = <1>;
+ 			#size-cells = <1>;
+ 
+ 			clocks = <&usb_clk 0>;
+ 			clock-names = "usb";
+ 
+ 			ranges;
+ 
+ 			dwc3@1F100000 {
+ 					compatible = "snps,dwc3", "synopsys,dwc3";
+ 					reg = <0x1F100000 0x10000>;
+ 					interrupts = <GIC_SHARED 68 IRQ_TYPE_LEVEL_HIGH>;
+ 					dr_mode = "host";
+ 
+ 					tx-fifo-resize;
+ 
+ 					maximum-speed = "high-speed";
+ 			};
+ 		};
+ 
+ 		pci: pci@1F052000 {
+ 			compatible = "snps,dw-pci";
+ 			interrupts = <GIC_SHARED 88 IRQ_TYPE_LEVEL_HIGH>,
+ 				<GIC_SHARED 89 IRQ_TYPE_LEVEL_HIGH>;
+ 			reg = <0x1F052000 0x1000>;
+ 		};
+ 
+ 		emc@1F042000 {
+ 			compatible = "be,emc", "be,memory-controller";
+ 			reg = <0x1F042000 0x1000>;
+ 			interrupts = <GIC_SHARED 96 IRQ_TYPE_LEVEL_HIGH>,
+ 						 <GIC_SHARED 97 IRQ_TYPE_LEVEL_HIGH>,
+ 						 <GIC_SHARED 98 IRQ_TYPE_LEVEL_HIGH>;
+ 			clocks = <&ddr_pll 0>;
+ 			clock-names = "ddrclk";
+ 		};
+ 
+ 		apb_ehb@1F059000 {
+ 			compatible = "be,apb-ehb";
+ 			reg = <0x1f059000 0x1000>;
+ 			interrupts = <GIC_SHARED 16 IRQ_TYPE_LEVEL_HIGH>;
+ 		};
+ 
+ 		axi_ehb@1F04D110 {
+ 			compatible = "be,axi-ehb";
+ 			reg = <0x1F04D110 0x8>;
+ 			interrupts = <GIC_SHARED 127 IRQ_TYPE_LEVEL_HIGH>;
+ 		};
+ 	};
+ 
+ 	apb {
+ 		compatible = "simple-bus";
+ 		#address-cells = <1>;
+ 		#size-cells = <1>;
+ 		interrupt-parent = <&gic>;
+ 
+ 		ranges;
+ 
+ 		timer0: timer0@1F049000 {
+ 			compatible = "snps,dw-apb-timer-osc";
+ 			interrupts = <GIC_SHARED 24 IRQ_TYPE_LEVEL_HIGH>;
+ 			reg = <0x1F049000 0x14>;
+ 			clocks = <&timer0_clk 0>;
+ 			clock-names = "timer";
+ 		};
+ 
+ 		timer1: timer1@1F049014 {
+ 			compatible = "snps,dw-apb-timer-sp";
+ 			reg = <0x1F049014 0x14>;
+ 			interrupts = <GIC_SHARED 25 IRQ_TYPE_LEVEL_HIGH>;
+ 			clocks = <&timer1_clk 0>;
+ 			clock-names = "timer";
+ 		};
+ 
+ 		timer2: timer2@1F049028 {
+ 			compatible = "snps,dw-apb-timer-sp";
+ 			reg = <0x1F049028 0x14>;
+ 			interrupts = <GIC_SHARED 26 IRQ_TYPE_LEVEL_HIGH>;
+ 			clocks = <&timer2_clk 0>;
+ 			clock-names = "timer";
+ 		};
+ 
+ 		uart0: serial0@1F04A000 {
+ 			compatible = "snps,dw-apb-uart";
+ 			reg = <0x1F04A000 0x1000>;
+ 			interrupts = <GIC_SHARED 48 IRQ_TYPE_LEVEL_HIGH>;
+ 			reg-shift = <2>;
+ 			reg-io-width = <4>;
+ 			clocks = <&uart_clk 0>, <&apb_clk 0>;
+ 			clock-names = "baudclk", "apb_pclk";
+ //			snps,uart-16550-compatible;
+ 			dcd-override;
+ 			dsr-override;
+ 			cts-override;
+ 			ri-override;
+ 		};
+ 
+ 		uart1: serial1@1F04B000 {
+ 			compatible = "snps,dw-apb-uart";
+ 			reg = <0x1F04B000 0x1000>;
+ 			interrupts = <GIC_SHARED 49 IRQ_TYPE_LEVEL_HIGH>;
+ 			reg-shift = <2>;
+ 			reg-io-width = <4>;
+ 			clocks = <&uart_clk 0>, <&apb_clk 0>;
+ 			clock-names = "baudclk", "apb_pclk";
+ 		};
+ 
+ 		wdt: watchdog@1F04C000 {
+ 			compatible = "snps,dw-wdt";
+ 			reg = <0x1F04C000 0x1000>;
+ 			interrupts = <GIC_SHARED 17 IRQ_TYPE_LEVEL_HIGH>;
+ 			clocks = <&wdt_clk 0>;
+ 			clock-names = "wdtclk";
+ 		};
+ 
+ 		i2c0: i2c0@1F046000 {
+ 			#address-cells = <1>;
+ 			#size-cells = <0>;
+ 			compatible = "snps,designware-i2c";
+ 			reg = <0x1F046000 0x1000>;
+ 			interrupts = <GIC_SHARED 33 IRQ_TYPE_LEVEL_HIGH>;
+ 			clock-frequency = <400000>;
+ 			clocks = <&i2c0_clk 0>;
+ 			clock-names = "i2c0clk";
+ 
+ 			codec@18 {
+ 				compatible = "tlv320aic310x";
+ 				reg = <0x18>;
+ 			};
+ 
+ 			gpioexp: gpioexp@20 {
+ 				compatible = "nxp,pca9500";
+ 				#gpio-cells = <2>;
+ 				reg = <0x20>;
+ 				gpio-controller;
+ 			};
+ 
+ 			eeprom@50 {
+ 				compatible = "atmel,24c02";
+ 				pagesize = <16>;
+ 				reg = <0x50>;
+ 			};
+ 		};
+ 
+ 		i2c1: i2c1@1F047000 {
+ 			#address-cells = <1>;
+ 			#size-cells = <0>;
+ 			compatible = "snps,designware-i2c";
+ 			reg = <0x1F047000 0x1000>;
+ 			interrupts = <GIC_SHARED 34 IRQ_TYPE_LEVEL_HIGH>;
+ 			clock-frequency = <400000>;
+ 			clocks = <&i2c1_clk 0>;
+ 			clock-names = "i2c1clk";
+ 
+ 			eeprom@50 {
+ 				compatible = "atmel,24c02";
+ 				pagesize = <16>;
+ 				reg = <0x50>;
+ 			};
+ 
+ 			eeprom@51 {
+ 				compatible = "atmel,24c02";
+ 				pagesize = <16>;
+ 				reg = <0x51>;
+ 			};
+ 
+ 			rtc@56 {
+ 				compatible = "abracon,abeoz9s3";
+ 				reg = <0x56>;
+ 			};
+ 
+ 		};
+ 
+ 		spi0: spi0@1F04E000 {
+ 			#address-cells = <1>;
+ 			#size-cells = <0>;
+ 			compatible = "snps,dw-apb-ssi", "snps,dw-spi";
+ 			reg = <0x1F04E000 0x1000>;
+ 			interrupts = <GIC_SHARED 40 IRQ_TYPE_LEVEL_HIGH>;
+ 			clocks = <&spi0_clk 0>;
+ 			clock-names = "spi0clk";
+ 			num-cs = <3>;
+ 			cs-gpios = <&porta 28 GPIO_ACTIVE_LOW>,
+ 				   <&porta 23 GPIO_ACTIVE_LOW>;
+ 
+ 			flash0: m25p80@0 {
+ 				#address-cells = <1>;
+ 				#size-cells = <1>;
+ 				status = "okay";
+ 				compatible = "micron,n25q256a", "jedec,spi-nor";
+ 				reg = <0>;
+ 				spi-max-frequency = <10000000>;
+ 				m25p,fast-read;
+ 
+ 				mtd0@00000000 {
+ 					label = "flash0";
+ 					reg = <0x00000000 0x02000000>;
+ 				};
+ 			};
+ 
+ 			flash1: m25p80@1 {
+ 				#address-cells = <1>;
+ 				#size-cells = <1>;
+ 				status = "okay";
+ 				compatible = "micron,n25q256a", "jedec,spi-nor";
+ 				reg = <1>;
+ 				spi-max-frequency = <10000000>;
+ 				m25p,fast-read;
+ 
+ 				mtd1@00000000 {
+ 					label = "flash1";
+ 					reg = <0x00000000 0x02000000>;
+ 				};
+ 			};
+ 		};
+ 
+ 		spi1: spi1@1F04F000 {
+ 			#address-cells = <1>;
+ 			#size-cells = <0>;
+ 			compatible = "snps,dw-apb-ssi", "snps,dw-spi";
+ 			reg = <0x1F04F000 0x1000>;
+ 			interrupts = <GIC_SHARED 41 IRQ_TYPE_LEVEL_HIGH>;
+ 			clocks = <&spi1_clk 0>;
+ 			clock-names = "spi1clk";
+ 			num-cs = <1>;
+ 			cs-gpios = <&porta 17 0>;
+ 		};
+ 
+ 		gpio: gpio@1F044000 {
+ 			compatible = "snps,dw-apb-gpio";
+ 			reg = <0x1F044000 0x1000>;
+ 			#address-cells = <1>;
+ 			#size-cells = <0>;
+ 
+ 			porta: gpio-controller@0 {
+ 				compatible = "snps,dw-apb-gpio-port";
+ 				#gpio-cells = <2>;
+ 				gpio-controller;
+ 				snps,nr-gpios = <32>;
+ 				reg = <0>;
+ 				#interrupt-cells = <2>;
+ 				interrupt-controller;
+ 				interrupts = <GIC_SHARED 19 IRQ_TYPE_LEVEL_HIGH>;
+ 			};
+ 		};
+ 
+ 		/* 64 KiB SRAM at address 0x1BF80000 */
+ 		sram: sram@1BF80000 {
+ 			compatible = "mmio-sram";
+ 			reg = <0x1BF80000 0x10000>;
+ 
+ 			#address-cells = <1>;
+ 			#size-cells = <1>;
+ 
+ 			ranges = <0 0x1BF80000 0x10000>;
+ 
+ 			smp-sram@0 {
+ 				compatible = "be,smp-sram";
+ 				reg = <0 0x10000>;
+ 				label="Internal SRAM";
+ 				export;
+ 			};
+ 		};
+ 	};
+ };
diff -rcNP linux-4.4.24/arch/mips/boot/dts/baikal/baikal_bfk.dts linux-4.4.24-baikal/arch/mips/boot/dts/baikal/baikal_bfk.dts
*** linux-4.4.24/arch/mips/boot/dts/baikal/baikal_bfk.dts	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/arch/mips/boot/dts/baikal/baikal_bfk.dts	2016-11-11 14:49:51.000000000 +0300
***************
*** 0 ****
--- 1,516 ----
+ /*
+  * Baikal-T BFK board device tree.
+  *
+  * Copyright (C) 2014-2016  Baikal Electronics JSC
+  *
+  * This program is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU General Public License
+  * as published by the Free Software Foundation; either version 2
+  * of the License, or (at your option) any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; if not, write to the Free Software
+  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+  */
+ 
+ #include <dt-bindings/interrupt-controller/mips-gic.h>
+ #include <dt-bindings/gpio/gpio.h>
+ 
+ /dts-v1/;
+ 
+ /include/ "baikal_clocks.dtsi"
+ 
+ / {
+ 	model = "Baikal-T BFK Board";
+ 	compatible = "baikal,mips";
+ 	#address-cells = <1>;
+ 	#size-cells = <1>;
+ 	interrupt-parent = <&gic>;
+ 
+ 	aliases {
+ 		gic = &gic;
+ 		serial0 = &uart0;
+ 		serial1 = &uart1;
+ 		i2c0 = &i2c0;
+ 		i2c1 = &i2c1;
+ 		ssi0 = &spi0;
+ 		ssi1 = &spi1;
+ 		ethernet0 = &gmac0;
+ 		ethernet1 = &gmac1;
+ /*		ethernet2 = &xgmac; */
+ 		mdio-gpio0 = &mdio0;
+ 	};
+ 
+ 	chosen {
+ 		bootargs = "root=/dev/ram rw console=ttyS0,38400 earlyprintk=uart8250,mmio32,0x1F04A000,38400 nohtw";
+ 		linux,initrd-start = <0x01000000>;
+ 		linux,initrd-end   = <0x02000000>;
+ 	};
+ 
+ 	cpus {
+ 		#address-cells = <1>;
+ 		#size-cells = <0>;
+ 
+ 		CPU0: cpu@0 {
+ 			device_type = "cpu";
+ 			compatible = "mti,p5600";
+ 			reg = <0x0>;
+ 			clocks = <&cpu_clk 0>;
+ 			clock-names = "cpuclk";
+ 		};
+ 
+ 		CPU1: cpu@1 {
+ 			device_type = "cpu";
+ 			compatible = "mti,p5600";
+ 			reg = <0x1>;
+ 			clocks = <&cpu_clk 0>;
+ 			clock-names = "cpuclk";
+ 		};
+ 	};
+ 
+ 	memory {
+ 		device_type = "memory";
+ 		reg = <0x00000000 0x08000000>,
+ 		      <0x20000000 0xC0000000>;
+ 	};
+ 
+ 	gic: gic@1BDC0000 {
+ 		compatible = "mti,gic";
+ 		reg = <0x1BDC0000 0x20000>;
+ 
+ 		interrupt-controller;
+ 		#interrupt-cells = <3>;
+ 
+ 		timer:timer {
+ 			compatible = "mti,gic-timer";
+ 			interrupts = <GIC_LOCAL 1 IRQ_TYPE_NONE>;
+ 			clock-frequency = <600000000>;
+ 			clocks = <&gic_clk 0>;
+ 			clock-names = "gicclk";
+ 		};
+ 	};
+ 	axi {
+ 		compatible = "simple-bus";
+ 		#address-cells = <1>;
+ 		#size-cells = <1>;
+ 		interrupt-parent = <&gic>;
+ 
+ 		ranges;
+ 
+ 		gic_wdt:gic_wdt {
+ 			compatible = "be,gic-wdt";
+ 			interrupts = <GIC_LOCAL 0 IRQ_TYPE_NONE>;
+ 			clock-frequency = <600000000>;
+ 			clocks = <&gic_clk 0>;
+ 			clock-names = "gicclk";
+ 		};
+ 
+ 		dma: dma@1f041000 {
+ 			compatible = "snps,dma-spear1340";
+ 			reg = <0x1f041000 0x1000>;
+ 			interrupts = <GIC_SHARED 56 IRQ_TYPE_LEVEL_HIGH>;
+ 			dma-channels = <8>;
+ 			dma-requests = <16>;
+ 			dma-masters = <2>;
+ 			#dma-cells = <3>;
+ 			chan_allocation_order = <1>;
+ 			chan_priority = <1>;
+ 			block_size = <0xfff>;
+ 			data_width = <3 3 0 0>;
+ 			clocks = <&dma_clk 0>;
+ 			clock-names = "hclk";
+ 		};
+ 
+ 		sata@1F050000 {
+ 			interrupt-parent = <&gic>;
+ 			compatible = "snps,dwc-ahci", "generic-ahci";
+ 			reg = <0x1F050000 0x2000>;
+ 			interrupts = <GIC_SHARED 64 IRQ_TYPE_LEVEL_HIGH>;
+ 			ports-implemented = <3>;
+ 			clocks = <&sata_clk 0>;
+ 			clock-names = "sataclk";
+ 		};
+ 
+ 		mdio0: be-mdio {
+ 			compatible = "be,mdio-gpio";
+ 			#address-cells = <1>;
+ 			#size-cells = <0>;
+ 			mdc-pin = <&porta 9 GPIO_ACTIVE_HIGH>;
+ 			mdio-pin = <&porta 11 GPIO_ACTIVE_HIGH>;
+ 			clocks = <&gpio_clk 0>;
+ 			clock-names = "gpioclk";
+ 
+ 			mv_ch0:88X2222@0C {
+ 				compatible = "marvell,88x2222", "ethernet-phy-ieee802.3-c45";
+ 				reg = <0x0C>;
+ 				phy-mode = "xgmii";
+ 				mv,line-mode = <0>; /* 10GBASE-R (0x71) */
+ 				mv,host-mode = <0>; /* 10GBASE-R (0x71) */
+ 			};
+ 
+ 			mv_ch1:88X2222@0D {
+ 				compatible = "marvell,88x2222", "ethernet-phy-ieee802.3-c45";
+ 				reg = <0x0D>;
+ 				phy-mode = "xgmii";
+ 				mv,line-mode = <0>; /* 10GBASE-R (0x71) */
+ 				mv,host-mode = <0>; /* 10GBASE-R (0x71) */
+ 			};
+ 
+ 			mv_ch2:88X2222@0E {
+ 				compatible = "marvell,88x2222", "ethernet-phy-ieee802.3-c45";
+ 				reg = <0x0E>;
+ 				phy-mode = "xgmii";
+ 				mv,line-mode = <0>; /* 10GBASE-R (0x71) */
+ 				mv,host-mode = <0>; /* 10GBASE-R (0x71) */
+ 			};
+ 
+ 			mv_ch3:88X2222@0F {
+ 				compatible = "marvell,88x2222", "ethernet-phy-ieee802.3-c45";
+ 				reg = <0x0F>;
+ 				phy-mode = "xgmii";
+ 				mv,line-mode = <0>; /* 10GBASE-R (0x71) */
+ 				mv,host-mode = <0>; /* 10GBASE-R (0x71) */
+ 			};
+ 		};
+ 
+ /*
+ 
+ 		xgbe_phy: xgbe_phy@1F05D000 {
+ 			compatible = "be,xgbe-phy", "ethernet-phy-ieee802.3-c45";
+ 			reg = <0x1F05D000 0x1000>;
+ 			phy-handle = <&mv_ch0>;
+ 			phy-mode = "xgmii";
+ 			clocks = <&div_156m 0>;
+ 			clock-names = "xgbe_clk";
+ 			be,speed-set = <1>;
+ 			be,mode-set = <0>;
+ 			be,external-clock;
+ 		};
+ 
+ 		xgmac: eth0@1F054000 {
+ 			compatible = "be,baikal-xgbe";
+ 			reg = <0x1F054000 0x4000>,
+ 			      <0x1F05D000 0x1000>;
+ 			interrupt-parent = <&gic>;
+ 			interrupts = <GIC_SHARED 80 IRQ_TYPE_LEVEL_HIGH>;
+ 			clocks = <&xgmac_dma 0>, <&xgmac_ptp 0>;
+ 			clock-names = "dma_clk", "ptp_clk";
+ 			phy-handle = <&xgbe_phy>;
+ 			phy-mode = "xgmii";
+ 			mac-address = [ 00 20 13 ba 1c a1 ];
+ 			local-mac-address = [ 00 20 13 ba 1c a1 ];
+ 		};
+ */
+ 
+ 		gmac0: eth1@1F05E000 {
+ 			compatible = "be,dwmac", "snps,dwmac-3.710", "snps,dwmac";
+ 			reg = <0x1F05E000 0x2000>;
+ 			interrupt-parent = <&gic>;
+ 			interrupts = <GIC_SHARED 72 IRQ_TYPE_LEVEL_HIGH>;
+ 			interrupt-names = "macirq";
+ 			phy-mode = "rgmii";
+ 			clocks = <&gmac0_clk 0>;
+ 			clock-names = "stmmaceth";
+ 			mac-address = [ 7a 72 6c 4a 7a 07 ];
+ 			local-mac-address = [ 7a 72 6c 4a 7a 07 ];
+ 			txd0-skew-ps = <0>;
+ 			txd1-skew-ps = <0>;
+ 			txd2-skew-ps = <0>;
+ 			txd3-skew-ps = <0>;
+ 			txc-skew-ps  = <0xff>;
+ 		};
+ 
+ 		gmac1: eth2@1F060000 {
+ 			compatible = "be,dwmac", "snps,dwmac-3.710", "snps,dwmac";
+ 			reg = <0x1F060000 0x2000>;
+ 			interrupt-parent = <&gic>;
+ 			interrupts = <GIC_SHARED 73 IRQ_TYPE_LEVEL_HIGH>;
+ 			interrupt-names = "macirq";
+ 			phy-mode = "rgmii";
+ 			clocks = <&gmac1_clk 0>;
+ 			clock-names = "stmmaceth";
+ 			mac-address = [ 7a 72 6c 4a 7b 07 ];
+ 			local-mac-address = [ 7a 72 6c 4a 7b 07 ];
+ 			txd0-skew-ps = <0>;
+ 			txd1-skew-ps = <0>;
+ 			txd2-skew-ps = <0>;
+ 			txd3-skew-ps = <0>;
+ 			txc-skew-ps  = <0xff>;
+ 		};
+ 
+ 		usb3: usb@1F04D050 {
+ 			compatible = "be,baikal-dwc3";
+ 
+ 			reg = <0x1F04D050 0x0004>;
+ 			interrupts = <GIC_SHARED 69 IRQ_TYPE_LEVEL_HIGH>;
+ 
+ 			#address-cells = <1>;
+ 			#size-cells = <1>;
+ 
+ 			clocks = <&usb_clk 0>;
+ 			clock-names = "usb";
+ 
+ 			ranges;
+ 
+ 			dwc3@1F100000 {
+ 					compatible = "snps,dwc3", "synopsys,dwc3";
+ 					reg = <0x1F100000 0x10000>;
+ 					interrupts = <GIC_SHARED 68 IRQ_TYPE_LEVEL_HIGH>;
+ 					dr_mode = "host";
+ 
+ 					tx-fifo-resize;
+ 
+ 					maximum-speed = "high-speed";
+ 			};
+ 		};
+ 
+ 		pci: pci@1F052000 {
+ 			compatible = "snps,dw-pci";
+ 			interrupts = <GIC_SHARED 88 IRQ_TYPE_LEVEL_HIGH>,
+ 				<GIC_SHARED 89 IRQ_TYPE_LEVEL_HIGH>;
+ 			reg = <0x1F052000 0x1000>;
+ 		};
+ 
+ 		emc@1F042000 {
+ 			compatible = "be,emc", "be,memory-controller";
+ 			reg = <0x1F042000 0x1000>;
+ 			interrupts = <GIC_SHARED 96 IRQ_TYPE_LEVEL_HIGH>,
+ 						 <GIC_SHARED 97 IRQ_TYPE_LEVEL_HIGH>,
+ 						 <GIC_SHARED 98 IRQ_TYPE_LEVEL_HIGH>;
+ 			clocks = <&ddr_pll 0>;
+ 			clock-names = "ddrclk";
+ 		};
+ 
+ 		apb_ehb@1F059000 {
+ 			compatible = "be,apb-ehb";
+ 			reg = <0x1f059000 0x1000>;
+ 			interrupts = <GIC_SHARED 16 IRQ_TYPE_LEVEL_HIGH>;
+ 		};
+ 
+ 		axi_ehb@1F04D110 {
+ 			compatible = "be,axi-ehb";
+ 			reg = <0x1F04D110 0x8>;
+ 			interrupts = <GIC_SHARED 127 IRQ_TYPE_LEVEL_HIGH>;
+ 		};
+ 	};
+ 
+ 	apb {
+ 		compatible = "simple-bus";
+ 		#address-cells = <1>;
+ 		#size-cells = <1>;
+ 		interrupt-parent = <&gic>;
+ 
+ 		ranges;
+ 
+ 		timer0: timer0@1F049000 {
+ 			compatible = "snps,dw-apb-timer-osc";
+ 			interrupts = <GIC_SHARED 24 IRQ_TYPE_LEVEL_HIGH>;
+ 			reg = <0x1F049000 0x14>;
+ 			clocks = <&timer0_clk 0>;
+ 			clock-names = "timer";
+ 		};
+ 
+ 		timer1: timer1@1F049014 {
+ 			compatible = "snps,dw-apb-timer-sp";
+ 			reg = <0x1F049014 0x14>;
+ 			interrupts = <GIC_SHARED 25 IRQ_TYPE_LEVEL_HIGH>;
+ 			clocks = <&timer1_clk 0>;
+ 			clock-names = "timer";
+ 		};
+ 
+ 		timer2: timer2@1F049028 {
+ 			compatible = "snps,dw-apb-timer-sp";
+ 			reg = <0x1F049028 0x14>;
+ 			interrupts = <GIC_SHARED 26 IRQ_TYPE_LEVEL_HIGH>;
+ 			clocks = <&timer2_clk 0>;
+ 			clock-names = "timer";
+ 		};
+ 
+ 		uart0: serial0@1F04A000 {
+ 			compatible = "snps,dw-apb-uart";
+ 			reg = <0x1F04A000 0x1000>;
+ 			interrupts = <GIC_SHARED 48 IRQ_TYPE_LEVEL_HIGH>;
+ 			reg-shift = <2>;
+ 			reg-io-width = <4>;
+ 			clocks = <&uart_clk 0>, <&apb_clk 0>;
+ 			clock-names = "baudclk", "apb_pclk";
+ //			snps,uart-16550-compatible;
+ 			dcd-override;
+ 			dsr-override;
+ 			cts-override;
+ 			ri-override;
+ 		};
+ 
+ 		uart1: serial1@1F04B000 {
+ 			compatible = "snps,dw-apb-uart";
+ 			reg = <0x1F04B000 0x1000>;
+ 			interrupts = <GIC_SHARED 49 IRQ_TYPE_LEVEL_HIGH>;
+ 			reg-shift = <2>;
+ 			reg-io-width = <4>;
+ 			clocks = <&uart_clk 0>, <&apb_clk 0>;
+ 			clock-names = "baudclk", "apb_pclk";
+ 		};
+ 
+ 		wdt: watchdog@1F04C000 {
+ 			compatible = "snps,dw-wdt";
+ 			reg = <0x1F04C000 0x1000>;
+ 			interrupts = <GIC_SHARED 17 IRQ_TYPE_LEVEL_HIGH>;
+ 			clocks = <&wdt_clk 0>;
+ 			clock-names = "wdtclk";
+ 		};
+ 
+ 		i2c0: i2c0@1F046000 {
+ 			#address-cells = <1>;
+ 			#size-cells = <0>;
+ 			compatible = "snps,designware-i2c";
+ 			reg = <0x1F046000 0x1000>;
+ 			interrupts = <GIC_SHARED 33 IRQ_TYPE_LEVEL_HIGH>;
+ 			clock-frequency = <400000>;
+ 			clocks = <&i2c0_clk 0>;
+ 			clock-names = "i2c0clk";
+ 
+ 			codec@18 {
+ 				compatible = "tlv320aic310x";
+ 				reg = <0x18>;
+ 			};
+ 
+ 			gpioexp: gpioexp@20 {
+ 				compatible = "nxp,pca9500";
+ 				#gpio-cells = <2>;
+ 				reg = <0x20>;
+ 				gpio-controller;
+ 			};
+ 
+ 			eeprom@50 {
+ 				compatible = "atmel,24c02";
+ 				pagesize = <16>;
+ 				reg = <0x50>;
+ 			};
+ 		};
+ 
+ 		i2c1: i2c1@1F047000 {
+ 			#address-cells = <1>;
+ 			#size-cells = <0>;
+ 			compatible = "snps,designware-i2c";
+ 			reg = <0x1F047000 0x1000>;
+ 			interrupts = <GIC_SHARED 34 IRQ_TYPE_LEVEL_HIGH>;
+ 			clock-frequency = <400000>;
+ 			clocks = <&i2c1_clk 0>;
+ 			clock-names = "i2c1clk";
+ 
+ 			eeprom@50 {
+ 				compatible = "atmel,24c02";
+ 				pagesize = <16>;
+ 				reg = <0x50>;
+ 			};
+ 
+ 			eeprom@51 {
+ 				compatible = "atmel,24c02";
+ 				pagesize = <16>;
+ 				reg = <0x51>;
+ 			};
+ 
+ 			rtc@56 {
+ 				compatible = "abracon,abeoz9s3";
+ 				reg = <0x56>;
+ 			};
+ 
+ 		};
+ 
+ 		spi0: spi0@1F04E000 {
+ 			#address-cells = <1>;
+ 			#size-cells = <0>;
+ 			compatible = "snps,dw-apb-ssi", "snps,dw-spi";
+ 			reg = <0x1F04E000 0x1000>;
+ 			interrupts = <GIC_SHARED 40 IRQ_TYPE_LEVEL_HIGH>;
+ 			clocks = <&spi0_clk 0>;
+ 			clock-names = "spi0clk";
+ 			num-cs = <3>;
+ 			cs-gpios = <&porta 28 GPIO_ACTIVE_LOW>,
+ 				   <&porta 23 GPIO_ACTIVE_LOW>;
+ 
+ 			flash0: m25p80@0 {
+ 				#address-cells = <1>;
+ 				#size-cells = <1>;
+ 				status = "okay";
+ 				compatible = "micron,n25q256a", "jedec,spi-nor";
+ 				reg = <0>;
+ 				spi-max-frequency = <10000000>;
+ 				m25p,fast-read;
+ 
+ 				mtd0@00000000 {
+ 					label = "flash0";
+ 					reg = <0x00000000 0x02000000>;
+ 				};
+ 			};
+ 
+ 			flash1: m25p80@1 {
+ 				#address-cells = <1>;
+ 				#size-cells = <1>;
+ 				status = "okay";
+ 				compatible = "micron,n25q256a", "jedec,spi-nor";
+ 				reg = <1>;
+ 				spi-max-frequency = <10000000>;
+ 				m25p,fast-read;
+ 
+ 				mtd1@00000000 {
+ 					label = "flash1";
+ 					reg = <0x00000000 0x02000000>;
+ 				};
+ 			};
+ 		};
+ 
+ 		spi1: spi1@1F04F000 {
+ 			#address-cells = <1>;
+ 			#size-cells = <0>;
+ 			compatible = "snps,dw-apb-ssi", "snps,dw-spi";
+ 			reg = <0x1F04F000 0x1000>;
+ 			interrupts = <GIC_SHARED 41 IRQ_TYPE_LEVEL_HIGH>;
+ 			clocks = <&spi1_clk 0>;
+ 			clock-names = "spi1clk";
+ 			num-cs = <1>;
+ 			cs-gpios = <&porta 17 0>;
+ 		};
+ 
+ 		gpio: gpio@1F044000 {
+ 			compatible = "snps,dw-apb-gpio";
+ 			reg = <0x1F044000 0x1000>;
+ 			#address-cells = <1>;
+ 			#size-cells = <0>;
+ 
+ 			porta: gpio-controller@0 {
+ 				compatible = "snps,dw-apb-gpio-port";
+ 				#gpio-cells = <2>;
+ 				gpio-controller;
+ 				snps,nr-gpios = <32>;
+ 				reg = <0>;
+ 				#interrupt-cells = <2>;
+ 				interrupt-controller;
+ 				interrupts = <GIC_SHARED 19 IRQ_TYPE_LEVEL_HIGH>;
+ 			};
+ 		};
+ 
+ 		/* 64 KiB SRAM at address 0x1BF80000 */
+ 		sram: sram@1BF80000 {
+ 			compatible = "mmio-sram";
+ 			reg = <0x1BF80000 0x10000>;
+ 
+ 			#address-cells = <1>;
+ 			#size-cells = <1>;
+ 
+ 			ranges = <0 0x1BF80000 0x10000>;
+ 
+ 			smp-sram@0 {
+ 				compatible = "be,smp-sram";
+ 				reg = <0 0x10000>;
+ 				label="Internal SRAM";
+ 				export;
+ 			};
+ 		};
+ 	};
+ };
diff -rcNP linux-4.4.24/arch/mips/boot/dts/baikal/baikal_clocks.dtsi linux-4.4.24-baikal/arch/mips/boot/dts/baikal/baikal_clocks.dtsi
*** linux-4.4.24/arch/mips/boot/dts/baikal/baikal_clocks.dtsi	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/arch/mips/boot/dts/baikal/baikal_clocks.dtsi	2016-11-11 14:49:51.000000000 +0300
***************
*** 0 ****
--- 1,347 ----
+ /*
+  * Baikal-T SOC clock tree.
+  *
+  * Copyright (C) 2014,2015  Baikal Electronics OJSC
+  *
+  * This program is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU General Public License
+  * as published by the Free Software Foundation; either version 2
+  * of the License, or (at your option) any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; if not, write to the Free Software
+  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+  */
+ 
+ / {
+ 	clocks {
+ 		#address-cells = <1>;
+ 		#size-cells = <1>;
+ 
+ 		ranges;
+ 
+ 		/* external oscillator */
+ 		osc: oscillator@0 {
+ 			compatible = "fixed-clock";
+ 			#clock-cells = <1>;
+ 			clock-frequency  = <25000000>;
+ 			clock-output-names = "osc";
+ 		};
+ 
+ 		core_pll: core_pll@1F04D000 {
+ 			compatible = "be,pmu-pll-clock";
+ 			#clock-cells = <1>;
+ 			clocks = <&osc 0>;
+ 			clock-names = "ref";
+ 			reg = <0x1F04D000 0x0008>;
+ 			clock-output-names = "corepll";
+ 		};
+ 
+ 		sata_pll: sata_pll@1F04D008 {
+ 			compatible = "be,pmu-pll-clock";
+ 			#clock-cells = <1>;
+ 			clocks = <&osc 0>;
+ 			clock-names = "ref";
+ 			reg = <0x1F04D008 0x0008>;
+ 			clock-output-names = "satapll";
+ 		};
+ 
+ 		ddr_pll: ddr_pll@1F04D010 {
+ 			compatible = "be,pmu-pll-clock";
+ 			#clock-cells = <1>;
+ 			clocks = <&osc 0>;
+ 			clock-names = "ref";
+ 			reg = <0x1F04D010 0x0008>;
+ 			clock-output-names = "ddrpll";
+ 		};
+ 
+ 		pcie_pll: pcie_pll@1F04D018 {
+ 			compatible = "be,pmu-pll-clock";
+ 			#clock-cells = <1>;
+ 			clocks = <&osc 0>;
+ 			clock-names = "ref";
+ 			reg = <0x1F04D018 0x0008>;
+ 			clock-output-names = "pciepll";
+ 		};
+ 
+ 		eth_pll: eth_pll@1F04D020 {
+ 			compatible = "be,pmu-pll-clock";
+ 			#clock-cells = <1>;
+ 			clocks = <&osc 0>;
+ 			clock-names = "ref";
+ 			reg = <0x1F04D020 0x0008>;
+ 			clock-output-names = "ethpll";
+ 		};
+ 
+ 		cpu_clk:cpu_clk {
+ 			compatible = "fixed-factor-clock";
+ 			clocks = <&core_pll 0>;
+ 			clock-names = "corepll";
+ 			#clock-cells = <0>;
+ 			clock-div = <1>;
+ 			clock-mult = <1>;
+ 			clock-output-names = "cpuclk";
+ 		};
+ 
+ 		gic_clk:gic_clk {
+ 			compatible = "fixed-factor-clock";
+ 			clocks = <&core_pll 0>;
+ 			clock-names = "corepll";
+ 			#clock-cells = <0>;
+ 			clock-div = <1>;
+ 			clock-mult = <1>;
+ 			clock-output-names = "gicclk";
+ 		};
+ 
+ 		div_1m:div_1m {
+ 			compatible = "fixed-factor-clock";
+ 			clocks = <&osc 0>;
+ 			clock-names = "osc";
+ 			#clock-cells = <0>;
+ 			clock-div = <25>;
+ 			clock-mult = <1>;
+ 			clock-output-names = "div1m";
+ 		};
+ 
+ 		div_125m:div_125m {
+ 			compatible = "fixed-factor-clock";
+ 			clocks = <&eth_pll 0>;
+ 			clock-names = "ethpll";
+ 			#clock-cells = <1>;
+ 			clock-div = <5>;
+ 			clock-mult = <1>;
+ 			clock-output-names = "div125m";
+ 		};
+ 
+ 		div_156m:div_156m {
+ 			compatible = "fixed-factor-clock";
+ 			clocks = <&eth_pll 0>;
+ 			clock-names = "ethpll";
+ 			#clock-cells = <1>;
+ 			clock-div = <4>;
+ 			clock-mult = <1>;
+ 			clock-output-names = "div156m";
+ 		};
+ 
+ 		axi_clk:axi_clk {
+ 			compatible = "fixed-factor-clock";
+ 			clocks = <&core_pll 0>;
+ 			clock-names = "corepll";
+ 			#clock-cells = <0>;
+ 			clock-div = <2>;
+ 			clock-mult = <1>;
+ 			clock-output-names = "axiclk";
+ 		};
+ 
+ 		pci_phy_clk:pci_phy_clk@1F04D05C {
+ 			compatible = "be,pmu-device-clock";
+ 			#clock-cells = <1>;
+ 			clocks = <&pcie_pll 0>;
+ 			clock-names = "pciepll";
+ 			reg = <0x1F04D05C 0x0004>;
+ 			clock-output-names = "pciphyclk";
+ 			divider-width = <4>;
+ 			nobypass;
+ 		};
+ 
+ 		sata_clk:sata_clk@1F04D060 {
+ 			compatible = "be,pmu-device-clock";
+ 			#clock-cells = <1>;
+ 			clocks = <&sata_pll 0>;
+ 			clock-names = "sataclk";
+ 			reg = <0x1F04D060 0x0004>;
+ 			clock-output-names = "sataclk";
+ 			divider-width = <4>;
+ 			nobypass;
+ 		};
+ 
+ 		apb_clk:apb_clk@1F04D064 {
+ 			compatible = "be,pmu-device-clock";
+ 			#clock-cells = <1>;
+ 			clocks = <&core_pll 0>;
+ 			clock-names = "corepll";
+ 			reg = <0x1F04D064 0x0004>;
+ 			clock-output-names = "apbclk";
+ 			divider-width = <5>;
+ 		};
+ 
+ 		gmac0_clk:gmac0_clk@1F04D068 {
+ 			compatible = "be,pmu-device-clock";
+ 			#clock-cells = <1>;
+ 			clocks = <&div_125m 0>;
+ 			clock-names = "div125m";
+ 			reg = <0x1F04D068 0x0004>;
+ 			clock-output-names = "gmac0clk";
+ 			divider-width = <0>;
+ 		};
+ 
+ 		gmac1_clk:gmac1_clk@1F04D06C {
+ 			compatible = "be,pmu-device-clock";
+ 			#clock-cells = <1>;
+ 			clocks = <&div_125m 0>;
+ 			clock-names = "div125m";
+ 			reg = <0x1F04D06C 0x0004>;
+ 			clock-output-names = "gmac1clk";
+ 			divider-width = <0>;
+ 		};
+ 
+ 		xgmac_dma:xgmac_dma@1F04D070 {
+ 			compatible = "be,pmu-device-clock";
+ 			#clock-cells = <1>;
+ 			clocks = <&div_156m 0>;
+ 			clock-names = "div156m";
+ 			reg = <0x1F04D070 0x0004>;
+ 			clock-output-names = "xgmac_dma";
+ 			clock-output = "dma_clk";
+ 			divider-width = <0>;
+ 		};
+ 
+ 		xgmac_ptp:xgmac_ptp {
+ 			compatible = "fixed-factor-clock";
+ 			clocks = <&div_156m 0>;
+ 			clock-names = "div156m";
+ 			#clock-cells = <0>;
+ 			clock-div = <4>;
+ 			clock-mult = <1>;
+ 			clock-output-names = "xgmacptp";
+ 			clock-output = "ptp_clk";
+ 		};
+ 
+ 		usb_clk:usb_clk@1F04D074 {
+ 			compatible = "be,pmu-device-clock";
+ 			#clock-cells = <1>;
+ 			clocks = <&div_125m 0>;
+ 			clock-names = "div125m";
+ 			reg = <0x1F04D074 0x0004>;
+ 			clock-output-names = "usbclk";
+ 			divider-width = <0>;
+ 		};
+ 
+ 		wdt_clk:wdt_clk@1F04D080 {
+ 			compatible = "be,pmu-device-clock";
+ 			#clock-cells = <1>;
+ 			clocks = <&div_1m 0>;
+ 			clock-names = "div1m";
+ 			reg = <0x1F04D080 0x0004>;
+ 			clock-output-names = "wdtclk";
+ 			divider-width = <0>;
+ 		};
+ 
+ 		uart_clk:uart_clk@1F04D084 {
+ 			compatible = "be,pmu-device-clock";
+ 			#clock-cells = <1>;
+ 			clocks = <&div_125m 0>;
+ 			clock-names = "div125m";
+ 			reg = <0x1F04D084 0x0004>;
+ 			clock-output-names = "baudclk";
+ 			divider-width = <4>;
+ 		};
+ 
+ 		timer0_clk:timer0_clk@1F04D088 {
+ 			compatible = "be,pmu-device-clock";
+ 			#clock-cells = <1>;
+ 			clocks = <&osc 0>;
+ 			clock-names = "ref";
+ 			reg = <0x1F04D088 0x0004>;
+ 			clock-output-names = "timer0clk";
+ 			divider-width = <17>;
+ 		};
+ 
+ 		timer1_clk:timer1_clk@1F04D08C {
+ 			compatible = "be,pmu-device-clock";
+ 			#clock-cells = <1>;
+ 			clocks = <&osc 0>;
+ 			clock-names = "ref";
+ 			reg = <0x1F04D08C 0x0004>;
+ 			clock-output-names = "timer1clk";
+ 			divider-width = <17>;
+ 		};
+ 
+ 		timer2_clk:timer2_clk@1F04D090 {
+ 			compatible = "be,pmu-device-clock";
+ 			#clock-cells = <1>;
+ 			clocks = <&osc 0>;
+ 			clock-names = "ref";
+ 			reg = <0x1F04D090 0x0004>;
+ 			clock-output-names = "timer2clk";
+ 			divider-width = <17>;
+ 		};
+ 
+ 		dma_clk:dma_clk {
+ 			compatible = "fixed-factor-clock";
+ 			clocks = <&apb_clk 0>;
+ 			clock-names = "apbclk";
+ 			#clock-cells = <0>;
+ 			clock-div = <1>;
+ 			clock-mult = <1>;
+ 			clock-output-names = "dmaclk";
+ 			clock-output = "hclk";
+ 		};
+ 
+ 		i2c0_clk:i2c0_clk {
+ 			compatible = "fixed-factor-clock";
+ 			clocks = <&div_125m 0>;
+ 			clock-names = "div125m";
+ 			#clock-cells = <0>;
+ 			clock-div = <1>;
+ 			clock-mult = <1>;
+ 			clock-output-names = "i2c0clk";
+ 		};
+ 
+ 		i2c1_clk:i2c1_clk {
+ 			compatible = "fixed-factor-clock";
+ 			clocks = <&div_125m 0>;
+ 			clock-names = "div125m";
+ 			#clock-cells = <0>;
+ 			clock-div = <1>;
+ 			clock-mult = <1>;
+ 			clock-output-names = "i2c1clk";
+ 		};
+ 
+ 		spi0_clk:spi0_clk {
+ 			compatible = "fixed-factor-clock";
+ 			clocks = <&apb_clk 0>;
+ 			clock-names = "apbclk";
+ 			#clock-cells = <0>;
+ 			clock-div = <1>;
+ 			clock-mult = <1>;
+ 			clock-output-names = "spi0clk";
+ 		};
+ 
+ 		spi1_clk:spi1_clk {
+ 			compatible = "fixed-factor-clock";
+ 			clocks = <&apb_clk 0>;
+ 			clock-names = "apbclk";
+ 			#clock-cells = <0>;
+ 			clock-div = <1>;
+ 			clock-mult = <1>;
+ 			clock-output-names = "spi1clk";
+ 		};
+ 
+ 		boot_clk:boot_clk {
+ 			compatible = "fixed-factor-clock";
+ 			clocks = <&apb_clk 0>;
+ 			clock-names = "apbclk";
+ 			#clock-cells = <0>;
+ 			clock-div = <1>;
+ 			clock-mult = <1>;
+ 			clock-output-names = "bootclk";
+ 		};
+ 
+ 		gpio_clk:gpio_clk {
+ 			compatible = "fixed-factor-clock";
+ 			clocks = <&osc 0>;
+ 			clock-names = "ref";
+ 			#clock-cells = <0>;
+ 			clock-div = <25>;
+ 			clock-mult = <1>;
+ 			clock-output-names = "gpioclk";
+ 			clock-output = "gpio_clk";
+ 		};
+ 	};
+ };
diff -rcNP linux-4.4.24/arch/mips/boot/dts/baikal/baikal.dts linux-4.4.24-baikal/arch/mips/boot/dts/baikal/baikal.dts
*** linux-4.4.24/arch/mips/boot/dts/baikal/baikal.dts	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/arch/mips/boot/dts/baikal/baikal.dts	2016-11-11 14:49:51.000000000 +0300
***************
*** 0 ****
--- 1,361 ----
+ /*
+  * Baikal-T SOC platform support code.
+  *
+  * Copyright (C) 2014,2015  Baikal Electronics OJSC
+  *
+  * This program is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU General Public License
+  * as published by the Free Software Foundation; either version 2
+  * of the License, or (at your option) any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; if not, write to the Free Software
+  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+  */
+ 
+ #include <dt-bindings/interrupt-controller/mips-gic.h>
+ 
+ /dts-v1/;
+ 
+ /include/ "baikal_clocks.dtsi"
+ 
+ / {
+ 	model = "Generic Baikal-T";
+ 	compatible = "baikal,mips";
+ 	#address-cells = <1>;
+ 	#size-cells = <1>;
+ 	interrupt-parent = <&gic>;
+ 	aliases {
+ 		gic = &gic;
+ 		serial0 = &uart0;
+ 		serial1 = &uart1;
+ 		i2c0 = &i2c0;
+ 		i2c1 = &i2c1;
+ 		ssi0 = &spi0;
+ 		ssi1 = &spi1;
+ 		ethernet1 = &gmac0;
+ 		ethernet2 = &gmac1;
+ 	};
+ 
+ 	chosen {
+ 		bootargs = "root=/dev/ram rw console=ttyS0,mmio32,115200 earlyprintk=uart8250,mmio32,0x1F04A000,115200 nocoherentio stmmaceth=chain_mode:1";
+ 		linux,initrd-start = <0x01000000>;
+ 		linux,initrd-end   = <0x03000000>;
+ 	};
+ 
+ 	cpus {
+ 		#address-cells = <1>;
+ 		#size-cells = <0>;
+ 
+ 		CPU0: cpu@0 {
+ 			device_type = "cpu";
+ 			compatible = "mips,p5600";
+ 			reg = <0x0>;
+ 			clocks = <&cpu_clk 0>;
+ 			clock-names = "cpuclk";
+ 		};
+ 
+ 		CPU1: cpu@1 {
+ 			device_type = "cpu";
+ 			compatible = "mips,p5600";
+ 			reg = <0x1>;
+ 			clocks = <&cpu_clk 0>;
+ 			clock-names = "cpuclk";
+ 		};
+ 	};
+ 
+ 	memory {
+ 		device_type = "memory";
+ 		reg = <0x00000000 0x08000000>;
+ 	};
+ 
+ 	gic: gic@1BDC0000 {
+ 		compatible = "mti,gic";
+ 		reg = <0x1BDC0000 0x20000>;
+ 
+ 		interrupt-controller;
+ 		#interrupt-cells = <3>;
+ 
+ 		timer:timer {
+ 			compatible = "mti,gic-timer";
+ 			interrupts = <GIC_LOCAL 1 IRQ_TYPE_NONE>;
+ 			clock-frequency = <30000000>;
+ 		};
+ 
+ 	};
+ 
+ 	soc {
+ 		compatible = "simple-bus";
+ 		#address-cells = <1>;
+ 		#size-cells = <1>;
+ 		interrupt-parent = <&gic>;
+ 
+ 		ranges;
+ 
+ 		dma: dma@1f041000 {
+ 			compatible = "snps,dma-spear1340";
+ 			reg = <0x1f041000 0x1000>;
+ 			interrupts = <GIC_SHARED 56 IRQ_TYPE_LEVEL_HIGH>;
+ 			dma-channels = <8>;
+ 			dma-requests = <16>;
+ 			dma-masters = <2>;
+ 			#dma-cells = <3>;
+ 			chan_allocation_order = <1>;
+ 			chan_priority = <1>;
+ 			block_size = <0xfff>;
+ 			data_width = <3 3 0 0>;
+ 			clocks = <&dma_clk 0>;
+ 			clock-names = "hclk";
+ 		};
+ 
+ 		sata@1F050000 {
+ 			interrupt-parent = <&gic>;
+ 			compatible = "synopsys,dwc-ahsata", "snps,spear-ahci";
+ 			reg = <0x1F050000 0x2000>;
+ 			interrupts = <GIC_SHARED 64 IRQ_TYPE_LEVEL_HIGH>;
+ 			clocks = <&sata_clk 0>;
+ 			clock-names = "sataclk";
+ 		};
+ 
+ 		gmac0: eth1@1F05E000 {
+ 			compatible = "snps,dwmac-3.710", "snps,dwmac";
+ 			reg = <0x1F05E000 0x2000>;
+ 			interrupt-parent = <&gic>;
+ 			interrupts = <GIC_SHARED 72 IRQ_TYPE_LEVEL_HIGH>;
+ 			interrupt-names = "macirq";
+ 			phy-mode = "gmii";
+ 			clocks = <&gmac0_clk 0>;
+ 			clock-names = "stmmaceth";
+ 			snps,fixed-burst;
+ 			mac-address = [ 00 20 13 ba 1c a2 ];
+ 			local-mac-address = [ 00 20 13 ba 1c a2 ];
+ 		};
+ 
+ 		gmac1: eth2@1F060000 {
+ 			compatible = "snps,dwmac-3.710", "snps,dwmac";
+ 			reg = <0x1F060000 0x2000>;
+ 			interrupt-parent = <&gic>;
+ 			interrupts = <GIC_SHARED 73 IRQ_TYPE_LEVEL_HIGH>;
+ 			interrupt-names = "macirq";
+ 			phy-mode = "gmii";
+ 			clocks = <&gmac1_clk 0>;
+ 			clock-names = "stmmaceth";
+ 			snps,fixed-burst;
+ 			mac-address = [ 00 20 13 ba 1c a3 ];
+ 			local-mac-address = [ 00 20 13 ba 1c a3 ];
+ 		};
+ 
+ 		/* Peripherial error handler block */
+ 		apb_ehb@1F059000 {
+ 			compatible = "be,apb-ehb";
+ 			reg = <0x1f059000 0x1000>;
+ 			interrupts = <GIC_SHARED 16 IRQ_TYPE_LEVEL_HIGH>;
+ 		};
+ 
+ 		/* Interconnect error handler block */
+ 
+ 		axi_ehb@1F04D110 {
+ 			compatible = "be,axi-ehb";
+ 			reg = <0x1F04D110 0x8>;
+ 			interrupts = <GIC_SHARED 127 IRQ_TYPE_LEVEL_HIGH>;
+ 		};
+ 
+ 		apb {
+ 			compatible = "simple-bus";
+ 			#address-cells = <1>;
+ 			#size-cells = <1>;
+ 			interrupt-parent = <&gic>;
+ 
+ 			ranges;
+ 
+ 			timer0: timer0@1F049000 {
+ 				compatible = "snps,dw-apb-timer-osc";
+ 				interrupts = <GIC_SHARED 24 IRQ_TYPE_LEVEL_HIGH>;
+ 				reg = <0x1F049000 0x14>;
+ 				clocks = <&timer0_clk 0>;
+ 				clock-names = "timer";
+ 			};
+ 
+ 			timer1: timer1@1F049014 {
+ 				compatible = "snps,dw-apb-timer-sp";
+ 				reg = <0x1F049014 0x14>;
+ 				interrupts = <GIC_SHARED 25 IRQ_TYPE_LEVEL_HIGH>;
+ 				clocks = <&timer1_clk 0>;
+ 				clock-names = "timer";
+ 			};
+ 
+ 			timer2: timer2@1F049028 {
+ 				compatible = "snps,dw-apb-timer-sp";
+ 				reg = <0x1F049028 0x14>;
+ 				interrupts = <GIC_SHARED 26 IRQ_TYPE_LEVEL_HIGH>;
+ 				clocks = <&timer2_clk 0>;
+ 				clock-names = "timer";
+ 			};
+ 
+ 			uart0: serial0@1F04A000 {
+ 				compatible = "snps,dw-apb-uart";
+ 				reg = <0x1F04A000 0x1000>;
+ 				interrupts = <GIC_SHARED 48 IRQ_TYPE_LEVEL_HIGH>;
+ 				reg-shift = <2>;
+ 				reg-io-width = <4>;
+ 				clocks = <&uart_clk 0>, <&apb_clk 0>;
+ 				clock-names = "baudclk", "apb_pclk";
+ 			};
+ 
+ 			uart1: serial1@1F04B000 {
+ 				compatible = "snps,dw-apb-uart";
+ 				reg = <0x1F04B000 0x1000>;
+ 				interrupts = <GIC_SHARED 49 IRQ_TYPE_LEVEL_HIGH>;
+ 				reg-shift = <2>;
+ 				reg-io-width = <4>;
+ 				clocks = <&uart_clk 0>, <&apb_clk 0>;
+ 				clock-names = "baudclk", "apb_pclk";
+ 			};
+ 
+ 			wdt: watchdog@1F04C000 {
+ 				compatible = "snps,dw-wdt";
+ 				reg = <0x1F04C000 0x1000>;
+ 				interrupts = <GIC_SHARED 17 IRQ_TYPE_LEVEL_HIGH>;
+ 				clocks = <&wdt_clk 0>;
+ 				clock-names = "wdtclk";
+ 			};
+ 
+ 			i2c0: i2c0@1F046000 {
+ 				#address-cells = <1>;
+ 				#size-cells = <0>;
+ 				compatible = "snps,designware-i2c";
+ 				reg = <0x1F046000 0x1000>;
+ 				interrupts = <GIC_SHARED 33 IRQ_TYPE_LEVEL_HIGH>;
+ 				clock-frequency = <400000>;
+ 				clocks = <&i2c0_clk 0>;
+ 				clock-names = "i2c0clk";
+ 
+ 				eeprom@50 {
+ 					compatible = "atmel,24c02";
+ 					pagesize = <16>;
+ 					reg = <0x50>;
+ 				};
+ 
+ 				eeprom@68 {
+ 					compatible = "dallas,ds1307";
+ 					reg = <0x68>;
+ 				};
+ 			};
+ 
+ 			i2c1: i2c1@1F047000 {
+ 				#address-cells = <1>;
+ 				#size-cells = <0>;
+ 				compatible = "snps,designware-i2c";
+ 				reg = <0x1F047000 0x1000>;
+ 				interrupts = <GIC_SHARED 34 IRQ_TYPE_LEVEL_HIGH>;
+ 				clock-frequency = <400000>;
+ 				clocks = <&i2c1_clk 0>;
+ 				clock-names = "i2c1clk";
+ 
+ 				eeprom@50 {
+ 					compatible = "atmel,24c02";
+ 					pagesize = <16>;
+ 					reg = <0x50>;
+ 				};
+ 			};
+ 
+ 			spi0: ssi0@1F04E000 {
+ 				#address-cells = <1>;
+ 				#size-cells = <0>;
+ 				compatible = "snps,dw-apb-ssi", "snps,dw-spi";
+ 				reg = <0x1F04E000 0x1000>;
+ 				interrupts = <GIC_SHARED 40 IRQ_TYPE_LEVEL_HIGH>;
+ 				clocks = <&spi0_clk 0>;
+ 				clock-names = "spi0clk";
+ 				num-cs = <6>;
+ 
+ 				flash0: m25p80@0 {
+ 					#address-cells = <1>;
+ 					#size-cells = <1>;
+ 					status = "okay";
+ 					compatible = "micron,n25q256a";
+ 					reg = <0>;
+ 					spi-max-frequency = <50000000>;
+ 					m25p,fast-read;
+ 
+ 					mtd0@00000000 {
+ 						label = "bootloader";
+ 						reg = <0x00000000 0x00040000>;
+ 						read-only;
+ 					};
+ 
+ 					mtd1@00040000 {
+ 						label = "enviroment";
+ 						reg = <0x00040000 0x00020000>;
+ 						read-only;
+ 					};
+ 
+ 					mtd2@00400000 {
+ 						label = "kernel";
+ 						reg = <0x00400000 0x00400000>;
+ 					};
+ 
+ 					mtd3@00440000 {
+ 						label = "rootfs";
+ 						reg = <0x00440000 0x00C00000>;
+ 					};
+ 
+ 					mtd4@00000000 {
+ 						label = "flash0";
+ 						reg = <0x00000000 0x02000000>;
+ 					};
+ 				};
+ 			};
+ 
+ 			spi1: ssi1@1F04F000 {
+ 				#address-cells = <1>;
+ 				#size-cells = <0>;
+ 				compatible = "snps,dw-apb-ssi", "snps,dw-spi";
+ 				reg = <0x1F04F000 0x1000>;
+ 				interrupts = <GIC_SHARED 41 IRQ_TYPE_LEVEL_HIGH>;
+ 				clocks = <&spi1_clk 0>;
+ 				clock-names = "spi1clk";
+ 				num-cs = <6>;
+ 
+ 				flash1: m25p80@0 {
+ 					#address-cells = <1>;
+ 					#size-cells = <1>;
+ 					status = "okay";
+ 					compatible = "micron,n25q256a";
+ 					reg = <0>;
+ 					spi-max-frequency = <50000000>;
+ 					m25p,fast-read;
+ 
+ 					mtd0@00000000 {
+ 						label = "flash1";
+ 						reg = <0x00000000 0x02000000>;
+ 					};
+ 				};
+ 			};
+ 
+ 			gpio: gpio@1F044000 {
+ 				compatible = "snps,dw-apb-gpio";
+ 				interrupts = <GIC_SHARED 19 IRQ_TYPE_LEVEL_HIGH>;
+ 				reg = <0x1F044000 0x1000>;
+ 				#address-cells = <1>;
+ 				#size-cells = <0>;
+ 
+ 				porta: gpio-controller@0 {
+ 					compatible = "snps,dw-apb-gpio-port";
+ 					#gpio-cells = <2>;
+ 					gpio-controller;
+ 					snps,nr-gpios = <32>;
+ 					reg = <0>;
+ 					#interrupt-cells = <3>;
+ 					interrupt-controller;
+ 					interrupts = <GIC_SHARED 19 IRQ_TYPE_LEVEL_HIGH>;
+ 				};
+ 			};
+ 		};
+ 	};
+ };
diff -rcNP linux-4.4.24/arch/mips/boot/dts/baikal/baikal_fpga.dts linux-4.4.24-baikal/arch/mips/boot/dts/baikal/baikal_fpga.dts
*** linux-4.4.24/arch/mips/boot/dts/baikal/baikal_fpga.dts	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/arch/mips/boot/dts/baikal/baikal_fpga.dts	2016-11-11 14:49:51.000000000 +0300
***************
*** 0 ****
--- 1,234 ----
+ /*
+  * Baikal-T FPGA device tree.
+  *
+  * Copyright (C) 2014,2015  Baikal Electronics JSC
+  *
+  * This program is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU General Public License
+  * as published by the Free Software Foundation; either version 2
+  * of the License, or (at your option) any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; if not, write to the Free Software
+  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+  */
+ 
+ #include <dt-bindings/interrupt-controller/mips-gic.h>
+ 
+ #define FPGA_CPU_FREQ	8000000
+ #define FPGA_GIC_FREQ	(FPGA_CPU_FREQ / 2)
+ #define FPGA_APB_FREQ	50000000
+ #define FPGA_UART_FREQ	12500000
+ 
+ /dts-v1/;
+ 
+ / {
+ 	model = "Baikal FPGA board";
+ 	compatible = "baikal,mips";
+ 	#address-cells = <1>;
+ 	#size-cells = <1>;
+ 	interrupt-parent = <&gic>;
+ 
+ 	aliases {
+ 		gic = &gic;
+ 		serial0 = &uart0;
+ 		serial1 = &uart1;
+ 	};
+ 
+ 	chosen {
+ 		bootargs = "root=/dev/ram rw console=ttyS0,mmio32,38400 earlyprintk=uart8250,mmio32,0x1F04A000,38400 nocoherentio nol2par nol1par";
+ 	};
+ 
+ 	cpus {
+ 		#address-cells = <1>;
+ 		#size-cells = <0>;
+ 
+ 		CPU0: cpu@0 {
+ 			device_type = "cpu";
+ 			compatible = "mti,p5600";
+ 			reg = <0x0>;
+ 			clocks = <&cpu_clk 0>;
+ 			clock-names = "cpuclk";
+ 		};
+ 
+ 		CPU1: cpu@1 {
+ 			device_type = "cpu";
+ 			compatible = "mti,p5600";
+ 			reg = <0x1>;
+ 			clocks = <&cpu_clk 0>;
+ 			clock-names = "cpuclk";
+ 		};
+ 	};
+ 
+ 	memory {
+ 		device_type = "memory";
+ 		reg = <0x00000000 0x08000000>;
+ 	};
+ 
+ 	gic: gic@1BDC0000 {
+ 		compatible = "mti,gic";
+ 		reg = <0x1BDC0000 0x20000>;
+ 
+ 		interrupt-controller;
+ 		#interrupt-cells = <3>;
+ 
+ 		timer:timer {
+ 			compatible = "mti,gic-timer";
+ 			interrupts = <GIC_LOCAL 1 IRQ_TYPE_NONE>;
+ 			clock-frequency = <FPGA_GIC_FREQ>;
+ 			clocks = <&gic_clk 0>;
+ 			clock-names = "gicclk";
+ 		};
+ 	};
+ 
+ 	axi {
+ 		compatible = "simple-bus";
+ 		#address-cells = <1>;
+ 		#size-cells = <1>;
+ 		interrupt-parent = <&gic>;
+ 
+ 		ranges;
+ 
+ 		apb_ehb@1F059000 {
+ 			compatible = "be,apb-ehb";
+ 			reg = <0x1f059000 0x1000>;
+ 			interrupts = <GIC_SHARED 16 IRQ_TYPE_LEVEL_HIGH>;
+ 		};
+ 
+ 		axi_ehb@1F04D110 {
+ 			compatible = "be,axi-ehb";
+ 			reg = <0x1F04D110 0x8>;
+ 			interrupts = <GIC_SHARED 127 IRQ_TYPE_LEVEL_HIGH>;
+ 		};
+ 	};
+ 
+ 	apb {
+ 		compatible = "simple-bus";
+ 		#address-cells = <1>;
+ 		#size-cells = <1>;
+ 		interrupt-parent = <&gic>;
+ 
+ 		ranges;
+ 
+ 		timer0: timer0@1F049000 {
+ 			compatible = "snps,dw-apb-timer-osc";
+ 			interrupts = <GIC_SHARED 24 IRQ_TYPE_LEVEL_HIGH>;
+ 			reg = <0x1F049000 0x14>;
+ 			clocks = <&timer0_clk 0>;
+ 			clock-names = "timer";
+ 		};
+ 
+ 		timer1: timer1@1F049014 {
+ 			compatible = "snps,dw-apb-timer-sp";
+ 			reg = <0x1F049014 0x14>;
+ 			interrupts = <GIC_SHARED 25 IRQ_TYPE_LEVEL_HIGH>;
+ 			clocks = <&timer1_clk 0>;
+ 			clock-names = "timer";
+ 		};
+ 
+ 		timer2: timer2@1F049028 {
+ 			compatible = "snps,dw-apb-timer-sp";
+ 			reg = <0x1F049028 0x14>;
+ 			interrupts = <GIC_SHARED 26 IRQ_TYPE_LEVEL_HIGH>;
+ 			clocks = <&timer2_clk 0>;
+ 			clock-names = "timer";
+ 		};
+ 
+ 		uart0: serial0@1F04A000 {
+ 			compatible = "snps,dw-apb-uart";
+ 			reg = <0x1F04A000 0x1000>;
+ 			interrupts = <GIC_SHARED 48 IRQ_TYPE_LEVEL_HIGH>;
+ 			reg-shift = <2>;
+ 			reg-io-width = <4>;
+ 			clocks = <&uart_clk 0>, <&apb_clk 0>;
+ 			clock-names = "baudclk", "apb_pclk";
+ 		};
+ 
+ 		uart1: serial1@1F04B000 {
+ 			compatible = "snps,dw-apb-uart";
+ 			reg = <0x1F04B000 0x1000>;
+ 			interrupts = <GIC_SHARED 49 IRQ_TYPE_LEVEL_HIGH>;
+ 			reg-shift = <2>;
+ 			reg-io-width = <4>;
+ 			clocks = <&uart_clk 0>, <&apb_clk 0>;
+ 			clock-names = "baudclk", "apb_pclk";
+ 		};
+ 	};
+ 
+ 	clocks {
+ 		#address-cells = <1>;
+ 		#size-cells = <1>;
+ 
+ 		ranges;
+ 
+ 		cpu_clk:cpu_clk {
+ 			compatible = "fixed-clock";
+ 			#clock-cells = <1>;
+ 			clock-frequency  = <FPGA_CPU_FREQ>;
+ 			clock-output-names = "cpuclk";
+ 		};
+ 
+ 		gic_clk:gic_clk {
+ 			compatible = "fixed-clock";
+ 			#clock-cells = <1>;
+ 			clock-frequency  = <FPGA_GIC_FREQ>;
+ 			clock-output-names = "gicclk";
+ 		};
+ 
+ 		div_1m:div_1m {
+ 			compatible = "fixed-clock";
+ 			#clock-cells = <1>;
+ 			clock-frequency  = <1000000>;
+ 			clock-output-names = "div1m";
+ 		};
+ 
+ 		apb_clk:apb_clk@1F04D064 {
+ 			compatible = "fixed-clock";
+ 			#clock-cells = <1>;
+ 			clock-frequency  = <FPGA_APB_FREQ>;
+ 			clock-output-names = "apbclk";
+ 		};
+ 
+ 		uart_clk:uart_clk@ {
+ 			compatible = "fixed-clock";
+ 			#clock-cells = <1>;
+ 			clock-frequency  = <FPGA_UART_FREQ>;
+ 			clock-output-names = "baudclk";
+ 		};
+ 
+ 		timer0_clk:timer0_clk {
+ 			compatible = "fixed-factor-clock";
+ 			#clock-cells = <1>;
+ 			clocks = <&apb_clk 0>;
+ 			clock-div = <1>;
+ 			clock-mult = <1>;
+ 			clock-names = "div1m";
+ 			clock-output-names = "timer0clk";
+ 		};
+ 
+ 		timer1_clk:timer1_clk {
+ 			compatible = "fixed-factor-clock";
+ 			#clock-cells = <1>;
+ 			clocks = <&apb_clk 0>;
+ 			clock-div = <1>;
+ 			clock-mult = <1>;
+ 			clock-names = "div1m";
+ 			clock-output-names = "timer1clk";
+ 		};
+ 
+ 		timer2_clk:timer2_clk {
+ 			compatible = "fixed-factor-clock";
+ 			#clock-cells = <1>;
+ 			clocks = <&apb_clk 0>;
+ 			clock-div = <1>;
+ 			clock-mult = <1>;
+ 			clock-names = "div1m";
+ 			clock-output-names = "timer2clk";
+ 		};
+ 	};
+ };
diff -rcNP linux-4.4.24/arch/mips/boot/dts/baikal/baikal_module.dts linux-4.4.24-baikal/arch/mips/boot/dts/baikal/baikal_module.dts
*** linux-4.4.24/arch/mips/boot/dts/baikal/baikal_module.dts	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/arch/mips/boot/dts/baikal/baikal_module.dts	2016-11-11 14:49:51.000000000 +0300
***************
*** 0 ****
--- 1,396 ----
+ /*
+  * Baikal-T BFK board device tree.
+  *
+  * Copyright (C) 2014,2015  Baikal Electronics JSC
+  *
+  * This program is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU General Public License
+  * as published by the Free Software Foundation; either version 2
+  * of the License, or (at your option) any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; if not, write to the Free Software
+  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+  */
+ 
+ #include <dt-bindings/interrupt-controller/mips-gic.h>
+ 
+ /dts-v1/;
+ 
+ /include/ "baikal_clocks.dtsi"
+ 
+ / {
+ 	model = "Baikal-T Module Board";
+ 	compatible = "baikal,mips";
+ 	#address-cells = <1>;
+ 	#size-cells = <1>;
+ 	interrupt-parent = <&gic>;
+ 	aliases {
+ 		gic = &gic;
+ 		serial0 = &uart0;
+ 		serial1 = &uart1;
+ 		i2c0 = &i2c0;
+ 		i2c1 = &i2c1;
+ 		ssi0 = &spi0;
+ 		ssi1 = &spi1;
+ 		ethernet0 = &gmac0;
+ 		ethernet1 = &gmac1;
+ 	};
+ 
+ 	chosen {
+ 		bootargs = "root=/dev/ram rw console=ttyS0,mmio32,38400 earlyprintk=uart8250,mmio32,0x1F04A000,38400 nohtw";
+ 		linux,initrd-start = <0x01000000>;
+ 		linux,initrd-end   = <0x02000000>;
+ 	};
+ 
+ 	cpus {
+ 		#address-cells = <1>;
+ 		#size-cells = <0>;
+ 
+ 		CPU0: cpu@0 {
+ 			device_type = "cpu";
+ 			compatible = "mti,p5600";
+ 			reg = <0x0>;
+ 			clocks = <&cpu_clk 0>;
+ 			clock-names = "cpuclk";
+ 		};
+ 
+ 		CPU1: cpu@1 {
+ 			device_type = "cpu";
+ 			compatible = "mti,p5600";
+ 			reg = <0x1>;
+ 			clocks = <&cpu_clk 0>;
+ 			clock-names = "cpuclk";
+ 		};
+ 	};
+ 
+ 	memory {
+ 		device_type = "memory";
+ 		reg = <0x00000000 0x08000000>,
+ 		      <0x20000000 0x80000000>;
+ 	};
+ 
+ 	gic: gic@1BDC0000 {
+ 		compatible = "mti,gic";
+ 		reg = <0x1BDC0000 0x20000>;
+ 
+ 		interrupt-controller;
+ 		#interrupt-cells = <3>;
+ 
+ 		timer:timer {
+ 			compatible = "mti,gic-timer";
+ 			interrupts = <GIC_LOCAL 1 IRQ_TYPE_NONE>;
+ 			clock-frequency = <600000000>;
+ 			clocks = <&gic_clk 0>;
+ 			clock-names = "gicclk";
+ 		};
+ 	};
+ 	axi {
+ 		compatible = "simple-bus";
+ 		#address-cells = <1>;
+ 		#size-cells = <1>;
+ 		interrupt-parent = <&gic>;
+ 
+ 		ranges;
+ 
+ 		dma: dma@1f041000 {
+ 			compatible = "snps,dma-spear1340";
+ 			reg = <0x1f041000 0x1000>;
+ 			interrupts = <GIC_SHARED 56 IRQ_TYPE_LEVEL_HIGH>;
+ 			dma-channels = <8>;
+ 			dma-requests = <16>;
+ 			dma-masters = <2>;
+ 			#dma-cells = <3>;
+ 			chan_allocation_order = <1>;
+ 			chan_priority = <1>;
+ 			block_size = <0xfff>;
+ 			data_width = <3 3 0 0>;
+ 			clocks = <&dma_clk 0>;
+ 			clock-names = "hclk";
+ 		};
+ 
+ 		sata@1F050000 {
+ 			interrupt-parent = <&gic>;
+ 			compatible = "synopsys,dwc-ahsata", "snps,spear-ahci";
+ 			reg = <0x1F050000 0x2000>;
+ 			interrupts = <GIC_SHARED 64 IRQ_TYPE_LEVEL_HIGH>;
+ 			clocks = <&sata_clk 0>;
+ 			clock-names = "sataclk";
+ 		};
+ 
+ 		gmac0: eth1@1F05E000 {
+ 			compatible = "be,baikal-stmmac", "snps,dwmac-3.710", "snps,dwmac";
+ 			reg = <0x1F05E000 0x2000>;
+ 			interrupt-parent = <&gic>;
+ 			interrupts = <GIC_SHARED 72 IRQ_TYPE_LEVEL_HIGH>;
+ 			interrupt-names = "macirq";
+ 			phy-mode = "rgmii";
+ 			clocks = <&gmac0_clk 0>;
+ 			clock-names = "stmmaceth";
+ 			mac-address = [ 7a 72 6c 4a 7a 07 ];
+ 			local-mac-address = [ 7a 72 6c 4a 7a 07 ];
+ 			txd0-skew-ps = <0>;
+ 			txd1-skew-ps = <0>;
+ 			txd2-skew-ps = <0>;
+ 			txd3-skew-ps = <0>;
+ 			txc-skew-ps  = <0xffff>;
+ 		};
+ 
+ 		gmac1: eth2@1F060000 {
+ 			compatible = "be,baikal-stmmac", "snps,dwmac-3.710", "snps,dwmac";
+ 			reg = <0x1F060000 0x2000>;
+ 			interrupt-parent = <&gic>;
+ 			interrupts = <GIC_SHARED 73 IRQ_TYPE_LEVEL_HIGH>;
+ 			interrupt-names = "macirq";
+ 			phy-mode = "rgmii";
+ 			clocks = <&gmac1_clk 0>;
+ 			clock-names = "stmmaceth";
+ 			mac-address = [ 7a 72 6c 4a 7b 07 ];
+ 			local-mac-address = [ 7a 72 6c 4a 7b 07 ];
+ 			txd0-skew-ps = <0>;
+ 			txd1-skew-ps = <0>;
+ 			txd2-skew-ps = <0>;
+ 			txd3-skew-ps = <0>;
+ 			txc-skew-ps  = <0xffff>;
+ 		};
+ 
+ 		usb3: usb@1F04D050 {
+ 			compatible = "be,baikal-dwc3";
+ 
+ 			reg = <0x1F04D050 0x0004>;
+ 			interrupts = <GIC_SHARED 69 IRQ_TYPE_LEVEL_HIGH>;
+ 
+ 			#address-cells = <1>;
+ 			#size-cells = <1>;
+ 
+ 			clocks = <&usb_clk 0>;
+ 			clock-names = "usb";
+ 
+ 			ranges;
+ 
+ 			dwc3@1F100000 {
+ 					compatible = "snps,dwc3", "synopsys,dwc3";
+ 					reg = <0x1F100000 0x10000>;
+ 					interrupts = <GIC_SHARED 68 IRQ_TYPE_LEVEL_HIGH>;
+ 					dr_mode = "host";
+ 
+ 					tx-fifo-resize;
+ 
+ 					maximum-speed = "high-speed";
+ 			};
+ 		};
+ 
+ 		apb_ehb@1F059000 {
+ 			compatible = "be,apb-ehb";
+ 			reg = <0x1f059000 0x1000>;
+ 			interrupts = <GIC_SHARED 16 IRQ_TYPE_LEVEL_HIGH>;
+ 		};
+ 
+ 		axi_ehb@1F04D110 {
+ 			compatible = "be,axi-ehb";
+ 			reg = <0x1F04D110 0x8>;
+ 			interrupts = <GIC_SHARED 127 IRQ_TYPE_LEVEL_HIGH>;
+ 		};
+ 	};
+ 
+ 	apb {
+ 		compatible = "simple-bus";
+ 		#address-cells = <1>;
+ 		#size-cells = <1>;
+ 		interrupt-parent = <&gic>;
+ 
+ 		ranges;
+ 
+ 		timer0: timer0@1F049000 {
+ 			compatible = "snps,dw-apb-timer-osc";
+ 			interrupts = <GIC_SHARED 24 IRQ_TYPE_LEVEL_HIGH>;
+ 			reg = <0x1F049000 0x14>;
+ 			clocks = <&timer0_clk 0>;
+ 			clock-names = "timer";
+ 		};
+ 
+ 		timer1: timer1@1F049014 {
+ 			compatible = "snps,dw-apb-timer-sp";
+ 			reg = <0x1F049014 0x14>;
+ 			interrupts = <GIC_SHARED 25 IRQ_TYPE_LEVEL_HIGH>;
+ 			clocks = <&timer1_clk 0>;
+ 			clock-names = "timer";
+ 		};
+ 
+ 		timer2: timer2@1F049028 {
+ 			compatible = "snps,dw-apb-timer-sp";
+ 			reg = <0x1F049028 0x14>;
+ 			interrupts = <GIC_SHARED 26 IRQ_TYPE_LEVEL_HIGH>;
+ 			clocks = <&timer2_clk 0>;
+ 			clock-names = "timer";
+ 		};
+ 
+ 		uart0: serial0@1F04A000 {
+ 			compatible = "snps,dw-apb-uart";
+ 			reg = <0x1F04A000 0x1000>;
+ 			interrupts = <GIC_SHARED 48 IRQ_TYPE_LEVEL_HIGH>;
+ 			reg-shift = <2>;
+ 			reg-io-width = <4>;
+ 			clocks = <&uart_clk 0>, <&apb_clk 0>;
+ 			clock-names = "baudclk", "apb_pclk";
+ 		};
+ 
+ 		uart1: serial1@1F04B000 {
+ 			compatible = "snps,dw-apb-uart";
+ 			reg = <0x1F04B000 0x1000>;
+ 			interrupts = <GIC_SHARED 49 IRQ_TYPE_LEVEL_HIGH>;
+ 			reg-shift = <2>;
+ 			reg-io-width = <4>;
+ 			clocks = <&uart_clk 0>, <&apb_clk 0>;
+ 			clock-names = "baudclk", "apb_pclk";
+ 		};
+ 
+ 		wdt: watchdog@1F04C000 {
+ 			compatible = "snps,dw-wdt";
+ 			reg = <0x1F04C000 0x1000>;
+ 			interrupts = <GIC_SHARED 17 IRQ_TYPE_LEVEL_HIGH>;
+ 			clocks = <&wdt_clk 0>;
+ 			clock-names = "wdtclk";
+ 		};
+ 
+ 		i2c0: i2c0@1F046000 {
+ 			#address-cells = <1>;
+ 			#size-cells = <0>;
+ 			compatible = "snps,designware-i2c";
+ 			reg = <0x1F046000 0x1000>;
+ 			interrupts = <GIC_SHARED 33 IRQ_TYPE_LEVEL_HIGH>;
+ 			clock-frequency = <400000>;
+ 			clocks = <&i2c0_clk 0>;
+ 			clock-names = "i2c0clk";
+ 
+ 			codec@18 {
+ 				compatible = "tlv320aic310x";
+ 				reg = <0x18>;
+ 			};
+ 
+ 			gpioexp: gpioexp@20 {
+ 				compatible = "nxp,pca9500";
+ 				reg = <0x20>;
+ 			};
+ 
+ 			eeprom@50 {
+ 				compatible = "atmel,24c02";
+ 				pagesize = <16>;
+ 				reg = <0x50>;
+ 			};
+ 		};
+ 
+ 		i2c1: i2c1@1F047000 {
+ 			#address-cells = <1>;
+ 			#size-cells = <0>;
+ 			compatible = "snps,designware-i2c";
+ 			reg = <0x1F047000 0x1000>;
+ 			interrupts = <GIC_SHARED 34 IRQ_TYPE_LEVEL_HIGH>;
+ 			clock-frequency = <400000>;
+ 			clocks = <&i2c1_clk 0>;
+ 			clock-names = "i2c1clk";
+ 
+ 			eeprom@50 {
+ 				compatible = "atmel,24c02";
+ 				pagesize = <16>;
+ 				reg = <0x50>;
+ 			};
+ 
+ 			eeprom@51 {
+ 				compatible = "atmel,24c02";
+ 				pagesize = <16>;
+ 				reg = <0x51>;
+ 			};
+ 
+ 			rtc@56 {
+ 				compatible = "abracon,abeoz9s3";
+ 				reg = <0x56>;
+ 			};
+ 
+ 		};
+ 
+ 		spi0: ssi0@1F04E000 {
+ 			#address-cells = <1>;
+ 			#size-cells = <0>;
+ 			compatible = "snps,dw-apb-ssi", "snps,dw-spi";
+ 			reg = <0x1F04E000 0x1000>;
+ 			interrupts = <GIC_SHARED 40 IRQ_TYPE_LEVEL_HIGH>;
+ 			clocks = <&spi0_clk 0>;
+ 			clock-names = "spi0clk";
+ 			num-cs = <1>;
+ 			cs-gpios = <&porta 17 0>;
+ 
+ 			flash0: m25p80@0 {
+ 				#address-cells = <1>;
+ 				#size-cells = <1>;
+ 				status = "okay";
+ 				compatible = "micron,n25q256a";
+ 				reg = <0>;
+ 				spi-max-frequency = <10000000>;
+ 				m25p,fast-read;
+ 
+ 				mtd0@00000000 {
+ 					label = "flash0";
+ 					reg = <0x00000000 0x02000000>;
+ 				};
+ 			};
+ 		};
+ 
+ 		spi1: ssi1@1F04F000 {
+ 			#address-cells = <1>;
+ 			#size-cells = <0>;
+ 			compatible = "snps,dw-apb-ssi", "snps,dw-spi";
+ 			reg = <0x1F04F000 0x1000>;
+ 			interrupts = <GIC_SHARED 41 IRQ_TYPE_LEVEL_HIGH>;
+ 			clocks = <&spi1_clk 0>;
+ 			clock-names = "spi1clk";
+ 			num-cs = <1>;
+ 
+ 			flash1: m25p80@0 {
+ 				#address-cells = <1>;
+ 				#size-cells = <1>;
+ 				status = "okay";
+ 				compatible = "micron,n25q256a";
+ 				reg = <0>;
+ 				spi-max-frequency = <10000000>;
+ 				m25p,fast-read;
+ 
+ 				mtd1@00000000 {
+ 					label = "flash1";
+ 					reg = <0x00000000 0x02000000>;
+ 				};
+ 			};
+ 		};
+ 
+ 		gpio: gpio@1F044000 {
+ 			compatible = "snps,dw-apb-gpio";
+ 			interrupts = <GIC_SHARED 19 IRQ_TYPE_LEVEL_HIGH>;
+ 			reg = <0x1F044000 0x1000>;
+ 			#address-cells = <1>;
+ 			#size-cells = <0>;
+ 
+ 			porta: gpio-controller@0 {
+ 				compatible = "snps,dw-apb-gpio-port";
+ 				#gpio-cells = <2>;
+ 				gpio-controller;
+ 				snps,nr-gpios = <32>;
+ 				reg = <0>;
+ 				#interrupt-cells = <3>;
+ 				interrupt-controller;
+ 				interrupts = <GIC_SHARED 19 IRQ_TYPE_LEVEL_HIGH>;
+ 			};
+ 		};
+ 
+ 		pci: pci@1F052000 {
+ 			compatible = "snps,dw-pci";
+ 			interrupts = <GIC_SHARED 88 IRQ_TYPE_LEVEL_HIGH>,
+ 				<GIC_SHARED 89 IRQ_TYPE_LEVEL_HIGH>;
+ 			reg = <0x1F052000 0x1000>;
+ 		};
+ 	};
+ };
diff -rcNP linux-4.4.24/arch/mips/boot/dts/baikal/baikal_qemu.dts linux-4.4.24-baikal/arch/mips/boot/dts/baikal/baikal_qemu.dts
*** linux-4.4.24/arch/mips/boot/dts/baikal/baikal_qemu.dts	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/arch/mips/boot/dts/baikal/baikal_qemu.dts	2016-11-11 14:49:51.000000000 +0300
***************
*** 0 ****
--- 1,386 ----
+ /*
+  * Baikal-T SOC QEMU device tree.
+  *
+  * Copyright (C) 2014,2015  Baikal Electronics OJSC
+  *
+  * This program is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU General Public License
+  * as published by the Free Software Foundation; either version 2
+  * of the License, or (at your option) any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; if not, write to the Free Software
+  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+  */
+ 
+ #include <dt-bindings/interrupt-controller/mips-gic.h>
+ 
+ /dts-v1/;
+ 
+ /include/ "baikal_clocks.dtsi"
+ 
+ / {
+ 	model = "Baikal-T QEMU Simulator";
+ 	compatible = "baikal,mips";
+ 	#address-cells = <1>;
+ 	#size-cells = <1>;
+ 	interrupt-parent = <&gic>;
+ 	aliases {
+ 		gic = &gic;
+ 		serial0 = &uart0;
+ 		serial1 = &uart1;
+ 		i2c0 = &i2c0;
+ 		i2c1 = &i2c1;
+ 		ssi0 = &spi0;
+ 		ssi1 = &spi1;
+ 		ethernet0 = &gmac0;
+ 		ethernet1 = &gmac1;
+ 		ethernet2 = &xgmac;
+ 	};
+ 
+ 	chosen {
+ 		bootargs = "root=/dev/ram rw console=ttyS0,mmio32,115200 earlyprintk=uart8250,mmio32,0x1F04A000,115200";
+ 		linux,initrd-start = <0x01000000>;
+ 		linux,initrd-end   = <0x03000000>;
+ 	};
+ 
+ 	cpus {
+ 		#address-cells = <1>;
+ 		#size-cells = <0>;
+ 
+ 		CPU0: cpu@0 {
+ 			device_type = "cpu";
+ 			compatible = "mips,p5600";
+ 			reg = <0x0>;
+ 			clocks = <&cpu_clk 0>;
+ 			clock-names = "cpuclk";
+ 		};
+ 
+ 		CPU1: cpu@1 {
+ 			device_type = "cpu";
+ 			compatible = "mips,p5600";
+ 			reg = <0x1>;
+ 			clocks = <&cpu_clk 0>;
+ 			clock-names = "cpuclk";
+ 		};
+ 	};
+ 
+ 	memory {
+ 		device_type = "memory";
+ 		reg = <0x00000000 0x08000000>,
+ 		      <0x20000000 0x40000000>;
+ 	};
+ 
+ 	gic: gic@1BDC0000 {
+ 		compatible = "mti,gic";
+ 		reg = <0x1BDC0000 0x20000>;
+ 
+ 		interrupt-controller;
+ 		#interrupt-cells = <3>;
+ 
+ 		timer:timer {
+ 			compatible = "mti,gic-timer";
+ 			interrupts = <GIC_LOCAL 1 IRQ_TYPE_NONE>;
+ 			clock-frequency = <30000000>;
+ 			clocks = <&gic_clk 0>;
+ 			clock-names = "gicclk";
+ 		};
+ 
+ 	};
+ 
+ 	soc {
+ 		compatible = "simple-bus";
+ 		#address-cells = <1>;
+ 		#size-cells = <1>;
+ 		interrupt-parent = <&gic>;
+ 
+ 		ranges;
+ 
+ 		dma: dma@1f041000 {
+ 			compatible = "snps,dma-spear1340";
+ 			reg = <0x1f041000 0x1000>;
+ 			interrupts = <GIC_SHARED 56 IRQ_TYPE_LEVEL_HIGH>;
+ 			dma-channels = <8>;
+ 			dma-requests = <16>;
+ 			dma-masters = <2>;
+ 			#dma-cells = <3>;
+ 			chan_allocation_order = <1>;
+ 			chan_priority = <1>;
+ 			block_size = <0xfff>;
+ 			data_width = <3 3 0 0>;
+ 			clocks = <&dma_clk 0>;
+ 			clock-names = "hclk";
+ 		};
+ 
+ 		sata@1F050000 {
+ 			interrupt-parent = <&gic>;
+ 			compatible = "synopsys,dwc-ahsata", "snps,spear-ahci";
+ 			reg = <0x1F050000 0x2000>;
+ 			interrupts = <GIC_SHARED 64 IRQ_TYPE_LEVEL_HIGH>;
+ 			clocks = <&sata_clk 0>;
+ 			clock-names = "sataclk";
+ 		};
+ 
+ 
+ 		gmac0: eth0@1F05E000 {
+ 			compatible = "snps,dwmac-3.710", "snps,dwmac";
+ 			reg = <0x1F05E000 0x2000>;
+ 			interrupt-parent = <&gic>;
+ 			interrupts = <GIC_SHARED 72 IRQ_TYPE_LEVEL_HIGH>;
+ 			interrupt-names = "macirq";
+ 			phy-mode = "gmii";
+ 			clocks = <&gmac0_clk 0>;
+ 			clock-names = "stmmaceth";
+ 			snps,fixed-burst;
+ 			mac-address = [ 00 20 13 ba 1c a2 ];
+ 			local-mac-address = [ 00 20 13 ba 1c a2 ];
+ 		};
+ 
+ 		gmac1: eth1@1F060000 {
+ 			compatible = "snps,dwmac-3.710", "snps,dwmac";
+ 			reg = <0x1F060000 0x2000>;
+ 			interrupt-parent = <&gic>;
+ 			interrupts = <GIC_SHARED 73 IRQ_TYPE_LEVEL_HIGH>;
+ 			interrupt-names = "macirq";
+ 			phy-mode = "gmii";
+ 			clocks = <&gmac1_clk 0>;
+ 			clock-names = "stmmaceth";
+ 			snps,fixed-burst;
+ 			mac-address = [ 00 20 13 ba 1c a3 ];
+ 			local-mac-address = [ 00 20 13 ba 1c a3 ];
+ 		};
+ 
+ 		xgbe_phy: xgbe_phy@1F05D000 {
+ 			compatible = "snps,xgbe-phy", "ethernet-phy-ieee802.3-c45";
+ 			reg = <0x1F05D000 0x1000>;
+ 		};
+ 
+ 		xgmac: eth2@1F054000 {
+ 			compatible = "amd,xgbe-seattle-v1a";
+ 			reg = <0x1F054000 0x4000>,
+ 				  <0x1F05D000 0x1000>;
+ 			interrupt-parent = <&gic>;
+ 			interrupts = <GIC_SHARED 80 IRQ_TYPE_LEVEL_HIGH>;
+ 			clocks = <&xgmac_dma 0>, <&xgmac_ptp 0>;
+ 			clock-names = "dma_clk", "ptp_clk";
+ 			phy-handle = <&xgbe_phy>;
+ 			phy-mode = "xgmii";
+ 			snps,speed-set = <1>;
+ 			mac-address = [ 00 20 13 ba 1c a1 ];
+ 			local-mac-address = [ 00 20 13 ba 1c a1 ];
+ 		};
+ 
+ 		/* Peripherial error handler block */
+ 		apb_ehb@1F059000 {
+ 			compatible = "be,apb-ehb";
+ 			reg = <0x1f059000 0x1000>;
+ 			interrupts = <GIC_SHARED 16 IRQ_TYPE_LEVEL_HIGH>;
+ 		};
+ 
+ 		/* Interconnect error handler block */
+ 
+ 		axi_ehb@1F04D110 {
+ 			compatible = "be,axi-ehb";
+ 			reg = <0x1F04D110 0x8>;
+ 			interrupts = <GIC_SHARED 127 IRQ_TYPE_LEVEL_HIGH>;
+ 		};
+ 
+ 		apb {
+ 			compatible = "simple-bus";
+ 			#address-cells = <1>;
+ 			#size-cells = <1>;
+ 			interrupt-parent = <&gic>;
+ 
+ 			ranges;
+ 
+ 			timer0: timer0@1F049000 {
+ 				compatible = "snps,dw-apb-timer-osc";
+ 				interrupts = <GIC_SHARED 24 IRQ_TYPE_LEVEL_HIGH>;
+ 				reg = <0x1F049000 0x14>;
+ 				clocks = <&timer0_clk 0>;
+ 				clock-names = "timer";
+ 			};
+ 
+ 			timer1: timer1@1F049014 {
+ 				compatible = "snps,dw-apb-timer-sp";
+ 				reg = <0x1F049014 0x14>;
+ 				interrupts = <GIC_SHARED 25 IRQ_TYPE_LEVEL_HIGH>;
+ 				clocks = <&timer1_clk 0>;
+ 				clock-names = "timer";
+ 			};
+ 
+ 			timer2: timer2@1F049028 {
+ 				compatible = "snps,dw-apb-timer-sp";
+ 				reg = <0x1F049028 0x14>;
+ 				interrupts = <GIC_SHARED 26 IRQ_TYPE_LEVEL_HIGH>;
+ 				clocks = <&timer2_clk 0>;
+ 				clock-names = "timer";
+ 			};
+ 
+ 			uart0: serial0@1F04A000 {
+ 				compatible = "snps,dw-apb-uart";
+ 				reg = <0x1F04A000 0x1000>;
+ 				interrupts = <GIC_SHARED 48 IRQ_TYPE_LEVEL_HIGH>;
+ 				reg-shift = <2>;
+ 				reg-io-width = <4>;
+ 				clocks = <&uart_clk 0>, <&apb_clk 0>;
+ 				clock-names = "baudclk", "apb_pclk";
+ 			};
+ 
+ 			uart1: serial1@1F04B000 {
+ 				compatible = "snps,dw-apb-uart";
+ 				reg = <0x1F04B000 0x1000>;
+ 				interrupts = <GIC_SHARED 49 IRQ_TYPE_LEVEL_HIGH>;
+ 				reg-shift = <2>;
+ 				reg-io-width = <4>;
+ 				clocks = <&uart_clk 0>, <&apb_clk 0>;
+ 				clock-names = "baudclk", "apb_pclk";
+ 			};
+ 
+ 			wdt: watchdog@1F04C000 {
+ 				compatible = "snps,dw-wdt";
+ 				reg = <0x1F04C000 0x1000>;
+ 				interrupts = <GIC_SHARED 17 IRQ_TYPE_LEVEL_HIGH>;
+ 				clocks = <&wdt_clk 0>;
+ 				clock-names = "wdtclk";
+ 			};
+ 
+ 			i2c0: i2c0@1F046000 {
+ 				#address-cells = <1>;
+ 				#size-cells = <0>;
+ 				compatible = "snps,designware-i2c";
+ 				reg = <0x1F046000 0x1000>;
+ 				interrupts = <GIC_SHARED 33 IRQ_TYPE_LEVEL_HIGH>;
+ 				clock-frequency = <400000>;
+ 				clocks = <&i2c0_clk 0>;
+ 				clock-names = "i2c0clk";
+ 
+ 				eeprom@50 {
+ 					compatible = "atmel,24c02";
+ 					pagesize = <16>;
+ 					reg = <0x50>;
+ 				};
+ 
+ 				eeprom@68 {
+ 					compatible = "dallas,ds1307";
+ 					reg = <0x68>;
+ 				};
+ 			};
+ 
+ 			i2c1: i2c1@1F047000 {
+ 				#address-cells = <1>;
+ 				#size-cells = <0>;
+ 				compatible = "snps,designware-i2c";
+ 				reg = <0x1F047000 0x1000>;
+ 				interrupts = <GIC_SHARED 34 IRQ_TYPE_LEVEL_HIGH>;
+ 				clock-frequency = <400000>;
+ 				clocks = <&i2c1_clk 0>;
+ 				clock-names = "i2c1clk";
+ 
+ 				eeprom@50 {
+ 					compatible = "atmel,24c02";
+ 					pagesize = <16>;
+ 					reg = <0x50>;
+ 				};
+ 			};
+ 
+ 			spi0: ssi0@1F04E000 {
+ 				#address-cells = <1>;
+ 				#size-cells = <0>;
+ 				compatible = "snps,dw-apb-ssi", "snps,dw-spi";
+ 				reg = <0x1F04E000 0x1000>;
+ 				interrupts = <GIC_SHARED 40 IRQ_TYPE_LEVEL_HIGH>;
+ 				clocks = <&spi0_clk 0>;
+ 				clock-names = "spi0clk";
+ 				num-cs = <6>;
+ 
+ 				flash0: m25p80@0 {
+ 					#address-cells = <1>;
+ 					#size-cells = <1>;
+ 					status = "okay";
+ 					compatible = "micron,n25q256a";
+ 					reg = <0>;
+ 					spi-max-frequency = <50000000>;
+ 					m25p,fast-read;
+ 
+ 					mtd0@00000000 {
+ 						label = "bootloader";
+ 						reg = <0x00000000 0x00040000>;
+ 						read-only;
+ 					};
+ 
+ 					mtd1@00040000 {
+ 						label = "enviroment";
+ 						reg = <0x00040000 0x00020000>;
+ 						read-only;
+ 					};
+ 
+ 					mtd2@00400000 {
+ 						label = "kernel";
+ 						reg = <0x00400000 0x00400000>;
+ 					};
+ 
+ 					mtd3@00440000 {
+ 						label = "rootfs";
+ 						reg = <0x00440000 0x00C00000>;
+ 					};
+ 
+ 					mtd4@00000000 {
+ 						label = "flash0";
+ 						reg = <0x00000000 0x02000000>;
+ 					};
+ 				};
+ 			};
+ 
+ 			spi1: ssi1@1F04F000 {
+ 				#address-cells = <1>;
+ 				#size-cells = <0>;
+ 				compatible = "snps,dw-apb-ssi", "snps,dw-spi";
+ 				reg = <0x1F04F000 0x1000>;
+ 				interrupts = <GIC_SHARED 41 IRQ_TYPE_LEVEL_HIGH>;
+ 				clocks = <&spi1_clk 0>;
+ 				clock-names = "spi1clk";
+ 				num-cs = <6>;
+ 
+ 				flash1: m25p80@0 {
+ 					#address-cells = <1>;
+ 					#size-cells = <1>;
+ 					status = "okay";
+ 					compatible = "micron,n25q256a";
+ 					reg = <0>;
+ 					spi-max-frequency = <50000000>;
+ 					m25p,fast-read;
+ 
+ 					mtd0@00000000 {
+ 						label = "flash1";
+ 						reg = <0x00000000 0x02000000>;
+ 					};
+ 				};
+ 			};
+ 
+ 			gpio: gpio@1F044000 {
+ 				compatible = "snps,dw-apb-gpio";
+ 				interrupts = <GIC_SHARED 19 IRQ_TYPE_LEVEL_HIGH>;
+ 				reg = <0x1F044000 0x1000>;
+ 				#address-cells = <1>;
+ 				#size-cells = <0>;
+ 
+ 				porta: gpio-controller@0 {
+ 					compatible = "snps,dw-apb-gpio-port";
+ 					#gpio-cells = <2>;
+ 					gpio-controller;
+ 					snps,nr-gpios = <32>;
+ 					reg = <0>;
+ 					#interrupt-cells = <3>;
+ 					interrupt-controller;
+ 					interrupts = <GIC_SHARED 19 IRQ_TYPE_LEVEL_HIGH>;
+ 				};
+ 			};
+ 		};
+ 	};
+ };
diff -rcNP linux-4.4.24/arch/mips/boot/dts/baikal/baikal_t1_clocks.dtsi linux-4.4.24-baikal/arch/mips/boot/dts/baikal/baikal_t1_clocks.dtsi
*** linux-4.4.24/arch/mips/boot/dts/baikal/baikal_t1_clocks.dtsi	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/arch/mips/boot/dts/baikal/baikal_t1_clocks.dtsi	2016-11-11 14:49:51.000000000 +0300
***************
*** 0 ****
--- 1,375 ----
+ /*
+  * Baikal-T1 SOC clock tree.
+  *
+  * Copyright (C) 2014,2015  Baikal Electronics OJSC
+  *
+  * This program is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU General Public License
+  * as published by the Free Software Foundation; either version 2
+  * of the License, or (at your option) any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; if not, write to the Free Software
+  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+  */
+ 
+ / {
+ 	clocks {
+ 		#address-cells = <1>;
+ 		#size-cells = <1>;
+ 
+ 		ranges;
+ 
+ 		/*** external oscillator ****/
+ 		osc25: oscillator@0 {
+ 			compatible = "fixed-clock";
+ 			#clock-cells = <1>;
+ 			clock-frequency  = <25000000>;
+ 			clock-output-names = "osc25";
+ 		};
+         
+ 
+         /*** primary clock domains ***/
+ 
+ 		core_pll: core_pll@1F04D000 {
+ 			compatible = "be,pmu-pll-clock";
+ 			#clock-cells = <1>;
+ 			clocks = <&osc25 0>;
+ 			clock-names = "ref";
+ 			reg = <0x1F04D000 0x0008>;
+ 			clock-output-names = "corepll";
+ 		};
+ 
+ 		sata_pll: sata_pll@1F04D008 {
+ 			compatible = "be,pmu-pll-clock";
+ 			#clock-cells = <1>;
+ 			clocks = <&osc25 0>;
+ 			clock-names = "ref";
+ 			reg = <0x1F04D008 0x0008>;
+ 			clock-output-names = "satapll";
+ 		};
+ 
+ 		ddr_pll: ddr_pll@1F04D010 {
+ 			compatible = "be,pmu-pll-clock";
+ 			#clock-cells = <1>;
+ 			clocks = <&osc25 0>;
+ 			clock-names = "ref";
+ 			reg = <0x1F04D010 0x0008>;
+ 			clock-output-names = "ddrpll";
+ 		};
+ 
+ 		pcie_pll: pcie_pll@1F04D018 {
+ 			compatible = "be,pmu-pll-clock";
+ 			#clock-cells = <1>;
+ 			clocks = <&osc25 0>;
+ 			clock-names = "ref";
+ 			reg = <0x1F04D018 0x0008>;
+ 			clock-output-names = "pciepll";
+ 		};
+ 
+ 		eth_pll: eth_pll@1F04D020 {
+ 			compatible = "be,pmu-pll-clock";
+ 			#clock-cells = <1>;
+ 			clocks = <&osc25 0>;
+ 			clock-names = "ref";
+ 			reg = <0x1F04D020 0x0008>;
+ 			clock-output-names = "ethpll";
+ 		};
+ 
+ 
+         /******** clocks ********/
+ 
+         /** core_pll domain **/
+ 		cpu_clk:cpu_clk {
+ 			compatible = "fixed-factor-clock";
+ 			clocks = <&core_pll 0>;
+ 			clock-names = "corepll";
+ 			#clock-cells = <0>;
+ 			clock-div = <1>;
+ 			clock-mult = <1>;
+ 			clock-output-names = "cpuclk";
+ 		};
+ 
+ 		gic_clk:gic_clk {
+ 			compatible = "fixed-factor-clock";
+ 			clocks = <&core_pll 0>;
+ 			clock-names = "corepll";
+ 			#clock-cells = <0>;
+ 			clock-div = <1>;
+ 			clock-mult = <1>;
+ 			clock-output-names = "gicclk";
+ 		};
+ 
+         /** pcie_pll domain **/
+ 		axi_clk:axi_clk {
+ 			compatible = "fixed-factor-clock";
+ 			clocks = <&pcie_pll 0>;
+ 			clock-names = "pciepll";
+ 			#clock-cells = <0>;
+ 			clock-div = <2>;
+ 			clock-mult = <1>;
+ 			clock-output-names = "axiclk";
+ 		};
+ 
+ 		apb_clk:apb_clk@1F04D064 {
+ 			compatible = "be,pmu-device-clock";
+ 			#clock-cells = <1>;
+ 			clocks = <&pcie_pll 0>;
+ 			clock-names = "pciepll";
+ 			reg = <0x1F04D064 0x0004>;
+ 			clock-output-names = "apbclk";
+ 			divider-width = <5>;
+ 		};
+ 
+ 		pci_phy_clk:pci_phy_clk@1F04D05C {
+ 			compatible = "be,pmu-device-clock";
+ 			#clock-cells = <1>;
+ 			clocks = <&pcie_pll 0>;
+ 			clock-names = "pciepll";
+ 			reg = <0x1F04D05C 0x0004>;
+ 			clock-output-names = "pciphyclk";
+ 			divider-width = <4>;
+ 			nobypass;
+ 		};
+ 
+         /** sata_pll domain **/
+ 		sata_clk:sata_clk@1F04D060 {
+ 			compatible = "be,pmu-device-clock";
+ 			#clock-cells = <1>;
+ 			clocks = <&sata_pll 0>;
+ 			clock-names = "sataclk";
+ 			reg = <0x1F04D060 0x0004>;
+ 			clock-output-names = "sataclk";
+ 			divider-width = <4>;
+ 			nobypass;
+ 		};
+ 
+         /** eth_pll domain **/
+ 		div_125m:div_125m {
+ 			compatible = "fixed-factor-clock";
+ 			clocks = <&eth_pll 0>;
+ 			clock-names = "ethpll";
+ 			#clock-cells = <1>;
+ 			clock-div = <5>;
+ 			clock-mult = <1>;
+ 			clock-output-names = "div125m";
+ 		};
+ 
+ 		div_156m:div_156m {
+ 			compatible = "fixed-factor-clock";
+ 			clocks = <&eth_pll 0>;
+ 			clock-names = "ethpll";
+ 			#clock-cells = <1>;
+ 			clock-div = <4>;
+ 			clock-mult = <1>;
+ 			clock-output-names = "div156m";
+ 		};
+ 
+         uart_clk:uart_clk@1F04D084 {
+             compatible = "be,pmu-device-clock";
+             #clock-cells = <1>;
+             clocks = <&eth_pll 0>;
+             clock-names = "ethpll";
+             reg = <0x1F04D084 0x0004>;
+             clock-output-names = "baudclk";
+             divider-width = <9>;
+         };
+         
+         /** osc25 derivatives **/
+ 		timer0_clk:timer0_clk@1F04D088 {
+ 			compatible = "be,pmu-device-clock";
+ 			#clock-cells = <1>;
+ 			clocks = <&osc25 0>;
+ 			clock-names = "ref";
+ 			reg = <0x1F04D088 0x0004>;
+ 			clock-output-names = "timer0clk";
+ 			divider-width = <17>;
+ 		};
+ 
+ 		timer1_clk:timer1_clk@1F04D08C {
+ 			compatible = "be,pmu-device-clock";
+ 			#clock-cells = <1>;
+ 			clocks = <&osc25 0>;
+ 			clock-names = "ref";
+ 			reg = <0x1F04D08C 0x0004>;
+ 			clock-output-names = "timer1clk";
+ 			divider-width = <17>;
+ 		};
+ 
+ 		timer2_clk:timer2_clk@1F04D090 {
+ 			compatible = "be,pmu-device-clock";
+ 			#clock-cells = <1>;
+ 			clocks = <&osc25 0>;
+ 			clock-names = "ref";
+ 			reg = <0x1F04D090 0x0004>;
+ 			clock-output-names = "timer2clk";
+ 			divider-width = <17>;
+ 		};
+ 
+ 		gpio_clk:gpio_clk {
+ 			compatible = "fixed-factor-clock";
+ 			clocks = <&osc25 0>;
+ 			clock-names = "ref";
+ 			#clock-cells = <0>;
+ 			clock-div = <25>;
+ 			clock-mult = <1>;
+ 			clock-output-names = "gpioclk";
+ 			clock-output = "gpio_clk";
+ 		};
+ 
+ 		pvt_clk:pvt_clk {
+ 			compatible = "fixed-factor-clock";
+ 			clocks = <&osc25 0>;
+ 			clock-names = "osc25";
+ 			#clock-cells = <0>;
+ 			clock-div = <21>;
+ 			clock-mult = <1>;
+ 			clock-output-names = "pvtclk";
+ 		};
+ 
+ 		div_1m:div_1m {
+ 			compatible = "fixed-factor-clock";
+ 			clocks = <&osc25 0>;
+ 			clock-names = "osc25";
+ 			#clock-cells = <0>;
+ 			clock-div = <25>;
+ 			clock-mult = <1>;
+ 			clock-output-names = "div1m";
+ 		};
+ 
+         /*** secondary clock domains ***/
+         
+         /** pcie_pll -> apb_clk domain **/
+ 		dma_clk:dma_clk {
+ 			compatible = "fixed-factor-clock";
+ 			clocks = <&apb_clk 0>;
+ 			clock-names = "apbclk";
+ 			#clock-cells = <0>;
+ 			clock-div = <1>;
+ 			clock-mult = <1>;
+ 			clock-output-names = "dmaclk";
+ 			clock-output = "hclk";
+ 		};
+ 
+ 		spi0_clk:spi0_clk {
+ 			compatible = "fixed-factor-clock";
+ 			clocks = <&apb_clk 0>;
+ 			clock-names = "apbclk";
+ 			#clock-cells = <0>;
+ 			clock-div = <1>;
+ 			clock-mult = <1>;
+ 			clock-output-names = "spi0clk";
+ 		};
+ 
+ 		spi1_clk:spi1_clk {
+ 			compatible = "fixed-factor-clock";
+ 			clocks = <&apb_clk 0>;
+ 			clock-names = "apbclk";
+ 			#clock-cells = <0>;
+ 			clock-div = <1>;
+ 			clock-mult = <1>;
+ 			clock-output-names = "spi1clk";
+ 		};
+ 
+ 		boot_clk:boot_clk {
+ 			compatible = "fixed-factor-clock";
+ 			clocks = <&apb_clk 0>;
+ 			clock-names = "apbclk";
+ 			#clock-cells = <0>;
+ 			clock-div = <1>;
+ 			clock-mult = <1>;
+ 			clock-output-names = "bootclk";
+ 		};
+ 
+         /** eth_pll -> div_125m domain **/
+ 		gmac0_clk:gmac0_clk@1F04D068 {
+ 			compatible = "be,pmu-device-clock";
+ 			#clock-cells = <1>;
+ 			clocks = <&div_125m 0>;
+ 			clock-names = "div125m";
+ 			reg = <0x1F04D068 0x0004>;
+ 			clock-output-names = "gmac0clk";
+ 			divider-width = <0>;
+ 		};
+ 
+ 		gmac1_clk:gmac1_clk@1F04D06C {
+ 			compatible = "be,pmu-device-clock";
+ 			#clock-cells = <1>;
+ 			clocks = <&div_125m 0>;
+ 			clock-names = "div125m";
+ 			reg = <0x1F04D06C 0x0004>;
+ 			clock-output-names = "gmac1clk";
+ 			divider-width = <0>;
+ 		};
+ 
+ 		usb_clk:usb_clk@1F04D074 {
+ 			compatible = "be,pmu-device-clock";
+ 			#clock-cells = <1>;
+ 			clocks = <&div_125m 0>;
+ 			clock-names = "div125m";
+ 			reg = <0x1F04D074 0x0004>;
+ 			clock-output-names = "usbclk";
+ 			divider-width = <0>;
+ 		};
+ 
+ 
+ 		i2c0_clk:i2c0_clk {
+ 			compatible = "fixed-factor-clock";
+ 			clocks = <&div_125m 0>;
+ 			clock-names = "div125m";
+ 			#clock-cells = <0>;
+ 			clock-div = <1>;
+ 			clock-mult = <1>;
+ 			clock-output-names = "i2c0clk";
+ 		};
+ 
+ 		i2c1_clk:i2c1_clk {
+ 			compatible = "fixed-factor-clock";
+ 			clocks = <&div_125m 0>;
+ 			clock-names = "div125m";
+ 			#clock-cells = <0>;
+ 			clock-div = <1>;
+ 			clock-mult = <1>;
+ 			clock-output-names = "i2c1clk";
+ 		};
+ 
+         /** eth_pll -> div_156m domain **/
+ 		xgmac_dma:xgmac_dma@1F04D070 {
+ 			compatible = "be,pmu-device-clock";
+ 			#clock-cells = <1>;
+ 			clocks = <&div_156m 0>;
+ 			clock-names = "div156m";
+ 			reg = <0x1F04D070 0x0004>;
+ 			clock-output-names = "xgmac_dma";
+ 			clock-output = "dma_clk";
+ 			divider-width = <0>;
+ 		};
+ 
+ 		xgmac_ptp:xgmac_ptp {
+ 			compatible = "fixed-factor-clock";
+ 			clocks = <&div_156m 0>;
+ 			clock-names = "div156m";
+ 			#clock-cells = <0>;
+ 			clock-div = <4>;
+ 			clock-mult = <1>;
+ 			clock-output-names = "xgmacptp";
+ 			clock-output = "ptp_clk";
+ 		};
+ 
+         /** osc25 -> div_1m domain **/
+ 		wdt_clk:wdt_clk@1F04D080 {
+ 			compatible = "be,pmu-device-clock";
+ 			#clock-cells = <1>;
+ 			clocks = <&div_1m 0>;
+ 			clock-names = "div1m";
+ 			reg = <0x1F04D080 0x0004>;
+ 			clock-output-names = "wdtclk";
+ 			divider-width = <0>;
+ 		};
+ 	};
+ };
diff -rcNP linux-4.4.24/arch/mips/boot/dts/baikal/Makefile linux-4.4.24-baikal/arch/mips/boot/dts/baikal/Makefile
*** linux-4.4.24/arch/mips/boot/dts/baikal/Makefile	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/arch/mips/boot/dts/baikal/Makefile	2016-11-11 14:49:51.000000000 +0300
***************
*** 0 ****
--- 1,23 ----
+ dtb-$(CONFIG_DTB_BAIKAL)	+= baikal.dtb
+ dtb-$(CONFIG_DTB_BAIKAL_BFK)	+= baikal_bfk.dtb
+ dtb-$(CONFIG_DTB_BAIKAL_BFK2)	+= baikal_bfk2.dtb
+ dtb-$(CONFIG_DTB_BAIKAL_FPGA)	+= baikal_fpga.dtb
+ dtb-$(CONFIG_DTB_BAIKAL_QEMU)	+= baikal_qemu.dtb
+ dtb-$(CONFIG_DTB_BAIKAL_MODULE)	+= baikal_module.dtb
+ 
+ 
+ dtb-$(CONFIG_DT_NONE)			+= \
+ 						baikal.dtb		\
+ 						baikal_bfk.dtb	\
+ 						baikal_bfk2.dtb	\
+ 						baikal_fpga.dtb	\
+ 						baikal_qemu.dtb	\
+ 						baikal_module.dtb
+ 
+ obj-y				+= $(patsubst %.dtb, %.dtb.o, $(dtb-y))
+ 
+ # Force kbuild to make empty built-in.o if necessary
+ obj-				+= dummy.o
+ 
+ always				:= $(dtb-y)
+ clean-files			:= *.dtb *.dtb.S
diff -rcNP linux-4.4.24/arch/mips/boot/dts/Makefile linux-4.4.24-baikal/arch/mips/boot/dts/Makefile
*** linux-4.4.24/arch/mips/boot/dts/Makefile	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/arch/mips/boot/dts/Makefile	2016-11-11 14:49:51.000000000 +0300
***************
*** 1,3 ****
--- 1,4 ----
+ dts-dirs	+= baikal
  dts-dirs	+= brcm
  dts-dirs	+= cavium-octeon
  dts-dirs	+= ingenic
diff -rcNP linux-4.4.24/arch/mips/configs/baikal_bfk2_defconfig linux-4.4.24-baikal/arch/mips/configs/baikal_bfk2_defconfig
*** linux-4.4.24/arch/mips/configs/baikal_bfk2_defconfig	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/arch/mips/configs/baikal_bfk2_defconfig	2016-11-11 14:49:51.000000000 +0300
***************
*** 0 ****
--- 1,298 ----
+ CONFIG_MIPS_BAIKAL=y
+ CONFIG_MACH_BAIKAL_BFK2=y
+ CONFIG_DTB_BAIKAL_BFK2=y
+ CONFIG_BAIKAL_ERRATA=y
+ CONFIG_BAIKAL_ERRATA_XGMAC=y
+ # CONFIG_BAIKAL_ERRATA_GMAC is not set
+ CONFIG_CPU_MIPS32_3_5_FEATURES=y
+ # CONFIG_CPU_MIPS32_3_5_EVA is not set
+ CONFIG_CPU_MIPS32_R5_FEATURES=y
+ CONFIG_CPU_MIPS32_R5_XPA=y
+ CONFIG_PAGE_SIZE_16KB=y
+ CONFIG_MIPS_CPS=y
+ CONFIG_CPU_HAS_MSA=y
+ CONFIG_NR_CPUS=2
+ CONFIG_HZ_100=y
+ CONFIG_KEXEC=y
+ CONFIG_MIPS_O32_FP64_SUPPORT=y
+ CONFIG_LOCALVERSION="-bfk2"
+ CONFIG_DEFAULT_HOSTNAME="baikal"
+ CONFIG_SYSVIPC=y
+ CONFIG_POSIX_MQUEUE=y
+ CONFIG_FHANDLE=y
+ CONFIG_AUDIT=y
+ CONFIG_IRQ_DOMAIN_DEBUG=y
+ CONFIG_NO_HZ_IDLE=y
+ CONFIG_HIGH_RES_TIMERS=y
+ CONFIG_IKCONFIG=y
+ CONFIG_IKCONFIG_PROC=y
+ CONFIG_LOG_BUF_SHIFT=15
+ CONFIG_CGROUPS=y
+ CONFIG_CGROUP_PERF=y
+ CONFIG_NAMESPACES=y
+ CONFIG_RELAY=y
+ CONFIG_BLK_DEV_INITRD=y
+ CONFIG_EXPERT=y
+ CONFIG_DEBUG_PERF_USE_VMALLOC=y
+ CONFIG_SLAB=y
+ CONFIG_MODULES=y
+ CONFIG_MODULE_UNLOAD=y
+ CONFIG_MODVERSIONS=y
+ CONFIG_MODULE_SRCVERSION_ALL=y
+ CONFIG_BLK_DEV_BSGLIB=y
+ CONFIG_PCI=y
+ CONFIG_PCI_MSI=y
+ CONFIG_PCI_DEBUG=y
+ CONFIG_PCI_REALLOC_ENABLE_AUTO=y
+ CONFIG_PCI_STUB=y
+ CONFIG_PCI_IOV=y
+ CONFIG_PCI_PRI=y
+ CONFIG_PCI_PASID=y
+ CONFIG_PCIEPORTBUS=y
+ CONFIG_PCIE_ECRC=y
+ CONFIG_PCIEAER_INJECT=y
+ CONFIG_NET=y
+ CONFIG_PACKET=y
+ CONFIG_PACKET_DIAG=y
+ CONFIG_UNIX=y
+ CONFIG_UNIX_DIAG=y
+ CONFIG_XFRM_USER=y
+ CONFIG_NET_KEY=y
+ CONFIG_INET=y
+ CONFIG_IP_MULTICAST=y
+ CONFIG_IP_PNP=y
+ CONFIG_INET_AH=y
+ CONFIG_INET_ESP=y
+ CONFIG_INET_IPCOMP=y
+ CONFIG_INET_UDP_DIAG=y
+ CONFIG_INET6_AH=y
+ CONFIG_INET6_ESP=y
+ CONFIG_INET6_IPCOMP=y
+ CONFIG_NETFILTER=y
+ CONFIG_NF_CONNTRACK=y
+ CONFIG_NF_TABLES=y
+ CONFIG_NF_TABLES_INET=y
+ CONFIG_NF_TABLES_NETDEV=y
+ CONFIG_NFT_EXTHDR=y
+ CONFIG_NFT_META=y
+ CONFIG_NFT_RBTREE=y
+ CONFIG_NFT_HASH=y
+ CONFIG_NFT_COUNTER=y
+ CONFIG_NFT_LOG=y
+ CONFIG_NFT_LIMIT=y
+ CONFIG_NFT_MASQ=y
+ CONFIG_NFT_REDIR=y
+ CONFIG_NFT_NAT=y
+ CONFIG_NFT_REJECT=y
+ CONFIG_NETFILTER_XT_TARGET_AUDIT=y
+ CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
+ CONFIG_NETFILTER_XT_TARGET_MARK=y
+ CONFIG_NETFILTER_XT_TARGET_NFLOG=y
+ CONFIG_NETFILTER_XT_TARGET_NFQUEUE=y
+ CONFIG_NETFILTER_XT_MATCH_ADDRTYPE=y
+ CONFIG_NETFILTER_XT_MATCH_CGROUP=y
+ CONFIG_NETFILTER_XT_MATCH_CPU=y
+ CONFIG_NETFILTER_XT_MATCH_IPRANGE=y
+ CONFIG_NETFILTER_XT_MATCH_LENGTH=y
+ CONFIG_NETFILTER_XT_MATCH_LIMIT=y
+ CONFIG_NETFILTER_XT_MATCH_MAC=y
+ CONFIG_NETFILTER_XT_MATCH_MULTIPORT=y
+ CONFIG_NETFILTER_XT_MATCH_OWNER=y
+ CONFIG_NETFILTER_XT_MATCH_POLICY=y
+ CONFIG_NETFILTER_XT_MATCH_PKTTYPE=y
+ CONFIG_NETFILTER_XT_MATCH_RECENT=y
+ CONFIG_NETFILTER_XT_MATCH_SOCKET=y
+ CONFIG_NETFILTER_XT_MATCH_TCPMSS=y
+ CONFIG_NF_CONNTRACK_IPV4=y
+ CONFIG_NFT_CHAIN_ROUTE_IPV4=y
+ CONFIG_NFT_DUP_IPV4=y
+ CONFIG_NF_TABLES_ARP=y
+ CONFIG_NFT_CHAIN_NAT_IPV4=y
+ CONFIG_NFT_MASQ_IPV4=y
+ CONFIG_NFT_REDIR_IPV4=y
+ CONFIG_IP_NF_IPTABLES=y
+ CONFIG_IP_NF_MATCH_AH=y
+ CONFIG_IP_NF_MATCH_ECN=y
+ CONFIG_IP_NF_MATCH_TTL=y
+ CONFIG_IP_NF_FILTER=y
+ CONFIG_IP_NF_TARGET_REJECT=y
+ CONFIG_IP_NF_TARGET_SYNPROXY=y
+ CONFIG_IP_NF_NAT=y
+ CONFIG_IP_NF_TARGET_MASQUERADE=y
+ CONFIG_IP_NF_TARGET_NETMAP=y
+ CONFIG_IP_NF_TARGET_REDIRECT=y
+ CONFIG_IP_NF_MANGLE=y
+ CONFIG_IP_NF_RAW=y
+ CONFIG_IP_NF_ARPTABLES=y
+ CONFIG_IP_NF_ARPFILTER=y
+ CONFIG_IP_NF_ARP_MANGLE=y
+ CONFIG_NFT_CHAIN_ROUTE_IPV6=y
+ CONFIG_NFT_DUP_IPV6=y
+ CONFIG_IP6_NF_IPTABLES=y
+ CONFIG_IP6_NF_MATCH_AH=y
+ CONFIG_IP6_NF_MATCH_EUI64=y
+ CONFIG_IP6_NF_MATCH_FRAG=y
+ CONFIG_IP6_NF_MATCH_OPTS=y
+ CONFIG_IP6_NF_MATCH_HL=y
+ CONFIG_IP6_NF_MATCH_IPV6HEADER=y
+ CONFIG_IP6_NF_MATCH_MH=y
+ CONFIG_IP6_NF_MATCH_RT=y
+ CONFIG_IP6_NF_FILTER=y
+ CONFIG_IP6_NF_TARGET_REJECT=y
+ CONFIG_IP6_NF_RAW=y
+ CONFIG_DNS_RESOLVER=y
+ CONFIG_NETLINK_DIAG=y
+ CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+ CONFIG_DEVTMPFS=y
+ CONFIG_DEVTMPFS_MOUNT=y
+ CONFIG_DEBUG_DRIVER=y
+ CONFIG_DEBUG_DEVRES=y
+ CONFIG_MIPS_CDMM=y
+ CONFIG_MTD=y
+ CONFIG_MTD_BLOCK=y
+ CONFIG_MTD_ROM=y
+ CONFIG_MTD_PHYSMAP=y
+ CONFIG_MTD_PHYSMAP_OF=y
+ CONFIG_MTD_PLATRAM=y
+ CONFIG_MTD_M25P80=y
+ CONFIG_MTD_SPI_NOR=y
+ CONFIG_BLK_DEV_LOOP=y
+ CONFIG_BLK_DEV_LOOP_MIN_COUNT=4
+ CONFIG_BLK_DEV_NBD=y
+ CONFIG_BLK_DEV_RAM=y
+ CONFIG_BLK_DEV_RAM_COUNT=4
+ CONFIG_BLK_DEV_RAM_SIZE=16384
+ CONFIG_SRAM=y
+ CONFIG_EEPROM_AT24=y
+ CONFIG_EEPROM_AT25=y
+ CONFIG_RAID_ATTRS=y
+ CONFIG_BLK_DEV_SD=y
+ CONFIG_CHR_DEV_SG=y
+ CONFIG_SCSI_CONSTANTS=y
+ CONFIG_SCSI_LOGGING=y
+ CONFIG_SCSI_SCAN_ASYNC=y
+ CONFIG_ATA=y
+ CONFIG_SATA_AHCI_PLATFORM=y
+ CONFIG_NETDEVICES=y
+ CONFIG_BAIKAL_XGBE=y
+ CONFIG_E1000=y
+ CONFIG_E1000E=y
+ CONFIG_IXGB=y
+ CONFIG_IXGBE=y
+ CONFIG_IXGBEVF=y
+ CONFIG_BAIKAL_XGBE_PHY=y
+ CONFIG_BAIKAL_MDIO=y
+ CONFIG_88X2222_PHY=y
+ CONFIG_MICREL_PHY=y
+ CONFIG_MDIO_BITBANG=y
+ CONFIG_MDIO_GPIO=y
+ CONFIG_LEGACY_PTY_COUNT=16
+ CONFIG_SERIAL_8250_NR_UARTS=2
+ CONFIG_SERIAL_8250_RUNTIME_UARTS=2
+ CONFIG_I2C_CHARDEV=y
+ CONFIG_SPI=y
+ CONFIG_DEBUG_GPIO=y
+ CONFIG_GPIO_GENERIC_PLATFORM=y
+ CONFIG_GPIO_PCF857X=y
+ CONFIG_POWER_SUPPLY=y
+ CONFIG_SENSORS_JC42=y
+ CONFIG_THERMAL=y
+ CONFIG_WATCHDOG=y
+ CONFIG_WATCHDOG_CORE=y
+ CONFIG_DRM=y
+ CONFIG_DRM_I2C_CH7006=m
+ CONFIG_DRM_I2C_SIL164=m
+ CONFIG_FB_NVIDIA=y
+ CONFIG_FB_NVIDIA_I2C=y
+ CONFIG_FB_UDL=y
+ CONFIG_FB_SIMPLE=y
+ CONFIG_FRAMEBUFFER_CONSOLE=y
+ CONFIG_FRAMEBUFFER_CONSOLE_ROTATION=y
+ CONFIG_SOUND=y
+ CONFIG_SND=y
+ CONFIG_SND_SOC=y
+ CONFIG_SND_SOC_TLV320AIC31XX=y
+ CONFIG_USB=y
+ CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+ CONFIG_USB_DYNAMIC_MINORS=y
+ CONFIG_USB_ULPI_BUS=y
+ CONFIG_USB_MON=y
+ CONFIG_USB_XHCI_HCD=y
+ CONFIG_USB_EHCI_HCD=m
+ CONFIG_USB_EHCI_ROOT_HUB_TT=y
+ CONFIG_USB_EHCI_HCD_PLATFORM=m
+ CONFIG_USB_OHCI_HCD=y
+ CONFIG_USB_OHCI_HCD_PLATFORM=y
+ CONFIG_USB_HCD_TEST_MODE=y
+ CONFIG_USB_STORAGE=y
+ CONFIG_USB_UAS=y
+ CONFIG_USB_DWC3_ULPI=y
+ CONFIG_MMC=y
+ CONFIG_MMC_USHC=y
+ CONFIG_RTC_CLASS=y
+ CONFIG_RTC_DRV_ABEOZ9S3=y
+ CONFIG_DMADEVICES=y
+ CONFIG_DMADEVICES_DEBUG=y
+ CONFIG_DMADEVICES_VDEBUG=y
+ CONFIG_DW_DMAC=y
+ CONFIG_STAGING=y
+ CONFIG_FB_SM750=y
+ CONFIG_MEMORY=y
+ CONFIG_EXT4_FS=y
+ CONFIG_AUTOFS4_FS=y
+ CONFIG_OVERLAY_FS=y
+ CONFIG_MSDOS_FS=y
+ CONFIG_VFAT_FS=y
+ CONFIG_PROC_KCORE=y
+ CONFIG_TMPFS=y
+ CONFIG_NFS_FS=y
+ CONFIG_NFS_V4=y
+ CONFIG_NFS_V4_1=y
+ CONFIG_NFS_V4_2=y
+ CONFIG_ROOT_NFS=y
+ CONFIG_NFS_USE_LEGACY_DNS=y
+ CONFIG_NLS_CODEPAGE_437=y
+ CONFIG_NLS_CODEPAGE_866=y
+ CONFIG_NLS_CODEPAGE_1251=y
+ CONFIG_NLS_ASCII=y
+ CONFIG_NLS_ISO8859_1=y
+ CONFIG_NLS_ISO8859_5=y
+ CONFIG_NLS_KOI8_R=y
+ CONFIG_NLS_UTF8=y
+ CONFIG_DYNAMIC_DEBUG=y
+ CONFIG_DEBUG_INFO=y
+ CONFIG_DEBUG_FS=y
+ CONFIG_DEBUG_SECTION_MISMATCH=y
+ CONFIG_DEBUG_MEMORY_INIT=y
+ CONFIG_LOCKUP_DETECTOR=y
+ CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC=y
+ CONFIG_SPARSE_RCU_POINTER=y
+ CONFIG_DMA_API_DEBUG=y
+ CONFIG_DEBUG_ZBOOT=y
+ CONFIG_CRYPTO_CRYPTD=m
+ CONFIG_CRYPTO_TEST=m
+ CONFIG_CRYPTO_CCM=m
+ CONFIG_CRYPTO_ECB=m
+ CONFIG_CRYPTO_LRW=m
+ CONFIG_CRYPTO_PCBC=m
+ CONFIG_CRYPTO_XCBC=m
+ CONFIG_CRYPTO_MD4=m
+ CONFIG_CRYPTO_MICHAEL_MIC=m
+ CONFIG_CRYPTO_SHA512=m
+ CONFIG_CRYPTO_TGR192=m
+ CONFIG_CRYPTO_WP512=m
+ CONFIG_CRYPTO_ANUBIS=m
+ CONFIG_CRYPTO_ARC4=m
+ CONFIG_CRYPTO_BLOWFISH=m
+ CONFIG_CRYPTO_CAMELLIA=m
+ CONFIG_CRYPTO_CAST5=m
+ CONFIG_CRYPTO_CAST6=m
+ CONFIG_CRYPTO_FCRYPT=m
+ CONFIG_CRYPTO_KHAZAD=m
+ CONFIG_CRYPTO_SERPENT=m
+ CONFIG_CRYPTO_TEA=m
+ CONFIG_CRYPTO_TWOFISH=m
+ CONFIG_CRYPTO_ANSI_CPRNG=m
+ CONFIG_CRC_ITU_T=y
+ CONFIG_CRC7=y
+ CONFIG_LIBCRC32C=m
diff -rcNP linux-4.4.24/arch/mips/configs/baikal_bfk_defconfig linux-4.4.24-baikal/arch/mips/configs/baikal_bfk_defconfig
*** linux-4.4.24/arch/mips/configs/baikal_bfk_defconfig	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/arch/mips/configs/baikal_bfk_defconfig	2016-11-11 14:49:51.000000000 +0300
***************
*** 0 ****
--- 1,297 ----
+ CONFIG_MIPS_BAIKAL=y
+ CONFIG_DTB_BAIKAL_BFK=y
+ CONFIG_BAIKAL_ERRATA=y
+ CONFIG_BAIKAL_ERRATA_XGMAC=y
+ CONFIG_BAIKAL_ERRATA_GMAC=y
+ CONFIG_CPU_MIPS32_3_5_FEATURES=y
+ # CONFIG_CPU_MIPS32_3_5_EVA is not set
+ CONFIG_CPU_MIPS32_R5_FEATURES=y
+ CONFIG_CPU_MIPS32_R5_XPA=y
+ CONFIG_PAGE_SIZE_16KB=y
+ CONFIG_MIPS_CPS=y
+ CONFIG_CPU_HAS_MSA=y
+ CONFIG_NR_CPUS=2
+ CONFIG_HZ_100=y
+ CONFIG_KEXEC=y
+ CONFIG_MIPS_O32_FP64_SUPPORT=y
+ CONFIG_LOCALVERSION="-bfk"
+ CONFIG_DEFAULT_HOSTNAME="baikal"
+ CONFIG_SYSVIPC=y
+ CONFIG_POSIX_MQUEUE=y
+ CONFIG_FHANDLE=y
+ CONFIG_AUDIT=y
+ CONFIG_IRQ_DOMAIN_DEBUG=y
+ CONFIG_NO_HZ_IDLE=y
+ CONFIG_HIGH_RES_TIMERS=y
+ CONFIG_IKCONFIG=y
+ CONFIG_IKCONFIG_PROC=y
+ CONFIG_LOG_BUF_SHIFT=15
+ CONFIG_CGROUPS=y
+ CONFIG_CGROUP_PERF=y
+ CONFIG_NAMESPACES=y
+ CONFIG_RELAY=y
+ CONFIG_BLK_DEV_INITRD=y
+ CONFIG_EXPERT=y
+ CONFIG_DEBUG_PERF_USE_VMALLOC=y
+ CONFIG_SLAB=y
+ CONFIG_MODULES=y
+ CONFIG_MODULE_UNLOAD=y
+ CONFIG_MODVERSIONS=y
+ CONFIG_MODULE_SRCVERSION_ALL=y
+ CONFIG_BLK_DEV_BSGLIB=y
+ CONFIG_PCI=y
+ CONFIG_PCI_MSI=y
+ CONFIG_PCI_DEBUG=y
+ CONFIG_PCI_REALLOC_ENABLE_AUTO=y
+ CONFIG_PCI_STUB=y
+ CONFIG_PCI_IOV=y
+ CONFIG_PCI_PRI=y
+ CONFIG_PCI_PASID=y
+ CONFIG_PCIEPORTBUS=y
+ CONFIG_PCIE_ECRC=y
+ CONFIG_PCIEAER_INJECT=y
+ CONFIG_NET=y
+ CONFIG_PACKET=y
+ CONFIG_PACKET_DIAG=y
+ CONFIG_UNIX=y
+ CONFIG_UNIX_DIAG=y
+ CONFIG_XFRM_USER=y
+ CONFIG_NET_KEY=y
+ CONFIG_INET=y
+ CONFIG_IP_MULTICAST=y
+ CONFIG_IP_PNP=y
+ CONFIG_INET_AH=y
+ CONFIG_INET_ESP=y
+ CONFIG_INET_IPCOMP=y
+ CONFIG_INET_UDP_DIAG=y
+ CONFIG_INET6_AH=y
+ CONFIG_INET6_ESP=y
+ CONFIG_INET6_IPCOMP=y
+ CONFIG_NETFILTER=y
+ CONFIG_NF_CONNTRACK=y
+ CONFIG_NF_TABLES=y
+ CONFIG_NF_TABLES_INET=y
+ CONFIG_NF_TABLES_NETDEV=y
+ CONFIG_NFT_EXTHDR=y
+ CONFIG_NFT_META=y
+ CONFIG_NFT_RBTREE=y
+ CONFIG_NFT_HASH=y
+ CONFIG_NFT_COUNTER=y
+ CONFIG_NFT_LOG=y
+ CONFIG_NFT_LIMIT=y
+ CONFIG_NFT_MASQ=y
+ CONFIG_NFT_REDIR=y
+ CONFIG_NFT_NAT=y
+ CONFIG_NFT_REJECT=y
+ CONFIG_NETFILTER_XT_TARGET_AUDIT=y
+ CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
+ CONFIG_NETFILTER_XT_TARGET_MARK=y
+ CONFIG_NETFILTER_XT_TARGET_NFLOG=y
+ CONFIG_NETFILTER_XT_TARGET_NFQUEUE=y
+ CONFIG_NETFILTER_XT_MATCH_ADDRTYPE=y
+ CONFIG_NETFILTER_XT_MATCH_CGROUP=y
+ CONFIG_NETFILTER_XT_MATCH_CPU=y
+ CONFIG_NETFILTER_XT_MATCH_IPRANGE=y
+ CONFIG_NETFILTER_XT_MATCH_LENGTH=y
+ CONFIG_NETFILTER_XT_MATCH_LIMIT=y
+ CONFIG_NETFILTER_XT_MATCH_MAC=y
+ CONFIG_NETFILTER_XT_MATCH_MULTIPORT=y
+ CONFIG_NETFILTER_XT_MATCH_OWNER=y
+ CONFIG_NETFILTER_XT_MATCH_POLICY=y
+ CONFIG_NETFILTER_XT_MATCH_PKTTYPE=y
+ CONFIG_NETFILTER_XT_MATCH_RECENT=y
+ CONFIG_NETFILTER_XT_MATCH_SOCKET=y
+ CONFIG_NETFILTER_XT_MATCH_TCPMSS=y
+ CONFIG_NF_CONNTRACK_IPV4=y
+ CONFIG_NFT_CHAIN_ROUTE_IPV4=y
+ CONFIG_NFT_DUP_IPV4=y
+ CONFIG_NF_TABLES_ARP=y
+ CONFIG_NFT_CHAIN_NAT_IPV4=y
+ CONFIG_NFT_MASQ_IPV4=y
+ CONFIG_NFT_REDIR_IPV4=y
+ CONFIG_IP_NF_IPTABLES=y
+ CONFIG_IP_NF_MATCH_AH=y
+ CONFIG_IP_NF_MATCH_ECN=y
+ CONFIG_IP_NF_MATCH_TTL=y
+ CONFIG_IP_NF_FILTER=y
+ CONFIG_IP_NF_TARGET_REJECT=y
+ CONFIG_IP_NF_TARGET_SYNPROXY=y
+ CONFIG_IP_NF_NAT=y
+ CONFIG_IP_NF_TARGET_MASQUERADE=y
+ CONFIG_IP_NF_TARGET_NETMAP=y
+ CONFIG_IP_NF_TARGET_REDIRECT=y
+ CONFIG_IP_NF_MANGLE=y
+ CONFIG_IP_NF_RAW=y
+ CONFIG_IP_NF_ARPTABLES=y
+ CONFIG_IP_NF_ARPFILTER=y
+ CONFIG_IP_NF_ARP_MANGLE=y
+ CONFIG_NFT_CHAIN_ROUTE_IPV6=y
+ CONFIG_NFT_DUP_IPV6=y
+ CONFIG_IP6_NF_IPTABLES=y
+ CONFIG_IP6_NF_MATCH_AH=y
+ CONFIG_IP6_NF_MATCH_EUI64=y
+ CONFIG_IP6_NF_MATCH_FRAG=y
+ CONFIG_IP6_NF_MATCH_OPTS=y
+ CONFIG_IP6_NF_MATCH_HL=y
+ CONFIG_IP6_NF_MATCH_IPV6HEADER=y
+ CONFIG_IP6_NF_MATCH_MH=y
+ CONFIG_IP6_NF_MATCH_RT=y
+ CONFIG_IP6_NF_FILTER=y
+ CONFIG_IP6_NF_TARGET_REJECT=y
+ CONFIG_IP6_NF_RAW=y
+ CONFIG_DNS_RESOLVER=y
+ CONFIG_NETLINK_DIAG=y
+ CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+ CONFIG_DEVTMPFS=y
+ CONFIG_DEVTMPFS_MOUNT=y
+ CONFIG_DEBUG_DRIVER=y
+ CONFIG_DEBUG_DEVRES=y
+ CONFIG_MIPS_CDMM=y
+ CONFIG_MTD=y
+ CONFIG_MTD_BLOCK=y
+ CONFIG_MTD_ROM=y
+ CONFIG_MTD_PHYSMAP=y
+ CONFIG_MTD_PHYSMAP_OF=y
+ CONFIG_MTD_PLATRAM=y
+ CONFIG_MTD_M25P80=y
+ CONFIG_MTD_SPI_NOR=y
+ CONFIG_BLK_DEV_LOOP=y
+ CONFIG_BLK_DEV_LOOP_MIN_COUNT=4
+ CONFIG_BLK_DEV_NBD=y
+ CONFIG_BLK_DEV_RAM=y
+ CONFIG_BLK_DEV_RAM_COUNT=4
+ CONFIG_BLK_DEV_RAM_SIZE=16384
+ CONFIG_SRAM=y
+ CONFIG_EEPROM_AT24=y
+ CONFIG_EEPROM_AT25=y
+ CONFIG_RAID_ATTRS=y
+ CONFIG_BLK_DEV_SD=y
+ CONFIG_CHR_DEV_SG=y
+ CONFIG_SCSI_CONSTANTS=y
+ CONFIG_SCSI_LOGGING=y
+ CONFIG_SCSI_SCAN_ASYNC=y
+ CONFIG_ATA=y
+ CONFIG_SATA_AHCI_PLATFORM=y
+ CONFIG_NETDEVICES=y
+ CONFIG_BAIKAL_XGBE=y
+ CONFIG_E1000=y
+ CONFIG_E1000E=y
+ CONFIG_IXGB=y
+ CONFIG_IXGBE=y
+ CONFIG_IXGBEVF=y
+ CONFIG_BAIKAL_XGBE_PHY=y
+ CONFIG_BAIKAL_MDIO=y
+ CONFIG_88X2222_PHY=y
+ CONFIG_MICREL_PHY=y
+ CONFIG_MDIO_BITBANG=y
+ CONFIG_MDIO_GPIO=y
+ CONFIG_LEGACY_PTY_COUNT=16
+ CONFIG_SERIAL_8250_NR_UARTS=2
+ CONFIG_SERIAL_8250_RUNTIME_UARTS=2
+ CONFIG_I2C_CHARDEV=y
+ CONFIG_SPI=y
+ CONFIG_DEBUG_GPIO=y
+ CONFIG_GPIO_GENERIC_PLATFORM=y
+ CONFIG_GPIO_PCF857X=y
+ CONFIG_POWER_SUPPLY=y
+ CONFIG_SENSORS_JC42=y
+ CONFIG_THERMAL=y
+ CONFIG_WATCHDOG=y
+ CONFIG_WATCHDOG_CORE=y
+ CONFIG_DRM=y
+ CONFIG_DRM_I2C_CH7006=m
+ CONFIG_DRM_I2C_SIL164=m
+ CONFIG_FB_NVIDIA=y
+ CONFIG_FB_NVIDIA_I2C=y
+ CONFIG_FB_UDL=y
+ CONFIG_FB_SIMPLE=y
+ CONFIG_FRAMEBUFFER_CONSOLE=y
+ CONFIG_FRAMEBUFFER_CONSOLE_ROTATION=y
+ CONFIG_SOUND=y
+ CONFIG_SND=y
+ CONFIG_SND_SOC=y
+ CONFIG_SND_SOC_TLV320AIC31XX=y
+ CONFIG_USB=y
+ CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+ CONFIG_USB_DYNAMIC_MINORS=y
+ CONFIG_USB_ULPI_BUS=y
+ CONFIG_USB_MON=y
+ CONFIG_USB_XHCI_HCD=y
+ CONFIG_USB_EHCI_HCD=m
+ CONFIG_USB_EHCI_ROOT_HUB_TT=y
+ CONFIG_USB_EHCI_HCD_PLATFORM=m
+ CONFIG_USB_OHCI_HCD=y
+ CONFIG_USB_OHCI_HCD_PLATFORM=y
+ CONFIG_USB_HCD_TEST_MODE=y
+ CONFIG_USB_STORAGE=y
+ CONFIG_USB_UAS=y
+ CONFIG_USB_DWC3_ULPI=y
+ CONFIG_MMC=y
+ CONFIG_MMC_USHC=y
+ CONFIG_RTC_CLASS=y
+ CONFIG_RTC_DRV_ABEOZ9S3=y
+ CONFIG_DMADEVICES=y
+ CONFIG_DMADEVICES_DEBUG=y
+ CONFIG_DMADEVICES_VDEBUG=y
+ CONFIG_DW_DMAC=y
+ CONFIG_STAGING=y
+ CONFIG_FB_SM750=y
+ CONFIG_MEMORY=y
+ CONFIG_EXT4_FS=y
+ CONFIG_AUTOFS4_FS=y
+ CONFIG_OVERLAY_FS=y
+ CONFIG_MSDOS_FS=y
+ CONFIG_VFAT_FS=y
+ CONFIG_PROC_KCORE=y
+ CONFIG_TMPFS=y
+ CONFIG_NFS_FS=y
+ CONFIG_NFS_V4=y
+ CONFIG_NFS_V4_1=y
+ CONFIG_NFS_V4_2=y
+ CONFIG_ROOT_NFS=y
+ CONFIG_NFS_USE_LEGACY_DNS=y
+ CONFIG_NLS_CODEPAGE_437=y
+ CONFIG_NLS_CODEPAGE_866=y
+ CONFIG_NLS_CODEPAGE_1251=y
+ CONFIG_NLS_ASCII=y
+ CONFIG_NLS_ISO8859_1=y
+ CONFIG_NLS_ISO8859_5=y
+ CONFIG_NLS_KOI8_R=y
+ CONFIG_NLS_UTF8=y
+ CONFIG_DYNAMIC_DEBUG=y
+ CONFIG_DEBUG_INFO=y
+ CONFIG_DEBUG_FS=y
+ CONFIG_DEBUG_SECTION_MISMATCH=y
+ CONFIG_DEBUG_MEMORY_INIT=y
+ CONFIG_LOCKUP_DETECTOR=y
+ CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC=y
+ CONFIG_SPARSE_RCU_POINTER=y
+ CONFIG_DMA_API_DEBUG=y
+ CONFIG_DEBUG_ZBOOT=y
+ CONFIG_CRYPTO_CRYPTD=m
+ CONFIG_CRYPTO_TEST=m
+ CONFIG_CRYPTO_CCM=m
+ CONFIG_CRYPTO_ECB=m
+ CONFIG_CRYPTO_LRW=m
+ CONFIG_CRYPTO_PCBC=m
+ CONFIG_CRYPTO_XCBC=m
+ CONFIG_CRYPTO_MD4=m
+ CONFIG_CRYPTO_MICHAEL_MIC=m
+ CONFIG_CRYPTO_SHA512=m
+ CONFIG_CRYPTO_TGR192=m
+ CONFIG_CRYPTO_WP512=m
+ CONFIG_CRYPTO_ANUBIS=m
+ CONFIG_CRYPTO_ARC4=m
+ CONFIG_CRYPTO_BLOWFISH=m
+ CONFIG_CRYPTO_CAMELLIA=m
+ CONFIG_CRYPTO_CAST5=m
+ CONFIG_CRYPTO_CAST6=m
+ CONFIG_CRYPTO_FCRYPT=m
+ CONFIG_CRYPTO_KHAZAD=m
+ CONFIG_CRYPTO_SERPENT=m
+ CONFIG_CRYPTO_TEA=m
+ CONFIG_CRYPTO_TWOFISH=m
+ CONFIG_CRYPTO_ANSI_CPRNG=m
+ CONFIG_CRC_ITU_T=y
+ CONFIG_CRC7=y
+ CONFIG_LIBCRC32C=m
diff -rcNP linux-4.4.24/arch/mips/configs/baikal_fpga_defconfig linux-4.4.24-baikal/arch/mips/configs/baikal_fpga_defconfig
*** linux-4.4.24/arch/mips/configs/baikal_fpga_defconfig	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/arch/mips/configs/baikal_fpga_defconfig	2016-11-11 14:49:51.000000000 +0300
***************
*** 0 ****
--- 1,439 ----
+ # 
+ # Baikal-T FPGA default kernel configuration
+ #
+ # Copyright (C) 2014-2016 Baikal Electronics JSC
+ # 
+ # Author:
+ #   Dmitry Dunaev <dmitry.dunaev@baikalelectronics.ru>
+ #
+ # This program is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU General Public License
+ # as published by the Free Software Foundation; either version 2
+ # of the License, or (at your option) any later version.
+ #
+ # This program is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ # GNU General Public License for more details.
+ #
+ # You should have received a copy of the GNU General Public License
+ # along with this program; if not, write to the Free Software
+ # Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ #
+ 
+ CONFIG_MIPS=y
+ CONFIG_MIPS_BAIKAL=y
+ CONFIG_ARCH_BAIKAL=y
+ CONFIG_MACH_BAIKAL_FPGA=y
+ CONFIG_DTB_BAIKAL=y
+ CONFIG_RWSEM_GENERIC_SPINLOCK=y
+ CONFIG_GENERIC_HWEIGHT=y
+ CONFIG_GENERIC_CALIBRATE_DELAY=y
+ CONFIG_SCHED_OMIT_FRAME_POINTER=y
+ CONFIG_BOOT_RAW=y
+ CONFIG_MIPS_CLOCK_VSYSCALL=y
+ CONFIG_ARCH_SUPPORTS_UPROBES=y
+ CONFIG_DMA_NONCOHERENT=y
+ CONFIG_NEED_DMA_MAP_STATE=y
+ CONFIG_SYS_HAS_EARLY_PRINTK=y
+ CONFIG_HOTPLUG_CPU=y
+ CONFIG_SYS_SUPPORTS_HOTPLUG_CPU=y
+ CONFIG_MIPS_MACHINE=y
+ CONFIG_GENERIC_ISA_DMA=y
+ CONFIG_ISA_DMA_API=y
+ CONFIG_CPU_LITTLE_ENDIAN=y
+ CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
+ CONFIG_MIPS_SPRAM=y
+ CONFIG_SWAP_IO_SPACE=y
+ CONFIG_BOOT_ELF32=y
+ CONFIG_MIPS_L1_CACHE_SHIFT=5
+ CONFIG_CPU_MIPS32_R2=y
+ CONFIG_CPU_MIPS32_3_5_FEATURES=y
+ CONFIG_SYS_SUPPORTS_ZBOOT=y
+ CONFIG_SYS_SUPPORTS_ZBOOT_UART16550=y
+ CONFIG_SYS_HAS_CPU_MIPS32_R2=y
+ CONFIG_SYS_HAS_CPU_MIPS32_R3_5=y
+ CONFIG_WEAK_ORDERING=y
+ CONFIG_CPU_MIPS32=y
+ CONFIG_CPU_MIPSR2=y
+ CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+ CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+ CONFIG_CPU_SUPPORTS_CPUFREQ=y
+ CONFIG_CPU_SUPPORTS_UNCACHED_ACCELERATED=y
+ CONFIG_HARDWARE_WATCHPOINTS=y
+ CONFIG_32BIT=y
+ CONFIG_PAGE_SIZE_16KB=y
+ CONFIG_FORCE_MAX_ZONEORDER=11
+ CONFIG_BOARD_SCACHE=y
+ CONFIG_MIPS_CPU_SCACHE=y
+ CONFIG_CPU_HAS_PREFETCH=y
+ CONFIG_CPU_GENERIC_DUMP_TLB=y
+ CONFIG_CPU_R4K_FPU=y
+ CONFIG_CPU_R4K_CACHE_TLB=y
+ CONFIG_MIPS_CPS=y
+ CONFIG_MIPS_CPS_PM=y
+ CONFIG_MIPS_GIC_IPI=y
+ CONFIG_MIPS_GIC_IPI_LOW=y
+ CONFIG_MIPS_CM=y
+ CONFIG_MIPS_CPC=y
+ CONFIG_CPU_NEEDS_NO_SMARTMIPS_OR_MICROMIPS=y
+ CONFIG_CPU_MIPSR2_IRQ_VI=y
+ CONFIG_CPU_MIPSR2_IRQ_EI=y
+ CONFIG_CPU_HAS_SYNC=y
+ CONFIG_CPU_SUPPORTS_HIGHMEM=y
+ CONFIG_SYS_SUPPORTS_HIGHMEM=y
+ CONFIG_CPU_SUPPORTS_MSA=y
+ CONFIG_ARCH_FLATMEM_ENABLE=y
+ CONFIG_FLATMEM=y
+ CONFIG_FLAT_NODE_MEM_MAP=y
+ CONFIG_HAVE_MEMBLOCK=y
+ CONFIG_HAVE_MEMBLOCK_NODE_MAP=y
+ CONFIG_ARCH_DISCARD_MEMBLOCK=y
+ CONFIG_SPLIT_PTLOCK_CPUS=4
+ CONFIG_COMPACTION=y
+ CONFIG_MIGRATION=y
+ CONFIG_ZONE_DMA_FLAG=1
+ CONFIG_BOUNCE=y
+ CONFIG_VIRT_TO_BUS=y
+ CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+ CONFIG_SMP=y
+ CONFIG_SYS_SUPPORTS_MIPS_CPS=y
+ CONFIG_SYS_SUPPORTS_SMP=y
+ CONFIG_NR_CPUS=2
+ CONFIG_HZ_100=y
+ CONFIG_SYS_SUPPORTS_ARBIT_HZ=y
+ CONFIG_HZ=100
+ CONFIG_SCHED_HRTICK=y
+ CONFIG_PREEMPT_NONE=y
+ CONFIG_PREEMPT_COUNT=y
+ CONFIG_SECCOMP=y
+ CONFIG_USE_OF=y
+ CONFIG_MIPS_NO_APPENDED_DTB=y
+ CONFIG_MIPS_CMDLINE_FROM_DTB=y
+ CONFIG_LOCKDEP_SUPPORT=y
+ CONFIG_STACKTRACE_SUPPORT=y
+ CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+ CONFIG_PGTABLE_LEVELS=2
+ CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+ CONFIG_IRQ_WORK=y
+ CONFIG_BUILDTIME_EXTABLE_SORT=y
+ CONFIG_INIT_ENV_ARG_LIMIT=32
+ CONFIG_CROSS_COMPILE=""
+ CONFIG_LOCALVERSION="-fpga"
+ CONFIG_LOCALVERSION_AUTO=y
+ CONFIG_HAVE_KERNEL_GZIP=y
+ CONFIG_HAVE_KERNEL_BZIP2=y
+ CONFIG_HAVE_KERNEL_LZMA=y
+ CONFIG_HAVE_KERNEL_XZ=y
+ CONFIG_HAVE_KERNEL_LZO=y
+ CONFIG_HAVE_KERNEL_LZ4=y
+ CONFIG_KERNEL_GZIP=y
+ CONFIG_DEFAULT_HOSTNAME="baikal"
+ CONFIG_SWAP=y
+ CONFIG_CROSS_MEMORY_ATTACH=y
+ CONFIG_FHANDLE=y
+ CONFIG_USELIB=y
+ CONFIG_GENERIC_IRQ_PROBE=y
+ CONFIG_GENERIC_IRQ_SHOW=y
+ CONFIG_IRQ_DOMAIN=y
+ CONFIG_IRQ_FORCED_THREADING=y
+ CONFIG_ARCH_CLOCKSOURCE_DATA=y
+ CONFIG_GENERIC_TIME_VSYSCALL=y
+ CONFIG_GENERIC_CLOCKEVENTS=y
+ CONFIG_GENERIC_CMOS_UPDATE=y
+ CONFIG_TICK_ONESHOT=y
+ CONFIG_NO_HZ_COMMON=y
+ CONFIG_NO_HZ_IDLE=y
+ CONFIG_HIGH_RES_TIMERS=y
+ CONFIG_TICK_CPU_ACCOUNTING=y
+ CONFIG_TREE_RCU=y
+ CONFIG_SRCU=y
+ CONFIG_RCU_STALL_COMMON=y
+ CONFIG_LOG_BUF_SHIFT=17
+ CONFIG_LOG_CPU_MAX_BUF_SHIFT=17
+ CONFIG_GENERIC_SCHED_CLOCK=y
+ CONFIG_NAMESPACES=y
+ CONFIG_UTS_NS=y
+ CONFIG_PID_NS=y
+ CONFIG_BLK_DEV_INITRD=y
+ CONFIG_INITRAMFS_SOURCE="../../img/initramfs.gz"
+ CONFIG_INITRAMFS_ROOT_UID=0
+ CONFIG_INITRAMFS_ROOT_GID=0
+ CONFIG_RD_GZIP=y
+ CONFIG_RD_BZIP2=y
+ CONFIG_RD_LZMA=y
+ CONFIG_RD_XZ=y
+ CONFIG_RD_LZO=y
+ CONFIG_RD_LZ4=y
+ CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+ CONFIG_SYSCTL=y
+ CONFIG_ANON_INODES=y
+ CONFIG_SYSCTL_EXCEPTION_TRACE=y
+ CONFIG_EXPERT=y
+ CONFIG_MULTIUSER=y
+ CONFIG_SGETMASK_SYSCALL=y
+ CONFIG_SYSFS_SYSCALL=y
+ CONFIG_KALLSYMS=y
+ CONFIG_KALLSYMS_ALL=y
+ CONFIG_PRINTK=y
+ CONFIG_BUG=y
+ CONFIG_ELF_CORE=y
+ CONFIG_BASE_FULL=y
+ CONFIG_FUTEX=y
+ CONFIG_EPOLL=y
+ CONFIG_SIGNALFD=y
+ CONFIG_TIMERFD=y
+ CONFIG_EVENTFD=y
+ CONFIG_SHMEM=y
+ CONFIG_AIO=y
+ CONFIG_ADVISE_SYSCALLS=y
+ CONFIG_MEMBARRIER=y
+ CONFIG_EMBEDDED=y
+ CONFIG_HAVE_PERF_EVENTS=y
+ CONFIG_PERF_USE_VMALLOC=y
+ CONFIG_VM_EVENT_COUNTERS=y
+ CONFIG_COMPAT_BRK=y
+ CONFIG_SLAB=y
+ CONFIG_HAVE_OPROFILE=y
+ CONFIG_ARCH_USE_BUILTIN_BSWAP=y
+ CONFIG_HAVE_KPROBES=y
+ CONFIG_HAVE_KRETPROBES=y
+ CONFIG_HAVE_ARCH_TRACEHOOK=y
+ CONFIG_HAVE_DMA_ATTRS=y
+ CONFIG_HAVE_DMA_CONTIGUOUS=y
+ CONFIG_GENERIC_SMP_IDLE_THREAD=y
+ CONFIG_HAVE_CLK=y
+ CONFIG_HAVE_DMA_API_DEBUG=y
+ CONFIG_HAVE_ARCH_JUMP_LABEL=y
+ CONFIG_ARCH_WANT_IPC_PARSE_VERSION=y
+ CONFIG_HAVE_ARCH_SECCOMP_FILTER=y
+ CONFIG_HAVE_CC_STACKPROTECTOR=y
+ CONFIG_CC_STACKPROTECTOR_NONE=y
+ CONFIG_HAVE_CONTEXT_TRACKING=y
+ CONFIG_HAVE_VIRT_CPU_ACCOUNTING_GEN=y
+ CONFIG_HAVE_IRQ_TIME_ACCOUNTING=y
+ CONFIG_HAVE_MOD_ARCH_SPECIFIC=y
+ CONFIG_ARCH_HAS_ELF_RANDOMIZE=y
+ CONFIG_CLONE_BACKWARDS=y
+ CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+ CONFIG_SLABINFO=y
+ CONFIG_RT_MUTEXES=y
+ CONFIG_BASE_SMALL=0
+ CONFIG_BLOCK=y
+ CONFIG_LBDAF=y
+ CONFIG_BLK_DEV_BSG=y
+ CONFIG_MSDOS_PARTITION=y
+ CONFIG_EFI_PARTITION=y
+ CONFIG_IOSCHED_NOOP=y
+ CONFIG_IOSCHED_DEADLINE=y
+ CONFIG_IOSCHED_CFQ=y
+ CONFIG_DEFAULT_CFQ=y
+ CONFIG_DEFAULT_IOSCHED="cfq"
+ CONFIG_UNINLINE_SPIN_UNLOCK=y
+ CONFIG_FREEZER=y
+ CONFIG_MMU=y
+ CONFIG_ZONE_DMA=y
+ CONFIG_BINFMT_ELF=y
+ CONFIG_ARCH_BINFMT_ELF_STATE=y
+ CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS=y
+ CONFIG_BINFMT_SCRIPT=y
+ CONFIG_COREDUMP=y
+ CONFIG_TRAD_SIGNALS=y
+ CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+ CONFIG_ARCH_SUSPEND_POSSIBLE=y
+ CONFIG_SUSPEND=y
+ CONFIG_SUSPEND_FREEZER=y
+ CONFIG_PM_SLEEP=y
+ CONFIG_PM_SLEEP_SMP=y
+ CONFIG_PM=y
+ CONFIG_PM_CLK=y
+ CONFIG_HAVE_BPF_JIT=y
+ CONFIG_UEVENT_HELPER=y
+ CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+ CONFIG_DEVTMPFS=y
+ CONFIG_DEVTMPFS_MOUNT=y
+ CONFIG_STANDALONE=y
+ CONFIG_PREVENT_FIRMWARE_BUILD=y
+ CONFIG_FW_LOADER=y
+ CONFIG_FIRMWARE_IN_KERNEL=y
+ CONFIG_EXTRA_FIRMWARE=""
+ CONFIG_ALLOW_DEV_COREDUMP=y
+ CONFIG_DEBUG_DRIVER=y
+ CONFIG_DEBUG_DEVRES=y
+ CONFIG_SOC_BUS=y
+ CONFIG_DTC=y
+ CONFIG_OF=y
+ CONFIG_OF_FLATTREE=y
+ CONFIG_OF_EARLY_FLATTREE=y
+ CONFIG_OF_ADDRESS=y
+ CONFIG_OF_IRQ=y
+ CONFIG_ARCH_MIGHT_HAVE_PC_PARPORT=y
+ CONFIG_BLK_DEV=y
+ CONFIG_HAVE_IDE=y
+ CONFIG_SCSI_MOD=y
+ CONFIG_INPUT=y
+ CONFIG_INPUT_MOUSEDEV=y
+ CONFIG_INPUT_MOUSEDEV_PSAUX=y
+ CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+ CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+ CONFIG_INPUT_KEYBOARD=y
+ CONFIG_KEYBOARD_ATKBD=y
+ CONFIG_INPUT_MOUSE=y
+ CONFIG_MOUSE_PS2=y
+ CONFIG_MOUSE_PS2_ALPS=y
+ CONFIG_MOUSE_PS2_LOGIPS2PP=y
+ CONFIG_MOUSE_PS2_SYNAPTICS=y
+ CONFIG_MOUSE_PS2_CYPRESS=y
+ CONFIG_MOUSE_PS2_TRACKPOINT=y
+ CONFIG_MOUSE_PS2_FOCALTECH=y
+ CONFIG_SERIO=y
+ CONFIG_ARCH_MIGHT_HAVE_PC_SERIO=y
+ CONFIG_SERIO_I8042=y
+ CONFIG_SERIO_SERPORT=y
+ CONFIG_SERIO_LIBPS2=y
+ CONFIG_TTY=y
+ CONFIG_VT=y
+ CONFIG_CONSOLE_TRANSLATIONS=y
+ CONFIG_VT_CONSOLE=y
+ CONFIG_VT_CONSOLE_SLEEP=y
+ CONFIG_HW_CONSOLE=y
+ CONFIG_UNIX98_PTYS=y
+ CONFIG_LEGACY_PTYS=y
+ CONFIG_LEGACY_PTY_COUNT=256
+ CONFIG_DEVMEM=y
+ CONFIG_DEVKMEM=y
+ CONFIG_SERIAL_EARLYCON=y
+ CONFIG_SERIAL_8250=y
+ CONFIG_SERIAL_8250_DEPRECATED_OPTIONS=y
+ CONFIG_SERIAL_8250_CONSOLE=y
+ CONFIG_SERIAL_8250_NR_UARTS=2
+ CONFIG_SERIAL_8250_RUNTIME_UARTS=2
+ CONFIG_SERIAL_8250_EXTENDED=y
+ CONFIG_SERIAL_8250_DW=y
+ CONFIG_SERIAL_CORE=y
+ CONFIG_SERIAL_CORE_CONSOLE=y
+ CONFIG_HW_RANDOM=y
+ CONFIG_HWMON=y
+ CONFIG_SSB_POSSIBLE=y
+ CONFIG_BCMA_POSSIBLE=y
+ CONFIG_VGA_CONSOLE=y
+ CONFIG_DUMMY_CONSOLE=y
+ CONFIG_DUMMY_CONSOLE_COLUMNS=80
+ CONFIG_DUMMY_CONSOLE_ROWS=25
+ CONFIG_HID=y
+ CONFIG_HID_GENERIC=y
+ CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+ CONFIG_USB_SUPPORT=y
+ CONFIG_USB_ARCH_HAS_HCD=y
+ CONFIG_RTC_LIB=y
+ CONFIG_MIPS_PLATFORM_DEVICES=y
+ CONFIG_CLKDEV_LOOKUP=y
+ CONFIG_HAVE_CLK_PREPARE=y
+ CONFIG_HAVE_MACH_CLKDEV=y
+ CONFIG_COMMON_CLK=y
+ CONFIG_COMMON_CLK_BAIKAL=y
+ CONFIG_CLKSRC_OF=y
+ CONFIG_CLKSRC_PROBE=y
+ CONFIG_DW_APB_TIMER=y
+ CONFIG_DW_APB_TIMER_OF=y
+ CONFIG_CLKSRC_MIPS_GIC=y
+ CONFIG_IOMMU_SUPPORT=y
+ CONFIG_IRQCHIP=y
+ CONFIG_MIPS_GIC=y
+ CONFIG_FS_POSIX_ACL=y
+ CONFIG_EXPORTFS=y
+ CONFIG_FILE_LOCKING=y
+ CONFIG_FSNOTIFY=y
+ CONFIG_DNOTIFY=y
+ CONFIG_INOTIFY_USER=y
+ CONFIG_PROC_FS=y
+ CONFIG_PROC_KCORE=y
+ CONFIG_PROC_SYSCTL=y
+ CONFIG_PROC_PAGE_MONITOR=y
+ CONFIG_KERNFS=y
+ CONFIG_SYSFS=y
+ CONFIG_TMPFS=y
+ CONFIG_TMPFS_POSIX_ACL=y
+ CONFIG_TMPFS_XATTR=y
+ CONFIG_MISC_FILESYSTEMS=y
+ CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+ CONFIG_PRINTK_TIME=y
+ CONFIG_MESSAGE_LOGLEVEL_DEFAULT=4
+ CONFIG_DYNAMIC_DEBUG=y
+ CONFIG_DEBUG_INFO=y
+ CONFIG_ENABLE_WARN_DEPRECATED=y
+ CONFIG_ENABLE_MUST_CHECK=y
+ CONFIG_FRAME_WARN=1024
+ CONFIG_DEBUG_FS=y
+ CONFIG_DEBUG_SECTION_MISMATCH=y
+ CONFIG_SECTION_MISMATCH_WARN_ONLY=y
+ CONFIG_DEBUG_KERNEL=y
+ CONFIG_HAVE_DEBUG_KMEMLEAK=y
+ CONFIG_DEBUG_MEMORY_INIT=y
+ CONFIG_HAVE_DEBUG_STACKOVERFLOW=y
+ CONFIG_LOCKUP_DETECTOR=y
+ CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC=y
+ CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=1
+ CONFIG_DETECT_HUNG_TASK=y
+ CONFIG_DEFAULT_HUNG_TASK_TIMEOUT=120
+ CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE=0
+ CONFIG_PANIC_ON_OOPS_VALUE=0
+ CONFIG_PANIC_TIMEOUT=0
+ CONFIG_SCHED_DEBUG=y
+ CONFIG_DEBUG_SPINLOCK=y
+ CONFIG_DEBUG_MUTEXES=y
+ CONFIG_DEBUG_WW_MUTEX_SLOWPATH=y
+ CONFIG_DEBUG_LOCK_ALLOC=y
+ CONFIG_PROVE_LOCKING=y
+ CONFIG_LOCKDEP=y
+ CONFIG_LOCK_STAT=y
+ CONFIG_DEBUG_LOCKDEP=y
+ CONFIG_DEBUG_ATOMIC_SLEEP=y
+ CONFIG_TRACE_IRQFLAGS=y
+ CONFIG_STACKTRACE=y
+ CONFIG_PROVE_RCU=y
+ CONFIG_SPARSE_RCU_POINTER=y
+ CONFIG_RCU_CPU_STALL_TIMEOUT=21
+ CONFIG_HAVE_FUNCTION_TRACER=y
+ CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+ CONFIG_HAVE_DYNAMIC_FTRACE=y
+ CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+ CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+ CONFIG_HAVE_C_RECORDMCOUNT=y
+ CONFIG_TRACING_SUPPORT=y
+ CONFIG_FTRACE=y
+ CONFIG_BRANCH_PROFILE_NONE=y
+ CONFIG_HAVE_ARCH_KGDB=y
+ CONFIG_EARLY_PRINTK=y
+ CONFIG_DEFAULT_SECURITY_DAC=y
+ CONFIG_DEFAULT_SECURITY=""
+ CONFIG_BITREVERSE=y
+ CONFIG_RATIONAL=y
+ CONFIG_GENERIC_PCI_IOMAP=y
+ CONFIG_GENERIC_IO=y
+ CONFIG_CRC32=y
+ CONFIG_CRC32_SLICEBY8=y
+ CONFIG_ZLIB_INFLATE=y
+ CONFIG_LZO_DECOMPRESS=y
+ CONFIG_LZ4_DECOMPRESS=y
+ CONFIG_XZ_DEC=y
+ CONFIG_XZ_DEC_X86=y
+ CONFIG_XZ_DEC_POWERPC=y
+ CONFIG_XZ_DEC_IA64=y
+ CONFIG_XZ_DEC_ARM=y
+ CONFIG_XZ_DEC_ARMTHUMB=y
+ CONFIG_XZ_DEC_SPARC=y
+ CONFIG_XZ_DEC_BCJ=y
+ CONFIG_DECOMPRESS_GZIP=y
+ CONFIG_DECOMPRESS_BZIP2=y
+ CONFIG_DECOMPRESS_LZMA=y
+ CONFIG_DECOMPRESS_XZ=y
+ CONFIG_DECOMPRESS_LZO=y
+ CONFIG_DECOMPRESS_LZ4=y
+ CONFIG_HAS_IOMEM=y
+ CONFIG_HAS_IOPORT_MAP=y
+ CONFIG_HAS_DMA=y
+ CONFIG_GENERIC_ATOMIC64=y
+ CONFIG_ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE=y
+ CONFIG_LIBFDT=y
+ CONFIG_HAVE_KVM=y
diff -rcNP linux-4.4.24/arch/mips/configs/baikal_malta_defconfig linux-4.4.24-baikal/arch/mips/configs/baikal_malta_defconfig
*** linux-4.4.24/arch/mips/configs/baikal_malta_defconfig	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/arch/mips/configs/baikal_malta_defconfig	2016-11-11 14:49:51.000000000 +0300
***************
*** 0 ****
--- 1,1011 ----
+ # 
+ # Baikal-T MALTA default kernel configuration
+ #
+ # Copyright (C) 2014-2016 Baikal Electronics JSC
+ # 
+ # Author:
+ #   Dmitry Dunaev <dmitry.dunaev@baikalelectronics.ru>
+ #
+ # This program is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU General Public License
+ # as published by the Free Software Foundation; either version 2
+ # of the License, or (at your option) any later version.
+ #
+ # This program is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ # GNU General Public License for more details.
+ #
+ # You should have received a copy of the GNU General Public License
+ # along with this program; if not, write to the Free Software
+ # Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ #
+ CONFIG_MIPS=y
+ CONFIG_MIPS_MALTA=y
+ CONFIG_RWSEM_GENERIC_SPINLOCK=y
+ CONFIG_GENERIC_HWEIGHT=y
+ CONFIG_GENERIC_CALIBRATE_DELAY=y
+ CONFIG_SCHED_OMIT_FRAME_POINTER=y
+ CONFIG_ARCH_MAY_HAVE_PC_FDC=y
+ CONFIG_BOOT_RAW=y
+ CONFIG_CEVT_R4K=y
+ CONFIG_CSRC_R4K=y
+ CONFIG_CSRC_GIC=y
+ CONFIG_DMA_MAYBE_COHERENT=y
+ CONFIG_DMA_NONCOHERENT=y
+ CONFIG_NEED_DMA_MAP_STATE=y
+ CONFIG_I8259=y
+ CONFIG_MIPS_BONITO64=y
+ CONFIG_MIPS_MSC=y
+ CONFIG_SYNC_R4K=y
+ CONFIG_GENERIC_ISA_DMA=y
+ CONFIG_ISA_DMA_API=y
+ CONFIG_CPU_LITTLE_ENDIAN=y
+ CONFIG_SYS_SUPPORTS_BIG_ENDIAN=y
+ CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
+ CONFIG_IRQ_CPU=y
+ CONFIG_IRQ_GIC=y
+ CONFIG_PCI_GT64XXX_PCI0=y
+ CONFIG_SWAP_IO_SPACE=y
+ CONFIG_BOOT_ELF32=y
+ CONFIG_MIPS_L1_CACHE_SHIFT_6=y
+ CONFIG_MIPS_L1_CACHE_SHIFT=6
+ CONFIG_CPU_MIPS32_R2=y
+ CONFIG_SYS_SUPPORTS_ZBOOT=y
+ CONFIG_SYS_HAS_CPU_MIPS32_R1=y
+ CONFIG_SYS_HAS_CPU_MIPS32_R2=y
+ CONFIG_SYS_HAS_CPU_MIPS64_R1=y
+ CONFIG_SYS_HAS_CPU_MIPS64_R2=y
+ CONFIG_SYS_HAS_CPU_NEVADA=y
+ CONFIG_SYS_HAS_CPU_RM7000=y
+ CONFIG_WEAK_ORDERING=y
+ CONFIG_CPU_MIPS32=y
+ CONFIG_CPU_MIPSR2=y
+ CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+ CONFIG_SYS_SUPPORTS_64BIT_KERNEL=y
+ CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+ CONFIG_HARDWARE_WATCHPOINTS=y
+ CONFIG_32BIT=y
+ CONFIG_PAGE_SIZE_4KB=y
+ CONFIG_FORCE_MAX_ZONEORDER=11
+ CONFIG_BOARD_SCACHE=y
+ CONFIG_MIPS_CPU_SCACHE=y
+ CONFIG_CPU_HAS_PREFETCH=y
+ CONFIG_CPU_GENERIC_DUMP_TLB=y
+ CONFIG_CPU_R4K_FPU=y
+ CONFIG_CPU_R4K_CACHE_TLB=y
+ CONFIG_MIPS_MT_SMP=y
+ CONFIG_MIPS_MT=y
+ CONFIG_SCHED_SMT=y
+ CONFIG_SYS_SUPPORTS_SCHED_SMT=y
+ CONFIG_SYS_SUPPORTS_MULTITHREADING=y
+ CONFIG_MIPS_MT_FPAFF=y
+ CONFIG_MIPS_CMP=y
+ CONFIG_CPU_MIPSR2_IRQ_VI=y
+ CONFIG_CPU_MIPSR2_IRQ_EI=y
+ CONFIG_CPU_HAS_SYNC=y
+ CONFIG_CPU_SUPPORTS_HIGHMEM=y
+ CONFIG_SYS_SUPPORTS_SMARTMIPS=y
+ CONFIG_ARCH_FLATMEM_ENABLE=y
+ CONFIG_FLATMEM=y
+ CONFIG_FLAT_NODE_MEM_MAP=y
+ CONFIG_HAVE_MEMBLOCK=y
+ CONFIG_HAVE_MEMBLOCK_NODE_MAP=y
+ CONFIG_ARCH_DISCARD_MEMBLOCK=y
+ CONFIG_PAGEFLAGS_EXTENDED=y
+ CONFIG_SPLIT_PTLOCK_CPUS=4
+ CONFIG_COMPACTION=y
+ CONFIG_MIGRATION=y
+ CONFIG_ZONE_DMA_FLAG=1
+ CONFIG_BOUNCE=y
+ CONFIG_VIRT_TO_BUS=y
+ CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+ CONFIG_CROSS_MEMORY_ATTACH=y
+ CONFIG_SMP=y
+ CONFIG_SMP_UP=y
+ CONFIG_SYS_SUPPORTS_MIPS_CMP=y
+ CONFIG_SYS_SUPPORTS_SMP=y
+ CONFIG_NR_CPUS=16
+ CONFIG_MIPS_PERF_SHARED_TC_COUNTERS=y
+ CONFIG_HZ_100=y
+ CONFIG_SYS_SUPPORTS_ARBIT_HZ=y
+ CONFIG_HZ=100
+ CONFIG_PREEMPT_NONE=y
+ CONFIG_SECCOMP=y
+ CONFIG_MIPS_O32_FP64_SUPPORT=y
+ CONFIG_LOCKDEP_SUPPORT=y
+ CONFIG_STACKTRACE_SUPPORT=y
+ CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+ CONFIG_IRQ_WORK=y
+ CONFIG_BUILDTIME_EXTABLE_SORT=y
+ CONFIG_INIT_ENV_ARG_LIMIT=32
+ CONFIG_CROSS_COMPILE=""
+ CONFIG_LOCALVERSION="-malta"
+ CONFIG_HAVE_KERNEL_GZIP=y
+ CONFIG_HAVE_KERNEL_BZIP2=y
+ CONFIG_HAVE_KERNEL_LZMA=y
+ CONFIG_HAVE_KERNEL_XZ=y
+ CONFIG_HAVE_KERNEL_LZO=y
+ CONFIG_HAVE_KERNEL_LZ4=y
+ CONFIG_KERNEL_GZIP=y
+ CONFIG_DEFAULT_HOSTNAME="baikal"
+ CONFIG_SWAP=y
+ CONFIG_SYSVIPC=y
+ CONFIG_SYSVIPC_SYSCTL=y
+ CONFIG_GENERIC_IRQ_PROBE=y
+ CONFIG_GENERIC_IRQ_SHOW=y
+ CONFIG_IRQ_FORCED_THREADING=y
+ CONFIG_GENERIC_CLOCKEVENTS=y
+ CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+ CONFIG_GENERIC_CMOS_UPDATE=y
+ CONFIG_TICK_ONESHOT=y
+ CONFIG_NO_HZ_COMMON=y
+ CONFIG_NO_HZ_IDLE=y
+ CONFIG_NO_HZ=y
+ CONFIG_HIGH_RES_TIMERS=y
+ CONFIG_TICK_CPU_ACCOUNTING=y
+ CONFIG_TREE_RCU=y
+ CONFIG_RCU_STALL_COMMON=y
+ CONFIG_RCU_FANOUT=32
+ CONFIG_RCU_FANOUT_LEAF=16
+ CONFIG_LOG_BUF_SHIFT=15
+ CONFIG_NAMESPACES=y
+ CONFIG_UTS_NS=y
+ CONFIG_IPC_NS=y
+ CONFIG_PID_NS=y
+ CONFIG_NET_NS=y
+ CONFIG_RELAY=y
+ CONFIG_SYSCTL=y
+ CONFIG_ANON_INODES=y
+ CONFIG_HAVE_PCSPKR_PLATFORM=y
+ CONFIG_EXPERT=y
+ CONFIG_KALLSYMS=y
+ CONFIG_PRINTK=y
+ CONFIG_BUG=y
+ CONFIG_ELF_CORE=y
+ CONFIG_PCSPKR_PLATFORM=y
+ CONFIG_BASE_FULL=y
+ CONFIG_FUTEX=y
+ CONFIG_EPOLL=y
+ CONFIG_SIGNALFD=y
+ CONFIG_TIMERFD=y
+ CONFIG_EVENTFD=y
+ CONFIG_SHMEM=y
+ CONFIG_AIO=y
+ CONFIG_PCI_QUIRKS=y
+ CONFIG_HAVE_PERF_EVENTS=y
+ CONFIG_PERF_USE_VMALLOC=y
+ CONFIG_VM_EVENT_COUNTERS=y
+ CONFIG_SLAB=y
+ CONFIG_HAVE_OPROFILE=y
+ CONFIG_HAVE_KPROBES=y
+ CONFIG_HAVE_KRETPROBES=y
+ CONFIG_HAVE_ARCH_TRACEHOOK=y
+ CONFIG_HAVE_DMA_ATTRS=y
+ CONFIG_GENERIC_SMP_IDLE_THREAD=y
+ CONFIG_HAVE_DMA_API_DEBUG=y
+ CONFIG_HAVE_ARCH_JUMP_LABEL=y
+ CONFIG_ARCH_WANT_IPC_PARSE_VERSION=y
+ CONFIG_HAVE_CC_STACKPROTECTOR=y
+ CONFIG_CC_STACKPROTECTOR_NONE=y
+ CONFIG_HAVE_CONTEXT_TRACKING=y
+ CONFIG_HAVE_MOD_ARCH_SPECIFIC=y
+ CONFIG_MODULES_USE_ELF_REL=y
+ CONFIG_CLONE_BACKWARDS=y
+ CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+ CONFIG_SLABINFO=y
+ CONFIG_RT_MUTEXES=y
+ CONFIG_BASE_SMALL=0
+ CONFIG_MODULES=y
+ CONFIG_MODULE_UNLOAD=y
+ CONFIG_MODVERSIONS=y
+ CONFIG_MODULE_SRCVERSION_ALL=y
+ CONFIG_STOP_MACHINE=y
+ CONFIG_BLOCK=y
+ CONFIG_LBDAF=y
+ CONFIG_BLK_DEV_BSG=y
+ CONFIG_BLK_DEV_BSGLIB=y
+ CONFIG_MSDOS_PARTITION=y
+ CONFIG_EFI_PARTITION=y
+ CONFIG_IOSCHED_NOOP=y
+ CONFIG_IOSCHED_DEADLINE=y
+ CONFIG_IOSCHED_CFQ=y
+ CONFIG_DEFAULT_CFQ=y
+ CONFIG_DEFAULT_IOSCHED="cfq"
+ CONFIG_INLINE_SPIN_UNLOCK_IRQ=y
+ CONFIG_INLINE_READ_UNLOCK=y
+ CONFIG_INLINE_READ_UNLOCK_IRQ=y
+ CONFIG_INLINE_WRITE_UNLOCK=y
+ CONFIG_INLINE_WRITE_UNLOCK_IRQ=y
+ CONFIG_MUTEX_SPIN_ON_OWNER=y
+ CONFIG_HW_HAS_PCI=y
+ CONFIG_PCI=y
+ CONFIG_PCI_DOMAINS=y
+ CONFIG_MMU=y
+ CONFIG_I8253=y
+ CONFIG_ZONE_DMA=y
+ CONFIG_BINFMT_ELF=y
+ CONFIG_ARCH_BINFMT_ELF_RANDOMIZE_PIE=y
+ CONFIG_ELFCORE=y
+ CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS=y
+ CONFIG_BINFMT_SCRIPT=y
+ CONFIG_COREDUMP=y
+ CONFIG_TRAD_SIGNALS=y
+ CONFIG_MIPS_EXTERNAL_TIMER=y
+ CONFIG_NET=y
+ CONFIG_PACKET=y
+ CONFIG_UNIX=y
+ CONFIG_XFRM=y
+ CONFIG_XFRM_ALGO=y
+ CONFIG_XFRM_USER=m
+ CONFIG_XFRM_MIGRATE=y
+ CONFIG_XFRM_IPCOMP=m
+ CONFIG_NET_KEY=y
+ CONFIG_NET_KEY_MIGRATE=y
+ CONFIG_INET=y
+ CONFIG_IP_MULTICAST=y
+ CONFIG_IP_ADVANCED_ROUTER=y
+ CONFIG_IP_MULTIPLE_TABLES=y
+ CONFIG_IP_ROUTE_MULTIPATH=y
+ CONFIG_IP_ROUTE_VERBOSE=y
+ CONFIG_IP_ROUTE_CLASSID=y
+ CONFIG_IP_PNP=y
+ CONFIG_IP_PNP_DHCP=y
+ CONFIG_IP_PNP_BOOTP=y
+ CONFIG_NET_IPIP=m
+ CONFIG_NET_IP_TUNNEL=m
+ CONFIG_IP_MROUTE=y
+ CONFIG_IP_PIMSM_V1=y
+ CONFIG_IP_PIMSM_V2=y
+ CONFIG_SYN_COOKIES=y
+ CONFIG_INET_AH=m
+ CONFIG_INET_ESP=m
+ CONFIG_INET_IPCOMP=m
+ CONFIG_INET_XFRM_TUNNEL=m
+ CONFIG_INET_TUNNEL=m
+ CONFIG_INET_XFRM_MODE_TRANSPORT=m
+ CONFIG_INET_XFRM_MODE_TUNNEL=m
+ CONFIG_INET_XFRM_MODE_BEET=y
+ CONFIG_INET_LRO=y
+ CONFIG_INET_DIAG=y
+ CONFIG_INET_TCP_DIAG=y
+ CONFIG_TCP_CONG_CUBIC=y
+ CONFIG_DEFAULT_TCP_CONG="cubic"
+ CONFIG_TCP_MD5SIG=y
+ CONFIG_IPV6=m
+ CONFIG_IPV6_ROUTER_PREF=y
+ CONFIG_IPV6_ROUTE_INFO=y
+ CONFIG_IPV6_OPTIMISTIC_DAD=y
+ CONFIG_INET6_AH=m
+ CONFIG_INET6_ESP=m
+ CONFIG_INET6_IPCOMP=m
+ CONFIG_INET6_XFRM_TUNNEL=m
+ CONFIG_INET6_TUNNEL=m
+ CONFIG_INET6_XFRM_MODE_TRANSPORT=m
+ CONFIG_INET6_XFRM_MODE_TUNNEL=m
+ CONFIG_INET6_XFRM_MODE_BEET=m
+ CONFIG_IPV6_SIT=m
+ CONFIG_IPV6_NDISC_NODETYPE=y
+ CONFIG_IPV6_TUNNEL=m
+ CONFIG_IPV6_MROUTE=y
+ CONFIG_IPV6_PIMSM_V2=y
+ CONFIG_NETWORK_SECMARK=y
+ CONFIG_NETFILTER=y
+ CONFIG_NETFILTER_ADVANCED=y
+ CONFIG_BRIDGE_NETFILTER=y
+ CONFIG_NETFILTER_NETLINK=m
+ CONFIG_NETFILTER_NETLINK_QUEUE=m
+ CONFIG_NETFILTER_NETLINK_LOG=m
+ CONFIG_NF_CONNTRACK=m
+ CONFIG_NF_CONNTRACK_MARK=y
+ CONFIG_NF_CONNTRACK_SECMARK=y
+ CONFIG_NF_CONNTRACK_PROCFS=y
+ CONFIG_NF_CONNTRACK_EVENTS=y
+ CONFIG_NF_CT_PROTO_DCCP=m
+ CONFIG_NF_CT_PROTO_GRE=m
+ CONFIG_NF_CT_PROTO_SCTP=m
+ CONFIG_NF_CT_PROTO_UDPLITE=m
+ CONFIG_NF_CONNTRACK_AMANDA=m
+ CONFIG_NF_CONNTRACK_FTP=m
+ CONFIG_NF_CONNTRACK_H323=m
+ CONFIG_NF_CONNTRACK_IRC=m
+ CONFIG_NF_CONNTRACK_PPTP=m
+ CONFIG_NF_CONNTRACK_SANE=m
+ CONFIG_NF_CONNTRACK_SIP=m
+ CONFIG_NF_CONNTRACK_TFTP=m
+ CONFIG_NF_CT_NETLINK=m
+ CONFIG_NETFILTER_XTABLES=m
+ CONFIG_NETFILTER_XT_MARK=m
+ CONFIG_NETFILTER_XT_CONNMARK=m
+ CONFIG_NETFILTER_XT_TARGET_CLASSIFY=m
+ CONFIG_NETFILTER_XT_TARGET_CONNMARK=m
+ CONFIG_NETFILTER_XT_TARGET_HL=m
+ CONFIG_NETFILTER_XT_TARGET_MARK=m
+ CONFIG_NETFILTER_XT_TARGET_NFLOG=m
+ CONFIG_NETFILTER_XT_TARGET_NFQUEUE=m
+ CONFIG_NETFILTER_XT_TARGET_RATEEST=m
+ CONFIG_NETFILTER_XT_TARGET_TPROXY=m
+ CONFIG_NETFILTER_XT_TARGET_TRACE=m
+ CONFIG_NETFILTER_XT_TARGET_SECMARK=m
+ CONFIG_NETFILTER_XT_TARGET_TCPMSS=m
+ CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP=m
+ CONFIG_NETFILTER_XT_MATCH_COMMENT=m
+ CONFIG_NETFILTER_XT_MATCH_CONNBYTES=m
+ CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=m
+ CONFIG_NETFILTER_XT_MATCH_CONNMARK=m
+ CONFIG_NETFILTER_XT_MATCH_CONNTRACK=m
+ CONFIG_NETFILTER_XT_MATCH_DCCP=m
+ CONFIG_NETFILTER_XT_MATCH_ECN=m
+ CONFIG_NETFILTER_XT_MATCH_ESP=m
+ CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=m
+ CONFIG_NETFILTER_XT_MATCH_HELPER=m
+ CONFIG_NETFILTER_XT_MATCH_HL=m
+ CONFIG_NETFILTER_XT_MATCH_IPRANGE=m
+ CONFIG_NETFILTER_XT_MATCH_LENGTH=m
+ CONFIG_NETFILTER_XT_MATCH_LIMIT=m
+ CONFIG_NETFILTER_XT_MATCH_MAC=m
+ CONFIG_NETFILTER_XT_MATCH_MARK=m
+ CONFIG_NETFILTER_XT_MATCH_MULTIPORT=m
+ CONFIG_NETFILTER_XT_MATCH_OWNER=m
+ CONFIG_NETFILTER_XT_MATCH_POLICY=m
+ CONFIG_NETFILTER_XT_MATCH_PKTTYPE=m
+ CONFIG_NETFILTER_XT_MATCH_QUOTA=m
+ CONFIG_NETFILTER_XT_MATCH_RATEEST=m
+ CONFIG_NETFILTER_XT_MATCH_REALM=m
+ CONFIG_NETFILTER_XT_MATCH_RECENT=m
+ CONFIG_NETFILTER_XT_MATCH_SCTP=m
+ CONFIG_NETFILTER_XT_MATCH_SOCKET=m
+ CONFIG_NETFILTER_XT_MATCH_STATE=m
+ CONFIG_NETFILTER_XT_MATCH_STATISTIC=m
+ CONFIG_NETFILTER_XT_MATCH_STRING=m
+ CONFIG_NETFILTER_XT_MATCH_TCPMSS=m
+ CONFIG_NETFILTER_XT_MATCH_TIME=m
+ CONFIG_NETFILTER_XT_MATCH_U32=m
+ CONFIG_IP_VS=m
+ CONFIG_IP_VS_IPV6=y
+ CONFIG_IP_VS_TAB_BITS=12
+ CONFIG_IP_VS_PROTO_TCP=y
+ CONFIG_IP_VS_PROTO_UDP=y
+ CONFIG_IP_VS_PROTO_AH_ESP=y
+ CONFIG_IP_VS_PROTO_ESP=y
+ CONFIG_IP_VS_PROTO_AH=y
+ CONFIG_IP_VS_RR=m
+ CONFIG_IP_VS_WRR=m
+ CONFIG_IP_VS_LC=m
+ CONFIG_IP_VS_WLC=m
+ CONFIG_IP_VS_LBLC=m
+ CONFIG_IP_VS_LBLCR=m
+ CONFIG_IP_VS_DH=m
+ CONFIG_IP_VS_SH=m
+ CONFIG_IP_VS_SED=m
+ CONFIG_IP_VS_NQ=m
+ CONFIG_IP_VS_SH_TAB_BITS=8
+ CONFIG_NF_DEFRAG_IPV4=m
+ CONFIG_NF_CONNTRACK_IPV4=m
+ CONFIG_NF_CONNTRACK_PROC_COMPAT=y
+ CONFIG_IP_NF_IPTABLES=m
+ CONFIG_IP_NF_MATCH_AH=m
+ CONFIG_IP_NF_MATCH_ECN=m
+ CONFIG_IP_NF_MATCH_TTL=m
+ CONFIG_IP_NF_FILTER=m
+ CONFIG_IP_NF_TARGET_REJECT=m
+ CONFIG_IP_NF_TARGET_ULOG=m
+ CONFIG_IP_NF_MANGLE=m
+ CONFIG_IP_NF_TARGET_CLUSTERIP=m
+ CONFIG_IP_NF_TARGET_ECN=m
+ CONFIG_IP_NF_TARGET_TTL=m
+ CONFIG_IP_NF_RAW=m
+ CONFIG_IP_NF_ARPTABLES=m
+ CONFIG_IP_NF_ARPFILTER=m
+ CONFIG_IP_NF_ARP_MANGLE=m
+ CONFIG_NF_DEFRAG_IPV6=m
+ CONFIG_NF_CONNTRACK_IPV6=m
+ CONFIG_IP6_NF_IPTABLES=m
+ CONFIG_IP6_NF_MATCH_AH=m
+ CONFIG_IP6_NF_MATCH_EUI64=m
+ CONFIG_IP6_NF_MATCH_FRAG=m
+ CONFIG_IP6_NF_MATCH_OPTS=m
+ CONFIG_IP6_NF_MATCH_HL=m
+ CONFIG_IP6_NF_MATCH_IPV6HEADER=m
+ CONFIG_IP6_NF_MATCH_MH=m
+ CONFIG_IP6_NF_MATCH_RT=m
+ CONFIG_IP6_NF_TARGET_HL=m
+ CONFIG_IP6_NF_FILTER=m
+ CONFIG_IP6_NF_TARGET_REJECT=m
+ CONFIG_IP6_NF_MANGLE=m
+ CONFIG_IP6_NF_RAW=m
+ CONFIG_BRIDGE_NF_EBTABLES=m
+ CONFIG_BRIDGE_EBT_BROUTE=m
+ CONFIG_BRIDGE_EBT_T_FILTER=m
+ CONFIG_BRIDGE_EBT_T_NAT=m
+ CONFIG_BRIDGE_EBT_802_3=m
+ CONFIG_BRIDGE_EBT_AMONG=m
+ CONFIG_BRIDGE_EBT_ARP=m
+ CONFIG_BRIDGE_EBT_IP=m
+ CONFIG_BRIDGE_EBT_IP6=m
+ CONFIG_BRIDGE_EBT_LIMIT=m
+ CONFIG_BRIDGE_EBT_MARK=m
+ CONFIG_BRIDGE_EBT_PKTTYPE=m
+ CONFIG_BRIDGE_EBT_STP=m
+ CONFIG_BRIDGE_EBT_VLAN=m
+ CONFIG_BRIDGE_EBT_ARPREPLY=m
+ CONFIG_BRIDGE_EBT_DNAT=m
+ CONFIG_BRIDGE_EBT_MARK_T=m
+ CONFIG_BRIDGE_EBT_REDIRECT=m
+ CONFIG_BRIDGE_EBT_SNAT=m
+ CONFIG_BRIDGE_EBT_LOG=m
+ CONFIG_BRIDGE_EBT_ULOG=m
+ CONFIG_BRIDGE_EBT_NFLOG=m
+ CONFIG_IP_SCTP=m
+ CONFIG_SCTP_DEFAULT_COOKIE_HMAC_MD5=y
+ CONFIG_SCTP_COOKIE_HMAC_MD5=y
+ CONFIG_STP=m
+ CONFIG_GARP=m
+ CONFIG_BRIDGE=m
+ CONFIG_BRIDGE_IGMP_SNOOPING=y
+ CONFIG_HAVE_NET_DSA=y
+ CONFIG_VLAN_8021Q=m
+ CONFIG_VLAN_8021Q_GVRP=y
+ CONFIG_LLC=m
+ CONFIG_ATALK=m
+ CONFIG_DEV_APPLETALK=m
+ CONFIG_IPDDP=m
+ CONFIG_IPDDP_ENCAP=y
+ CONFIG_PHONET=m
+ CONFIG_NET_SCHED=y
+ CONFIG_NET_SCH_CBQ=m
+ CONFIG_NET_SCH_HTB=m
+ CONFIG_NET_SCH_HFSC=m
+ CONFIG_NET_SCH_PRIO=m
+ CONFIG_NET_SCH_RED=m
+ CONFIG_NET_SCH_SFQ=m
+ CONFIG_NET_SCH_TEQL=m
+ CONFIG_NET_SCH_TBF=m
+ CONFIG_NET_SCH_GRED=m
+ CONFIG_NET_SCH_DSMARK=m
+ CONFIG_NET_SCH_NETEM=m
+ CONFIG_NET_SCH_INGRESS=m
+ CONFIG_NET_CLS=y
+ CONFIG_NET_CLS_BASIC=m
+ CONFIG_NET_CLS_TCINDEX=m
+ CONFIG_NET_CLS_ROUTE4=m
+ CONFIG_NET_CLS_FW=m
+ CONFIG_NET_CLS_U32=m
+ CONFIG_NET_CLS_RSVP=m
+ CONFIG_NET_CLS_RSVP6=m
+ CONFIG_NET_CLS_FLOW=m
+ CONFIG_NET_CLS_ACT=y
+ CONFIG_NET_ACT_POLICE=y
+ CONFIG_NET_ACT_GACT=m
+ CONFIG_GACT_PROB=y
+ CONFIG_NET_ACT_MIRRED=m
+ CONFIG_NET_ACT_IPT=m
+ CONFIG_NET_ACT_NAT=m
+ CONFIG_NET_ACT_PEDIT=m
+ CONFIG_NET_ACT_SIMP=m
+ CONFIG_NET_ACT_SKBEDIT=m
+ CONFIG_NET_CLS_IND=y
+ CONFIG_NET_SCH_FIFO=y
+ CONFIG_RPS=y
+ CONFIG_RFS_ACCEL=y
+ CONFIG_XPS=y
+ CONFIG_NET_RX_BUSY_POLL=y
+ CONFIG_BQL=y
+ CONFIG_NET_FLOW_LIMIT=y
+ CONFIG_FIB_RULES=y
+ CONFIG_WIRELESS=y
+ CONFIG_WIRELESS_EXT=y
+ CONFIG_WEXT_CORE=y
+ CONFIG_WEXT_PROC=y
+ CONFIG_WEXT_SPY=y
+ CONFIG_WEXT_PRIV=y
+ CONFIG_CFG80211=m
+ CONFIG_CFG80211_DEFAULT_PS=y
+ CONFIG_LIB80211=m
+ CONFIG_LIB80211_CRYPT_WEP=m
+ CONFIG_LIB80211_CRYPT_CCMP=m
+ CONFIG_LIB80211_CRYPT_TKIP=m
+ CONFIG_MAC80211=m
+ CONFIG_MAC80211_HAS_RC=y
+ CONFIG_MAC80211_RC_PID=y
+ CONFIG_MAC80211_RC_MINSTREL=y
+ CONFIG_MAC80211_RC_MINSTREL_HT=y
+ CONFIG_MAC80211_RC_DEFAULT_PID=y
+ CONFIG_MAC80211_RC_DEFAULT="pid"
+ CONFIG_MAC80211_MESH=y
+ CONFIG_RFKILL=m
+ CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+ CONFIG_STANDALONE=y
+ CONFIG_PREVENT_FIRMWARE_BUILD=y
+ CONFIG_FW_LOADER=y
+ CONFIG_FIRMWARE_IN_KERNEL=y
+ CONFIG_EXTRA_FIRMWARE=""
+ CONFIG_FW_LOADER_USER_HELPER=y
+ CONFIG_CONNECTOR=m
+ CONFIG_MTD=y
+ CONFIG_MTD_BLKDEVS=y
+ CONFIG_MTD_BLOCK=y
+ CONFIG_MTD_OOPS=m
+ CONFIG_MTD_CFI=y
+ CONFIG_MTD_GEN_PROBE=y
+ CONFIG_MTD_MAP_BANK_WIDTH_1=y
+ CONFIG_MTD_MAP_BANK_WIDTH_2=y
+ CONFIG_MTD_MAP_BANK_WIDTH_4=y
+ CONFIG_MTD_CFI_I1=y
+ CONFIG_MTD_CFI_I2=y
+ CONFIG_MTD_CFI_INTELEXT=y
+ CONFIG_MTD_CFI_AMDSTD=y
+ CONFIG_MTD_CFI_STAA=y
+ CONFIG_MTD_CFI_UTIL=y
+ CONFIG_MTD_PHYSMAP=y
+ CONFIG_MTD_UBI=m
+ CONFIG_MTD_UBI_WL_THRESHOLD=4096
+ CONFIG_MTD_UBI_BEB_LIMIT=20
+ CONFIG_MTD_UBI_GLUEBI=m
+ CONFIG_ARCH_MIGHT_HAVE_PC_PARPORT=y
+ CONFIG_BLK_DEV=y
+ CONFIG_BLK_DEV_UMEM=m
+ CONFIG_BLK_DEV_LOOP=y
+ CONFIG_BLK_DEV_LOOP_MIN_COUNT=4
+ CONFIG_BLK_DEV_CRYPTOLOOP=m
+ CONFIG_BLK_DEV_NBD=y
+ CONFIG_BLK_DEV_RAM=y
+ CONFIG_BLK_DEV_RAM_COUNT=4
+ CONFIG_BLK_DEV_RAM_SIZE=32768
+ CONFIG_CDROM_PKTCDVD=m
+ CONFIG_CDROM_PKTCDVD_BUFFERS=8
+ CONFIG_ATA_OVER_ETH=m
+ CONFIG_HAVE_IDE=y
+ CONFIG_IDE=y
+ CONFIG_IDE_XFER_MODE=y
+ CONFIG_IDE_ATAPI=y
+ CONFIG_IDE_GD=y
+ CONFIG_IDE_GD_ATA=y
+ CONFIG_BLK_DEV_IDECD=y
+ CONFIG_BLK_DEV_IDECD_VERBOSE_ERRORS=y
+ CONFIG_IDE_PROC_FS=y
+ CONFIG_IDE_GENERIC=y
+ CONFIG_BLK_DEV_IDEDMA_SFF=y
+ CONFIG_BLK_DEV_IDEPCI=y
+ CONFIG_IDEPCI_PCIBUS_ORDER=y
+ CONFIG_BLK_DEV_GENERIC=y
+ CONFIG_BLK_DEV_IDEDMA_PCI=y
+ CONFIG_BLK_DEV_PIIX=y
+ CONFIG_BLK_DEV_IT8213=m
+ CONFIG_BLK_DEV_TC86C001=m
+ CONFIG_BLK_DEV_IDEDMA=y
+ CONFIG_SCSI_MOD=m
+ CONFIG_RAID_ATTRS=m
+ CONFIG_SCSI=m
+ CONFIG_SCSI_DMA=y
+ CONFIG_SCSI_TGT=m
+ CONFIG_SCSI_NETLINK=y
+ CONFIG_SCSI_PROC_FS=y
+ CONFIG_BLK_DEV_SD=m
+ CONFIG_CHR_DEV_ST=m
+ CONFIG_CHR_DEV_OSST=m
+ CONFIG_BLK_DEV_SR=m
+ CONFIG_BLK_DEV_SR_VENDOR=y
+ CONFIG_CHR_DEV_SG=m
+ CONFIG_SCSI_MULTI_LUN=y
+ CONFIG_SCSI_CONSTANTS=y
+ CONFIG_SCSI_LOGGING=y
+ CONFIG_SCSI_SCAN_ASYNC=y
+ CONFIG_SCSI_SPI_ATTRS=m
+ CONFIG_SCSI_FC_ATTRS=m
+ CONFIG_SCSI_ISCSI_ATTRS=m
+ CONFIG_SCSI_LOWLEVEL=y
+ CONFIG_ISCSI_TCP=m
+ CONFIG_BLK_DEV_3W_XXXX_RAID=m
+ CONFIG_SCSI_3W_9XXX=m
+ CONFIG_SCSI_ACARD=m
+ CONFIG_SCSI_AACRAID=m
+ CONFIG_SCSI_AIC7XXX=m
+ CONFIG_AIC7XXX_CMDS_PER_DEVICE=32
+ CONFIG_AIC7XXX_RESET_DELAY_MS=15000
+ CONFIG_AIC7XXX_DEBUG_MASK=0
+ CONFIG_AIC7XXX_REG_PRETTY_PRINT=y
+ CONFIG_MD=y
+ CONFIG_BLK_DEV_MD=m
+ CONFIG_MD_LINEAR=m
+ CONFIG_MD_RAID0=m
+ CONFIG_MD_RAID1=m
+ CONFIG_MD_RAID10=m
+ CONFIG_MD_RAID456=m
+ CONFIG_MD_MULTIPATH=m
+ CONFIG_MD_FAULTY=m
+ CONFIG_BLK_DEV_DM_BUILTIN=y
+ CONFIG_BLK_DEV_DM=m
+ CONFIG_DM_BUFIO=m
+ CONFIG_DM_CRYPT=m
+ CONFIG_DM_SNAPSHOT=m
+ CONFIG_DM_MIRROR=m
+ CONFIG_DM_ZERO=m
+ CONFIG_DM_MULTIPATH=m
+ CONFIG_NETDEVICES=y
+ CONFIG_MII=y
+ CONFIG_NET_CORE=y
+ CONFIG_BONDING=m
+ CONFIG_DUMMY=m
+ CONFIG_EQUALIZER=m
+ CONFIG_IFB=m
+ CONFIG_MACVLAN=m
+ CONFIG_TUN=m
+ CONFIG_VETH=m
+ CONFIG_ETHERNET=y
+ CONFIG_MDIO=m
+ CONFIG_NET_VENDOR_ADAPTEC=y
+ CONFIG_NET_VENDOR_ALTEON=y
+ CONFIG_NET_VENDOR_AMD=y
+ CONFIG_PCNET32=y
+ CONFIG_NET_VENDOR_ARC=y
+ CONFIG_NET_VENDOR_ATHEROS=y
+ CONFIG_NET_CADENCE=y
+ CONFIG_NET_VENDOR_BROADCOM=y
+ CONFIG_NET_VENDOR_BROCADE=y
+ CONFIG_NET_VENDOR_CHELSIO=y
+ CONFIG_CHELSIO_T3=m
+ CONFIG_NET_VENDOR_CISCO=y
+ CONFIG_NET_VENDOR_DEC=y
+ CONFIG_NET_VENDOR_DLINK=y
+ CONFIG_NET_VENDOR_EMULEX=y
+ CONFIG_NET_VENDOR_EXAR=y
+ CONFIG_NET_VENDOR_HP=y
+ CONFIG_NET_VENDOR_INTEL=y
+ CONFIG_NET_VENDOR_I825XX=y
+ CONFIG_NET_VENDOR_MARVELL=y
+ CONFIG_NET_VENDOR_MELLANOX=y
+ CONFIG_NET_VENDOR_MICREL=y
+ CONFIG_NET_VENDOR_MYRI=y
+ CONFIG_NET_VENDOR_NATSEMI=y
+ CONFIG_NET_VENDOR_8390=y
+ CONFIG_AX88796=m
+ CONFIG_NET_VENDOR_NVIDIA=y
+ CONFIG_NET_VENDOR_OKI=y
+ CONFIG_NET_PACKET_ENGINE=y
+ CONFIG_NET_VENDOR_QLOGIC=y
+ CONFIG_NETXEN_NIC=m
+ CONFIG_NET_VENDOR_REALTEK=y
+ CONFIG_NET_VENDOR_RDC=y
+ CONFIG_NET_VENDOR_SEEQ=y
+ CONFIG_NET_VENDOR_SILAN=y
+ CONFIG_NET_VENDOR_SIS=y
+ CONFIG_NET_VENDOR_SMSC=y
+ CONFIG_NET_VENDOR_STMICRO=y
+ CONFIG_NET_VENDOR_SUN=y
+ CONFIG_NET_VENDOR_TEHUTI=y
+ CONFIG_NET_VENDOR_TI=y
+ CONFIG_NET_VENDOR_TOSHIBA=y
+ CONFIG_TC35815=m
+ CONFIG_NET_VENDOR_VIA=y
+ CONFIG_NET_VENDOR_WIZNET=y
+ CONFIG_PHYLIB=m
+ CONFIG_MARVELL_PHY=m
+ CONFIG_DAVICOM_PHY=m
+ CONFIG_QSEMI_PHY=m
+ CONFIG_LXT_PHY=m
+ CONFIG_CICADA_PHY=m
+ CONFIG_VITESSE_PHY=m
+ CONFIG_SMSC_PHY=m
+ CONFIG_BROADCOM_PHY=m
+ CONFIG_ICPLUS_PHY=m
+ CONFIG_REALTEK_PHY=m
+ CONFIG_MDIO_BITBANG=m
+ CONFIG_WLAN=y
+ CONFIG_ATMEL=m
+ CONFIG_PCI_ATMEL=m
+ CONFIG_PRISM54=m
+ CONFIG_HOSTAP=m
+ CONFIG_HOSTAP_FIRMWARE=y
+ CONFIG_HOSTAP_FIRMWARE_NVRAM=y
+ CONFIG_HOSTAP_PLX=m
+ CONFIG_HOSTAP_PCI=m
+ CONFIG_IPW2100=m
+ CONFIG_IPW2100_MONITOR=y
+ CONFIG_LIBIPW=m
+ CONFIG_LIBERTAS=m
+ CONFIG_RTL_CARDS=m
+ CONFIG_INPUT=y
+ CONFIG_INPUT_MOUSEDEV=y
+ CONFIG_INPUT_MOUSEDEV_PSAUX=y
+ CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+ CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+ CONFIG_SERIO=y
+ CONFIG_ARCH_MIGHT_HAVE_PC_SERIO=y
+ CONFIG_SERIO_SERPORT=y
+ CONFIG_TTY=y
+ CONFIG_VT=y
+ CONFIG_CONSOLE_TRANSLATIONS=y
+ CONFIG_VT_CONSOLE=y
+ CONFIG_HW_CONSOLE=y
+ CONFIG_VT_HW_CONSOLE_BINDING=y
+ CONFIG_UNIX98_PTYS=y
+ CONFIG_LEGACY_PTYS=y
+ CONFIG_LEGACY_PTY_COUNT=256
+ CONFIG_DEVKMEM=y
+ CONFIG_SERIAL_8250=y
+ CONFIG_SERIAL_8250_DEPRECATED_OPTIONS=y
+ CONFIG_SERIAL_8250_CONSOLE=y
+ CONFIG_SERIAL_8250_PCI=y
+ CONFIG_SERIAL_8250_NR_UARTS=4
+ CONFIG_SERIAL_8250_RUNTIME_UARTS=4
+ CONFIG_SERIAL_CORE=y
+ CONFIG_SERIAL_CORE_CONSOLE=y
+ CONFIG_HW_RANDOM=m
+ CONFIG_DEVPORT=y
+ CONFIG_ARCH_HAVE_CUSTOM_GPIO_H=y
+ CONFIG_HWMON=y
+ CONFIG_SSB_POSSIBLE=y
+ CONFIG_BCMA_POSSIBLE=y
+ CONFIG_VGA_ARB=y
+ CONFIG_VGA_ARB_MAX_GPUS=16
+ CONFIG_FB=y
+ CONFIG_FB_CFB_FILLRECT=y
+ CONFIG_FB_CFB_COPYAREA=y
+ CONFIG_FB_CFB_IMAGEBLIT=y
+ CONFIG_FB_CIRRUS=y
+ CONFIG_DUMMY_CONSOLE=y
+ CONFIG_FRAMEBUFFER_CONSOLE=y
+ CONFIG_HID=m
+ CONFIG_HID_GENERIC=m
+ CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+ CONFIG_USB_SUPPORT=y
+ CONFIG_USB_ARCH_HAS_HCD=y
+ CONFIG_RTC_LIB=y
+ CONFIG_RTC_CLASS=y
+ CONFIG_RTC_HCTOSYS=y
+ CONFIG_RTC_SYSTOHC=y
+ CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+ CONFIG_RTC_INTF_SYSFS=y
+ CONFIG_RTC_INTF_PROC=y
+ CONFIG_RTC_INTF_DEV=y
+ CONFIG_RTC_DRV_CMOS=y
+ CONFIG_UIO=m
+ CONFIG_UIO_CIF=m
+ CONFIG_CLKSRC_I8253=y
+ CONFIG_CLKEVT_I8253=y
+ CONFIG_I8253_LOCK=y
+ CONFIG_CLKBLD_I8253=y
+ CONFIG_IOMMU_SUPPORT=y
+ CONFIG_EXT2_FS=y
+ CONFIG_EXT3_FS=y
+ CONFIG_EXT3_DEFAULTS_TO_ORDERED=y
+ CONFIG_EXT3_FS_XATTR=y
+ CONFIG_JBD=y
+ CONFIG_FS_MBCACHE=y
+ CONFIG_REISERFS_FS=m
+ CONFIG_REISERFS_PROC_INFO=y
+ CONFIG_REISERFS_FS_XATTR=y
+ CONFIG_REISERFS_FS_POSIX_ACL=y
+ CONFIG_REISERFS_FS_SECURITY=y
+ CONFIG_JFS_FS=m
+ CONFIG_JFS_POSIX_ACL=y
+ CONFIG_JFS_SECURITY=y
+ CONFIG_XFS_FS=m
+ CONFIG_XFS_QUOTA=y
+ CONFIG_XFS_POSIX_ACL=y
+ CONFIG_FS_POSIX_ACL=y
+ CONFIG_EXPORTFS=y
+ CONFIG_FILE_LOCKING=y
+ CONFIG_FSNOTIFY=y
+ CONFIG_DNOTIFY=y
+ CONFIG_INOTIFY_USER=y
+ CONFIG_QUOTA=y
+ CONFIG_PRINT_QUOTA_WARNING=y
+ CONFIG_QUOTA_TREE=y
+ CONFIG_QFMT_V2=y
+ CONFIG_QUOTACTL=y
+ CONFIG_FUSE_FS=m
+ CONFIG_ISO9660_FS=m
+ CONFIG_JOLIET=y
+ CONFIG_ZISOFS=y
+ CONFIG_UDF_FS=m
+ CONFIG_UDF_NLS=y
+ CONFIG_FAT_FS=m
+ CONFIG_MSDOS_FS=m
+ CONFIG_VFAT_FS=m
+ CONFIG_FAT_DEFAULT_CODEPAGE=437
+ CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+ CONFIG_PROC_FS=y
+ CONFIG_PROC_KCORE=y
+ CONFIG_PROC_SYSCTL=y
+ CONFIG_PROC_PAGE_MONITOR=y
+ CONFIG_SYSFS=y
+ CONFIG_TMPFS=y
+ CONFIG_MISC_FILESYSTEMS=y
+ CONFIG_AFFS_FS=m
+ CONFIG_HFS_FS=m
+ CONFIG_HFSPLUS_FS=m
+ CONFIG_BEFS_FS=m
+ CONFIG_BFS_FS=m
+ CONFIG_EFS_FS=m
+ CONFIG_JFFS2_FS=m
+ CONFIG_JFFS2_FS_DEBUG=0
+ CONFIG_JFFS2_FS_WRITEBUFFER=y
+ CONFIG_JFFS2_FS_XATTR=y
+ CONFIG_JFFS2_FS_POSIX_ACL=y
+ CONFIG_JFFS2_FS_SECURITY=y
+ CONFIG_JFFS2_COMPRESSION_OPTIONS=y
+ CONFIG_JFFS2_ZLIB=y
+ CONFIG_JFFS2_RTIME=y
+ CONFIG_JFFS2_RUBIN=y
+ CONFIG_JFFS2_CMODE_PRIORITY=y
+ CONFIG_CRAMFS=m
+ CONFIG_VXFS_FS=m
+ CONFIG_MINIX_FS=m
+ CONFIG_MINIX_FS_NATIVE_ENDIAN=y
+ CONFIG_ROMFS_FS=m
+ CONFIG_ROMFS_BACKED_BY_BLOCK=y
+ CONFIG_ROMFS_ON_BLOCK=y
+ CONFIG_SYSV_FS=m
+ CONFIG_UFS_FS=m
+ CONFIG_NETWORK_FILESYSTEMS=y
+ CONFIG_NFS_FS=y
+ CONFIG_NFS_V2=y
+ CONFIG_NFS_V3=y
+ CONFIG_ROOT_NFS=y
+ CONFIG_NFSD=y
+ CONFIG_NFSD_V3=y
+ CONFIG_LOCKD=y
+ CONFIG_LOCKD_V4=y
+ CONFIG_NFS_COMMON=y
+ CONFIG_SUNRPC=y
+ CONFIG_NLS=m
+ CONFIG_NLS_DEFAULT="iso8859-1"
+ CONFIG_NLS_CODEPAGE_437=m
+ CONFIG_NLS_CODEPAGE_737=m
+ CONFIG_NLS_CODEPAGE_775=m
+ CONFIG_NLS_CODEPAGE_850=m
+ CONFIG_NLS_CODEPAGE_852=m
+ CONFIG_NLS_CODEPAGE_855=m
+ CONFIG_NLS_CODEPAGE_857=m
+ CONFIG_NLS_CODEPAGE_860=m
+ CONFIG_NLS_CODEPAGE_861=m
+ CONFIG_NLS_CODEPAGE_862=m
+ CONFIG_NLS_CODEPAGE_863=m
+ CONFIG_NLS_CODEPAGE_864=m
+ CONFIG_NLS_CODEPAGE_865=m
+ CONFIG_NLS_CODEPAGE_866=m
+ CONFIG_NLS_CODEPAGE_869=m
+ CONFIG_NLS_CODEPAGE_936=m
+ CONFIG_NLS_CODEPAGE_950=m
+ CONFIG_NLS_CODEPAGE_932=m
+ CONFIG_NLS_CODEPAGE_949=m
+ CONFIG_NLS_CODEPAGE_874=m
+ CONFIG_NLS_ISO8859_8=m
+ CONFIG_NLS_CODEPAGE_1250=m
+ CONFIG_NLS_CODEPAGE_1251=m
+ CONFIG_NLS_ASCII=m
+ CONFIG_NLS_ISO8859_1=m
+ CONFIG_NLS_ISO8859_2=m
+ CONFIG_NLS_ISO8859_3=m
+ CONFIG_NLS_ISO8859_4=m
+ CONFIG_NLS_ISO8859_5=m
+ CONFIG_NLS_ISO8859_6=m
+ CONFIG_NLS_ISO8859_7=m
+ CONFIG_NLS_ISO8859_9=m
+ CONFIG_NLS_ISO8859_13=m
+ CONFIG_NLS_ISO8859_14=m
+ CONFIG_NLS_ISO8859_15=m
+ CONFIG_NLS_KOI8_R=m
+ CONFIG_NLS_KOI8_U=m
+ CONFIG_NLS_UTF8=m
+ CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+ CONFIG_DEFAULT_MESSAGE_LOGLEVEL=4
+ CONFIG_ENABLE_WARN_DEPRECATED=y
+ CONFIG_ENABLE_MUST_CHECK=y
+ CONFIG_FRAME_WARN=1024
+ CONFIG_DEBUG_KERNEL=y
+ CONFIG_HAVE_DEBUG_KMEMLEAK=y
+ CONFIG_HAVE_DEBUG_STACKOVERFLOW=y
+ CONFIG_PANIC_ON_OOPS_VALUE=0
+ CONFIG_PANIC_TIMEOUT=0
+ CONFIG_SCHED_DEBUG=y
+ CONFIG_RCU_CPU_STALL_TIMEOUT=21
+ CONFIG_HAVE_FUNCTION_TRACER=y
+ CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+ CONFIG_HAVE_FUNCTION_TRACE_MCOUNT_TEST=y
+ CONFIG_HAVE_DYNAMIC_FTRACE=y
+ CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+ CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+ CONFIG_HAVE_C_RECORDMCOUNT=y
+ CONFIG_TRACING_SUPPORT=y
+ CONFIG_FTRACE=y
+ CONFIG_BRANCH_PROFILE_NONE=y
+ CONFIG_HAVE_ARCH_KGDB=y
+ CONFIG_CMDLINE_BOOL=y
+ CONFIG_CMDLINE="root=/dev/ram rw debug verbose"
+ CONFIG_DEFAULT_SECURITY_DAC=y
+ CONFIG_DEFAULT_SECURITY=""
+ CONFIG_XOR_BLOCKS=m
+ CONFIG_ASYNC_CORE=m
+ CONFIG_ASYNC_MEMCPY=m
+ CONFIG_ASYNC_XOR=m
+ CONFIG_ASYNC_PQ=m
+ CONFIG_ASYNC_RAID6_RECOV=m
+ CONFIG_CRYPTO=y
+ CONFIG_CRYPTO_ALGAPI=y
+ CONFIG_CRYPTO_ALGAPI2=y
+ CONFIG_CRYPTO_AEAD=m
+ CONFIG_CRYPTO_AEAD2=y
+ CONFIG_CRYPTO_BLKCIPHER=m
+ CONFIG_CRYPTO_BLKCIPHER2=y
+ CONFIG_CRYPTO_HASH=y
+ CONFIG_CRYPTO_HASH2=y
+ CONFIG_CRYPTO_RNG=m
+ CONFIG_CRYPTO_RNG2=y
+ CONFIG_CRYPTO_PCOMP2=y
+ CONFIG_CRYPTO_MANAGER=y
+ CONFIG_CRYPTO_MANAGER2=y
+ CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
+ CONFIG_CRYPTO_GF128MUL=m
+ CONFIG_CRYPTO_NULL=m
+ CONFIG_CRYPTO_WORKQUEUE=y
+ CONFIG_CRYPTO_CRYPTD=m
+ CONFIG_CRYPTO_AUTHENC=m
+ CONFIG_CRYPTO_CCM=m
+ CONFIG_CRYPTO_SEQIV=m
+ CONFIG_CRYPTO_CBC=m
+ CONFIG_CRYPTO_CTR=m
+ CONFIG_CRYPTO_ECB=m
+ CONFIG_CRYPTO_LRW=m
+ CONFIG_CRYPTO_PCBC=m
+ CONFIG_CRYPTO_HMAC=y
+ CONFIG_CRYPTO_XCBC=m
+ CONFIG_CRYPTO_CRC32C=m
+ CONFIG_CRYPTO_MD4=m
+ CONFIG_CRYPTO_MD5=y
+ CONFIG_CRYPTO_MICHAEL_MIC=m
+ CONFIG_CRYPTO_SHA1=m
+ CONFIG_CRYPTO_SHA256=m
+ CONFIG_CRYPTO_SHA512=m
+ CONFIG_CRYPTO_TGR192=m
+ CONFIG_CRYPTO_WP512=m
+ CONFIG_CRYPTO_AES=y
+ CONFIG_CRYPTO_ANUBIS=m
+ CONFIG_CRYPTO_ARC4=m
+ CONFIG_CRYPTO_BLOWFISH=m
+ CONFIG_CRYPTO_BLOWFISH_COMMON=m
+ CONFIG_CRYPTO_CAMELLIA=m
+ CONFIG_CRYPTO_CAST_COMMON=m
+ CONFIG_CRYPTO_CAST5=m
+ CONFIG_CRYPTO_CAST6=m
+ CONFIG_CRYPTO_DES=m
+ CONFIG_CRYPTO_FCRYPT=m
+ CONFIG_CRYPTO_KHAZAD=m
+ CONFIG_CRYPTO_SERPENT=m
+ CONFIG_CRYPTO_TEA=m
+ CONFIG_CRYPTO_TWOFISH=m
+ CONFIG_CRYPTO_TWOFISH_COMMON=m
+ CONFIG_CRYPTO_DEFLATE=m
+ CONFIG_CRYPTO_HW=y
+ CONFIG_RAID6_PQ=m
+ CONFIG_BITREVERSE=y
+ CONFIG_GENERIC_NET_UTILS=y
+ CONFIG_NO_GENERIC_PCI_IOPORT_MAP=y
+ CONFIG_GENERIC_PCI_IOMAP=y
+ CONFIG_GENERIC_IO=y
+ CONFIG_CRC16=m
+ CONFIG_CRC_ITU_T=m
+ CONFIG_CRC32=y
+ CONFIG_CRC32_SLICEBY8=y
+ CONFIG_LIBCRC32C=m
+ CONFIG_ZLIB_INFLATE=m
+ CONFIG_ZLIB_DEFLATE=m
+ CONFIG_TEXTSEARCH=y
+ CONFIG_TEXTSEARCH_KMP=m
+ CONFIG_TEXTSEARCH_BM=m
+ CONFIG_TEXTSEARCH_FSM=m
+ CONFIG_HAS_IOMEM=y
+ CONFIG_HAS_IOPORT=y
+ CONFIG_HAS_DMA=y
+ CONFIG_CPU_RMAP=y
+ CONFIG_DQL=y
+ CONFIG_NLATTR=y
+ CONFIG_GENERIC_ATOMIC64=y
+ CONFIG_ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE=y
+ CONFIG_AVERAGE=y
+ CONFIG_FONT_SUPPORT=y
+ CONFIG_FONT_8x8=y
+ CONFIG_FONT_8x16=y
+ CONFIG_HAVE_KVM=y
diff -rcNP linux-4.4.24/arch/mips/configs/baikal_module_defconfig linux-4.4.24-baikal/arch/mips/configs/baikal_module_defconfig
*** linux-4.4.24/arch/mips/configs/baikal_module_defconfig	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/arch/mips/configs/baikal_module_defconfig	2016-11-11 14:49:51.000000000 +0300
***************
*** 0 ****
--- 1,1018 ----
+ # 
+ # Baikal-T MODULE board default kernel configuration
+ #
+ # Copyright (C) 2014-2016 Baikal Electronics JSC
+ # 
+ # Author:
+ #   Dmitry Dunaev <dmitry.dunaev@baikalelectronics.ru>
+ #
+ # This program is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU General Public License
+ # as published by the Free Software Foundation; either version 2
+ # of the License, or (at your option) any later version.
+ #
+ # This program is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ # GNU General Public License for more details.
+ #
+ # You should have received a copy of the GNU General Public License
+ # along with this program; if not, write to the Free Software
+ # Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ #
+ 
+ CONFIG_MIPS=y
+ CONFIG_MIPS_BAIKAL=y
+ CONFIG_ARCH_BAIKAL=y
+ CONFIG_MACH_BAIKAL_MODULE=y
+ CONFIG_DTB_BAIKAL_MODULE=y
+ CONFIG_BAIKAL_ERRATA=y
+ CONFIG_BAIKAL_ERRATA_XGMAC=y
+ CONFIG_BAIKAL_ERRATA_GMAC=y
+ CONFIG_SYS_HAS_CPU_MIPS32_R5=y
+ CONFIG_RWSEM_GENERIC_SPINLOCK=y
+ CONFIG_GENERIC_HWEIGHT=y
+ CONFIG_GENERIC_CALIBRATE_DELAY=y
+ CONFIG_SCHED_OMIT_FRAME_POINTER=y
+ CONFIG_BOOT_RAW=y
+ CONFIG_MIPS_CLOCK_VSYSCALL=y
+ CONFIG_ARCH_SUPPORTS_UPROBES=y
+ CONFIG_DMA_NONCOHERENT=y
+ CONFIG_NEED_DMA_MAP_STATE=y
+ CONFIG_SYS_HAS_EARLY_PRINTK=y
+ CONFIG_HOTPLUG_CPU=y
+ CONFIG_SYS_SUPPORTS_HOTPLUG_CPU=y
+ CONFIG_MIPS_MACHINE=y
+ CONFIG_GENERIC_ISA_DMA=y
+ CONFIG_ISA_DMA_API=y
+ CONFIG_CPU_LITTLE_ENDIAN=y
+ CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
+ CONFIG_MIPS_SPRAM=y
+ CONFIG_SWAP_IO_SPACE=y
+ CONFIG_BOOT_ELF32=y
+ CONFIG_MIPS_L1_CACHE_SHIFT=5
+ CONFIG_CPU_MIPS32_R2=y
+ CONFIG_CPU_MIPS32_3_5_FEATURES=y
+ CONFIG_CPU_MIPS32_3_5_EVA=y
+ CONFIG_CPU_MIPS32_R5_FEATURES=y
+ CONFIG_SYS_SUPPORTS_ZBOOT=y
+ CONFIG_SYS_SUPPORTS_ZBOOT_UART16550=y
+ CONFIG_SYS_HAS_CPU_MIPS32_R2=y
+ CONFIG_SYS_HAS_CPU_MIPS32_R3_5=y
+ CONFIG_WEAK_ORDERING=y
+ CONFIG_CPU_MIPS32=y
+ CONFIG_CPU_MIPSR2=y
+ CONFIG_EVA=y
+ CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+ CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+ CONFIG_CPU_SUPPORTS_CPUFREQ=y
+ CONFIG_CPU_SUPPORTS_UNCACHED_ACCELERATED=y
+ CONFIG_HARDWARE_WATCHPOINTS=y
+ CONFIG_32BIT=y
+ CONFIG_PAGE_SIZE_16KB=y
+ CONFIG_FORCE_MAX_ZONEORDER=11
+ CONFIG_BOARD_SCACHE=y
+ CONFIG_MIPS_CPU_SCACHE=y
+ CONFIG_CPU_HAS_PREFETCH=y
+ CONFIG_CPU_GENERIC_DUMP_TLB=y
+ CONFIG_CPU_R4K_FPU=y
+ CONFIG_CPU_R4K_CACHE_TLB=y
+ CONFIG_MIPS_CPS=y
+ CONFIG_MIPS_CPS_PM=y
+ CONFIG_MIPS_GIC_IPI=y
+ CONFIG_MIPS_GIC_IPI_LOW=y
+ CONFIG_MIPS_CM=y
+ CONFIG_MIPS_CPC=y
+ CONFIG_CPU_NEEDS_NO_SMARTMIPS_OR_MICROMIPS=y
+ CONFIG_CPU_HAS_MSA=y
+ CONFIG_CPU_MIPSR2_IRQ_VI=y
+ CONFIG_CPU_MIPSR2_IRQ_EI=y
+ CONFIG_CPU_HAS_SYNC=y
+ CONFIG_CPU_SUPPORTS_HIGHMEM=y
+ CONFIG_SYS_SUPPORTS_HIGHMEM=y
+ CONFIG_CPU_SUPPORTS_MSA=y
+ CONFIG_ARCH_FLATMEM_ENABLE=y
+ CONFIG_HW_PERF_EVENTS=y
+ CONFIG_FLATMEM=y
+ CONFIG_FLAT_NODE_MEM_MAP=y
+ CONFIG_HAVE_MEMBLOCK=y
+ CONFIG_HAVE_MEMBLOCK_NODE_MAP=y
+ CONFIG_ARCH_DISCARD_MEMBLOCK=y
+ CONFIG_SPLIT_PTLOCK_CPUS=4
+ CONFIG_COMPACTION=y
+ CONFIG_MIGRATION=y
+ CONFIG_ZONE_DMA_FLAG=1
+ CONFIG_BOUNCE=y
+ CONFIG_VIRT_TO_BUS=y
+ CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+ CONFIG_SMP=y
+ CONFIG_SYS_SUPPORTS_MIPS_CPS=y
+ CONFIG_SYS_SUPPORTS_SMP=y
+ CONFIG_NR_CPUS=2
+ CONFIG_HZ_100=y
+ CONFIG_SYS_SUPPORTS_ARBIT_HZ=y
+ CONFIG_HZ=100
+ CONFIG_SCHED_HRTICK=y
+ CONFIG_PREEMPT_NONE=y
+ CONFIG_KEXEC=y
+ CONFIG_SECCOMP=y
+ CONFIG_MIPS_O32_FP64_SUPPORT=y
+ CONFIG_USE_OF=y
+ CONFIG_MIPS_NO_APPENDED_DTB=y
+ CONFIG_MIPS_CMDLINE_FROM_DTB=y
+ CONFIG_LOCKDEP_SUPPORT=y
+ CONFIG_STACKTRACE_SUPPORT=y
+ CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+ CONFIG_PGTABLE_LEVELS=2
+ CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+ CONFIG_IRQ_WORK=y
+ CONFIG_BUILDTIME_EXTABLE_SORT=y
+ CONFIG_INIT_ENV_ARG_LIMIT=32
+ CONFIG_CROSS_COMPILE=""
+ CONFIG_LOCALVERSION="-module"
+ CONFIG_LOCALVERSION_AUTO=y
+ CONFIG_HAVE_KERNEL_GZIP=y
+ CONFIG_HAVE_KERNEL_BZIP2=y
+ CONFIG_HAVE_KERNEL_LZMA=y
+ CONFIG_HAVE_KERNEL_XZ=y
+ CONFIG_HAVE_KERNEL_LZO=y
+ CONFIG_HAVE_KERNEL_LZ4=y
+ CONFIG_KERNEL_GZIP=y
+ CONFIG_DEFAULT_HOSTNAME="baikal"
+ CONFIG_SWAP=y
+ CONFIG_SYSVIPC=y
+ CONFIG_SYSVIPC_SYSCTL=y
+ CONFIG_POSIX_MQUEUE=y
+ CONFIG_POSIX_MQUEUE_SYSCTL=y
+ CONFIG_CROSS_MEMORY_ATTACH=y
+ CONFIG_FHANDLE=y
+ CONFIG_USELIB=y
+ CONFIG_AUDIT=y
+ CONFIG_GENERIC_IRQ_PROBE=y
+ CONFIG_GENERIC_IRQ_SHOW=y
+ CONFIG_GENERIC_IRQ_CHIP=y
+ CONFIG_IRQ_DOMAIN=y
+ CONFIG_GENERIC_MSI_IRQ=y
+ CONFIG_IRQ_DOMAIN_DEBUG=y
+ CONFIG_IRQ_FORCED_THREADING=y
+ CONFIG_ARCH_CLOCKSOURCE_DATA=y
+ CONFIG_GENERIC_TIME_VSYSCALL=y
+ CONFIG_GENERIC_CLOCKEVENTS=y
+ CONFIG_GENERIC_CMOS_UPDATE=y
+ CONFIG_TICK_ONESHOT=y
+ CONFIG_NO_HZ_COMMON=y
+ CONFIG_NO_HZ_IDLE=y
+ CONFIG_HIGH_RES_TIMERS=y
+ CONFIG_TICK_CPU_ACCOUNTING=y
+ CONFIG_TREE_RCU=y
+ CONFIG_SRCU=y
+ CONFIG_RCU_STALL_COMMON=y
+ CONFIG_BUILD_BIN2C=y
+ CONFIG_IKCONFIG=y
+ CONFIG_IKCONFIG_PROC=y
+ CONFIG_LOG_BUF_SHIFT=15
+ CONFIG_LOG_CPU_MAX_BUF_SHIFT=12
+ CONFIG_GENERIC_SCHED_CLOCK=y
+ CONFIG_CGROUPS=y
+ CONFIG_CGROUP_PERF=y
+ CONFIG_NAMESPACES=y
+ CONFIG_UTS_NS=y
+ CONFIG_IPC_NS=y
+ CONFIG_PID_NS=y
+ CONFIG_NET_NS=y
+ CONFIG_RELAY=y
+ CONFIG_BLK_DEV_INITRD=y
+ CONFIG_INITRAMFS_SOURCE=""
+ CONFIG_RD_GZIP=y
+ CONFIG_RD_BZIP2=y
+ CONFIG_RD_LZMA=y
+ CONFIG_RD_XZ=y
+ CONFIG_RD_LZO=y
+ CONFIG_RD_LZ4=y
+ CONFIG_SYSCTL=y
+ CONFIG_ANON_INODES=y
+ CONFIG_SYSCTL_EXCEPTION_TRACE=y
+ CONFIG_BPF=y
+ CONFIG_EXPERT=y
+ CONFIG_MULTIUSER=y
+ CONFIG_SGETMASK_SYSCALL=y
+ CONFIG_SYSFS_SYSCALL=y
+ CONFIG_KALLSYMS=y
+ CONFIG_PRINTK=y
+ CONFIG_BUG=y
+ CONFIG_ELF_CORE=y
+ CONFIG_BASE_FULL=y
+ CONFIG_FUTEX=y
+ CONFIG_EPOLL=y
+ CONFIG_SIGNALFD=y
+ CONFIG_TIMERFD=y
+ CONFIG_EVENTFD=y
+ CONFIG_SHMEM=y
+ CONFIG_AIO=y
+ CONFIG_ADVISE_SYSCALLS=y
+ CONFIG_PCI_QUIRKS=y
+ CONFIG_MEMBARRIER=y
+ CONFIG_HAVE_PERF_EVENTS=y
+ CONFIG_PERF_USE_VMALLOC=y
+ CONFIG_PERF_EVENTS=y
+ CONFIG_DEBUG_PERF_USE_VMALLOC=y
+ CONFIG_VM_EVENT_COUNTERS=y
+ CONFIG_COMPAT_BRK=y
+ CONFIG_SLAB=y
+ CONFIG_KEXEC_CORE=y
+ CONFIG_HAVE_OPROFILE=y
+ CONFIG_ARCH_USE_BUILTIN_BSWAP=y
+ CONFIG_HAVE_KPROBES=y
+ CONFIG_HAVE_KRETPROBES=y
+ CONFIG_HAVE_ARCH_TRACEHOOK=y
+ CONFIG_HAVE_DMA_ATTRS=y
+ CONFIG_HAVE_DMA_CONTIGUOUS=y
+ CONFIG_GENERIC_SMP_IDLE_THREAD=y
+ CONFIG_HAVE_CLK=y
+ CONFIG_HAVE_DMA_API_DEBUG=y
+ CONFIG_HAVE_ARCH_JUMP_LABEL=y
+ CONFIG_ARCH_WANT_IPC_PARSE_VERSION=y
+ CONFIG_HAVE_ARCH_SECCOMP_FILTER=y
+ CONFIG_SECCOMP_FILTER=y
+ CONFIG_HAVE_CC_STACKPROTECTOR=y
+ CONFIG_CC_STACKPROTECTOR_NONE=y
+ CONFIG_HAVE_CONTEXT_TRACKING=y
+ CONFIG_HAVE_VIRT_CPU_ACCOUNTING_GEN=y
+ CONFIG_HAVE_IRQ_TIME_ACCOUNTING=y
+ CONFIG_HAVE_MOD_ARCH_SPECIFIC=y
+ CONFIG_MODULES_USE_ELF_REL=y
+ CONFIG_ARCH_HAS_ELF_RANDOMIZE=y
+ CONFIG_CLONE_BACKWARDS=y
+ CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+ CONFIG_SLABINFO=y
+ CONFIG_RT_MUTEXES=y
+ CONFIG_BASE_SMALL=0
+ CONFIG_MODULES=y
+ CONFIG_MODULE_UNLOAD=y
+ CONFIG_MODVERSIONS=y
+ CONFIG_MODULE_SRCVERSION_ALL=y
+ CONFIG_MODULES_TREE_LOOKUP=y
+ CONFIG_BLOCK=y
+ CONFIG_LBDAF=y
+ CONFIG_BLK_DEV_BSG=y
+ CONFIG_BLK_DEV_BSGLIB=y
+ CONFIG_MSDOS_PARTITION=y
+ CONFIG_EFI_PARTITION=y
+ CONFIG_IOSCHED_NOOP=y
+ CONFIG_IOSCHED_DEADLINE=y
+ CONFIG_IOSCHED_CFQ=y
+ CONFIG_DEFAULT_CFQ=y
+ CONFIG_DEFAULT_IOSCHED="cfq"
+ CONFIG_INLINE_SPIN_UNLOCK_IRQ=y
+ CONFIG_INLINE_READ_UNLOCK=y
+ CONFIG_INLINE_READ_UNLOCK_IRQ=y
+ CONFIG_INLINE_WRITE_UNLOCK=y
+ CONFIG_INLINE_WRITE_UNLOCK_IRQ=y
+ CONFIG_FREEZER=y
+ CONFIG_HW_HAS_PCI=y
+ CONFIG_PCI=y
+ CONFIG_PCI_DOMAINS=y
+ CONFIG_PCI_MSI=y
+ CONFIG_PCI_DEBUG=y
+ CONFIG_PCI_REALLOC_ENABLE_AUTO=y
+ CONFIG_PCI_STUB=y
+ CONFIG_PCI_ATS=y
+ CONFIG_PCI_IOV=y
+ CONFIG_PCI_PRI=y
+ CONFIG_PCI_PASID=y
+ CONFIG_PCIEPORTBUS=y
+ CONFIG_PCIEAER=y
+ CONFIG_PCIE_ECRC=y
+ CONFIG_PCIEAER_INJECT=y
+ CONFIG_PCIEASPM=y
+ CONFIG_PCIEASPM_DEFAULT=y
+ CONFIG_PCIE_PME=y
+ CONFIG_MMU=y
+ CONFIG_ZONE_DMA=y
+ CONFIG_BINFMT_ELF=y
+ CONFIG_ARCH_BINFMT_ELF_STATE=y
+ CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS=y
+ CONFIG_BINFMT_SCRIPT=y
+ CONFIG_COREDUMP=y
+ CONFIG_TRAD_SIGNALS=y
+ CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+ CONFIG_ARCH_SUSPEND_POSSIBLE=y
+ CONFIG_SUSPEND=y
+ CONFIG_SUSPEND_FREEZER=y
+ CONFIG_PM_SLEEP=y
+ CONFIG_PM_SLEEP_SMP=y
+ CONFIG_PM=y
+ CONFIG_PM_CLK=y
+ CONFIG_NET=y
+ CONFIG_NET_INGRESS=y
+ CONFIG_PACKET=y
+ CONFIG_PACKET_DIAG=y
+ CONFIG_UNIX=y
+ CONFIG_UNIX_DIAG=y
+ CONFIG_XFRM=y
+ CONFIG_XFRM_ALGO=y
+ CONFIG_XFRM_USER=y
+ CONFIG_XFRM_IPCOMP=y
+ CONFIG_NET_KEY=y
+ CONFIG_INET=y
+ CONFIG_IP_MULTICAST=y
+ CONFIG_IP_PNP=y
+ CONFIG_NET_IP_TUNNEL=y
+ CONFIG_SYN_COOKIES=y
+ CONFIG_INET_AH=y
+ CONFIG_INET_ESP=y
+ CONFIG_INET_IPCOMP=y
+ CONFIG_INET_XFRM_TUNNEL=y
+ CONFIG_INET_TUNNEL=y
+ CONFIG_INET_XFRM_MODE_TRANSPORT=y
+ CONFIG_INET_XFRM_MODE_TUNNEL=y
+ CONFIG_INET_XFRM_MODE_BEET=y
+ CONFIG_INET_LRO=y
+ CONFIG_INET_DIAG=y
+ CONFIG_INET_TCP_DIAG=y
+ CONFIG_INET_UDP_DIAG=y
+ CONFIG_TCP_CONG_CUBIC=y
+ CONFIG_DEFAULT_TCP_CONG="cubic"
+ CONFIG_IPV6=y
+ CONFIG_INET6_AH=y
+ CONFIG_INET6_ESP=y
+ CONFIG_INET6_IPCOMP=y
+ CONFIG_INET6_XFRM_TUNNEL=y
+ CONFIG_INET6_TUNNEL=y
+ CONFIG_INET6_XFRM_MODE_TRANSPORT=y
+ CONFIG_INET6_XFRM_MODE_TUNNEL=y
+ CONFIG_INET6_XFRM_MODE_BEET=y
+ CONFIG_IPV6_SIT=y
+ CONFIG_IPV6_NDISC_NODETYPE=y
+ CONFIG_NET_PTP_CLASSIFY=y
+ CONFIG_NETFILTER=y
+ CONFIG_NETFILTER_ADVANCED=y
+ CONFIG_NETFILTER_INGRESS=y
+ CONFIG_NETFILTER_NETLINK=y
+ CONFIG_NETFILTER_NETLINK_QUEUE=y
+ CONFIG_NETFILTER_NETLINK_LOG=y
+ CONFIG_NF_TABLES=y
+ CONFIG_NF_TABLES_INET=y
+ CONFIG_NF_TABLES_NETDEV=y
+ CONFIG_NFT_EXTHDR=y
+ CONFIG_NFT_META=y
+ CONFIG_NFT_RBTREE=y
+ CONFIG_NFT_HASH=y
+ CONFIG_NFT_COUNTER=y
+ CONFIG_NFT_LOG=y
+ CONFIG_NFT_LIMIT=y
+ CONFIG_NFT_REJECT=y
+ CONFIG_NFT_REJECT_INET=y
+ CONFIG_NETFILTER_XTABLES=y
+ CONFIG_NETFILTER_XT_MARK=y
+ CONFIG_NETFILTER_XT_TARGET_AUDIT=y
+ CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
+ CONFIG_NETFILTER_XT_TARGET_MARK=y
+ CONFIG_NETFILTER_XT_TARGET_NFLOG=y
+ CONFIG_NETFILTER_XT_TARGET_NFQUEUE=y
+ CONFIG_NETFILTER_XT_MATCH_ADDRTYPE=y
+ CONFIG_NETFILTER_XT_MATCH_CGROUP=y
+ CONFIG_NETFILTER_XT_MATCH_CPU=y
+ CONFIG_NETFILTER_XT_MATCH_ECN=y
+ CONFIG_NETFILTER_XT_MATCH_HL=y
+ CONFIG_NETFILTER_XT_MATCH_IPRANGE=y
+ CONFIG_NETFILTER_XT_MATCH_LENGTH=y
+ CONFIG_NETFILTER_XT_MATCH_LIMIT=y
+ CONFIG_NETFILTER_XT_MATCH_MAC=y
+ CONFIG_NETFILTER_XT_MATCH_MULTIPORT=y
+ CONFIG_NETFILTER_XT_MATCH_OWNER=y
+ CONFIG_NETFILTER_XT_MATCH_POLICY=y
+ CONFIG_NETFILTER_XT_MATCH_PKTTYPE=y
+ CONFIG_NETFILTER_XT_MATCH_RECENT=y
+ CONFIG_NETFILTER_XT_MATCH_SOCKET=y
+ CONFIG_NETFILTER_XT_MATCH_TCPMSS=y
+ CONFIG_NF_DEFRAG_IPV4=y
+ CONFIG_NF_TABLES_IPV4=y
+ CONFIG_NFT_CHAIN_ROUTE_IPV4=y
+ CONFIG_NFT_REJECT_IPV4=y
+ CONFIG_NFT_DUP_IPV4=y
+ CONFIG_NF_TABLES_ARP=y
+ CONFIG_NF_DUP_IPV4=y
+ CONFIG_NF_REJECT_IPV4=y
+ CONFIG_IP_NF_IPTABLES=y
+ CONFIG_IP_NF_MATCH_AH=y
+ CONFIG_IP_NF_MATCH_ECN=y
+ CONFIG_IP_NF_MATCH_TTL=y
+ CONFIG_IP_NF_FILTER=y
+ CONFIG_IP_NF_TARGET_REJECT=y
+ CONFIG_IP_NF_RAW=y
+ CONFIG_IP_NF_ARPTABLES=y
+ CONFIG_IP_NF_ARPFILTER=y
+ CONFIG_IP_NF_ARP_MANGLE=y
+ CONFIG_NF_DEFRAG_IPV6=y
+ CONFIG_NF_TABLES_IPV6=y
+ CONFIG_NFT_CHAIN_ROUTE_IPV6=y
+ CONFIG_NFT_REJECT_IPV6=y
+ CONFIG_NFT_DUP_IPV6=y
+ CONFIG_NF_DUP_IPV6=y
+ CONFIG_NF_REJECT_IPV6=y
+ CONFIG_IP6_NF_IPTABLES=y
+ CONFIG_IP6_NF_MATCH_AH=y
+ CONFIG_IP6_NF_MATCH_EUI64=y
+ CONFIG_IP6_NF_MATCH_FRAG=y
+ CONFIG_IP6_NF_MATCH_OPTS=y
+ CONFIG_IP6_NF_MATCH_HL=y
+ CONFIG_IP6_NF_MATCH_IPV6HEADER=y
+ CONFIG_IP6_NF_MATCH_MH=y
+ CONFIG_IP6_NF_MATCH_RT=y
+ CONFIG_IP6_NF_FILTER=y
+ CONFIG_IP6_NF_TARGET_REJECT=y
+ CONFIG_IP6_NF_RAW=y
+ CONFIG_HAVE_NET_DSA=y
+ CONFIG_DNS_RESOLVER=y
+ CONFIG_NETLINK_DIAG=y
+ CONFIG_RPS=y
+ CONFIG_RFS_ACCEL=y
+ CONFIG_XPS=y
+ CONFIG_CGROUP_NET_CLASSID=y
+ CONFIG_NET_RX_BUSY_POLL=y
+ CONFIG_BQL=y
+ CONFIG_NET_FLOW_LIMIT=y
+ CONFIG_WIRELESS=y
+ CONFIG_MAC80211_STA_HASH_MAX_SIZE=0
+ CONFIG_HAVE_BPF_JIT=y
+ CONFIG_UEVENT_HELPER=y
+ CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+ CONFIG_DEVTMPFS=y
+ CONFIG_DEVTMPFS_MOUNT=y
+ CONFIG_STANDALONE=y
+ CONFIG_PREVENT_FIRMWARE_BUILD=y
+ CONFIG_FW_LOADER=y
+ CONFIG_FIRMWARE_IN_KERNEL=y
+ CONFIG_EXTRA_FIRMWARE=""
+ CONFIG_ALLOW_DEV_COREDUMP=y
+ CONFIG_DEBUG_DRIVER=y
+ CONFIG_DEBUG_DEVRES=y
+ CONFIG_SOC_BUS=y
+ CONFIG_REGMAP=y
+ CONFIG_REGMAP_I2C=y
+ CONFIG_REGMAP_SPI=y
+ CONFIG_REGMAP_MMIO=y
+ CONFIG_DMA_SHARED_BUFFER=y
+ CONFIG_MIPS_CDMM=y
+ CONFIG_MTD=y
+ CONFIG_MTD_OF_PARTS=y
+ CONFIG_MTD_BLKDEVS=y
+ CONFIG_MTD_BLOCK=y
+ CONFIG_MTD_MAP_BANK_WIDTH_1=y
+ CONFIG_MTD_MAP_BANK_WIDTH_2=y
+ CONFIG_MTD_MAP_BANK_WIDTH_4=y
+ CONFIG_MTD_CFI_I1=y
+ CONFIG_MTD_CFI_I2=y
+ CONFIG_MTD_RAM=y
+ CONFIG_MTD_ROM=y
+ CONFIG_MTD_PHYSMAP=y
+ CONFIG_MTD_PHYSMAP_OF=y
+ CONFIG_MTD_PLATRAM=y
+ CONFIG_MTD_M25P80=y
+ CONFIG_MTD_SPI_NOR=y
+ CONFIG_MTD_SPI_NOR_USE_4K_SECTORS=y
+ CONFIG_DTC=y
+ CONFIG_OF=y
+ CONFIG_OF_FLATTREE=y
+ CONFIG_OF_EARLY_FLATTREE=y
+ CONFIG_OF_ADDRESS=y
+ CONFIG_OF_ADDRESS_PCI=y
+ CONFIG_OF_IRQ=y
+ CONFIG_OF_NET=y
+ CONFIG_OF_MDIO=y
+ CONFIG_OF_PCI=y
+ CONFIG_OF_PCI_IRQ=y
+ CONFIG_OF_MTD=y
+ CONFIG_ARCH_MIGHT_HAVE_PC_PARPORT=y
+ CONFIG_BLK_DEV=y
+ CONFIG_BLK_DEV_LOOP=y
+ CONFIG_BLK_DEV_LOOP_MIN_COUNT=4
+ CONFIG_BLK_DEV_NBD=y
+ CONFIG_BLK_DEV_RAM=y
+ CONFIG_BLK_DEV_RAM_COUNT=4
+ CONFIG_BLK_DEV_RAM_SIZE=16384
+ CONFIG_SRAM=y
+ CONFIG_EEPROM_AT24=y
+ CONFIG_EEPROM_AT25=y
+ CONFIG_HAVE_IDE=y
+ CONFIG_SCSI_MOD=y
+ CONFIG_RAID_ATTRS=y
+ CONFIG_SCSI=y
+ CONFIG_SCSI_DMA=y
+ CONFIG_SCSI_PROC_FS=y
+ CONFIG_BLK_DEV_SD=y
+ CONFIG_CHR_DEV_SG=y
+ CONFIG_SCSI_CONSTANTS=y
+ CONFIG_SCSI_LOGGING=y
+ CONFIG_SCSI_SCAN_ASYNC=y
+ CONFIG_SCSI_LOWLEVEL=y
+ CONFIG_ATA=y
+ CONFIG_ATA_VERBOSE_ERROR=y
+ CONFIG_SATA_PMP=y
+ CONFIG_SATA_AHCI_PLATFORM=y
+ CONFIG_ATA_SFF=y
+ CONFIG_ATA_BMDMA=y
+ CONFIG_NETDEVICES=y
+ CONFIG_MII=y
+ CONFIG_NET_CORE=y
+ CONFIG_ETHERNET=y
+ CONFIG_MDIO=y
+ CONFIG_NET_VENDOR_3COM=y
+ CONFIG_NET_VENDOR_ADAPTEC=y
+ CONFIG_NET_VENDOR_AGERE=y
+ CONFIG_NET_VENDOR_ALTEON=y
+ CONFIG_NET_VENDOR_AMD=y
+ CONFIG_NET_VENDOR_ARC=y
+ CONFIG_NET_VENDOR_ATHEROS=y
+ CONFIG_NET_CADENCE=y
+ CONFIG_NET_VENDOR_BAIKAL=y
+ CONFIG_BAIKAL_XGBE=y
+ CONFIG_NET_VENDOR_BROADCOM=y
+ CONFIG_NET_VENDOR_BROCADE=y
+ CONFIG_NET_VENDOR_CAVIUM=y
+ CONFIG_NET_VENDOR_CHELSIO=y
+ CONFIG_NET_VENDOR_CISCO=y
+ CONFIG_NET_VENDOR_DEC=y
+ CONFIG_NET_VENDOR_DLINK=y
+ CONFIG_NET_VENDOR_EMULEX=y
+ CONFIG_NET_VENDOR_EZCHIP=y
+ CONFIG_NET_VENDOR_EXAR=y
+ CONFIG_NET_VENDOR_HP=y
+ CONFIG_NET_VENDOR_INTEL=y
+ CONFIG_E1000=y
+ CONFIG_E1000E=y
+ CONFIG_IXGB=y
+ CONFIG_IXGBE=y
+ CONFIG_IXGBE_HWMON=y
+ CONFIG_IXGBEVF=y
+ CONFIG_NET_VENDOR_I825XX=y
+ CONFIG_NET_VENDOR_MARVELL=y
+ CONFIG_NET_VENDOR_MELLANOX=y
+ CONFIG_NET_VENDOR_MICREL=y
+ CONFIG_NET_VENDOR_MICROCHIP=y
+ CONFIG_NET_VENDOR_MYRI=y
+ CONFIG_NET_VENDOR_NATSEMI=y
+ CONFIG_NET_VENDOR_8390=y
+ CONFIG_NET_VENDOR_NVIDIA=y
+ CONFIG_NET_VENDOR_OKI=y
+ CONFIG_NET_PACKET_ENGINE=y
+ CONFIG_NET_VENDOR_QLOGIC=y
+ CONFIG_NET_VENDOR_QUALCOMM=y
+ CONFIG_NET_VENDOR_REALTEK=y
+ CONFIG_NET_VENDOR_RENESAS=y
+ CONFIG_NET_VENDOR_RDC=y
+ CONFIG_NET_VENDOR_ROCKER=y
+ CONFIG_NET_VENDOR_SAMSUNG=y
+ CONFIG_NET_VENDOR_SEEQ=y
+ CONFIG_NET_VENDOR_SILAN=y
+ CONFIG_NET_VENDOR_SIS=y
+ CONFIG_NET_VENDOR_SMSC=y
+ CONFIG_NET_VENDOR_STMICRO=y
+ CONFIG_STMMAC_ETH=y
+ CONFIG_STMMAC_PLATFORM=y
+ CONFIG_DWMAC_GENERIC=y
+ CONFIG_DWMAC_BAIKAL=y
+ CONFIG_NET_VENDOR_SUN=y
+ CONFIG_NET_VENDOR_SYNOPSYS=y
+ CONFIG_NET_VENDOR_TEHUTI=y
+ CONFIG_NET_VENDOR_TI=y
+ CONFIG_NET_VENDOR_TOSHIBA=y
+ CONFIG_NET_VENDOR_VIA=y
+ CONFIG_NET_VENDOR_WIZNET=y
+ CONFIG_PHYLIB=y
+ CONFIG_BAIKAL_XGBE_PHY=y
+ CONFIG_BAIKAL_MDIO=y
+ CONFIG_88X2222_PHY=y
+ CONFIG_MICREL_PHY=y
+ CONFIG_MDIO_BITBANG=y
+ CONFIG_MDIO_GPIO=y
+ CONFIG_USB_NET_DRIVERS=y
+ CONFIG_WLAN=y
+ CONFIG_INPUT=y
+ CONFIG_INPUT_MOUSEDEV=y
+ CONFIG_INPUT_MOUSEDEV_PSAUX=y
+ CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+ CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+ CONFIG_INPUT_KEYBOARD=y
+ CONFIG_KEYBOARD_ATKBD=y
+ CONFIG_INPUT_MOUSE=y
+ CONFIG_MOUSE_PS2=y
+ CONFIG_MOUSE_PS2_ALPS=y
+ CONFIG_MOUSE_PS2_LOGIPS2PP=y
+ CONFIG_MOUSE_PS2_SYNAPTICS=y
+ CONFIG_MOUSE_PS2_CYPRESS=y
+ CONFIG_MOUSE_PS2_TRACKPOINT=y
+ CONFIG_MOUSE_PS2_FOCALTECH=y
+ CONFIG_SERIO=y
+ CONFIG_ARCH_MIGHT_HAVE_PC_SERIO=y
+ CONFIG_SERIO_I8042=y
+ CONFIG_SERIO_SERPORT=y
+ CONFIG_SERIO_LIBPS2=y
+ CONFIG_TTY=y
+ CONFIG_VT=y
+ CONFIG_CONSOLE_TRANSLATIONS=y
+ CONFIG_VT_CONSOLE=y
+ CONFIG_VT_CONSOLE_SLEEP=y
+ CONFIG_HW_CONSOLE=y
+ CONFIG_VT_HW_CONSOLE_BINDING=y
+ CONFIG_UNIX98_PTYS=y
+ CONFIG_LEGACY_PTYS=y
+ CONFIG_LEGACY_PTY_COUNT=16
+ CONFIG_DEVMEM=y
+ CONFIG_DEVKMEM=y
+ CONFIG_SERIAL_EARLYCON=y
+ CONFIG_SERIAL_8250=y
+ CONFIG_SERIAL_8250_DEPRECATED_OPTIONS=y
+ CONFIG_SERIAL_8250_CONSOLE=y
+ CONFIG_SERIAL_8250_DMA=y
+ CONFIG_SERIAL_8250_PCI=y
+ CONFIG_SERIAL_8250_NR_UARTS=2
+ CONFIG_SERIAL_8250_RUNTIME_UARTS=2
+ CONFIG_SERIAL_8250_EXTENDED=y
+ CONFIG_SERIAL_8250_DW=y
+ CONFIG_SERIAL_CORE=y
+ CONFIG_SERIAL_CORE_CONSOLE=y
+ CONFIG_HW_RANDOM=m
+ CONFIG_DEVPORT=y
+ CONFIG_I2C=y
+ CONFIG_I2C_BOARDINFO=y
+ CONFIG_I2C_COMPAT=y
+ CONFIG_I2C_CHARDEV=y
+ CONFIG_I2C_HELPER_AUTO=y
+ CONFIG_I2C_ALGOBIT=y
+ CONFIG_I2C_DESIGNWARE_CORE=y
+ CONFIG_I2C_DESIGNWARE_PLATFORM=y
+ CONFIG_SPI=y
+ CONFIG_SPI_MASTER=y
+ CONFIG_SPI_DESIGNWARE=y
+ CONFIG_SPI_DW_MMIO=y
+ CONFIG_PPS=y
+ CONFIG_PTP_1588_CLOCK=y
+ CONFIG_ARCH_WANT_OPTIONAL_GPIOLIB=y
+ CONFIG_GPIOLIB=y
+ CONFIG_GPIO_DEVRES=y
+ CONFIG_OF_GPIO=y
+ CONFIG_GPIOLIB_IRQCHIP=y
+ CONFIG_DEBUG_GPIO=y
+ CONFIG_GPIO_SYSFS=y
+ CONFIG_GPIO_GENERIC=y
+ CONFIG_GPIO_DWAPB=y
+ CONFIG_GPIO_GENERIC_PLATFORM=y
+ CONFIG_GPIO_PCF857X=y
+ CONFIG_POWER_SUPPLY=y
+ CONFIG_HWMON=y
+ CONFIG_SENSORS_JC42=y
+ CONFIG_THERMAL=y
+ CONFIG_THERMAL_HWMON=y
+ CONFIG_THERMAL_OF=y
+ CONFIG_THERMAL_DEFAULT_GOV_STEP_WISE=y
+ CONFIG_THERMAL_GOV_STEP_WISE=y
+ CONFIG_WATCHDOG=y
+ CONFIG_WATCHDOG_CORE=y
+ CONFIG_DW_WATCHDOG=y
+ CONFIG_SSB_POSSIBLE=y
+ CONFIG_BCMA_POSSIBLE=y
+ CONFIG_MFD_SYSCON=y
+ CONFIG_VGA_ARB=y
+ CONFIG_VGA_ARB_MAX_GPUS=16
+ CONFIG_DRM=y
+ CONFIG_DRM_KMS_HELPER=y
+ CONFIG_DRM_KMS_FB_HELPER=y
+ CONFIG_DRM_FBDEV_EMULATION=y
+ CONFIG_DRM_I2C_CH7006=m
+ CONFIG_DRM_I2C_SIL164=m
+ CONFIG_DRM_BRIDGE=y
+ CONFIG_FB=y
+ CONFIG_FB_CMDLINE=y
+ CONFIG_FB_DDC=y
+ CONFIG_FB_CFB_FILLRECT=y
+ CONFIG_FB_CFB_COPYAREA=y
+ CONFIG_FB_CFB_IMAGEBLIT=y
+ CONFIG_FB_SYS_FILLRECT=y
+ CONFIG_FB_SYS_COPYAREA=y
+ CONFIG_FB_SYS_IMAGEBLIT=y
+ CONFIG_FB_SYS_FOPS=y
+ CONFIG_FB_DEFERRED_IO=y
+ CONFIG_FB_BACKLIGHT=y
+ CONFIG_FB_MODE_HELPERS=y
+ CONFIG_FB_NVIDIA=y
+ CONFIG_FB_NVIDIA_I2C=y
+ CONFIG_FB_NVIDIA_BACKLIGHT=y
+ CONFIG_FB_UDL=y
+ CONFIG_FB_SIMPLE=y
+ CONFIG_BACKLIGHT_LCD_SUPPORT=y
+ CONFIG_LCD_CLASS_DEVICE=m
+ CONFIG_BACKLIGHT_CLASS_DEVICE=y
+ CONFIG_BACKLIGHT_GENERIC=y
+ CONFIG_VGASTATE=y
+ CONFIG_HDMI=y
+ CONFIG_VGA_CONSOLE=y
+ CONFIG_DUMMY_CONSOLE=y
+ CONFIG_DUMMY_CONSOLE_COLUMNS=80
+ CONFIG_DUMMY_CONSOLE_ROWS=25
+ CONFIG_FRAMEBUFFER_CONSOLE=y
+ CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
+ CONFIG_FRAMEBUFFER_CONSOLE_ROTATION=y
+ CONFIG_SOUND=y
+ CONFIG_SND=y
+ CONFIG_SND_TIMER=y
+ CONFIG_SND_PCM=y
+ CONFIG_SND_JACK=y
+ CONFIG_SND_PCM_TIMER=y
+ CONFIG_SND_SUPPORT_OLD_API=y
+ CONFIG_SND_PROC_FS=y
+ CONFIG_SND_VERBOSE_PROCFS=y
+ CONFIG_SND_DRIVERS=y
+ CONFIG_SND_PCI=y
+ CONFIG_SND_HDA_PREALLOC_SIZE=64
+ CONFIG_SND_SPI=y
+ CONFIG_SND_MIPS=y
+ CONFIG_SND_USB=y
+ CONFIG_SND_SOC=y
+ CONFIG_SND_SOC_I2C_AND_SPI=y
+ CONFIG_SND_SOC_TLV320AIC31XX=y
+ CONFIG_HID=y
+ CONFIG_HID_GENERIC=y
+ CONFIG_USB_HID=y
+ CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+ CONFIG_USB_SUPPORT=y
+ CONFIG_USB_COMMON=y
+ CONFIG_USB_ARCH_HAS_HCD=y
+ CONFIG_USB=y
+ CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+ CONFIG_USB_DEFAULT_PERSIST=y
+ CONFIG_USB_DYNAMIC_MINORS=y
+ CONFIG_USB_ULPI_BUS=y
+ CONFIG_USB_MON=y
+ CONFIG_USB_XHCI_HCD=y
+ CONFIG_USB_XHCI_PCI=y
+ CONFIG_USB_XHCI_PLATFORM=y
+ CONFIG_USB_EHCI_HCD=m
+ CONFIG_USB_EHCI_ROOT_HUB_TT=y
+ CONFIG_USB_EHCI_TT_NEWSCHED=y
+ CONFIG_USB_EHCI_PCI=m
+ CONFIG_USB_EHCI_HCD_PLATFORM=m
+ CONFIG_USB_OHCI_HCD=y
+ CONFIG_USB_OHCI_HCD_PCI=y
+ CONFIG_USB_OHCI_HCD_PLATFORM=y
+ CONFIG_USB_HCD_TEST_MODE=y
+ CONFIG_USB_STORAGE=y
+ CONFIG_USB_UAS=y
+ CONFIG_USB_DWC3=y
+ CONFIG_USB_DWC3_ULPI=y
+ CONFIG_USB_DWC3_HOST=y
+ CONFIG_USB_DWC3_PCI=y
+ CONFIG_USB_DWC3_BAIKAL=y
+ CONFIG_USB_PHY=y
+ CONFIG_MMC=y
+ CONFIG_MMC_BLOCK=y
+ CONFIG_MMC_BLOCK_MINORS=8
+ CONFIG_MMC_BLOCK_BOUNCE=y
+ CONFIG_MMC_USHC=y
+ CONFIG_RTC_LIB=y
+ CONFIG_RTC_CLASS=y
+ CONFIG_RTC_HCTOSYS=y
+ CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+ CONFIG_RTC_SYSTOHC=y
+ CONFIG_RTC_SYSTOHC_DEVICE="rtc0"
+ CONFIG_RTC_INTF_SYSFS=y
+ CONFIG_RTC_INTF_PROC=y
+ CONFIG_RTC_INTF_DEV=y
+ CONFIG_RTC_DRV_ABEOZ9S3=y
+ CONFIG_DMADEVICES=y
+ CONFIG_DMADEVICES_DEBUG=y
+ CONFIG_DMADEVICES_VDEBUG=y
+ CONFIG_DMA_ENGINE=y
+ CONFIG_DMA_OF=y
+ CONFIG_DW_DMAC_CORE=y
+ CONFIG_DW_DMAC=y
+ CONFIG_STAGING=y
+ CONFIG_FB_SM750=y
+ CONFIG_MIPS_PLATFORM_DEVICES=y
+ CONFIG_CLKDEV_LOOKUP=y
+ CONFIG_HAVE_CLK_PREPARE=y
+ CONFIG_HAVE_MACH_CLKDEV=y
+ CONFIG_COMMON_CLK=y
+ CONFIG_COMMON_CLK_BAIKAL=y
+ CONFIG_CLKSRC_OF=y
+ CONFIG_CLKSRC_PROBE=y
+ CONFIG_DW_APB_TIMER=y
+ CONFIG_DW_APB_TIMER_OF=y
+ CONFIG_CLKSRC_MIPS_GIC=y
+ CONFIG_IOMMU_SUPPORT=y
+ CONFIG_MEMORY=y
+ CONFIG_IRQCHIP=y
+ CONFIG_MIPS_GIC=y
+ CONFIG_RESET_CONTROLLER=y
+ CONFIG_RAS=y
+ CONFIG_EXT4_FS=y
+ CONFIG_EXT4_USE_FOR_EXT2=y
+ CONFIG_JBD2=y
+ CONFIG_FS_MBCACHE=y
+ CONFIG_EXPORTFS=y
+ CONFIG_FILE_LOCKING=y
+ CONFIG_FSNOTIFY=y
+ CONFIG_DNOTIFY=y
+ CONFIG_INOTIFY_USER=y
+ CONFIG_AUTOFS4_FS=y
+ CONFIG_OVERLAY_FS=y
+ CONFIG_FAT_FS=y
+ CONFIG_MSDOS_FS=y
+ CONFIG_VFAT_FS=y
+ CONFIG_FAT_DEFAULT_CODEPAGE=437
+ CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+ CONFIG_PROC_FS=y
+ CONFIG_PROC_KCORE=y
+ CONFIG_PROC_SYSCTL=y
+ CONFIG_PROC_PAGE_MONITOR=y
+ CONFIG_KERNFS=y
+ CONFIG_SYSFS=y
+ CONFIG_TMPFS=y
+ CONFIG_MISC_FILESYSTEMS=y
+ CONFIG_NETWORK_FILESYSTEMS=y
+ CONFIG_NFS_FS=y
+ CONFIG_NFS_V2=y
+ CONFIG_NFS_V3=y
+ CONFIG_NFS_V4=y
+ CONFIG_NFS_V4_1=y
+ CONFIG_NFS_V4_2=y
+ CONFIG_PNFS_FILE_LAYOUT=y
+ CONFIG_PNFS_FLEXFILE_LAYOUT=m
+ CONFIG_NFS_V4_1_IMPLEMENTATION_ID_DOMAIN="kernel.org"
+ CONFIG_ROOT_NFS=y
+ CONFIG_NFS_USE_LEGACY_DNS=y
+ CONFIG_GRACE_PERIOD=y
+ CONFIG_LOCKD=y
+ CONFIG_LOCKD_V4=y
+ CONFIG_NFS_COMMON=y
+ CONFIG_SUNRPC=y
+ CONFIG_SUNRPC_GSS=y
+ CONFIG_SUNRPC_BACKCHANNEL=y
+ CONFIG_NLS=y
+ CONFIG_NLS_DEFAULT="iso8859-1"
+ CONFIG_NLS_CODEPAGE_437=y
+ CONFIG_NLS_CODEPAGE_866=y
+ CONFIG_NLS_CODEPAGE_1251=y
+ CONFIG_NLS_ASCII=y
+ CONFIG_NLS_ISO8859_1=y
+ CONFIG_NLS_ISO8859_5=y
+ CONFIG_NLS_KOI8_R=y
+ CONFIG_NLS_UTF8=y
+ CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+ CONFIG_MESSAGE_LOGLEVEL_DEFAULT=4
+ CONFIG_DYNAMIC_DEBUG=y
+ CONFIG_DEBUG_INFO=y
+ CONFIG_ENABLE_WARN_DEPRECATED=y
+ CONFIG_ENABLE_MUST_CHECK=y
+ CONFIG_FRAME_WARN=1024
+ CONFIG_DEBUG_FS=y
+ CONFIG_DEBUG_SECTION_MISMATCH=y
+ CONFIG_SECTION_MISMATCH_WARN_ONLY=y
+ CONFIG_DEBUG_KERNEL=y
+ CONFIG_HAVE_DEBUG_KMEMLEAK=y
+ CONFIG_DEBUG_MEMORY_INIT=y
+ CONFIG_HAVE_DEBUG_STACKOVERFLOW=y
+ CONFIG_LOCKUP_DETECTOR=y
+ CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC=y
+ CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=1
+ CONFIG_DETECT_HUNG_TASK=y
+ CONFIG_DEFAULT_HUNG_TASK_TIMEOUT=120
+ CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE=0
+ CONFIG_PANIC_ON_OOPS_VALUE=0
+ CONFIG_PANIC_TIMEOUT=0
+ CONFIG_SCHED_DEBUG=y
+ CONFIG_SPARSE_RCU_POINTER=y
+ CONFIG_RCU_CPU_STALL_TIMEOUT=21
+ CONFIG_HAVE_FUNCTION_TRACER=y
+ CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+ CONFIG_HAVE_DYNAMIC_FTRACE=y
+ CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+ CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+ CONFIG_HAVE_C_RECORDMCOUNT=y
+ CONFIG_TRACING_SUPPORT=y
+ CONFIG_FTRACE=y
+ CONFIG_BRANCH_PROFILE_NONE=y
+ CONFIG_TRACING_EVENTS_GPIO=y
+ CONFIG_DMA_API_DEBUG=y
+ CONFIG_HAVE_ARCH_KGDB=y
+ CONFIG_EARLY_PRINTK=y
+ CONFIG_DEBUG_ZBOOT=y
+ CONFIG_KEYS=y
+ CONFIG_DEFAULT_SECURITY_DAC=y
+ CONFIG_DEFAULT_SECURITY=""
+ CONFIG_CRYPTO=y
+ CONFIG_CRYPTO_ALGAPI=y
+ CONFIG_CRYPTO_ALGAPI2=y
+ CONFIG_CRYPTO_AEAD=y
+ CONFIG_CRYPTO_AEAD2=y
+ CONFIG_CRYPTO_BLKCIPHER=y
+ CONFIG_CRYPTO_BLKCIPHER2=y
+ CONFIG_CRYPTO_HASH=y
+ CONFIG_CRYPTO_HASH2=y
+ CONFIG_CRYPTO_RNG=m
+ CONFIG_CRYPTO_RNG2=y
+ CONFIG_CRYPTO_RNG_DEFAULT=m
+ CONFIG_CRYPTO_PCOMP2=y
+ CONFIG_CRYPTO_AKCIPHER2=y
+ CONFIG_CRYPTO_MANAGER=y
+ CONFIG_CRYPTO_MANAGER2=y
+ CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
+ CONFIG_CRYPTO_GF128MUL=m
+ CONFIG_CRYPTO_NULL=y
+ CONFIG_CRYPTO_NULL2=y
+ CONFIG_CRYPTO_WORKQUEUE=y
+ CONFIG_CRYPTO_CRYPTD=m
+ CONFIG_CRYPTO_AUTHENC=y
+ CONFIG_CRYPTO_TEST=m
+ CONFIG_CRYPTO_CCM=m
+ CONFIG_CRYPTO_SEQIV=m
+ CONFIG_CRYPTO_ECHAINIV=m
+ CONFIG_CRYPTO_CBC=y
+ CONFIG_CRYPTO_CTR=m
+ CONFIG_CRYPTO_ECB=m
+ CONFIG_CRYPTO_LRW=m
+ CONFIG_CRYPTO_PCBC=m
+ CONFIG_CRYPTO_HMAC=y
+ CONFIG_CRYPTO_XCBC=m
+ CONFIG_CRYPTO_CRC32C=y
+ CONFIG_CRYPTO_MD4=m
+ CONFIG_CRYPTO_MD5=y
+ CONFIG_CRYPTO_MICHAEL_MIC=m
+ CONFIG_CRYPTO_SHA1=y
+ CONFIG_CRYPTO_SHA256=m
+ CONFIG_CRYPTO_SHA512=m
+ CONFIG_CRYPTO_TGR192=m
+ CONFIG_CRYPTO_WP512=m
+ CONFIG_CRYPTO_AES=y
+ CONFIG_CRYPTO_ANUBIS=m
+ CONFIG_CRYPTO_ARC4=m
+ CONFIG_CRYPTO_BLOWFISH=m
+ CONFIG_CRYPTO_BLOWFISH_COMMON=m
+ CONFIG_CRYPTO_CAMELLIA=m
+ CONFIG_CRYPTO_CAST_COMMON=m
+ CONFIG_CRYPTO_CAST5=m
+ CONFIG_CRYPTO_CAST6=m
+ CONFIG_CRYPTO_DES=y
+ CONFIG_CRYPTO_FCRYPT=m
+ CONFIG_CRYPTO_KHAZAD=m
+ CONFIG_CRYPTO_SERPENT=m
+ CONFIG_CRYPTO_TEA=m
+ CONFIG_CRYPTO_TWOFISH=m
+ CONFIG_CRYPTO_TWOFISH_COMMON=m
+ CONFIG_CRYPTO_DEFLATE=y
+ CONFIG_CRYPTO_ANSI_CPRNG=m
+ CONFIG_CRYPTO_DRBG_MENU=m
+ CONFIG_CRYPTO_DRBG_HMAC=y
+ CONFIG_CRYPTO_DRBG=m
+ CONFIG_CRYPTO_JITTERENTROPY=m
+ CONFIG_CRYPTO_HW=y
+ CONFIG_BITREVERSE=y
+ CONFIG_RATIONAL=y
+ CONFIG_GENERIC_NET_UTILS=y
+ CONFIG_NO_GENERIC_PCI_IOPORT_MAP=y
+ CONFIG_GENERIC_PCI_IOMAP=y
+ CONFIG_GENERIC_IO=y
+ CONFIG_CRC16=y
+ CONFIG_CRC_ITU_T=y
+ CONFIG_CRC32=y
+ CONFIG_CRC32_SLICEBY8=y
+ CONFIG_CRC7=y
+ CONFIG_LIBCRC32C=m
+ CONFIG_AUDIT_GENERIC=y
+ CONFIG_ZLIB_INFLATE=y
+ CONFIG_ZLIB_DEFLATE=y
+ CONFIG_LZO_COMPRESS=y
+ CONFIG_LZO_DECOMPRESS=y
+ CONFIG_LZ4_DECOMPRESS=y
+ CONFIG_XZ_DEC=y
+ CONFIG_XZ_DEC_X86=y
+ CONFIG_XZ_DEC_POWERPC=y
+ CONFIG_XZ_DEC_IA64=y
+ CONFIG_XZ_DEC_ARM=y
+ CONFIG_XZ_DEC_ARMTHUMB=y
+ CONFIG_XZ_DEC_SPARC=y
+ CONFIG_XZ_DEC_BCJ=y
+ CONFIG_DECOMPRESS_GZIP=y
+ CONFIG_DECOMPRESS_BZIP2=y
+ CONFIG_DECOMPRESS_LZMA=y
+ CONFIG_DECOMPRESS_XZ=y
+ CONFIG_DECOMPRESS_LZO=y
+ CONFIG_DECOMPRESS_LZ4=y
+ CONFIG_GENERIC_ALLOCATOR=y
+ CONFIG_ASSOCIATIVE_ARRAY=y
+ CONFIG_HAS_IOMEM=y
+ CONFIG_HAS_IOPORT_MAP=y
+ CONFIG_HAS_DMA=y
+ CONFIG_CPU_RMAP=y
+ CONFIG_DQL=y
+ CONFIG_GLOB=y
+ CONFIG_NLATTR=y
+ CONFIG_GENERIC_ATOMIC64=y
+ CONFIG_ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE=y
+ CONFIG_LIBFDT=y
+ CONFIG_OID_REGISTRY=y
+ CONFIG_FONT_SUPPORT=y
+ CONFIG_FONT_8x8=y
+ CONFIG_FONT_8x16=y
+ CONFIG_HAVE_KVM=y
diff -rcNP linux-4.4.24/arch/mips/configs/baikal_qemu_defconfig linux-4.4.24-baikal/arch/mips/configs/baikal_qemu_defconfig
*** linux-4.4.24/arch/mips/configs/baikal_qemu_defconfig	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/arch/mips/configs/baikal_qemu_defconfig	2016-11-11 14:49:51.000000000 +0300
***************
*** 0 ****
--- 1,725 ----
+ # 
+ # Baikal-T QEMU default kernel configuration
+ #
+ # Copyright (C) 2014-2016 Baikal Electronics JSC
+ # 
+ # Author:
+ #   Dmitry Dunaev <dmitry.dunaev@baikalelectronics.ru>
+ #
+ # This program is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU General Public License
+ # as published by the Free Software Foundation; either version 2
+ # of the License, or (at your option) any later version.
+ #
+ # This program is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ # GNU General Public License for more details.
+ #
+ # You should have received a copy of the GNU General Public License
+ # along with this program; if not, write to the Free Software
+ # Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ #
+ 
+ CONFIG_MIPS=y
+ CONFIG_MIPS_BAIKAL=y
+ CONFIG_ARCH_BAIKAL=y
+ CONFIG_MACH_BAIKAL_QEMU=y
+ CONFIG_DTB_BAIKAL_QEMU=y
+ CONFIG_RWSEM_GENERIC_SPINLOCK=y
+ CONFIG_GENERIC_HWEIGHT=y
+ CONFIG_GENERIC_CALIBRATE_DELAY=y
+ CONFIG_SCHED_OMIT_FRAME_POINTER=y
+ CONFIG_BOOT_RAW=y
+ CONFIG_DMA_NONCOHERENT=y
+ CONFIG_NEED_DMA_MAP_STATE=y
+ CONFIG_SYS_HAS_EARLY_PRINTK=y
+ CONFIG_HOTPLUG_CPU=y
+ CONFIG_SYS_SUPPORTS_HOTPLUG_CPU=y
+ CONFIG_GENERIC_ISA_DMA=y
+ CONFIG_ISA_DMA_API=y
+ CONFIG_CPU_LITTLE_ENDIAN=y
+ CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
+ CONFIG_SWAP_IO_SPACE=y
+ CONFIG_BOOT_ELF32=y
+ CONFIG_MIPS_L1_CACHE_SHIFT=5
+ CONFIG_CPU_MIPS32_R2=y
+ CONFIG_CPU_MIPS32_3_5_FEATURES=n
+ CONFIG_SYS_SUPPORTS_ZBOOT=y
+ CONFIG_SYS_SUPPORTS_ZBOOT_UART16550=y
+ CONFIG_SYS_HAS_CPU_MIPS32_R2=y
+ CONFIG_SYS_HAS_CPU_MIPS32_R3_5=y
+ CONFIG_WEAK_ORDERING=y
+ CONFIG_CPU_MIPS32=y
+ CONFIG_CPU_MIPSR2=y
+ CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+ CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+ CONFIG_CPU_SUPPORTS_UNCACHED_ACCELERATED=y
+ CONFIG_HARDWARE_WATCHPOINTS=y
+ CONFIG_32BIT=y
+ CONFIG_PAGE_SIZE_16KB=y
+ CONFIG_FORCE_MAX_ZONEORDER=11
+ CONFIG_BOARD_SCACHE=y
+ CONFIG_MIPS_CPU_SCACHE=y
+ CONFIG_CPU_HAS_PREFETCH=y
+ CONFIG_CPU_GENERIC_DUMP_TLB=y
+ CONFIG_CPU_R4K_FPU=y
+ CONFIG_CPU_R4K_CACHE_TLB=y
+ CONFIG_MIPS_CPS=y
+ CONFIG_MIPS_CPS_PM=y
+ CONFIG_MIPS_GIC_IPI=y
+ CONFIG_MIPS_CM=y
+ CONFIG_MIPS_CPC=y
+ CONFIG_CPU_NEEDS_NO_SMARTMIPS_OR_MICROMIPS=y
+ CONFIG_CPU_MIPSR2_IRQ_VI=y
+ CONFIG_CPU_MIPSR2_IRQ_EI=y
+ CONFIG_CPU_HAS_SYNC=y
+ CONFIG_HIGHMEM=y
+ CONFIG_CPU_SUPPORTS_HIGHMEM=y
+ CONFIG_SYS_SUPPORTS_HIGHMEM=y
+ CONFIG_SYS_SUPPORTS_SMARTMIPS=y
+ CONFIG_CPU_SUPPORTS_MSA=y
+ CONFIG_ARCH_FLATMEM_ENABLE=y
+ CONFIG_FLATMEM=y
+ CONFIG_FLAT_NODE_MEM_MAP=y
+ CONFIG_HAVE_MEMBLOCK=y
+ CONFIG_HAVE_MEMBLOCK_NODE_MAP=y
+ CONFIG_ARCH_DISCARD_MEMBLOCK=y
+ CONFIG_PAGEFLAGS_EXTENDED=y
+ CONFIG_SPLIT_PTLOCK_CPUS=4
+ CONFIG_COMPACTION=y
+ CONFIG_MIGRATION=y
+ CONFIG_ZONE_DMA_FLAG=1
+ CONFIG_BOUNCE=y
+ CONFIG_VIRT_TO_BUS=y
+ CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+ CONFIG_SMP=y
+ CONFIG_SYS_SUPPORTS_MIPS_CPS=y
+ CONFIG_SYS_SUPPORTS_SMP=y
+ CONFIG_NR_CPUS=2
+ CONFIG_HZ_100=y
+ CONFIG_SYS_SUPPORTS_ARBIT_HZ=y
+ CONFIG_HZ=100
+ CONFIG_PREEMPT_NONE=y
+ CONFIG_SECCOMP=y
+ CONFIG_USE_OF=y
+ CONFIG_MIPS_ERRATA=y
+ CONFIG_MIPS_ERRATA_E21=y
+ CONFIG_LOCKDEP_SUPPORT=y
+ CONFIG_STACKTRACE_SUPPORT=y
+ CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+ CONFIG_IRQ_WORK=y
+ CONFIG_BUILDTIME_EXTABLE_SORT=y
+ CONFIG_INIT_ENV_ARG_LIMIT=32
+ CONFIG_CROSS_COMPILE=""
+ CONFIG_LOCALVERSION="-qemu"
+ CONFIG_HAVE_KERNEL_GZIP=y
+ CONFIG_HAVE_KERNEL_BZIP2=y
+ CONFIG_HAVE_KERNEL_LZMA=y
+ CONFIG_HAVE_KERNEL_XZ=y
+ CONFIG_HAVE_KERNEL_LZO=y
+ CONFIG_HAVE_KERNEL_LZ4=y
+ CONFIG_KERNEL_GZIP=y
+ CONFIG_DEFAULT_HOSTNAME="baikal"
+ CONFIG_SWAP=y
+ CONFIG_SYSVIPC=y
+ CONFIG_SYSVIPC_SYSCTL=y
+ CONFIG_CROSS_MEMORY_ATTACH=y
+ CONFIG_FHANDLE=y
+ CONFIG_USELIB=y
+ CONFIG_GENERIC_IRQ_PROBE=y
+ CONFIG_GENERIC_IRQ_SHOW=y
+ CONFIG_GENERIC_IRQ_CHIP=y
+ CONFIG_IRQ_DOMAIN=y
+ CONFIG_IRQ_DOMAIN_DEBUG=y
+ CONFIG_IRQ_FORCED_THREADING=y
+ CONFIG_GENERIC_CLOCKEVENTS=y
+ CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+ CONFIG_GENERIC_CMOS_UPDATE=y
+ CONFIG_TICK_ONESHOT=y
+ CONFIG_NO_HZ_COMMON=y
+ CONFIG_NO_HZ_IDLE=y
+ CONFIG_HIGH_RES_TIMERS=y
+ CONFIG_TICK_CPU_ACCOUNTING=y
+ CONFIG_TREE_RCU=y
+ CONFIG_RCU_STALL_COMMON=y
+ CONFIG_RCU_FANOUT=32
+ CONFIG_RCU_FANOUT_LEAF=16
+ CONFIG_BUILD_BIN2C=y
+ CONFIG_IKCONFIG=y
+ CONFIG_IKCONFIG_PROC=y
+ CONFIG_LOG_BUF_SHIFT=15
+ CONFIG_LOG_CPU_MAX_BUF_SHIFT=12
+ CONFIG_GENERIC_SCHED_CLOCK=y
+ CONFIG_CGROUPS=y
+ CONFIG_NAMESPACES=y
+ CONFIG_UTS_NS=y
+ CONFIG_IPC_NS=y
+ CONFIG_PID_NS=y
+ CONFIG_NET_NS=y
+ CONFIG_RELAY=y
+ CONFIG_BLK_DEV_INITRD=y
+ CONFIG_INITRAMFS_SOURCE=""
+ CONFIG_RD_GZIP=y
+ CONFIG_RD_BZIP2=y
+ CONFIG_RD_LZMA=y
+ CONFIG_RD_XZ=y
+ CONFIG_RD_LZO=y
+ CONFIG_RD_LZ4=y
+ CONFIG_INIT_FALLBACK=y
+ CONFIG_SYSCTL=y
+ CONFIG_ANON_INODES=y
+ CONFIG_BPF=y
+ CONFIG_EXPERT=y
+ CONFIG_SGETMASK_SYSCALL=y
+ CONFIG_SYSFS_SYSCALL=y
+ CONFIG_KALLSYMS=y
+ CONFIG_PRINTK=y
+ CONFIG_BUG=y
+ CONFIG_ELF_CORE=y
+ CONFIG_BASE_FULL=y
+ CONFIG_FUTEX=y
+ CONFIG_EPOLL=y
+ CONFIG_SIGNALFD=y
+ CONFIG_TIMERFD=y
+ CONFIG_EVENTFD=y
+ CONFIG_SHMEM=y
+ CONFIG_AIO=y
+ CONFIG_ADVISE_SYSCALLS=y
+ CONFIG_HAVE_PERF_EVENTS=y
+ CONFIG_PERF_USE_VMALLOC=y
+ CONFIG_VM_EVENT_COUNTERS=y
+ CONFIG_COMPAT_BRK=y
+ CONFIG_SLAB=y
+ CONFIG_HAVE_OPROFILE=y
+ CONFIG_HAVE_KPROBES=y
+ CONFIG_HAVE_KRETPROBES=y
+ CONFIG_HAVE_ARCH_TRACEHOOK=y
+ CONFIG_HAVE_DMA_ATTRS=y
+ CONFIG_HAVE_DMA_CONTIGUOUS=y
+ CONFIG_GENERIC_SMP_IDLE_THREAD=y
+ CONFIG_HAVE_CLK=y
+ CONFIG_HAVE_DMA_API_DEBUG=y
+ CONFIG_HAVE_ARCH_JUMP_LABEL=y
+ CONFIG_ARCH_WANT_IPC_PARSE_VERSION=y
+ CONFIG_HAVE_ARCH_SECCOMP_FILTER=y
+ CONFIG_SECCOMP_FILTER=y
+ CONFIG_HAVE_CC_STACKPROTECTOR=y
+ CONFIG_CC_STACKPROTECTOR_NONE=y
+ CONFIG_HAVE_CONTEXT_TRACKING=y
+ CONFIG_HAVE_MOD_ARCH_SPECIFIC=y
+ CONFIG_MODULES_USE_ELF_REL=y
+ CONFIG_CLONE_BACKWARDS=y
+ CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+ CONFIG_SLABINFO=y
+ CONFIG_RT_MUTEXES=y
+ CONFIG_BASE_SMALL=0
+ CONFIG_MODULES=y
+ CONFIG_MODULE_UNLOAD=y
+ CONFIG_MODVERSIONS=y
+ CONFIG_MODULE_SRCVERSION_ALL=y
+ CONFIG_STOP_MACHINE=y
+ CONFIG_BLOCK=y
+ CONFIG_LBDAF=y
+ CONFIG_BLK_DEV_BSG=y
+ CONFIG_BLK_DEV_BSGLIB=y
+ CONFIG_MSDOS_PARTITION=y
+ CONFIG_EFI_PARTITION=y
+ CONFIG_IOSCHED_NOOP=y
+ CONFIG_IOSCHED_DEADLINE=y
+ CONFIG_IOSCHED_CFQ=y
+ CONFIG_DEFAULT_CFQ=y
+ CONFIG_DEFAULT_IOSCHED="cfq"
+ CONFIG_INLINE_SPIN_UNLOCK_IRQ=y
+ CONFIG_INLINE_READ_UNLOCK=y
+ CONFIG_INLINE_READ_UNLOCK_IRQ=y
+ CONFIG_INLINE_WRITE_UNLOCK=y
+ CONFIG_INLINE_WRITE_UNLOCK_IRQ=y
+ CONFIG_FREEZER=y
+ CONFIG_HW_HAS_PCI=y
+ CONFIG_MMU=y
+ CONFIG_ZONE_DMA=y
+ CONFIG_BINFMT_ELF=y
+ CONFIG_ARCH_BINFMT_ELF_RANDOMIZE_PIE=y
+ CONFIG_ARCH_BINFMT_ELF_STATE=y
+ CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS=y
+ CONFIG_BINFMT_SCRIPT=y
+ CONFIG_COREDUMP=y
+ CONFIG_TRAD_SIGNALS=y
+ CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+ CONFIG_ARCH_SUSPEND_POSSIBLE=y
+ CONFIG_SUSPEND=y
+ CONFIG_SUSPEND_FREEZER=y
+ CONFIG_PM_SLEEP=y
+ CONFIG_PM_SLEEP_SMP=y
+ CONFIG_PM=y
+ CONFIG_PM_CLK=y
+ CONFIG_NET=y
+ CONFIG_PACKET=y
+ CONFIG_PACKET_DIAG=y
+ CONFIG_UNIX=y
+ CONFIG_UNIX_DIAG=y
+ CONFIG_XFRM=y
+ CONFIG_XFRM_ALGO=y
+ CONFIG_XFRM_USER=y
+ CONFIG_XFRM_IPCOMP=y
+ CONFIG_NET_KEY=y
+ CONFIG_INET=y
+ CONFIG_IP_MULTICAST=y
+ CONFIG_IP_PNP=y
+ CONFIG_NET_IP_TUNNEL=y
+ CONFIG_SYN_COOKIES=y
+ CONFIG_INET_AH=y
+ CONFIG_INET_ESP=y
+ CONFIG_INET_IPCOMP=y
+ CONFIG_INET_XFRM_TUNNEL=y
+ CONFIG_INET_TUNNEL=y
+ CONFIG_INET_XFRM_MODE_TRANSPORT=y
+ CONFIG_INET_XFRM_MODE_TUNNEL=y
+ CONFIG_INET_XFRM_MODE_BEET=y
+ CONFIG_INET_LRO=y
+ CONFIG_INET_DIAG=y
+ CONFIG_INET_TCP_DIAG=y
+ CONFIG_INET_UDP_DIAG=y
+ CONFIG_TCP_CONG_CUBIC=y
+ CONFIG_DEFAULT_TCP_CONG="cubic"
+ CONFIG_IPV6=y
+ CONFIG_INET6_AH=y
+ CONFIG_INET6_ESP=y
+ CONFIG_INET6_IPCOMP=y
+ CONFIG_INET6_XFRM_TUNNEL=y
+ CONFIG_INET6_TUNNEL=y
+ CONFIG_INET6_XFRM_MODE_TRANSPORT=y
+ CONFIG_INET6_XFRM_MODE_TUNNEL=y
+ CONFIG_INET6_XFRM_MODE_BEET=y
+ CONFIG_IPV6_SIT=y
+ CONFIG_IPV6_NDISC_NODETYPE=y
+ CONFIG_NET_PTP_CLASSIFY=y
+ CONFIG_NETFILTER=y
+ CONFIG_NETFILTER_ADVANCED=y
+ CONFIG_HAVE_NET_DSA=y
+ CONFIG_DNS_RESOLVER=y
+ CONFIG_NETLINK_DIAG=y
+ CONFIG_RPS=y
+ CONFIG_RFS_ACCEL=y
+ CONFIG_XPS=y
+ CONFIG_NET_RX_BUSY_POLL=y
+ CONFIG_BQL=y
+ CONFIG_NET_FLOW_LIMIT=y
+ CONFIG_WIRELESS=y
+ CONFIG_HAVE_BPF_JIT=y
+ CONFIG_UEVENT_HELPER=y
+ CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+ CONFIG_DEVTMPFS=y
+ CONFIG_DEVTMPFS_MOUNT=y
+ CONFIG_STANDALONE=y
+ CONFIG_PREVENT_FIRMWARE_BUILD=y
+ CONFIG_FW_LOADER=y
+ CONFIG_FIRMWARE_IN_KERNEL=y
+ CONFIG_EXTRA_FIRMWARE=""
+ CONFIG_ALLOW_DEV_COREDUMP=y
+ CONFIG_DEBUG_DRIVER=y
+ CONFIG_DEBUG_DEVRES=y
+ CONFIG_SOC_BUS=y
+ CONFIG_MTD=y
+ CONFIG_MTD_CMDLINE_PARTS=y
+ CONFIG_MTD_OF_PARTS=y
+ CONFIG_MTD_BLKDEVS=y
+ CONFIG_MTD_BLOCK=y
+ CONFIG_MTD_JEDECPROBE=y
+ CONFIG_MTD_GEN_PROBE=y
+ CONFIG_MTD_MAP_BANK_WIDTH_1=y
+ CONFIG_MTD_MAP_BANK_WIDTH_2=y
+ CONFIG_MTD_MAP_BANK_WIDTH_4=y
+ CONFIG_MTD_CFI_I1=y
+ CONFIG_MTD_CFI_I2=y
+ CONFIG_MTD_M25P80=y
+ CONFIG_MTD_BLOCK2MTD=y
+ CONFIG_MTD_SPI_NOR=y
+ CONFIG_MTD_SPI_NOR_USE_4K_SECTORS=y
+ CONFIG_DTC=y
+ CONFIG_OF=y
+ CONFIG_OF_FLATTREE=y
+ CONFIG_OF_EARLY_FLATTREE=y
+ CONFIG_OF_ADDRESS=y
+ CONFIG_OF_IRQ=y
+ CONFIG_OF_NET=y
+ CONFIG_OF_MDIO=y
+ CONFIG_OF_MTD=y
+ CONFIG_ARCH_MIGHT_HAVE_PC_PARPORT=y
+ CONFIG_BLK_DEV=y
+ CONFIG_BLK_DEV_LOOP=y
+ CONFIG_BLK_DEV_LOOP_MIN_COUNT=4
+ CONFIG_BLK_DEV_NBD=y
+ CONFIG_BLK_DEV_RAM=y
+ CONFIG_BLK_DEV_RAM_COUNT=4
+ CONFIG_BLK_DEV_RAM_SIZE=32768
+ CONFIG_EEPROM_AT24=y
+ CONFIG_EEPROM_AT25=y
+ CONFIG_HAVE_IDE=y
+ CONFIG_SCSI_MOD=y
+ CONFIG_RAID_ATTRS=y
+ CONFIG_SCSI=y
+ CONFIG_SCSI_DMA=y
+ CONFIG_SCSI_PROC_FS=y
+ CONFIG_BLK_DEV_SD=y
+ CONFIG_CHR_DEV_SG=y
+ CONFIG_SCSI_CONSTANTS=y
+ CONFIG_SCSI_LOGGING=y
+ CONFIG_SCSI_SCAN_ASYNC=y
+ CONFIG_SCSI_LOWLEVEL=y
+ CONFIG_ATA=y
+ CONFIG_ATA_VERBOSE_ERROR=y
+ CONFIG_SATA_PMP=y
+ CONFIG_SATA_AHCI_PLATFORM=y
+ CONFIG_ATA_SFF=y
+ CONFIG_ATA_BMDMA=y
+ CONFIG_NETDEVICES=y
+ CONFIG_MII=y
+ CONFIG_NET_CORE=y
+ CONFIG_ETHERNET=y
+ CONFIG_NET_VENDOR_AMD=y
+ CONFIG_AMD_XGBE=y
+ CONFIG_NET_VENDOR_ARC=y
+ CONFIG_NET_VENDOR_BROADCOM=y
+ CONFIG_NET_VENDOR_INTEL=y
+ CONFIG_NET_VENDOR_I825XX=y
+ CONFIG_NET_VENDOR_MARVELL=y
+ CONFIG_NET_VENDOR_MICREL=y
+ CONFIG_NET_VENDOR_MICROCHIP=y
+ CONFIG_NET_VENDOR_NATSEMI=y
+ CONFIG_NET_VENDOR_8390=y
+ CONFIG_NET_VENDOR_QUALCOMM=y
+ CONFIG_NET_VENDOR_ROCKER=y
+ CONFIG_NET_VENDOR_SAMSUNG=y
+ CONFIG_NET_VENDOR_SEEQ=y
+ CONFIG_NET_VENDOR_SMSC=y
+ CONFIG_NET_VENDOR_STMICRO=y
+ CONFIG_STMMAC_ETH=y
+ CONFIG_STMMAC_PLATFORM=y
+ CONFIG_NET_VENDOR_VIA=y
+ CONFIG_NET_VENDOR_WIZNET=y
+ CONFIG_PHYLIB=y
+ CONFIG_DW_XGBE_PHY=y
+ CONFIG_MARVELL_PHY=y
+ CONFIG_MICREL_PHY=y
+ CONFIG_WLAN=y
+ CONFIG_INPUT=y
+ CONFIG_INPUT_MOUSEDEV=y
+ CONFIG_INPUT_MOUSEDEV_PSAUX=y
+ CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+ CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+ CONFIG_INPUT_KEYBOARD=y
+ CONFIG_KEYBOARD_ATKBD=y
+ CONFIG_INPUT_MOUSE=y
+ CONFIG_MOUSE_PS2=y
+ CONFIG_MOUSE_PS2_ALPS=y
+ CONFIG_MOUSE_PS2_LOGIPS2PP=y
+ CONFIG_MOUSE_PS2_SYNAPTICS=y
+ CONFIG_MOUSE_PS2_CYPRESS=y
+ CONFIG_MOUSE_PS2_TRACKPOINT=y
+ CONFIG_SERIO=y
+ CONFIG_ARCH_MIGHT_HAVE_PC_SERIO=y
+ CONFIG_SERIO_I8042=y
+ CONFIG_SERIO_SERPORT=y
+ CONFIG_SERIO_LIBPS2=y
+ CONFIG_TTY=y
+ CONFIG_VT=y
+ CONFIG_CONSOLE_TRANSLATIONS=y
+ CONFIG_VT_CONSOLE=y
+ CONFIG_VT_CONSOLE_SLEEP=y
+ CONFIG_HW_CONSOLE=y
+ CONFIG_VT_HW_CONSOLE_BINDING=y
+ CONFIG_UNIX98_PTYS=y
+ CONFIG_LEGACY_PTYS=y
+ CONFIG_LEGACY_PTY_COUNT=16
+ CONFIG_DEVKMEM=y
+ CONFIG_SERIAL_EARLYCON=y
+ CONFIG_SERIAL_8250=y
+ CONFIG_SERIAL_8250_DEPRECATED_OPTIONS=y
+ CONFIG_SERIAL_8250_CONSOLE=y
+ CONFIG_SERIAL_8250_DMA=y
+ CONFIG_SERIAL_8250_NR_UARTS=2
+ CONFIG_SERIAL_8250_RUNTIME_UARTS=2
+ CONFIG_SERIAL_8250_EXTENDED=y
+ CONFIG_SERIAL_8250_DW=y
+ CONFIG_SERIAL_CORE=y
+ CONFIG_SERIAL_CORE_CONSOLE=y
+ CONFIG_HW_RANDOM=m
+ CONFIG_I2C=y
+ CONFIG_I2C_BOARDINFO=y
+ CONFIG_I2C_COMPAT=y
+ CONFIG_I2C_CHARDEV=y
+ CONFIG_I2C_HELPER_AUTO=y
+ CONFIG_I2C_DESIGNWARE_CORE=y
+ CONFIG_I2C_DESIGNWARE_PLATFORM=y
+ CONFIG_SPI=y
+ CONFIG_SPI_MASTER=y
+ CONFIG_SPI_BAIKAL=y
+ CONFIG_SPI_DESIGNWARE=y
+ CONFIG_SPI_DW_MMIO=y
+ CONFIG_PPS=y
+ CONFIG_PTP_1588_CLOCK=y
+ CONFIG_ARCH_HAVE_CUSTOM_GPIO_H=y
+ CONFIG_ARCH_WANT_OPTIONAL_GPIOLIB=y
+ CONFIG_GPIOLIB=y
+ CONFIG_GPIO_DEVRES=y
+ CONFIG_OF_GPIO=y
+ CONFIG_DEBUG_GPIO=y
+ CONFIG_GPIO_SYSFS=y
+ CONFIG_GPIO_GENERIC=y
+ CONFIG_GPIO_GENERIC_PLATFORM=y
+ CONFIG_GPIO_DWAPB=y
+ CONFIG_HWMON=y
+ CONFIG_SENSORS_JC42=y
+ CONFIG_WATCHDOG=y
+ CONFIG_WATCHDOG_CORE=y
+ CONFIG_WATCHDOG_NOWAYOUT=y
+ CONFIG_DW_WATCHDOG=y
+ CONFIG_SSB_POSSIBLE=y
+ CONFIG_BCMA_POSSIBLE=y
+ CONFIG_VGA_CONSOLE=y
+ CONFIG_DUMMY_CONSOLE=y
+ CONFIG_HID=y
+ CONFIG_HID_GENERIC=y
+ CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+ CONFIG_USB_SUPPORT=y
+ CONFIG_USB_ARCH_HAS_HCD=y
+ CONFIG_RTC_LIB=y
+ CONFIG_RTC_CLASS=y
+ CONFIG_RTC_HCTOSYS=y
+ CONFIG_RTC_SYSTOHC=y
+ CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+ CONFIG_RTC_INTF_SYSFS=y
+ CONFIG_RTC_INTF_PROC=y
+ CONFIG_RTC_INTF_DEV=y
+ CONFIG_RTC_DRV_DS1307=y
+ CONFIG_RTC_DRV_DW=y
+ CONFIG_DMADEVICES=y
+ CONFIG_DW_DMAC_CORE=y
+ CONFIG_DW_DMAC=y
+ CONFIG_DMA_ENGINE=y
+ CONFIG_DMA_OF=y
+ CONFIG_CLKDEV_LOOKUP=y
+ CONFIG_HAVE_CLK_PREPARE=y
+ CONFIG_HAVE_MACH_CLKDEV=y
+ CONFIG_COMMON_CLK=y
+ CONFIG_COMMON_CLK_BAIKAL=y
+ CONFIG_CLKSRC_OF=y
+ CONFIG_DW_APB_TIMER=y
+ CONFIG_DW_APB_TIMER_OF=y
+ CONFIG_CLKSRC_MIPS_GIC=y
+ CONFIG_IOMMU_SUPPORT=y
+ CONFIG_IRQCHIP=y
+ CONFIG_MIPS_GIC=y
+ CONFIG_RESET_CONTROLLER=y
+ CONFIG_EXT2_FS=y
+ CONFIG_EXT3_FS=y
+ CONFIG_EXT3_DEFAULTS_TO_ORDERED=y
+ CONFIG_EXT3_FS_XATTR=y
+ CONFIG_EXT4_FS=m
+ CONFIG_JBD=y
+ CONFIG_JBD2=m
+ CONFIG_FS_MBCACHE=y
+ CONFIG_EXPORTFS=y
+ CONFIG_FILE_LOCKING=y
+ CONFIG_FSNOTIFY=y
+ CONFIG_DNOTIFY=y
+ CONFIG_INOTIFY_USER=y
+ CONFIG_QUOTA=y
+ CONFIG_PRINT_QUOTA_WARNING=y
+ CONFIG_QUOTA_TREE=y
+ CONFIG_QFMT_V2=y
+ CONFIG_QUOTACTL=y
+ CONFIG_FAT_FS=y
+ CONFIG_MSDOS_FS=y
+ CONFIG_VFAT_FS=y
+ CONFIG_FAT_DEFAULT_CODEPAGE=437
+ CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+ CONFIG_PROC_FS=y
+ CONFIG_PROC_KCORE=y
+ CONFIG_PROC_SYSCTL=y
+ CONFIG_PROC_PAGE_MONITOR=y
+ CONFIG_KERNFS=y
+ CONFIG_SYSFS=y
+ CONFIG_TMPFS=y
+ CONFIG_MISC_FILESYSTEMS=y
+ CONFIG_JFFS2_FS=y
+ CONFIG_JFFS2_FS_DEBUG=0
+ CONFIG_JFFS2_FS_WRITEBUFFER=y
+ CONFIG_JFFS2_ZLIB=y
+ CONFIG_JFFS2_RTIME=y
+ CONFIG_SQUASHFS=y
+ CONFIG_SQUASHFS_FILE_CACHE=y
+ CONFIG_SQUASHFS_DECOMP_SINGLE=y
+ CONFIG_SQUASHFS_ZLIB=y
+ CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE=3
+ CONFIG_ROMFS_FS=y
+ CONFIG_ROMFS_BACKED_BY_BLOCK=y
+ CONFIG_ROMFS_ON_BLOCK=y
+ CONFIG_NETWORK_FILESYSTEMS=y
+ CONFIG_NFS_FS=y
+ CONFIG_NFS_V2=y
+ CONFIG_NFS_V3=y
+ CONFIG_NFS_V4=y
+ CONFIG_NFS_V4_1=y
+ CONFIG_NFS_V4_2=y
+ CONFIG_PNFS_FILE_LAYOUT=y
+ CONFIG_NFS_V4_1_IMPLEMENTATION_ID_DOMAIN="kernel.org"
+ CONFIG_NFS_USE_KERNEL_DNS=y
+ CONFIG_GRACE_PERIOD=y
+ CONFIG_LOCKD=y
+ CONFIG_LOCKD_V4=y
+ CONFIG_NFS_COMMON=y
+ CONFIG_SUNRPC=y
+ CONFIG_SUNRPC_GSS=y
+ CONFIG_SUNRPC_BACKCHANNEL=y
+ CONFIG_NLS=y
+ CONFIG_NLS_DEFAULT="iso8859-1"
+ CONFIG_NLS_CODEPAGE_437=y
+ CONFIG_NLS_CODEPAGE_866=y
+ CONFIG_NLS_CODEPAGE_1251=y
+ CONFIG_NLS_ASCII=y
+ CONFIG_NLS_ISO8859_1=y
+ CONFIG_NLS_ISO8859_5=y
+ CONFIG_NLS_KOI8_R=y
+ CONFIG_NLS_UTF8=y
+ CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+ CONFIG_MESSAGE_LOGLEVEL_DEFAULT=4
+ CONFIG_DYNAMIC_DEBUG=y
+ CONFIG_DEBUG_INFO=y
+ CONFIG_ENABLE_WARN_DEPRECATED=y
+ CONFIG_ENABLE_MUST_CHECK=y
+ CONFIG_FRAME_WARN=1024
+ CONFIG_DEBUG_FS=y
+ CONFIG_DEBUG_SECTION_MISMATCH=y
+ CONFIG_DEBUG_KERNEL=y
+ CONFIG_HAVE_DEBUG_KMEMLEAK=y
+ CONFIG_DEBUG_MEMORY_INIT=y
+ CONFIG_HAVE_DEBUG_STACKOVERFLOW=y
+ CONFIG_LOCKUP_DETECTOR=y
+ CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC=y
+ CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=1
+ CONFIG_DETECT_HUNG_TASK=y
+ CONFIG_DEFAULT_HUNG_TASK_TIMEOUT=120
+ CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE=0
+ CONFIG_PANIC_ON_OOPS_VALUE=0
+ CONFIG_PANIC_TIMEOUT=0
+ CONFIG_SCHED_DEBUG=y
+ CONFIG_SPARSE_RCU_POINTER=y
+ CONFIG_RCU_CPU_STALL_TIMEOUT=21
+ CONFIG_HAVE_FUNCTION_TRACER=y
+ CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+ CONFIG_HAVE_DYNAMIC_FTRACE=y
+ CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+ CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+ CONFIG_HAVE_C_RECORDMCOUNT=y
+ CONFIG_TRACING_SUPPORT=y
+ CONFIG_FTRACE=y
+ CONFIG_BRANCH_PROFILE_NONE=y
+ CONFIG_HAVE_ARCH_KGDB=y
+ CONFIG_EARLY_PRINTK=y
+ CONFIG_RUNTIME_DEBUG=y
+ CONFIG_DEBUG_ZBOOT=y
+ CONFIG_KEYS=y
+ CONFIG_DEFAULT_SECURITY_DAC=y
+ CONFIG_DEFAULT_SECURITY=""
+ CONFIG_CRYPTO=y
+ CONFIG_CRYPTO_ALGAPI=y
+ CONFIG_CRYPTO_ALGAPI2=y
+ CONFIG_CRYPTO_AEAD=y
+ CONFIG_CRYPTO_AEAD2=y
+ CONFIG_CRYPTO_BLKCIPHER=y
+ CONFIG_CRYPTO_BLKCIPHER2=y
+ CONFIG_CRYPTO_HASH=y
+ CONFIG_CRYPTO_HASH2=y
+ CONFIG_CRYPTO_RNG=m
+ CONFIG_CRYPTO_RNG2=y
+ CONFIG_CRYPTO_PCOMP2=y
+ CONFIG_CRYPTO_MANAGER=y
+ CONFIG_CRYPTO_MANAGER2=y
+ CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
+ CONFIG_CRYPTO_GF128MUL=m
+ CONFIG_CRYPTO_NULL=m
+ CONFIG_CRYPTO_WORKQUEUE=y
+ CONFIG_CRYPTO_CRYPTD=m
+ CONFIG_CRYPTO_AUTHENC=y
+ CONFIG_CRYPTO_TEST=m
+ CONFIG_CRYPTO_CCM=m
+ CONFIG_CRYPTO_SEQIV=m
+ CONFIG_CRYPTO_CBC=y
+ CONFIG_CRYPTO_CTR=m
+ CONFIG_CRYPTO_ECB=m
+ CONFIG_CRYPTO_LRW=m
+ CONFIG_CRYPTO_PCBC=m
+ CONFIG_CRYPTO_HMAC=y
+ CONFIG_CRYPTO_XCBC=m
+ CONFIG_CRYPTO_CRC32C=y
+ CONFIG_CRYPTO_MD4=m
+ CONFIG_CRYPTO_MD5=y
+ CONFIG_CRYPTO_MICHAEL_MIC=m
+ CONFIG_CRYPTO_SHA1=y
+ CONFIG_CRYPTO_SHA256=m
+ CONFIG_CRYPTO_SHA512=m
+ CONFIG_CRYPTO_TGR192=m
+ CONFIG_CRYPTO_WP512=m
+ CONFIG_CRYPTO_AES=y
+ CONFIG_CRYPTO_ANUBIS=m
+ CONFIG_CRYPTO_ARC4=m
+ CONFIG_CRYPTO_BLOWFISH=m
+ CONFIG_CRYPTO_BLOWFISH_COMMON=m
+ CONFIG_CRYPTO_CAMELLIA=m
+ CONFIG_CRYPTO_CAST_COMMON=m
+ CONFIG_CRYPTO_CAST5=m
+ CONFIG_CRYPTO_CAST6=m
+ CONFIG_CRYPTO_DES=y
+ CONFIG_CRYPTO_FCRYPT=m
+ CONFIG_CRYPTO_KHAZAD=m
+ CONFIG_CRYPTO_SERPENT=m
+ CONFIG_CRYPTO_TEA=m
+ CONFIG_CRYPTO_TWOFISH=m
+ CONFIG_CRYPTO_TWOFISH_COMMON=m
+ CONFIG_CRYPTO_DEFLATE=y
+ CONFIG_CRYPTO_ANSI_CPRNG=m
+ CONFIG_CRYPTO_HW=y
+ CONFIG_BITREVERSE=y
+ CONFIG_GENERIC_NET_UTILS=y
+ CONFIG_GENERIC_PCI_IOMAP=y
+ CONFIG_GENERIC_IO=y
+ CONFIG_CRC16=y
+ CONFIG_CRC_ITU_T=m
+ CONFIG_CRC32=y
+ CONFIG_CRC32_SLICEBY8=y
+ CONFIG_LIBCRC32C=m
+ CONFIG_ZLIB_INFLATE=y
+ CONFIG_ZLIB_DEFLATE=y
+ CONFIG_LZO_DECOMPRESS=y
+ CONFIG_LZ4_DECOMPRESS=y
+ CONFIG_XZ_DEC=y
+ CONFIG_XZ_DEC_X86=y
+ CONFIG_XZ_DEC_POWERPC=y
+ CONFIG_XZ_DEC_IA64=y
+ CONFIG_XZ_DEC_ARM=y
+ CONFIG_XZ_DEC_ARMTHUMB=y
+ CONFIG_XZ_DEC_SPARC=y
+ CONFIG_XZ_DEC_BCJ=y
+ CONFIG_DECOMPRESS_GZIP=y
+ CONFIG_DECOMPRESS_BZIP2=y
+ CONFIG_DECOMPRESS_LZMA=y
+ CONFIG_DECOMPRESS_XZ=y
+ CONFIG_DECOMPRESS_LZO=y
+ CONFIG_DECOMPRESS_LZ4=y
+ CONFIG_ASSOCIATIVE_ARRAY=y
+ CONFIG_HAS_IOMEM=y
+ CONFIG_HAS_IOPORT_MAP=y
+ CONFIG_HAS_DMA=y
+ CONFIG_CPU_RMAP=y
+ CONFIG_DQL=y
+ CONFIG_GLOB=y
+ CONFIG_NLATTR=y
+ CONFIG_GENERIC_ATOMIC64=y
+ CONFIG_ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE=y
+ CONFIG_AVERAGE=y
+ CONFIG_LIBFDT=y
+ CONFIG_OID_REGISTRY=y
+ CONFIG_HAVE_KVM=y
diff -rcNP linux-4.4.24/arch/mips/include/asm/maar.h linux-4.4.24-baikal/arch/mips/include/asm/maar.h
*** linux-4.4.24/arch/mips/include/asm/maar.h	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/arch/mips/include/asm/maar.h	2016-11-11 14:49:51.000000000 +0300
***************
*** 26,32 ****
   *
   * Return:	The number of MAAR pairs configured.
   */
! unsigned platform_maar_init(unsigned num_pairs);
  
  /**
   * write_maar_pair() - write to a pair of MAARs
--- 26,32 ----
   *
   * Return:	The number of MAAR pairs configured.
   */
! unsigned __weak platform_maar_init(unsigned num_pairs);
  
  /**
   * write_maar_pair() - write to a pair of MAARs
***************
*** 66,80 ****
  }
  
  /**
-  * maar_init() - initialise MAARs
-  *
-  * Performs initialisation of MAARs for the current CPU, making use of the
-  * platforms implementation of platform_maar_init where necessary and
-  * duplicating the setup it provides on secondary CPUs.
-  */
- extern void maar_init(void);
- 
- /**
   * struct maar_config - MAAR configuration data
   * @lower:	The lowest address that the MAAR pair will affect. Must be
   *		aligned to a 2^16 byte boundary.
--- 66,71 ----
diff -rcNP linux-4.4.24/arch/mips/include/asm/mach-baikal/cpu-feature-overrides.h linux-4.4.24-baikal/arch/mips/include/asm/mach-baikal/cpu-feature-overrides.h
*** linux-4.4.24/arch/mips/include/asm/mach-baikal/cpu-feature-overrides.h	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/arch/mips/include/asm/mach-baikal/cpu-feature-overrides.h	2016-11-11 14:48:05.000000000 +0300
***************
*** 0 ****
--- 1,84 ----
+ /*
+  * Baikal-T SOC platform support code.
+  *
+  * Copyright (C) 2014  Baikal Electronics OJSC
+  *
+  * This program is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU General Public License
+  * as published by the Free Software Foundation; either version 2
+  * of the License, or (at your option) any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; if not, write to the Free Software
+  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+  */
+ #ifndef _BAIKAL_CPU_FEATURE_OVERRIDES_H
+ #define _BAIKAL_CPU_FEATURE_OVERRIDES_H
+ 
+ #if 0
+ 
+ #define cpu_has_tlb		1
+ #define cpu_has_4kex		1
+ #define cpu_has_3k_cache	0
+ #define cpu_has_4k_cache	1
+ #define cpu_has_tx39_cache	0
+ #define cpu_has_sb1_cache	0
+ #define cpu_has_fpu		0
+ #define cpu_has_32fpr		0
+ #define cpu_has_counter		1
+ #define cpu_has_watch		1
+ #define cpu_has_divec		1
+ 
+ #define cpu_has_prefetch	1
+ #define cpu_has_ejtag		1
+ #define cpu_has_llsc		1
+ 
+ #define cpu_has_mips16		1
+ #define cpu_has_mdmx		0
+ #define cpu_has_mips3d		0
+ #define cpu_has_smartmips	0
+ 
+ #define cpu_has_mips32r1	1
+ #define cpu_has_mips32r2	1
+ #define cpu_has_mips64r1	0
+ #define cpu_has_mips64r2	0
+ 
+ #define cpu_has_dsp		1
+ #define cpu_has_mipsmt		0
+ 
+ #define cpu_has_64bits		0
+ #define cpu_has_64bit_zero_reg	0
+ #define cpu_has_64bit_gp_regs	0
+ #define cpu_has_64bit_addresses	0
+ 
+ #define cpu_dcache_line_size()	32
+ #define cpu_icache_line_size()	32
+ #define cpu_has_maar		0
+ #define cpu_has_tlbinv		1
+ 
+ #endif
+ 
+ #define cpu_has_64bits		0
+ #define cpu_has_mips32r1	1
+ #define cpu_has_mips32r2	1
+ #define cpu_has_mips64r1	0
+ #define cpu_has_mips64r2	0
+ 
+ #define cpu_has_veic		1
+ #define cpu_has_mipsmt		0
+ #define cpu_has_counter		1
+ #ifdef CONFIG_CPU_HAS_MSA
+ #define cpu_has_msa		1
+ #else
+ #define cpu_has_msa		0
+ #endif
+ 
+ #define cpu_has_maar		1
+ #define cpu_has_htw		0
+ 
+ #endif /* _BAIKAL_CPU_FEATURE_OVERRIDES_H */
diff -rcNP linux-4.4.24/arch/mips/include/asm/mach-baikal/gpio.h linux-4.4.24-baikal/arch/mips/include/asm/mach-baikal/gpio.h
*** linux-4.4.24/arch/mips/include/asm/mach-baikal/gpio.h	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/arch/mips/include/asm/mach-baikal/gpio.h	2016-11-11 14:48:05.000000000 +0300
***************
*** 0 ****
--- 1,28 ----
+ /*
+  * Baikal-T SOC platform support code.
+  *
+  * Copyright (C) 2014  Baikal Electronics OJSC
+  *
+  * This program is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU General Public License
+  * as published by the Free Software Foundation; either version 2
+  * of the License, or (at your option) any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; if not, write to the Free Software
+  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+  */
+ #ifndef __ASM_ARM_ARCH_GPIO_H
+ #define __ASM_ARM_ARCH_GPIO_H
+ 
+ #define ARCH_NR_GPIOS 40
+ 
+ #include_next <gpio.h>
+ 
+ #endif /* __ASM_ARM_ARCH_GPIO_H */
+ 
diff -rcNP linux-4.4.24/arch/mips/include/asm/mach-baikal/hardware.h linux-4.4.24-baikal/arch/mips/include/asm/mach-baikal/hardware.h
*** linux-4.4.24/arch/mips/include/asm/mach-baikal/hardware.h	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/arch/mips/include/asm/mach-baikal/hardware.h	2016-11-11 14:48:05.000000000 +0300
***************
*** 0 ****
--- 1,88 ----
+ /*
+  * Baikal-T SOC platform support code.
+  *
+  * Copyright (C) 2014,2015  Baikal Electronics OJSC
+  *
+  * This program is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU General Public License
+  * as published by the Free Software Foundation; either version 2
+  * of the License, or (at your option) any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; if not, write to the Free Software
+  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+  */
+ 
+ #ifndef __ASM_ARCH_HARDWARE_H
+ #define __ASM_ARCH_HARDWARE_H
+ /*
+  * 26.08.2013 Dmitry Duanev
+  * In terms of address constants the physical addresses has
+  * suffix _START. All virtual addresses has suffix _BASE
+  * The constant prefix specifies the target CPU (f.ex BAIKAL_)
+  *
+  * 27.01.2014 Dmitry Dunaev
+  * Memory map is adopted to the MIPS architecture
+  */
+ 
+ #include <linux/sizes.h>
+ 
+ /* Global IO addresses */
+ #define BAIKAL_IO_START			(0x1F000000)
+ #define BAIKAL_IO_SIZE			SZ_16M
+ /* PCI mapping region */
+ #define BAIKAL_PCI_MAP_START	(0x08000000)
+ #define BAIKAL_PCI_MAP_SIZE		SZ_256M
+ 
+ /* Physical allocation of subsystems */
+ #define BAIKAL_BOOT_START		(0x1FC00000)
+ #define BAIKAL_BOOT_SIZE		SZ_4M
+ #define BAIKAL_SRAM_START		(0x1BF80000)
+ #define BAIKAL_SRAM_SIZE		SZ_64K
+ #define BAIKAL_ROM_START		(0x1BFC0000)
+ #define BAIKAL_ROM_SIZE			SZ_64K
+ #define BAIKAL_DRAM_START		(0x00000000)
+ #define BAIKAL_DRAM_SIZE		SZ_128M
+ #define BAIKAL_HIGHMEM_START	(0x20000000)
+ #define BAIKAL_HIGHMEM_SIZE		SZ_1G
+ 
+ /* Peripheral addresses, offset from BAIKAL_IO_START */
+ #define BAIKAL_P5600			(BAIKAL_IO_START + 0x00000000)
+ #define BAIKAL_BOOT_CTRL_START	(BAIKAL_IO_START + 0x00040000)
+ #define BAIKAL_BOOT_CTRL_CSR	(BAIKAL_BOOT_CTRL_START + 0x00)
+ #define BAIKAL_BOOT_CTRL_MAR	(BAIKAL_BOOT_CTRL_START + 0x04)
+ #define BAIKAL_BOOT_CTRL_DRID	(BAIKAL_BOOT_CTRL_START + 0x08)
+ #define BAIKAL_BOOT_CTRL_VID	(BAIKAL_BOOT_CTRL_START + 0x0C)
+ #define BAIKAL_DMA_START		(BAIKAL_IO_START + 0x00041000)
+ #define BAIKAL_DDR_START		(BAIKAL_IO_START + 0x00042000)
+ #define BAIKAL_DDR_PHY			(BAIKAL_IO_START + 0x00043000)
+ #define BAIKAL_GPIO_START		(BAIKAL_IO_START + 0x00044000)
+ #define BAIKAL_CTRL_GPIO_START	(BAIKAL_IO_START + 0x00045000)
+ #define BAIKAL_I2C_START		(BAIKAL_IO_START + 0x00046000)
+ #define BAIKAL_SPI_START		(BAIKAL_IO_START + 0x00047000)
+ #define BAIKAL_RTC_START		(BAIKAL_IO_START + 0x00048000)
+ #define BAIKAL_TIMERS_START		(BAIKAL_IO_START + 0x00049000)
+ #define BAIKAL_UART0_START		(BAIKAL_IO_START + 0x0004A000)
+ #define BAIKAL_UART1_START		(BAIKAL_IO_START + 0x0004B000)
+ #define BAIKAL_WDT_START		(BAIKAL_IO_START + 0x0004C000)
+ #define BAIKAL_PMU_START		(BAIKAL_IO_START + 0x0004D000)
+ #define BAIKAL_PMU_I2C_START	(BAIKAL_IO_START + 0x0004D800)
+ #define BAIKAL_GMAC_START		(BAIKAL_IO_START + 0x0004E000)
+ #define BAIKAL_GMAC_DMA			(BAIKAL_IO_START + 0x0004F000)
+ #define BAIKAL_SATA_START		(BAIKAL_IO_START + 0x00050000)
+ #define BAIKAL_PCI_START		(BAIKAL_IO_START + 0x00051000)
+ #define BAIKAL_PCI_DMA			(BAIKAL_IO_START + 0x00052000)
+ #define BAIKAL_USB_START		(BAIKAL_IO_START + 0x00053000)
+ #define BAIKAL_USB_DMA			(BAIKAL_IO_START + 0x00054000)
+ #define BAIKAL_XGMAC_START		(BAIKAL_IO_START + 0x00055000)
+ #define BAIKAL_XGMAC_DMA		(BAIKAL_IO_START + 0x00056000)
+ #define BAIKAL_VIRTUAL_BLOCK	(BAIKAL_IO_START + 0x000FF000)
+ #define BAIKAL_VBLOCK_EXIT		(BAIKAL_VIRTUAL_BLOCK + 0x00)
+ #define BAIKAL_VBLOCK_REVISION	(BAIKAL_VIRTUAL_BLOCK + 0x04)
+ 
+ #endif /* __ASM_ARCH_HARDWARE_H */
diff -rcNP linux-4.4.24/arch/mips/include/asm/mach-baikal/irq.h linux-4.4.24-baikal/arch/mips/include/asm/mach-baikal/irq.h
*** linux-4.4.24/arch/mips/include/asm/mach-baikal/irq.h	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/arch/mips/include/asm/mach-baikal/irq.h	2016-11-11 14:48:05.000000000 +0300
***************
*** 0 ****
--- 1,28 ----
+ /*
+  * Baikal-T SOC platform support code.
+  *
+  * Copyright (C) 2014  Baikal Electronics OJSC
+  *
+  * This program is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU General Public License
+  * as published by the Free Software Foundation; either version 2
+  * of the License, or (at your option) any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; if not, write to the Free Software
+  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+  */
+ #ifndef __ASM_BAIKAL_IRQ_H
+ #define __ASM_BAIKAL_IRQ_H
+ 
+ #define NR_IRQS 255
+ #define MIPS_CPU_IRQ_BASE	0
+ 
+ #include_next <irq.h>
+ 
+ #endif /* __ASM_BAIKAL_IRQ_H */
diff -rcNP linux-4.4.24/arch/mips/include/asm/mach-baikal/kernel-entry-init.h linux-4.4.24-baikal/arch/mips/include/asm/mach-baikal/kernel-entry-init.h
*** linux-4.4.24/arch/mips/include/asm/mach-baikal/kernel-entry-init.h	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/arch/mips/include/asm/mach-baikal/kernel-entry-init.h	2016-11-11 14:49:51.000000000 +0300
***************
*** 0 ****
--- 1,307 ----
+ /*
+  * This file is subject to the terms and conditions of the GNU General Public
+  * License.  See the file "COPYING" in the main directory of this archive
+  * for more details.
+  *
+  * Chris Dearman (chris@mips.com)
+  * Copyright (C) 2007 Mips Technologies, Inc.
+  * Copyright (C) 2014 Imagination Technologies Ltd.
+  */
+ #ifndef __ASM_MACH_MIPS_KERNEL_ENTRY_INIT_H
+ #define __ASM_MACH_MIPS_KERNEL_ENTRY_INIT_H
+ 
+ #include <asm/regdef.h>
+ #include <asm/mipsregs.h>
+ 
+ 	/*
+ 	 * Prepare segments for EVA boot:
+ 	 *
+ 	 * This is in case the processor boots in legacy configuration
+ 	 * (SI_EVAReset is de-asserted and CONFIG5.K == 0)
+ 	 *
+ 	 * ========================= Mappings =============================
+ 	 * Virtual memory           Physical memory           Mapping
+ 	 * 0x00000000 - 0x7fffffff  0x80000000 - 0xfffffffff   MUSUK (kuseg)
+ 	 *                          Flat 2GB physical memory
+ 	 *
+ 	 * 0x80000000 - 0x9fffffff  0x00000000 - 0x1ffffffff   MUSUK (kseg0)
+ 	 * 0xa0000000 - 0xbf000000  0x00000000 - 0x1ffffffff   MUSUK (kseg1)
+ 	 * 0xc0000000 - 0xdfffffff             -                 MK  (kseg2)
+ 	 * 0xe0000000 - 0xffffffff             -                 MK  (kseg3)
+ 	 *
+ 	 *
+ 	 * Lowmem is expanded to 2GB
+ 	 *
+ 	 * The following code uses the t0, t1, t2 and ra registers without
+ 	 * previously preserving them.
+ 	 *
+ 	 */
+ 	.macro	platform_eva_init
+ 
+ 	.set	push
+ 	.set	reorder
+ #if 0
+ 	/*
+ 	 * Get Config.K0 value and use it to program
+ 	 * the segmentation registers
+ 	 */
+ 	mfc0    t1, CP0_CONFIG
+ 	andi	t1, 0x7 /* CCA */
+ #endif
+ 	/*
+ 	 * Directly use cacheable, coherent, write-back,
+ 	 * write-allocate, read misses request shared attribute
+ 	 */
+ 	li      t1, 0x5
+ 	move	t2, t1
+ 	ins	t2, t1, 16, 3
+ 	/* SegCtl0 */
+ 	li      t0, ((MIPS_SEGCFG_MK << MIPS_SEGCFG_AM_SHIFT) |		\
+ 		(0 << MIPS_SEGCFG_PA_SHIFT) |				\
+ 		(1 << MIPS_SEGCFG_EU_SHIFT)) |				\
+ 		(((MIPS_SEGCFG_MK << MIPS_SEGCFG_AM_SHIFT) |		\
+ 		(0 << MIPS_SEGCFG_PA_SHIFT) |				\
+ 		(1 << MIPS_SEGCFG_EU_SHIFT)) << 16)
+ 	or	t0, t2
+ 	mtc0	t0, CP0_PAGEMASK, 2
+ 
+ 	/* SegCtl1 */
+ 	li      t0, ((MIPS_SEGCFG_MUSUK << MIPS_SEGCFG_AM_SHIFT) |	\
+ 		(0 << MIPS_SEGCFG_PA_SHIFT) |				\
+ 		(2 << MIPS_SEGCFG_C_SHIFT) |				\
+ 		(1 << MIPS_SEGCFG_EU_SHIFT)) |				\
+ 		(((MIPS_SEGCFG_MUSUK << MIPS_SEGCFG_AM_SHIFT) |		\
+ 		(0 << MIPS_SEGCFG_PA_SHIFT) |				\
+ 		(1 << MIPS_SEGCFG_EU_SHIFT)) << 16)
+ 	ins	t0, t1, 16, 3
+ 	mtc0	t0, CP0_PAGEMASK, 3
+ 
+ 	/* SegCtl2 */
+ 	li	t0, ((MIPS_SEGCFG_MUSUK << MIPS_SEGCFG_AM_SHIFT) |	\
+ 		(6 << MIPS_SEGCFG_PA_SHIFT) |				\
+ 		(1 << MIPS_SEGCFG_EU_SHIFT)) |				\
+ 		(((MIPS_SEGCFG_MUSUK << MIPS_SEGCFG_AM_SHIFT) |		\
+ 		(4 << MIPS_SEGCFG_PA_SHIFT) |				\
+ 		(1 << MIPS_SEGCFG_EU_SHIFT)) << 16)
+ 	or	t0, t2
+ 	mtc0	t0, CP0_PAGEMASK, 4
+ 
+ 	jal	mips_ihb
+ 	mfc0    t0, CP0_CONFIG, 5
+ 	li      t2, MIPS_CONF5_K      /* K bit */
+ 	or      t0, t0, t2
+ 	mtc0    t0, CP0_CONFIG, 5
+ 
+ 	sync
+ 	jal	mips_ihb
+ 
+ 	mfc0    t0, CP0_CONFIG, 0
+ 	li      t2, MIPS32R5_CONF_MM      /* Write Merge */
+ 	or      t0, t0, t2
+ 	mtc0    t0, CP0_CONFIG, 0
+ 	sync
+ 	jal	mips_ihb
+ 	nop
+ 
+ 	.set	pop
+ 	.endm
+ 
+ 	/*
+ 	 * Prepare segments for LEGACY boot:
+ 	 *
+ 	 * ========================= Mappings =============================
+ 	 * Segment   Virtual    Size   Access Mode   Physical   Caching   EU
+ 	 * -------   -------    ----   -----------   --------   -------   --
+ 	 *    0      e0000000   512M      MK            UND         U       0
+ 	 *    1      c0000000   512M      MSK           UND         U       0
+ 	 *    2      a0000000   512M      UK            000         2       0
+ 	 *    3      80000000   512M      UK            000         3       0
+ 	 *    4      40000000    1G       MUSK          UND         U       1
+ 	 *    5      00000000    1G       MUSK          UND         U       1
+ 	 *
+ 	 * The following code uses the t0, t1, t2 and ra registers without
+ 	 * previously preserving them.
+ 	 *
+ 	 */
+ 	.macro	platform_legacy_init
+ 
+ 	.set	push
+ 	.set	reorder
+ #if 0
+ 	/*
+ 	 * Get Config.K0 value and use it to program
+ 	 * the segmentation registers
+ 	 */
+ 	mfc0    t1, CP0_CONFIG
+ 	andi	t1, 0x7 /* CCA */
+ #endif
+ 	/*
+ 	 * Directly use cacheable, coherent, write-back,
+ 	 * write-allocate, read misses request shared attribute
+ 	 */
+ 	li      t1, 0x5
+ 	move	t2, t1
+ 	ins	t2, t1, 16, 3
+ 	/* SegCtl0 */
+ 	li      t0, ((MIPS_SEGCFG_MK << MIPS_SEGCFG_AM_SHIFT) |		\
+ 		(0 << MIPS_SEGCFG_PA_SHIFT)) |				\
+ 		(((MIPS_SEGCFG_MSK << MIPS_SEGCFG_AM_SHIFT) |		\
+ 		(0 << MIPS_SEGCFG_PA_SHIFT)) << 16)
+ 	or	t0, t2
+ 	mtc0	t0, CP0_PAGEMASK, 2
+ 
+ 	/* SegCtl1 */
+ 	li      t0, ((MIPS_SEGCFG_UK << MIPS_SEGCFG_AM_SHIFT) |	\
+ 		(0 << MIPS_SEGCFG_PA_SHIFT) |				\
+ 		(2 << MIPS_SEGCFG_C_SHIFT)) |				\
+ 		(((MIPS_SEGCFG_UK << MIPS_SEGCFG_AM_SHIFT) |		\
+ 		(0 << MIPS_SEGCFG_PA_SHIFT)) << 16)
+ 	ins	t0, t1, 16, 3
+ 	mtc0	t0, CP0_PAGEMASK, 3
+ 
+ 	/* SegCtl2 */
+ 	li	t0, ((MIPS_SEGCFG_MUSK << MIPS_SEGCFG_AM_SHIFT) |	\
+ 		(6 << MIPS_SEGCFG_PA_SHIFT) |				\
+ 		(1 << MIPS_SEGCFG_EU_SHIFT)) |				\
+ 		(((MIPS_SEGCFG_MUSK << MIPS_SEGCFG_AM_SHIFT) |		\
+ 		(4 << MIPS_SEGCFG_PA_SHIFT) |				\
+ 		(1 << MIPS_SEGCFG_EU_SHIFT)) << 16)
+ 	or	t0, t2
+ 	mtc0	t0, CP0_PAGEMASK, 4
+ 
+ 	jal	mips_ihb
+ 	nop
+ 
+ 	mfc0    t0, CP0_CONFIG, 5
+ 	li      t2, MIPS_CONF5_K      /* K bit */
+ 	or      t0, t0, t2
+ 	mtc0    t0, CP0_CONFIG, 5
+ 	sync
+ 	jal	mips_ihb
+ 	nop
+ 
+ 	mfc0    t0, CP0_CONFIG, 0
+ 	li      t2, MIPS32R5_CONF_MM      /* Write Merge */
+ 	or      t0, t0, t2
+ 	mtc0    t0, CP0_CONFIG, 0
+ 	sync
+ 	jal	mips_ihb
+ 	nop
+ 
+ 	.set	pop
+ 	.endm
+ 
+ 	.macro	platform_errata_fix
+ 
+ 	.set	push
+ 	.set	reorder
+ 
+ 	jal	mips_ihb
+ 	nop
+ 
+ 	/*
+ 	 * Disable load/store bonding.
+ 	 */
+ 	mfc0    t0, CP0_CONFIG, 6
+ 	lui     t1, (MIPS_CONF6_DLSB >> 16)
+ 	or      t0, t0, t1
+ 	/*
+ 	 * This disables all JR prediction other than JR $31.
+ 	 */
+ 	ori     t0, t0, MIPS_CONF6_JRCD
+ 	mtc0    t0, CP0_CONFIG, 6
+ 	sync
+ 	jal	mips_ihb
+ 	nop
+ 
+ 	/*
+ 	 * This disables all JR $31 prediction through return prediction stack.
+ 	 */
+ 	mfc0    t0, CP0_CONFIG, 7
+ 	ori     t0, t0, MIPS_CONF7_RPS
+ 	mtc0    t0, CP0_CONFIG, 7
+ 	sync
+ 	jal	mips_ihb
+ 	nop
+ 
+ 	.set	pop
+ 	.endm
+ 
+ 	.macro	platform_enable_msa
+ 
+ 	.set	push
+ 	.set	reorder
+ 
+ #ifdef CONFIG_CPU_HAS_MSA
+ 	jal	mips_ihb
+ 	nop
+ 
+ 	mfc0	t0, CP0_CONFIG, 5
+ 	li	t1, MIPS_CONF5_MSAEN
+ 	or	t0, t0, t1
+ 	mtc0	t0, CP0_CONFIG, 5
+ 	sync
+ 	jal	mips_ihb
+ 	nop
+ 
+ 	mfc0	t0, CP0_STATUS, 0
+ 	li	t1, ST0_FR
+ 	or	t0, t0, t1
+ 	mtc0	t0, CP0_STATUS, 0
+ 	sync
+ 	jal	mips_ihb
+ 	nop
+ #endif /* CONFIG_CPU_HAS_MSA */
+ 
+ 	.set	pop
+ 	.endm
+ 
+ 	.macro	kernel_entry_setup
+ 
+ 	sync
+ 	ehb
+ 
+ #ifdef CONFIG_EVA
+ 	mfc0    t1, CP0_CONFIG
+ 	bgez    t1, 9f
+ 	mfc0	t0, CP0_CONFIG, 1
+ 	bgez	t0, 9f
+ 	mfc0	t0, CP0_CONFIG, 2
+ 	bgez	t0, 9f
+ 	mfc0	t0, CP0_CONFIG, 3
+ 	sll     t0, t0, 6   /* SC bit */
+ 	bgez    t0, 9f
+ 
+ 	platform_eva_init
+ 
+ 	b       0f
+ 9:	b	9b
+ 	nop
+ #else
+ 	platform_legacy_init
+ #endif /* CONFIG_EVA */
+ 0:
+ 	platform_errata_fix
+ 	platform_enable_msa
+ 
+ 	.endm
+ 
+ /*
+  * Do SMP slave processor setup necessary before we can safely execute C code.
+  */
+ 	.macro	smp_slave_setup
+ 	sync
+ 	ehb
+ 
+ #ifdef CONFIG_EVA
+ 	platform_eva_init
+ #else
+ 	platform_legacy_init
+ #endif  /* CONFIG_EVA */
+ 
+ 	platform_errata_fix
+ 	platform_enable_msa
+ 
+ 	.endm
+ 
+ #endif /* __ASM_MACH_MIPS_KERNEL_ENTRY_INIT_H */
diff -rcNP linux-4.4.24/arch/mips/include/asm/mach-baikal/spaces.h linux-4.4.24-baikal/arch/mips/include/asm/mach-baikal/spaces.h
*** linux-4.4.24/arch/mips/include/asm/mach-baikal/spaces.h	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/arch/mips/include/asm/mach-baikal/spaces.h	2016-11-11 14:48:05.000000000 +0300
***************
*** 0 ****
--- 1,50 ----
+ /*
+  * Baikal-T SOC platform support code.
+  *
+  * Copyright (C) 2014  Baikal Electronics OJSC
+  *
+  * This program is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU General Public License
+  * as published by the Free Software Foundation; either version 2
+  * of the License, or (at your option) any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; if not, write to the Free Software
+  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+  */
+ #ifndef _ASM_BAIKAL_SPACES_H
+ #define _ASM_BAIKAL_SPACES_H
+ 
+ #include <asm/mach-baikal/hardware.h>
+ 
+ /*
+  * Virtual addresses offset
+  */
+ #define PAGE_OFFSET 		_AC(0x80000000, UL)
+ /*
+  * Physical addresses offset
+  */
+ #define PHYS_OFFSET 		_AC(0x00000000, UL)
+ 
+ /*
+  * Uncached addresses offset
+  */
+ #define UNCAC_BASE	_AC(0xa0000000, UL)	/* 0xa0000000 + PHYS_OFFSET */
+ 
+ /*
+  * High memory segment physical addresses
+  */
+ #define HIGHMEM_START		_AC(0x20000000, UL)
+ /*
+  * I/O memory space
+  */
+ #define IO_BASE		UNCAC_BASE
+ 
+ #include_next <spaces.h>
+ 
+ #endif /* __ASM_BAIKAL_SPACES_H */
diff -rcNP linux-4.4.24/arch/mips/include/asm/mach-baikal/war.h linux-4.4.24-baikal/arch/mips/include/asm/mach-baikal/war.h
*** linux-4.4.24/arch/mips/include/asm/mach-baikal/war.h	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/arch/mips/include/asm/mach-baikal/war.h	2016-11-11 14:48:05.000000000 +0300
***************
*** 0 ****
--- 1,38 ----
+ /*
+  * Baikal-T SOC platform support code.
+  *
+  * Copyright (C) 2014  Baikal Electronics OJSC
+  *
+  * This program is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU General Public License
+  * as published by the Free Software Foundation; either version 2
+  * of the License, or (at your option) any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; if not, write to the Free Software
+  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+  */
+ #ifndef __ASM_MIPS_MACH_MIPS_WAR_H
+ #define __ASM_MIPS_MACH_MIPS_WAR_H
+ 
+ #define R4600_V1_INDEX_ICACHEOP_WAR		0
+ #define R4600_V1_HIT_CACHEOP_WAR		0
+ #define R4600_V2_HIT_CACHEOP_WAR		0
+ #define R5432_CP0_INTERRUPT_WAR			0
+ #define BCM1250_M3_WAR					0
+ #define SIBYTE_1956_WAR					0
+ #define MIPS4K_ICACHE_REFILL_WAR		0
+ #define MIPS_CACHE_SYNC_WAR				0
+ #define TX49XX_ICACHE_INDEX_INV_WAR		0
+ #define ICACHE_REFILLS_WORKAROUND_WAR	0
+ #define R10000_LLSC_WAR					0
+ #define MIPS34K_MISSED_ITLB_WAR			0
+ 
+ #include <asm/war.h>
+ 
+ #endif /* __ASM_MIPS_MACH_MIPS_WAR_H */
diff -rcNP linux-4.4.24/arch/mips/include/asm/mips-boards/baikal.h linux-4.4.24-baikal/arch/mips/include/asm/mips-boards/baikal.h
*** linux-4.4.24/arch/mips/include/asm/mips-boards/baikal.h	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/arch/mips/include/asm/mips-boards/baikal.h	2016-11-11 14:49:51.000000000 +0300
***************
*** 0 ****
--- 1,49 ----
+ /*
+  * Baikal-T SOC platform support code.
+  *
+  * Copyright (C) 2014-2016  Baikal Electronics OJSC
+  * 
+  * Author:
+  *   Dmitry Dunaev <dmitry.dunaev@baikalelectronics.ru>
+  *
+  * This program is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU General Public License
+  * as published by the Free Software Foundation; either version 2
+  * of the License, or (at your option) any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; if not, write to the Free Software
+  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+  */
+ 
+ #ifndef __ASM_MIPS_BOARDS_BAIKAL_H
+ #define __ASM_MIPS_BOARDS_BAIKAL_H
+ 
+ #include <asm/addrspace.h>
+ #include <asm/io.h>
+ 
+ /*
+  * GCMP Specific definitions
+  */
+ #define GCMP_BASE_ADDR			0x1fbf8000
+ #define GCMP_ADDRSPACE_SZ		(256 * 1024)
+ 
+ /*
+  * GIC Specific definitions
+  */
+ #define GIC_BASE_ADDR			0x1bdc0000
+ #define GIC_ADDRSPACE_SZ		(128 * 1024)
+ 
+ /*
+  * CPC Specific definitions
+  */
+ #define CPC_BASE_ADDR			0x1bde0000
+ #define CPC_ADDRSPACE_SZ		(24 * 1024)
+ 
+ 
+ #endif /* __ASM_MIPS_BOARDS_BAIKAL_H */
diff -rcNP linux-4.4.24/arch/mips/include/asm/mipsregs.h linux-4.4.24-baikal/arch/mips/include/asm/mipsregs.h
*** linux-4.4.24/arch/mips/include/asm/mipsregs.h	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/arch/mips/include/asm/mipsregs.h	2016-11-11 14:49:51.000000000 +0300
***************
*** 61,66 ****
--- 61,67 ----
  #define CP0_EPC $14
  #define CP0_PRID $15
  #define CP0_EBASE $15, 1
+ #define CP0_CDMMBASE $15, 2
  #define CP0_CMGCRBASE $15, 3
  #define CP0_CONFIG $16
  #define CP0_CONFIG3 $16, 3
***************
*** 493,498 ****
--- 494,508 ----
  #define MIPS_CONF_AT		(_ULCAST_(3) << 13)
  #define MIPS_CONF_M		(_ULCAST_(1) << 31)
  
+ /* Bits specific to the MIPS32R5. */
+ #define MIPS32R5_CONF_K23	(_ULCAST_(7) << 28)
+ #define MIPS32R5_CONF_KU	(_ULCAST_(7) << 25)
+ #define MIPS32R5_CONF_ISP	(_ULCAST_(1) << 24)
+ #define MIPS32R5_CONF_DSP	(_ULCAST_(1) << 23)
+ #define MIPS32R5_CONF_UDI	(_ULCAST_(1) << 22)
+ #define MIPS32R5_CONF_SB	(_ULCAST_(1) << 21)
+ #define MIPS32R5_CONF_MM	(_ULCAST_(1) << 18)
+ 
  /*
   * Bits in the MIPS32/64 PRA coprocessor 0 config registers 1 and above.
   */
***************
*** 596,612 ****
--- 606,629 ----
  #define MIPS_CONF5_CV		(_ULCAST_(1) << 29)
  #define MIPS_CONF5_K		(_ULCAST_(1) << 30)
  
+ /* Jump register cache prediction disable */
+ #define MIPS_CONF6_JRCD		(_ULCAST_(1) << 0)
+ /* MIPSr6 enable */
+ #define MIPS_CONF6_R6		(_ULCAST_(1) << 2)
  #define MIPS_CONF6_SYND		(_ULCAST_(1) << 13)
  /* proAptiv FTLB on/off bit */
  #define MIPS_CONF6_FTLBEN	(_ULCAST_(1) << 15)
  /* FTLB probability bits */
  #define MIPS_CONF6_FTLBP_SHIFT	(16)
+ /* Disable load/store bonding */
+ #define MIPS_CONF6_DLSB		(_ULCAST_(1) << 21)
  
  #define MIPS_CONF7_WII		(_ULCAST_(1) << 31)
  
  #define MIPS_CONF7_RPS		(_ULCAST_(1) << 2)
  
  #define MIPS_CONF7_IAR		(_ULCAST_(1) << 10)
+ /* Alias removed */
  #define MIPS_CONF7_AR		(_ULCAST_(1) << 16)
  /* FTLB probability bits for R6 */
  #define MIPS_CONF7_FTLBP_SHIFT	(18)
***************
*** 1205,1210 ****
--- 1222,1230 ----
  
  #define read_c0_prid()		__read_32bit_c0_register($15, 0)
  
+ #define read_c0_cdmm()		__read_ulong_c0_register($15, 2)
+ #define write_c0_cdmm(val)	__write_ulong_c0_register($15, 2, val)
+ 
  #define read_c0_cmgcrbase()	__read_ulong_c0_register($15, 3)
  
  #define read_c0_config()	__read_32bit_c0_register($16, 0)
diff -rcNP linux-4.4.24/arch/mips/Kbuild.platforms linux-4.4.24-baikal/arch/mips/Kbuild.platforms
*** linux-4.4.24/arch/mips/Kbuild.platforms	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/arch/mips/Kbuild.platforms	2016-11-11 14:49:51.000000000 +0300
***************
*** 4,9 ****
--- 4,10 ----
  platforms += ar7
  platforms += ath25
  platforms += ath79
+ platforms += baikal
  platforms += bcm47xx
  platforms += bcm63xx
  platforms += bmips
diff -rcNP linux-4.4.24/arch/mips/Kconfig linux-4.4.24-baikal/arch/mips/Kconfig
*** linux-4.4.24/arch/mips/Kconfig	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/arch/mips/Kconfig	2016-11-11 14:49:51.000000000 +0300
***************
*** 143,148 ****
--- 143,190 ----
  	help
  	  Support for the Atheros AR71XX/AR724X/AR913X SoCs.
  
+ config MIPS_BAIKAL
+ 	bool "MIPS Baikal-T SoC"
+ 	select BOOT_ELF32
+ 	select BOOT_RAW
+ 	select LIBFDT
+ 	select USE_OF
+ 	select GENERIC_ISA_DMA
+ 	select DMA_NONCOHERENT
+ 	select SCHED_HRTICK
+ 	select MIPS_CPU_SCACHE
+ 	select MIPS_MACHINE
+ 	select MIPS_GIC
+ 	select MIPS_GIC_IPI_LOW
+ 	select IRQ_DOMAIN
+ 	select SWAP_IO_SPACE
+ 	select HAVE_MACH_CLKDEV
+ 	select COMMON_CLK
+ 	select CLKDEV_LOOKUP
+ 	select CLKSRC_MIPS_GIC
+ 	select CPU_MIPSR2_IRQ_VI
+ 	select CPU_MIPSR2_IRQ_EI
+ 	select CPU_SUPPORTS_32BIT_KERNEL
+ 	select CPU_SUPPORTS_HIGHMEM
+ 	select CPU_SUPPORTS_UNCACHED_ACCELERATED
+ 	select CPU_HAS_SYNC
+ 	select CPU_HAS_PREFETCH
+ 	select CPU_SUPPORTS_MSA
+ 	select SYS_HAS_CPU_MIPS32_R2
+ 	select SYS_HAS_CPU_MIPS32_R3_5
+ 	select SYS_HAS_EARLY_PRINTK
+ 	select SYS_HAS_32BIT_KERNEL
+ 	select CPU_SUPPORTS_CPUFREQ
+ 	select SYS_SUPPORTS_HIGHMEM
+ 	select SYS_SUPPORTS_32BIT_KERNEL
+ 	select SYS_SUPPORTS_LITTLE_ENDIAN
+ 	select SYS_SUPPORTS_ZBOOT
+ 	select SYS_SUPPORTS_ZBOOT_UART16550
+ 	select SYS_SUPPORTS_MIPS_CPS
+ 	select SYS_SUPPORTS_SMP
+         help
+           Support for the Baikal-T SoCs.
+ 
  config BMIPS_GENERIC
  	bool "Broadcom Generic BMIPS kernel"
  	select BOOT_RAW
***************
*** 973,978 ****
--- 1015,1021 ----
  source "arch/mips/alchemy/Kconfig"
  source "arch/mips/ath25/Kconfig"
  source "arch/mips/ath79/Kconfig"
+ source "arch/mips/baikal/Kconfig"
  source "arch/mips/bcm47xx/Kconfig"
  source "arch/mips/bcm63xx/Kconfig"
  source "arch/mips/bmips/Kconfig"
***************
*** 2295,2300 ****
--- 2338,2346 ----
  	depends on MIPS_GIC
  	bool
  
+ config MIPS_GIC_IPI_LOW
+ 	bool
+ 
  config MIPS_CM
  	bool
  
***************
*** 3018,3024 ****
  source "net/Kconfig"
  
  source "drivers/Kconfig"
! 
  source "drivers/firmware/Kconfig"
  
  source "fs/Kconfig"
--- 3064,3070 ----
  source "net/Kconfig"
  
  source "drivers/Kconfig"
! 	
  source "drivers/firmware/Kconfig"
  
  source "fs/Kconfig"
diff -rcNP linux-4.4.24/arch/mips/kernel/smp.c linux-4.4.24-baikal/arch/mips/kernel/smp.c
*** linux-4.4.24/arch/mips/kernel/smp.c	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/arch/mips/kernel/smp.c	2016-11-11 14:49:51.000000000 +0300
***************
*** 43,48 ****
--- 43,50 ----
  #include <asm/time.h>
  #include <asm/setup.h>
  #include <asm/maar.h>
+  
+ extern void maar_init(void);
  
  cpumask_t cpu_callin_map;		/* Bitmask of started secondaries */
  
diff -rcNP linux-4.4.24/arch/mips/kernel/smp-cps.c linux-4.4.24-baikal/arch/mips/kernel/smp-cps.c
*** linux-4.4.24/arch/mips/kernel/smp-cps.c	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/arch/mips/kernel/smp-cps.c	2016-11-11 14:49:51.000000000 +0300
***************
*** 210,216 ****
  	if (mips_cpc_present()) {
  		/* Reset the core */
  		mips_cpc_lock_other(core);
! 		write_cpc_co_cmd(CPC_Cx_CMD_RESET);
  
  		timeout = 100;
  		while (true) {
--- 210,220 ----
  	if (mips_cpc_present()) {
  		/* Reset the core */
  		mips_cpc_lock_other(core);
! 		/*
! 		 * Use PWRUP instead of RESET command for operating EJTAG.
! 		 * Otherwise there is no EJTAG chain.
! 		 */
! 		write_cpc_co_cmd(CPC_Cx_CMD_PWRUP);
  
  		timeout = 100;
  		while (true) {
***************
*** 304,311 ****
  	if (cpu_has_mipsmt)
  		dmt();
  
! 	change_c0_status(ST0_IM, STATUSF_IP2 | STATUSF_IP3 | STATUSF_IP4 |
! 				 STATUSF_IP5 | STATUSF_IP6 | STATUSF_IP7);
  }
  
  static void cps_smp_finish(void)
--- 308,318 ----
  	if (cpu_has_mipsmt)
  		dmt();
  
! 	if (cpu_has_veic)
! 		clear_c0_status(ST0_IM);
! 	else
! 		change_c0_status(ST0_IM, STATUSF_IP2 | STATUSF_IP3 | STATUSF_IP4 |
! 				 	STATUSF_IP5 | STATUSF_IP6 | STATUSF_IP7);
  }
  
  static void cps_smp_finish(void)
diff -rcNP linux-4.4.24/arch/mips/mm/init.c linux-4.4.24-baikal/arch/mips/mm/init.c
*** linux-4.4.24/arch/mips/mm/init.c	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/arch/mips/mm/init.c	2016-11-11 14:49:51.000000000 +0300
***************
*** 37,50 ****
  #include <asm/cpu.h>
  #include <asm/dma.h>
  #include <asm/kmap_types.h>
- #include <asm/maar.h>
  #include <asm/mmu_context.h>
  #include <asm/sections.h>
  #include <asm/pgtable.h>
  #include <asm/pgalloc.h>
  #include <asm/tlb.h>
  #include <asm/fixmap.h>
- #include <asm/maar.h>
  
  /*
   * We have up to 8 empty zeroed pages so we can map one of the right colour
--- 37,48 ----
***************
*** 92,105 ****
  
  	BUG_ON(Page_dcache_dirty(page));
  
- 	preempt_disable();
  	pagefault_disable();
  	idx = (addr >> PAGE_SHIFT) & (FIX_N_COLOURS - 1);
  	idx += in_interrupt() ? FIX_N_COLOURS : 0;
  	vaddr = __fix_to_virt(FIX_CMAP_END - idx);
  	pte = mk_pte(page, prot);
  #if defined(CONFIG_PHYS_ADDR_T_64BIT) && defined(CONFIG_CPU_MIPS32)
! 	entrylo = pte_to_entrylo(pte.pte_high);
  #else
  	entrylo = pte_to_entrylo(pte_val(pte));
  #endif
--- 90,102 ----
  
  	BUG_ON(Page_dcache_dirty(page));
  
  	pagefault_disable();
  	idx = (addr >> PAGE_SHIFT) & (FIX_N_COLOURS - 1);
  	idx += in_interrupt() ? FIX_N_COLOURS : 0;
  	vaddr = __fix_to_virt(FIX_CMAP_END - idx);
  	pte = mk_pte(page, prot);
  #if defined(CONFIG_PHYS_ADDR_T_64BIT) && defined(CONFIG_CPU_MIPS32)
! 	entrylo = pte.pte_high;
  #else
  	entrylo = pte_to_entrylo(pte_val(pte));
  #endif
***************
*** 109,119 ****
  	write_c0_entryhi(vaddr & (PAGE_MASK << 1));
  	write_c0_entrylo0(entrylo);
  	write_c0_entrylo1(entrylo);
- #ifdef CONFIG_XPA
- 	entrylo = (pte.pte_low & _PFNX_MASK);
- 	writex_c0_entrylo0(entrylo);
- 	writex_c0_entrylo1(entrylo);
- #endif
  	tlbidx = read_c0_wired();
  	write_c0_wired(tlbidx + 1);
  	write_c0_index(tlbidx);
--- 106,111 ----
***************
*** 155,161 ****
  	write_c0_entryhi(old_ctx);
  	local_irq_restore(flags);
  	pagefault_enable();
- 	preempt_enable();
  }
  
  void copy_user_highpage(struct page *to, struct page *from,
--- 147,152 ----
***************
*** 253,371 ****
  #endif
  }
  
- unsigned __weak platform_maar_init(unsigned num_pairs)
- {
- 	struct maar_config cfg[BOOT_MEM_MAP_MAX];
- 	unsigned i, num_configured, num_cfg = 0;
- 	phys_addr_t skip;
- 
- 	for (i = 0; i < boot_mem_map.nr_map; i++) {
- 		switch (boot_mem_map.map[i].type) {
- 		case BOOT_MEM_RAM:
- 		case BOOT_MEM_INIT_RAM:
- 			break;
- 		default:
- 			continue;
- 		}
- 
- 		skip = 0x10000 - (boot_mem_map.map[i].addr & 0xffff);
- 
- 		cfg[num_cfg].lower = boot_mem_map.map[i].addr;
- 		cfg[num_cfg].lower += skip;
- 
- 		cfg[num_cfg].upper = cfg[num_cfg].lower;
- 		cfg[num_cfg].upper += boot_mem_map.map[i].size - 1;
- 		cfg[num_cfg].upper -= skip;
- 
- 		cfg[num_cfg].attrs = MIPS_MAAR_S;
- 		num_cfg++;
- 	}
- 
- 	num_configured = maar_config(cfg, num_cfg, num_pairs);
- 	if (num_configured < num_cfg)
- 		pr_warn("Not enough MAAR pairs (%u) for all bootmem regions (%u)\n",
- 			num_pairs, num_cfg);
- 
- 	return num_configured;
- }
- 
- void maar_init(void)
- {
- 	unsigned num_maars, used, i;
- 	phys_addr_t lower, upper, attr;
- 	static struct {
- 		struct maar_config cfgs[3];
- 		unsigned used;
- 	} recorded = { { { 0 } }, 0 };
- 
- 	if (!cpu_has_maar)
- 		return;
- 
- 	/* Detect the number of MAARs */
- 	write_c0_maari(~0);
- 	back_to_back_c0_hazard();
- 	num_maars = read_c0_maari() + 1;
- 
- 	/* MAARs should be in pairs */
- 	WARN_ON(num_maars % 2);
- 
- 	/* Set MAARs using values we recorded already */
- 	if (recorded.used) {
- 		used = maar_config(recorded.cfgs, recorded.used, num_maars / 2);
- 		BUG_ON(used != recorded.used);
- 	} else {
- 		/* Configure the required MAARs */
- 		used = platform_maar_init(num_maars / 2);
- 	}
- 
- 	/* Disable any further MAARs */
- 	for (i = (used * 2); i < num_maars; i++) {
- 		write_c0_maari(i);
- 		back_to_back_c0_hazard();
- 		write_c0_maar(0);
- 		back_to_back_c0_hazard();
- 	}
- 
- 	if (recorded.used)
- 		return;
- 
- 	pr_info("MAAR configuration:\n");
- 	for (i = 0; i < num_maars; i += 2) {
- 		write_c0_maari(i);
- 		back_to_back_c0_hazard();
- 		upper = read_c0_maar();
- 
- 		write_c0_maari(i + 1);
- 		back_to_back_c0_hazard();
- 		lower = read_c0_maar();
- 
- 		attr = lower & upper;
- 		lower = (lower & MIPS_MAAR_ADDR) << 4;
- 		upper = ((upper & MIPS_MAAR_ADDR) << 4) | 0xffff;
- 
- 		pr_info("  [%d]: ", i / 2);
- 		if (!(attr & MIPS_MAAR_V)) {
- 			pr_cont("disabled\n");
- 			continue;
- 		}
- 
- 		pr_cont("%pa-%pa", &lower, &upper);
- 
- 		if (attr & MIPS_MAAR_S)
- 			pr_cont(" speculate");
- 
- 		pr_cont("\n");
- 
- 		/* Record the setup for use on secondary CPUs */
- 		if (used <= ARRAY_SIZE(recorded.cfgs)) {
- 			recorded.cfgs[recorded.used].lower = lower;
- 			recorded.cfgs[recorded.used].upper = upper;
- 			recorded.cfgs[recorded.used].attrs = attr;
- 			recorded.used++;
- 		}
- 	}
- }
- 
  #ifndef CONFIG_NEED_MULTIPLE_NODES
  int page_is_ram(unsigned long pagenr)
  {
--- 244,249 ----
***************
*** 448,453 ****
--- 326,363 ----
  #endif
  }
  
+ unsigned __weak platform_maar_init(unsigned num_maars)
+ {
+ 	return 0;
+ }
+ 
+ void maar_init(void)
+ {
+ 	unsigned num_maars, used, i;
+ 
+ 	if (!cpu_has_maar)
+ 		return;
+ 
+ 	/* Detect the number of MAARs */
+ 	write_c0_maari(~0);
+ 	back_to_back_c0_hazard();
+ 	num_maars = read_c0_maari() + 1;
+ 
+ 	/* MAARs should be in pairs */
+ 	WARN_ON(num_maars % 2);
+ 
+ 	/* Configure the required MAARs */
+ 	used = platform_maar_init(num_maars / 2);
+ 
+ 	/* Disable any further MAARs */
+ 	for (i = (used * 2); i < num_maars; i++) {
+ 		write_c0_maari(i);
+ 		back_to_back_c0_hazard();
+ 		write_c0_maar(0);
+ 		back_to_back_c0_hazard();
+ 	}
+ }
+ 
  void __init mem_init(void)
  {
  #ifdef CONFIG_HIGHMEM
diff -rcNP linux-4.4.24/arch/mips/pci/fixup-baikal.c linux-4.4.24-baikal/arch/mips/pci/fixup-baikal.c
*** linux-4.4.24/arch/mips/pci/fixup-baikal.c	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/arch/mips/pci/fixup-baikal.c	2016-11-11 14:49:51.000000000 +0300
***************
*** 0 ****
--- 1,104 ----
+ /*
+  *  Baikal-T SOC platform support code.
+  *
+  *  Copyright (C) 2015,2016 Baikal Electronics JSC.
+  *
+  *  This program is free software; you can distribute it and/or modify it
+  *  under the terms of the GNU General Public License (Version 2) as
+  *  published by the Free Software Foundation.
+  *
+  *  This program is distributed in the hope it will be useful, but WITHOUT
+  *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+  *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+  *  for more details.
+  *
+  *  You should have received a copy of the GNU General Public License along
+  *  with this program; if not, write to the Free Software Foundation, Inc.,
+  *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+  *
+  *  BAIKAL MIPS boards specific PCI support.
+  */
+ 
+ #include <linux/of_irq.h>
+ #include <linux/of_pci.h>
+ 
+ #define NEC_VENDOR_ID		0x1033
+ #define NEC_USB3_DEVID		0x0194
+ 
+ #define SM_VENDOR_ID		0x126f
+ #define SM750_DEVID			0x0750
+ 
+ int pcibios_plat_dev_init(struct pci_dev *dev)
+ {
+ 	uint16_t config;
+ 	uint32_t dconfig;
+ 	int pos;
+ 
+ 	/* Enable reporting System errors and parity errors on all devices */
+ 	/* Enable parity checking and error reporting */
+ 	pci_read_config_word(dev, PCI_COMMAND, &config);
+ 	config |= PCI_COMMAND_PARITY | PCI_COMMAND_SERR;
+ 	pci_write_config_word(dev, PCI_COMMAND, config);
+ 
+ 
+ 	/* Enable the PCIe normal error reporting */
+ 	config = PCI_EXP_DEVCTL_CERE; /* Correctable Error Reporting */
+ 	config |= PCI_EXP_DEVCTL_NFERE; /* Non-Fatal Error Reporting */
+ 	config |= PCI_EXP_DEVCTL_FERE;	/* Fatal Error Reporting */
+ 	config |= PCI_EXP_DEVCTL_URRE;	/* Unsupported Request */
+ 	pcie_capability_set_word(dev, PCI_EXP_DEVCTL, config);
+ 
+ 	/* Find the Advanced Error Reporting capability */
+ 	pos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ERR);
+ 
+ 	if (pos) {
+ 		/* Clear Uncorrectable Error Status */
+ 		pci_read_config_dword(dev, pos + PCI_ERR_UNCOR_STATUS,
+ 				      &dconfig);
+ 		pci_write_config_dword(dev, pos + PCI_ERR_UNCOR_STATUS,
+ 				       dconfig);
+ 		/* Enable reporting of all uncorrectable errors */
+ 		/* Uncorrectable Error Mask - turned on bits disable errors */
+ 		pci_write_config_dword(dev, pos + PCI_ERR_UNCOR_MASK, 0);
+ 		/*
+ 		 * Leave severity at HW default. This only controls if
+ 		 * errors are reported as uncorrectable or
+ 		 * correctable, not if the error is reported.
+ 		 */
+ 		/* PCI_ERR_UNCOR_SEVER - Uncorrectable Error Severity */
+ 		/* Clear Correctable Error Status */
+ 		pci_read_config_dword(dev, pos + PCI_ERR_COR_STATUS, &dconfig);
+ 		pci_write_config_dword(dev, pos + PCI_ERR_COR_STATUS, dconfig);
+ 		/* Enable reporting of all correctable errors */
+ 		/* Correctable Error Mask - turned on bits disable errors */
+ 		pci_write_config_dword(dev, pos + PCI_ERR_COR_MASK, 0);
+ #ifdef DW_CHECK_ECRC
+ 		/* Advanced Error Capabilities */
+ 		pci_read_config_dword(dev, pos + PCI_ERR_CAP, &dconfig);
+ 		/* ECRC Generation Enable */
+ 		if (dconfig & PCI_ERR_CAP_ECRC_GENC)
+ 			dconfig |= PCI_ERR_CAP_ECRC_GENE;
+ 		/* ECRC Check Enable */
+ 		if (dconfig & PCI_ERR_CAP_ECRC_CHKC)
+ 			dconfig |= PCI_ERR_CAP_ECRC_CHKE;
+ 		pci_write_config_dword(dev, pos + PCI_ERR_CAP, dconfig);
+ #endif /* DW_CHECK_ECRC */
+ 		/* PCI_ERR_HEADER_LOG - Header Log Register (16 bytes) */
+ 		/* Report all errors to the root complex */
+ 		pci_write_config_dword(dev, pos + PCI_ERR_ROOT_COMMAND,
+ 				       PCI_ERR_ROOT_CMD_COR_EN |
+ 				       PCI_ERR_ROOT_CMD_NONFATAL_EN |
+ 				       PCI_ERR_ROOT_CMD_FATAL_EN);
+ 		/* Clear the Root status register */
+ 		pci_read_config_dword(dev, pos + PCI_ERR_ROOT_STATUS, &dconfig);
+ 		pci_write_config_dword(dev, pos + PCI_ERR_ROOT_STATUS, dconfig);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ int __init pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
+ {
+ 	return of_irq_parse_and_map_pci(dev, slot, pin);
+ }
+ 
diff -rcNP linux-4.4.24/arch/mips/pci/Makefile linux-4.4.24-baikal/arch/mips/pci/Makefile
*** linux-4.4.24/arch/mips/pci/Makefile	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/arch/mips/pci/Makefile	2016-11-11 14:49:51.000000000 +0300
***************
*** 32,37 ****
--- 32,38 ----
  obj-$(CONFIG_LEMOTE_MACH2F)	+= fixup-lemote2f.o ops-loongson2.o
  obj-$(CONFIG_LOONGSON_MACH3X)	+= fixup-loongson3.o ops-loongson3.o
  obj-$(CONFIG_MIPS_MALTA)	+= fixup-malta.o pci-malta.o
+ obj-$(CONFIG_MIPS_BAIKAL)	+= fixup-baikal.o pci-baikal.o ops-dw.o
  obj-$(CONFIG_PMC_MSP7120_GW)	+= fixup-pmcmsp.o ops-pmcmsp.o
  obj-$(CONFIG_PMC_MSP7120_EVAL)	+= fixup-pmcmsp.o ops-pmcmsp.o
  obj-$(CONFIG_PMC_MSP7120_FPGA)	+= fixup-pmcmsp.o ops-pmcmsp.o
***************
*** 64,67 ****
--- 65,69 ----
  ifdef CONFIG_PCI_MSI
  obj-$(CONFIG_CAVIUM_OCTEON_SOC) += msi-octeon.o
  obj-$(CONFIG_CPU_XLP)		+= msi-xlp.o
+ obj-$(CONFIG_MIPS_BAIKAL)	+= msi-baikal.o
  endif
diff -rcNP linux-4.4.24/arch/mips/pci/msi-baikal.c linux-4.4.24-baikal/arch/mips/pci/msi-baikal.c
*** linux-4.4.24/arch/mips/pci/msi-baikal.c	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/arch/mips/pci/msi-baikal.c	2016-11-11 14:49:51.000000000 +0300
***************
*** 0 ****
--- 1,207 ----
+ /*
+  *  Baikal-T SOC platform support code.
+  *
+  *  Copyright (C) 2015,2016 Baikal Electronics JSC.
+  *
+  *  This program is free software; you can distribute it and/or modify it
+  *  under the terms of the GNU General Public License (Version 2) as
+  *  published by the Free Software Foundation.
+  *
+  *  This program is distributed in the hope it will be useful, but WITHOUT
+  *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+  *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+  *  for more details.
+  *
+  *  You should have received a copy of the GNU General Public License along
+  *  with this program; if not, write to the Free Software Foundation, Inc.,
+  *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+  *
+  *  BAIKAL MIPS boards specific PCI support.
+  */
+ #include <linux/device.h>
+ #include <linux/init.h>
+ #include <linux/kernel.h>
+ #include <linux/msi.h>
+ #include <linux/spinlock.h>
+ 
+ #include "pci-baikal.h"
+ 
+ 
+ #define	MAX_DW_MSI_IRQS		256
+ #define HW_MSI_IRQ_OFF		512
+ 
+ typedef struct {
+ 	unsigned int		msi_data;
+ 	struct irq_domain	*irq_domain;
+ 	spinlock_t		msi_lock;
+ 	DECLARE_BITMAP(msi_irqs, MAX_DW_MSI_IRQS);
+ } dw_msi_data_t;
+ 
+ dw_msi_data_t 	dw_msi_data;
+ 
+ int arch_setup_msi_irq(struct pci_dev *dev, struct msi_desc *desc)
+ {
+ 	struct msi_msg msg;
+ 	int virq, hwirq;
+ 	unsigned int reg;
+ 	unsigned long flags;
+ 
+ 	spin_lock_irqsave(&dw_msi_data.msi_lock, flags);
+ 
+ 	if ((hwirq = bitmap_find_free_region(dw_msi_data.msi_irqs, MAX_DW_MSI_IRQS, 0)) < 0) {
+ 		spin_unlock_irqrestore(&dw_msi_data.msi_lock, flags);
+ 		pr_err("PCI MSI: Cannot allocate MSI HW interrupt number.\n");
+ 		return -ENOSPC;
+ 	}
+ 
+ 	/* Get a virtual interrupt number for MSI interrupt. */
+ 	if ((virq = irq_find_mapping(dw_msi_data.irq_domain, HW_MSI_IRQ_OFF + hwirq)) == 0) {
+ 		spin_unlock_irqrestore(&dw_msi_data.msi_lock, flags);
+ 		pr_err("PCI MSI: Cannot allocate MSI virtual interrupt number.\n");
+ 		return -ENOSPC;
+ 	}
+ 
+ 	/* Get MSI interrupt register based on virq */
+ 	reg = READ_PCIE_REG(PCIE_MSI_CTRL_INT_0_EN_OFF + MSI_INTERRUPT_OFF * (hwirq / 32));
+ 
+ 	/* Enable MSI interrupt. */
+ 	reg |= (1 << (hwirq % 32));
+ 	WRITE_PCIE_REG(PCIE_MSI_CTRL_INT_0_EN_OFF + MSI_INTERRUPT_OFF * (hwirq / 32), reg);
+ 
+ 	spin_unlock_irqrestore(&dw_msi_data.msi_lock, flags);
+ 
+ 	pr_info("PCI MSI: setup hwirq:%d  virq:%d\n", hwirq, virq);
+ 
+ 	/* Construct message. */
+ 	msg.data = hwirq;
+ 	msg.address_lo = virt_to_phys((void *)dw_msi_data.msi_data);
+ 	msg.address_hi = 0;
+ 
+ 	wmb();
+ 
+ 	irq_set_msi_desc(virq, desc);
+ 	pci_write_msi_msg(virq, &msg);
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * Called when a device no longer needs its MSI interrupts. All
+  * MSI interrupts for the device are freed.
+  *
+  * @irq:    The devices first irq number. There may be multple in sequence.
+  */
+ void arch_teardown_msi_irq(unsigned int irq)
+ {
+ 	unsigned int reg;
+ 	unsigned long flags;
+ 
+ 	pr_info("PCI MSI: free irq %d\n", irq);
+ 
+ 	spin_lock_irqsave(&dw_msi_data.msi_lock, flags);
+ 
+ 	bitmap_release_region(dw_msi_data.msi_irqs, irq, 0);
+ 
+ 	/* Get MSI interrupt register based on virq */
+ 	reg = READ_PCIE_REG(PCIE_MSI_CTRL_INT_0_EN_OFF + MSI_INTERRUPT_OFF * (irq / 32));
+ 
+ 	/* Disable MSI interrupt. */
+ 	reg &= ~(1 << (irq % 32));
+ 	WRITE_PCIE_REG(PCIE_MSI_CTRL_INT_0_EN_OFF + MSI_INTERRUPT_OFF * (irq / 32), reg);
+ 
+ 	spin_unlock_irqrestore(&dw_msi_data.msi_lock, flags);
+ }
+ 
+ static struct irq_chip dw_irq_chip_msi = {
+ 	.name = "PCI MSI",
+ 	.irq_enable = pci_msi_unmask_irq,
+ 	.irq_disable = pci_msi_mask_irq,
+ 	.irq_mask = pci_msi_mask_irq,
+ 	.irq_unmask = pci_msi_unmask_irq,
+ };
+ 
+ /*
+  * Called by the interrupt handling code when an MSI interrupt
+  * occurs.
+  */
+ irqreturn_t dw_msi_interrupt(int id, void *dev_id) 
+ {
+ 	int irq, bit, i;
+ 	irqreturn_t ret = IRQ_NONE;
+ 	unsigned long reg;
+ 
+ 	pr_debug("PCI MSI: irq=%d\n", id);
+ 
+ 	/* Check all MSI interrupts */
+ 	for (i = 0; i < 8; i++) {
+ 		if ((reg = READ_PCIE_REG(PCIE_MSI_CTRL_INT_0_STATUS_OFF + MSI_INTERRUPT_OFF * (i))) != 0) {
+ 			ret = IRQ_HANDLED;
+ 			bit = 0;
+ 			while ((bit = find_next_bit(&reg, 32, bit)) != 32) {
+ 				irq = irq_find_mapping(dw_msi_data.irq_domain, HW_MSI_IRQ_OFF + i * 32 + bit);
+ 
+ 				pr_debug("PCI MSI: msi_stat_reg=0x%lx hwirq=%d, virq=%d\n", reg,
+ 					(i * 32 + bit), irq);
+ 
+ 				/* Ack an interrupt. */
+ 				WRITE_PCIE_REG(PCIE_MSI_CTRL_INT_0_STATUS_OFF + MSI_INTERRUPT_OFF * (i),
+ 					(1 << bit));
+ 
+ 				/* Generate irq. */
+ 				do_IRQ(irq);
+ 
+ 				bit++;
+ 
+ 				wmb();
+ 
+ 			}
+ 		}
+ 
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ static int dw_msi_map(struct irq_domain *domain, unsigned int irq, irq_hw_number_t hwirq)
+ {
+         irq_set_chip_and_handler(irq, &dw_irq_chip_msi, handle_simple_irq);
+         irq_set_chip_data(irq, domain->host_data);
+ 
+         return 0;
+ }
+ 
+ static const struct irq_domain_ops msi_domain_ops = {
+         .map = dw_msi_map,
+ };
+ 
+ 
+ /*
+  * Initializes the MSI interrupt handling code
+  */
+ int dw_msi_init(void)
+ {
+ 	int i;
+ 
+ 	dw_msi_data.msi_data = PHYS_PCI_MSI_BASE_ADDR;
+ 	spin_lock_init(&dw_msi_data.msi_lock);
+ 
+ 	/* Set data address. */
+ 	WRITE_PCIE_REG(PCIE_MSI_CTRL_ADDR_OFF, virt_to_phys((void *)dw_msi_data.msi_data));
+ 	WRITE_PCIE_REG(PCIE_MSI_CTRL_UPPER_ADDR_OFF, 0);
+ 
+ 	/* Register MSI interrupts. */
+ 	dw_msi_data.irq_domain = irq_domain_add_linear(NULL, (HW_MSI_IRQ_OFF + MAX_DW_MSI_IRQS),
+ 							&msi_domain_ops, &dw_msi_data);
+ 	if (!dw_msi_data.irq_domain) {
+ 		pr_err("PCI MSI: Cannot create irq domain.\n");
+ 		return -ENXIO;
+ 	}
+ 
+ 	for (i = HW_MSI_IRQ_OFF; i < (HW_MSI_IRQ_OFF + MAX_DW_MSI_IRQS); i++) {
+ 		irq_create_mapping(dw_msi_data.irq_domain, i);
+ 		irq_set_chip_and_handler(i, &dw_irq_chip_msi, handle_simple_irq);
+ 	}
+ 
+ 	return 0;
+ }
+ 
diff -rcNP linux-4.4.24/arch/mips/pci/ops-dw.c linux-4.4.24-baikal/arch/mips/pci/ops-dw.c
*** linux-4.4.24/arch/mips/pci/ops-dw.c	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/arch/mips/pci/ops-dw.c	2016-11-11 14:49:51.000000000 +0300
***************
*** 0 ****
--- 1,145 ----
+ /*
+  *  Baikal-T SOC platform support code.
+  *
+  *  Copyright (C) 2015,2016 Baikal Electronics JSC.
+  *
+  *  This program is free software; you can distribute it and/or modify it
+  *  under the terms of the GNU General Public License (Version 2) as
+  *  published by the Free Software Foundation.
+  *
+  *  This program is distributed in the hope it will be useful, but WITHOUT
+  *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+  *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+  *  for more details.
+  *
+  *  You should have received a copy of the GNU General Public License along
+  *  with this program; if not, write to the Free Software Foundation, Inc.,
+  *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+  *
+  *  BAIKAL MIPS boards specific PCI support.
+  */
+ 
+ #include <linux/types.h>
+ #include <linux/pci.h>
+ #include <linux/kernel.h>
+ 
+ #include "pci-baikal.h"
+ 
+ #define IDT_PES32NT8AG2_ID		0x808F111D
+ #define IDT_PES32NT8BG2_ID		0x8088111D
+ #define IDT_VID				0x111D
+ 
+ 
+ /*
+  * We can't address 8 and 16 bit words directly.  Instead we have to
+  * read/write a 32bit word and mask/modify the data we actually want.
+  */
+ static int dw_pcibios_read(struct pci_bus *bus, unsigned int devfn,
+ 			     int where, int size, u32 *val)
+ {
+ 	volatile u32 data = 0;
+ 	volatile u8 *addr = 0;
+ 	u16 target;
+ 
+     if ((bus->number == PCIE_ROOT_BUS_NUM) && (PCI_SLOT(devfn) != 0)) {
+ 		*val = 0xffffffff;
+ 		return PCIBIOS_DEVICE_NOT_FOUND;
+ 	}
+ 
+ 	if ((size == 2) && (where & 1)) {
+ 		*val = 0xffffffff;
+ 		return PCIBIOS_BAD_REGISTER_NUMBER;
+ 	} else if ((size == 4) && (where & 3)) {
+ 		*val = 0xffffffff;
+ 		return PCIBIOS_BAD_REGISTER_NUMBER;
+ 	}
+ 
+ 	target = ((bus->number << 8) | devfn);
+ 
+ 	if ((!bus->parent) || (bus->parent->number == bus->number)) {
+ 		/* dw_set_iatu_region(dir, index, base_addr, limit_addr, target_addr, tlp_type) */
+ 		dw_set_iatu_region(REGION_DIR_OUTBOUND, IATU_RD0_INDEX, PHYS_PCI_RD0_BASE_ADDR >> 16,
+ 				PHYS_PCI_RD0_LIMIT_ADDR >> 16, target, TLP_TYPE_CFGRD0);
+ 		addr = (u8 *)PCI_RD0_BASE_ADDR;
+ 	} else {
+ 		dw_set_iatu_region(REGION_DIR_OUTBOUND, IATU_RD1_INDEX, PHYS_PCI_RD1_BASE_ADDR >> 16,
+ 				PHYS_PCI_RD1_LIMIT_ADDR >> 16, target, TLP_TYPE_CFGRD1);
+ 		addr = (u8 *)PCI_RD1_BASE_ADDR;
+ 	}
+ 
+ 	wmb();
+ 
+ 	addr += (where & ~0x3);
+ 	data = readl(addr);
+ 
+ 	if (size == 1)
+ 		*val = (data >> ((where & 3) << 3)) & 0xff;
+ 	else if (size == 2)
+ 		*val = (data >> ((where & 3) << 3)) & 0xffff;
+ 	else
+ 		*val = data;
+ 
+ 	dev_dbg(&bus->dev, "bus=%d devfn=0x%x where=0x%x addr=0x%x val=0x%x\n",
+ 		bus->number, devfn, where, (unsigned int)addr, (unsigned int)*val);
+ 
+ 	return PCIBIOS_SUCCESSFUL;
+ }
+ 
+ static int dw_pcibios_write(struct pci_bus *bus, unsigned int devfn,
+ 			      int where, int size, u32 val)
+ {
+ 	volatile u32 data = 0;
+ 	volatile u8 *addr = 0;
+ 	u16 target;
+ 
+     if ((bus->number == PCIE_ROOT_BUS_NUM) && (PCI_SLOT(devfn) != 0)) {
+ 		return PCIBIOS_DEVICE_NOT_FOUND;
+ 	}
+ 
+ 	if ((size == 2) && (where & 1))
+ 		return PCIBIOS_BAD_REGISTER_NUMBER;
+ 	else if ((size == 4) && (where & 3))
+ 		return PCIBIOS_BAD_REGISTER_NUMBER;
+ 
+ 	target = ((bus->number << 8) | devfn);
+ 
+ 	if ((!bus->parent) || (bus->parent->number == bus->number)) {
+ 		/* dw_set_iatu_region(dir, index, base_addr, limit_addr, target_addr, tlp_type) */
+ 		dw_set_iatu_region(REGION_DIR_OUTBOUND, IATU_RD0_INDEX, PHYS_PCI_RD0_BASE_ADDR >> 16,
+ 				PHYS_PCI_RD0_LIMIT_ADDR >> 16, target, TLP_TYPE_CFGRD0);
+ 		addr = (u8 *)PCI_RD0_BASE_ADDR;
+ 	} else {
+ 		dw_set_iatu_region(REGION_DIR_OUTBOUND, IATU_RD1_INDEX, PHYS_PCI_RD1_BASE_ADDR >> 16,
+ 				PHYS_PCI_RD1_LIMIT_ADDR >> 16, target, TLP_TYPE_CFGRD1);
+ 		addr = (u8 *)PCI_RD1_BASE_ADDR;
+ 	}
+ 
+ 	wmb();
+ 
+ 	addr += (where & ~0x3);
+ 
+ 	if (size == 4)
+ 		data = val;
+ 	else {
+ 		data = readl(addr);
+ 
+ 		if (size == 1)
+ 			data = (data & ~(0xff << ((where & 3) << 3))) |
+ 				(val << ((where & 3) << 3));
+ 		else if (size == 2)
+ 			data = (data & ~(0xffff << ((where & 3) << 3))) |
+ 				(val << ((where & 3) << 3));
+ 	}
+ 
+ 	writel(data, addr);
+ 
+ 	dev_dbg(&bus->dev, "bus=%d devfn=0x%x where=0x%x addr = 0x%x data=0x%x\n",
+ 		bus->number, devfn, where, (unsigned int)addr, data);
+ 
+ 	return PCIBIOS_SUCCESSFUL;
+ }
+ 
+ struct pci_ops dw_pci_ops = {
+ 	.read = dw_pcibios_read,
+ 	.write = dw_pcibios_write
+ };
diff -rcNP linux-4.4.24/arch/mips/pci/pci-baikal.c linux-4.4.24-baikal/arch/mips/pci/pci-baikal.c
*** linux-4.4.24/arch/mips/pci/pci-baikal.c	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/arch/mips/pci/pci-baikal.c	2016-11-11 14:49:51.000000000 +0300
***************
*** 0 ****
--- 1,565 ----
+ /*
+  *  Baikal-T SOC platform support code.
+  *
+  *  Copyright (C) 2015,2016 Baikal Electronics JSC.
+  *
+  *  This program is free software; you can distribute it and/or modify it
+  *  under the terms of the GNU General Public License (Version 2) as
+  *  published by the Free Software Foundation.
+  *
+  *  This program is distributed in the hope it will be useful, but WITHOUT
+  *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+  *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+  *  for more details.
+  *
+  *  You should have received a copy of the GNU General Public License along
+  *  with this program; if not, write to the Free Software Foundation, Inc.,
+  *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+  *
+  *  BAIKAL MIPS boards specific PCI support.
+  */
+ #include <linux/types.h>
+ #include <linux/pci.h>
+ #include <linux/kernel.h>
+ #include <linux/init.h>
+ #include <linux/interrupt.h>
+ #include <linux/device.h>	/* dev_err */
+ #include <linux/module.h>
+ #include <linux/of_platform.h>	/* open firmware functioons */
+ 
+ #include <asm/mips-cm.h>
+ #include <asm/mips-boards/generic.h>
+ #include "pci-baikal.h"
+ 
+ static struct resource dw_mem_resource = {
+ 	.name	= "DW PCI MEM",
+ 	.start	= PHYS_PCIMEM_BASE_ADDR,
+ 	.end	= PHYS_PCIMEM_LIMIT_ADDR,
+ 	.flags	= IORESOURCE_MEM,
+ };
+ 
+ static struct resource dw_io_resource = {
+ 	.name	= "DW PCI I/O",
+ 	.start	= PHYS_PCIIO_BASE_ADDR,
+ 	.end	= PHYS_PCIIO_LIMIT_ADDR,
+ 	.flags	= IORESOURCE_IO,
+ };
+ 
+ static struct resource dw_busn_resource = {
+ 	.name	= "DW PCI busn",
+ 	.start	= PCIE_ROOT_BUS_NUM, /* It's going to be overwritten anyway */
+ 	.end	= 255,
+ 	.flags	= IORESOURCE_BUS,
+ };
+ 
+ extern struct pci_ops dw_pci_ops;
+ int dw_pcie_get_busn(void);
+ 
+ static struct pci_controller dw_controller = {
+ 	.pci_ops	= &dw_pci_ops,
+ 	.io_resource	= &dw_io_resource,
+ 	.mem_resource	= &dw_mem_resource,
+ 	.busn_resource	= &dw_busn_resource,
+     .get_busno  = dw_pcie_get_busn,
+ };
+ 
+ #ifdef CONFIG_PCI_MSI
+ static int dw_msi_irq;
+ #endif /* CONFIG_PCI_MSI */
+ 
+ static int dw_aer_irq;
+ 
+ #define PCIE_PHY_RETRIES	1000000
+ #define PCIE_ERROR_VALUE	0xFFFFFFFF
+ #define PHY_ALL_LANES		0xF
+ #define PHY_LANE0			0x1
+ 
+ #define OK					0
+ #define ERROR				-1
+ #define ERROR_MISMATCH1		0x0010
+ #define ERROR_MISMATCH2		0x0020
+ #define ERROR_MISMATCH3		0x0040
+ #define ERROR_MISMATCH4		0x0080
+ #define ERROR_MISMATCH5		0x0100
+ #define ERROR_MISMATCH6		0x0200
+ #define ERROR_MISMATCH7		0x0400
+ #define ERROR_MISMATCH8		0x0800
+ 
+ /* Retrieve the secondary bus number of the RC */
+ int dw_pcie_get_busn(void)
+ {
+    return PCIE_ROOT_BUS_NUM;
+ }
+ 
+ void pci_dw_dma_init(void);
+ 
+ void baikal_find_vga_mem_init(void);
+ 
+ uint32_t dw_pcie_phy_read(uint32_t phy_addr)
+ {
+ 	uint32_t reg;
+ 	int i;
+ 
+ 	/* Set lane0 for reading values. */
+ 	WRITE_PCIE_REG(PCIE_BK_MGMT_SEL_LANE, PHY_LANE0);
+ 
+ 	/* Write the address of the PHY register. */
+ 	WRITE_PCIE_REG(PCIE_BK_MGMT_CTRL, (phy_addr & BK_MGMT_CTRL_ADDR_MASK) | BK_MGMT_CTRL_READ);
+ 
+ 	for (i = 0; i < PCIE_PHY_RETRIES; i++) {
+ 		reg = READ_PCIE_REG(PCIE_BK_MGMT_CTRL);
+ 		if (reg & BK_MGMT_CTRL_DONE) {
+ 			/* Read data register. */
+ 			reg = READ_PCIE_REG(PCIE_BK_MGMT_READ_DATA);
+ 			pr_debug("%s: phy_addr=0x%x val=0x%x\n", __func__, phy_addr, reg);
+ 			return reg;
+ 		}
+ 	}
+ 
+ 	pr_err("%s: timeout expired for phy_addr=0x%x\n", __func__, phy_addr);
+ 
+ 	/* return error */
+ 	return PCIE_ERROR_VALUE;
+ }
+ 
+ uint32_t dw_pcie_phy_write(uint32_t phy_addr, uint32_t val)
+ {
+ 	uint32_t reg;
+ 	int i;
+ 
+ 	pr_debug("%s: phy_addr=0x%x val=0x%x\n", __func__, phy_addr, val);
+ 
+ 	/* Set line. */
+ 	WRITE_PCIE_REG(PCIE_BK_MGMT_SEL_LANE, PHY_ALL_LANES);
+ 
+ 	/* Write value to data register. */
+ 	WRITE_PCIE_REG(PCIE_BK_MGMT_WRITE_DATA, val);
+ 
+ 	/* Write the address of the PHY register. */
+ 	WRITE_PCIE_REG(PCIE_BK_MGMT_CTRL, (phy_addr & BK_MGMT_CTRL_ADDR_MASK) | BK_MGMT_CTRL_WRITE);
+ 
+ 	for (i = 0; i < PCIE_PHY_RETRIES; i++) {
+ 		reg = READ_PCIE_REG(PCIE_BK_MGMT_CTRL);
+ 		if (reg & BK_MGMT_CTRL_DONE) {
+ 			return OK;
+ 		}
+ 	}
+ 
+ 	pr_err("%s: timeout expired for phy_addr=0x%x\n", __func__, phy_addr);
+ 
+ 	/* return error */
+ 	return PCIE_ERROR_VALUE;
+ }
+ 
+ void dw_set_iatu_region(int dir, int index, int base_addr, int limit_addr, int target_addr, int tlp_type)
+ {
+ 	WRITE_PCIE_REG(PCIE_IATU_VIEWPORT_OFF, ((index << REGION_INDEX_SHIFT) | (dir << REGION_DIR_SHIFT)));
+ 	WRITE_PCIE_REG(PCIE_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_0, (base_addr << LWR_BASE_RW_SHIFT));
+ 	WRITE_PCIE_REG(PCIE_IATU_UPR_BASE_ADDR_OFF_OUTBOUND_0, 0);	
+ 	WRITE_PCIE_REG(PCIE_IATU_LIMIT_ADDR_OFF_OUTBOUND_0, (limit_addr << LIMIT_ADDR_RW_SHIFT));
+ 	WRITE_PCIE_REG(PCIE_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_0, (target_addr << LWR_TARGET_RW_SHIFT));
+ 	WRITE_PCIE_REG(PCIE_IATU_UPR_TARGET_ADDR_OFF_OUTBOUND_0, 0);
+ 	WRITE_PCIE_REG(PCIE_IATU_REGION_CTRL_1_OFF_OUTBOUND_0, (tlp_type << IATU_REGION_CTRL_1_OFF_OUTBOUND_0_TYPE_SHIFT));
+ 	WRITE_PCIE_REG(PCIE_IATU_REGION_CTRL_2_OFF_OUTBOUND_0, IATU_REGION_CTRL_2_OFF_OUTBOUND_0_REGION_EN);
+ 
+ 	wmb();	
+ }
+ 
+ #define PLL_WAIT_RETRIES 1000
+ int dw_init_pll(const unsigned int pmu_register)
+ {
+ 	uint32_t reg;
+ 	int i = 0;
+ 
+ 	/* Wait for LOCK bit in BK_PMU_COREPLL_CTL */
+ 	while(!(READ_PMU_REG(BK_PMU_COREPLL_CTL) & BK_PMU_LOCK_BIT)) {
+ 		if((i++) == PLL_WAIT_RETRIES) {
+ 			return ERROR;
+ 		}
+ 	}
+ 	/* Set EN & RST bit in pmu_register */
+ 	reg = READ_PMU_REG(pmu_register);
+ 	reg |= BK_PMU_EN_BIT | BK_PMU_RST_BIT;
+ 	WRITE_PMU_REG(pmu_register, reg);
+ 
+ 	/* Wait for LOCK bit in pmu_register */
+ 	i = 0;
+ 	while(!(READ_PMU_REG(pmu_register) & BK_PMU_LOCK_BIT)) {
+ 		if((i++) == PLL_WAIT_RETRIES) {
+ 			return ERROR;
+ 		}
+ 	}
+ 
+ 	return OK;
+ }
+ 
+ int dw_pcie_init(void)
+ {
+ 	volatile uint32_t reg;
+ 	int i, st = 0;
+ 
+ 	/* PMU PCIe init. */
+ 
+ 	/* 1., 2. Start BK_PMU_PCIEPLL_CTL. */
+ 	dw_init_pll(BK_PMU_PCIEPLL_CTL);
+ 
+ 	/* 3. Read value of BK_PMU_AXI_PCIE_M_CTL, set EN bit. */
+ 	reg = READ_PMU_REG(BK_PMU_AXI_PCIE_M_CTL);
+ 	reg |= PMU_AXI_PCIE_M_CTL_EN;
+ 	WRITE_PMU_REG(BK_PMU_AXI_PCIE_M_CTL, reg);
+ 
+ 	/* 4. Read value of BK_PMU_AXI_PCIE_S_CTL, set EN bit. */
+ 	reg = READ_PMU_REG(BK_PMU_AXI_PCIE_S_CTL);
+ 	reg |= PMU_AXI_PCIE_S_CTL_EN;
+ 	WRITE_PMU_REG(BK_PMU_AXI_PCIE_S_CTL, reg);
+ 
+ 	/*
+ 	 * 5. Read value of BK_PMU_PCIE_RSTC, set bits: PHY_RESET,
+ 	 * PIPE_RESET, CORE_RST, PWR_RST, STICKY_RST, NONSTICKY_RST, HOT_RESET.
+ 	 */
+ 	reg = READ_PMU_REG(BK_PMU_PCIE_RSTC);
+ 	reg |= (PMU_PCIE_RSTC_PHY_RESET | PMU_PCIE_RSTC_PIPE_RESET |
+ 		PMU_PCIE_RSTC_CORE_RST|  PMU_PCIE_RSTC_PWR_RST | 
+ 		PMU_PCIE_RSTC_STICKY_RST | PMU_PCIE_RSTC_NONSTICKY_RST
+ 		/*PMU_PCIE_RSTC_HOT_RESET*/);
+ 	WRITE_PMU_REG(BK_PMU_PCIE_RSTC, reg);
+ 
+ 	/* 6. Read value of BK_PMU_PCIE_RSTC, reset PHY_RESET bit. */
+ 	reg = READ_PMU_REG(BK_PMU_PCIE_RSTC);
+ 	reg &= ~(PMU_PCIE_RSTC_PHY_RESET | PMU_PCIE_RSTC_PIPE_RESET |
+ 		PMU_PCIE_RSTC_CORE_RST|  PMU_PCIE_RSTC_PWR_RST |
+ 		PMU_PCIE_RSTC_STICKY_RST | PMU_PCIE_RSTC_NONSTICKY_RST);
+ 	WRITE_PMU_REG(BK_PMU_PCIE_RSTC, reg);
+ 
+ 	/* 3.1 Set DBI2 mode, dbi2_cs = 0x1 */
+ 	reg = READ_PMU_REG(BK_PMU_PCIE_GENC);
+ 	reg |= PMU_PCIE_GENC_DBI2_MODE;
+ 	WRITE_PMU_REG(BK_PMU_PCIE_GENC, reg);
+ 
+ 	/* 3.2 Set writing to RO Registers Using DBI */
+ 	WRITE_PCIE_REG(PCIE_MISC_CONTROL_1_OFF, DBI_RO_WR_EN);
+ 
+ 	/* 4.1 Allow access to the PHY registers, phy0_mgmt_pcs_reg_sel = 0x1. */
+ 	reg = READ_PMU_REG(BK_PMU_PCIE_GENC);
+ 	reg |= PMU_PCIE_GENC_MGMT_ENABLE;
+ 	WRITE_PMU_REG(BK_PMU_PCIE_GENC, reg);
+ 
+ 	/* 4.2 All lanes can read/write PHY registers using the management interface. */
+ 	WRITE_PCIE_REG(PCIE_BK_MGMT_SEL_LANE, 0xF);
+ 
+ 	/*
+ 	 * 7. Wait for stable clocks: SDS_PCS_CLOCK_READY bit in
+ 	 * DWC_GLBL_PLL_MONITOR register of PCIe PHY.
+ 	 */
+ 	for (i = 0; i < PCIE_PHY_RETRIES; i++) {
+ 		reg = dw_pcie_phy_read(PCIE_PHY_DWC_GLBL_PLL_MONITOR);
+ 
+ 		if (reg == PCIE_ERROR_VALUE) {
+ 			return ERROR;
+ 		}
+ 		if ((reg & SDS_PCS_CLOCK_READY) == SDS_PCS_CLOCK_READY) {
+ 			break;
+ 		}
+ 	}
+ 
+ 	if (i == PCIE_PHY_RETRIES) {
+ 		/* Return an error if the timeout expired. */
+ 		return ERROR;
+ 	}
+ 
+ 	/* 
+ 	 * 8. Read value of BK_PMU_PCIE_RSTC, reset bits: PIPE_RESET, CORE_RST,
+ 	 * PWR_RST, STICKY_RST, NONSTICKY_RST, HOT_RESET.
+ 	 */
+ 	reg = READ_PMU_REG(BK_PMU_PCIE_RSTC);
+ 	reg &= ~(PMU_PCIE_RSTC_PIPE_RESET | PMU_PCIE_RSTC_CORE_RST | PMU_PCIE_RSTC_PWR_RST |
+ 		PMU_PCIE_RSTC_STICKY_RST | PMU_PCIE_RSTC_NONSTICKY_RST | PMU_PCIE_RSTC_HOT_RESET);
+ 	WRITE_PMU_REG(BK_PMU_PCIE_RSTC, reg);
+ 
+ 	pr_info("%s: DEV_ID_VEND_ID=0x%x CLASS_CODE_REV_ID=0x%x\n", __func__,
+ 		READ_PCIE_REG(PCIE_TYPE1_DEV_ID_VEND_ID_REG), READ_PCIE_REG(PCIE_TYPE1_CLASS_CODE_REV_ID_REG));
+ 
+ 	/* 5. Set the fast mode. */
+ 	reg = READ_PCIE_REG(PCIE_PORT_LINK_CTRL_OFF);
+ 	reg |= FAST_LINK_MODE;
+ 	WRITE_PCIE_REG(PCIE_PORT_LINK_CTRL_OFF, reg);
+ 
+ 	reg = dw_pcie_phy_read(PCIE_PHY_DWC_GLBL_PLL_CFG_0);
+ 	reg &= ~PCS_SDS_PLL_FTHRESH_MASK;
+ 	dw_pcie_phy_write(PCIE_PHY_DWC_GLBL_PLL_CFG_0, reg);
+ 	
+ 	reg = dw_pcie_phy_read(PCIE_PHY_DWC_GLBL_TERM_CFG);
+ 	reg |= FAST_TERM_CAL;
+ 	dw_pcie_phy_write(PCIE_PHY_DWC_GLBL_TERM_CFG, reg);
+ 
+ 	reg = dw_pcie_phy_read(PCIE_PHY_DWC_RX_LOOP_CTRL);
+ 	reg |= (FAST_OFST_CNCL | FAST_DLL_LOCK);
+ 	dw_pcie_phy_write(PCIE_PHY_DWC_RX_LOOP_CTRL, reg);
+ 	
+ 	reg = dw_pcie_phy_read(PCIE_PHY_DWC_TX_CFG_0);
+ 	reg |= (FAST_TRISTATE_MODE | FAST_RDET_MODE | FAST_CM_MODE);
+ 	dw_pcie_phy_write(PCIE_PHY_DWC_TX_CFG_0, reg);
+ 
+ 	/* 6. Set number of lanes. */
+ 	reg = READ_PCIE_REG(PCIE_GEN2_CTRL_OFF);
+ 	reg &= ~NUM_OF_LANES_MASK;
+ 	reg |= (0x4 << NUM_OF_LANES_SHIFT);
+ 	WRITE_PCIE_REG(PCIE_GEN2_CTRL_OFF, reg);
+ 
+ 	reg = READ_PCIE_REG(PCIE_PORT_LINK_CTRL_OFF);
+ 	reg &= ~LINK_CAPABLE_MASK;
+ 	reg |= (0x7 << LINK_CAPABLE_SHIFT);
+ 	WRITE_PCIE_REG(PCIE_PORT_LINK_CTRL_OFF, reg);
+ 
+ 	/* 7. Enable GEN3 */
+ 	reg = READ_PCIE_REG(PCIE_GEN3_EQ_CONTROL_OFF);
+ 	reg &= ~(GEN3_EQ_FB_MODE_MASK | GEN3_EQ_PSET_REQ_VEC_MASK);
+ 	reg |= ((GEN3_EQ_EVAL_2MS_DISABLE) | (0x1 << GEN3_EQ_FB_MODE_SHIFT) |
+ 		(0x1 << GEN3_EQ_PSET_REQ_VEC_SHIFT));
+ 	WRITE_PCIE_REG(PCIE_GEN3_EQ_CONTROL_OFF, reg);
+ 
+ 	WRITE_PCIE_REG(PCIE_LANE_EQUALIZATION_CONTROL01_REG, 0);
+ 	WRITE_PCIE_REG(PCIE_LANE_EQUALIZATION_CONTROL23_REG, 0);
+ 
+ 	dw_pcie_phy_write(PCIE_PHY_DWC_RX_PRECORR_CTRL, 0);
+ 	dw_pcie_phy_write(PCIE_PHY_DWC_RX_CTLE_CTRL, 0x200);
+ 	dw_pcie_phy_write(PCIE_PHY_DWC_RX_VMA_CTRL, 0xc000);
+ 	dw_pcie_phy_write(PCIE_PHY_DWC_PCS_LANE_VMA_FINE_CTRL_0, 0);
+ 	dw_pcie_phy_write(PCIE_PHY_DWC_PCS_LANE_VMA_FINE_CTRL_1, 0);
+ 	dw_pcie_phy_write(PCIE_PHY_DWC_PCS_LANE_VMA_FINE_CTRL_2, 0);
+ 	dw_pcie_phy_write(PCIE_PHY_DWC_EQ_WAIT_TIME, 0xa);
+ 
+ 	/* Configure bus. */
+ 	reg = READ_PCIE_REG(PCIE_SEC_LAT_TIMER_SUB_BUS_SEC_BUS_PRI_BUS_REG);
+ 	reg &= 0xff000000;
+     reg |= (0x00ff0000 | (PCIE_ROOT_BUS_NUM << 8)); /* IDT PCI Bridge don't like the primary bus equals 0. */
+ 	WRITE_PCIE_REG(PCIE_SEC_LAT_TIMER_SUB_BUS_SEC_BUS_PRI_BUS_REG, reg);
+ 
+ 	/* Setup memory base. */
+ 	reg = ((PHYS_PCIMEM_LIMIT_ADDR & 0xfff00000) | ((PHYS_PCIMEM_BASE_ADDR & 0xfff00000) >> 16));
+ 	WRITE_PCIE_REG(PCIE_MEM_LIMIT_MEM_BASE_REG, reg);
+ 
+ 	/* Setup IO base. */
+ 	reg = ((PHYS_PCIIO_LIMIT_ADDR & 0x0000f000) | ((PHYS_PCIIO_BASE_ADDR & 0x0000f000) >> 8));
+ 	WRITE_PCIE_REG(PCIE_SEC_STAT_IO_LIMIT_IO_BASE_REG, reg);
+ 	reg = ((PHYS_PCIIO_LIMIT_ADDR & 0xffff0000) | ((PHYS_PCIIO_BASE_ADDR & 0xffff0000) >> 16));
+ 	WRITE_PCIE_REG(PCIE_IO_LIMIT_UPPER_IO_BASE_UPPER_REG, reg);
+ 
+ 	/* 8. Set master for PCIe EP. */
+ 	reg = READ_PCIE_REG(PCIE_TYPE1_STATUS_COMMAND_REG);
+ 	reg |= (TYPE1_STATUS_COMMAND_REG_BME | TYPE1_STATUS_COMMAND_REG_MSE | TYPE1_STATUS_COMMAND_REG_IOSE);
+ 	reg |= (PCI_COMMAND_PARITY | PCI_COMMAND_SERR); // Add check error.
+ 	WRITE_PCIE_REG(PCIE_TYPE1_STATUS_COMMAND_REG, reg);
+ 
+ 	/* AER */
+ 	reg =  READ_PCIE_REG(PCIE_DEVICE_CONTROL_DEVICE_STATUS);
+ 	reg |= PCI_EXP_DEVCTL_CERE; /* Correctable Error Reporting */
+ 	reg |= PCI_EXP_DEVCTL_NFERE; /* Non-Fatal Error Reporting */
+ 	reg |= PCI_EXP_DEVCTL_FERE;	/* Fatal Error Reporting */
+ 	reg |= PCI_EXP_DEVCTL_URRE;	/* Unsupported Request */
+ 	WRITE_PCIE_REG(PCIE_DEVICE_CONTROL_DEVICE_STATUS, reg);
+ 
+ 	/* Unmask Uncorrectable Errors. */
+ 	reg = READ_PCIE_REG(PCIE_UNCORR_ERR_STATUS_OFF);
+ 	WRITE_PCIE_REG(PCIE_UNCORR_ERR_STATUS_OFF, reg);
+ 	WRITE_PCIE_REG(PCIE_UNCORR_ERR_MASK_OFF, 0);
+ 
+ 	/* Unmask Correctable Errors. */
+ 	reg = READ_PCIE_REG(PCIE_CORR_ERR_STATUS_OFF);
+ 	WRITE_PCIE_REG(PCIE_CORR_ERR_STATUS_OFF, reg);
+ 	WRITE_PCIE_REG(PCIE_CORR_ERR_MASK_OFF, 0);
+ 
+ #ifdef DW_CHECK_ECRC
+ 	reg = READ_PCIE_REG(PCIE_ADV_ERR_CAP_CTRL_OFF);
+ 	/* ECRC Generation Enable */
+ 	if (reg & PCI_ERR_CAP_ECRC_GENC)
+ 		reg |= PCI_ERR_CAP_ECRC_GENE;
+ 	/* ECRC Check Enable */
+ 	if (reg & PCI_ERR_CAP_ECRC_CHKC)
+ 		reg |= PCI_ERR_CAP_ECRC_CHKE;
+ 	WRITE_PCIE_REG(PCIE_ADV_ERR_CAP_CTRL_OFF, reg);
+ #endif /* DW_CHECK_ECRC */
+ 
+ 	/* 9. Set Inbound/Outbound iATU regions. */
+ 
+ 	/* dw_set_iatu_region(dir,  index, base_addr, limit_addr, target_addr, tlp_type) */
+ 
+ 	dw_set_iatu_region(REGION_DIR_OUTBOUND, IATU_RD0_INDEX, PHYS_PCI_RD0_BASE_ADDR >> 16,
+ 				PHYS_PCI_RD0_LIMIT_ADDR >> 16, 0x0000, TLP_TYPE_CFGRD0);
+ 
+ 	dw_set_iatu_region(REGION_DIR_OUTBOUND, IATU_RD1_INDEX, PHYS_PCI_RD1_BASE_ADDR >> 16,
+ 				PHYS_PCI_RD1_LIMIT_ADDR >> 16, 0x0000, TLP_TYPE_CFGRD1);
+ 
+ 	dw_set_iatu_region(REGION_DIR_OUTBOUND, IATU_MEM_INDEX, PHYS_PCIMEM_BASE_ADDR >> 16,
+ 				PHYS_PCIMEM_LIMIT_ADDR >> 16, PHYS_PCIMEM_BASE_ADDR >> 16, TLP_TYPE_MEM);
+ 
+ 	dw_set_iatu_region(REGION_DIR_OUTBOUND, IATU_IO_INDEX, PHYS_PCIIO_BASE_ADDR >> 16,
+ 				PHYS_PCIIO_LIMIT_ADDR >> 16, PHYS_PCIIO_BASE_ADDR >> 16,  TLP_TYPE_IO);
+ 
+ 	/*
+ 	 * Set Gen2 or Gen1 speed. At that moment it's impossible to
+ 	 * configure a link on GEN3 speed.
+ 	 */
+ 	reg = READ_PCIE_REG(PCIE_LINK_CONTROL2_LINK_STATUS2_REG);
+ 	reg &= ~PCIE_LINK_CONTROL2_GEN_MASK;
+ 	reg |= PCIE_LINK_CONTROL2_GEN2;
+ 	WRITE_PCIE_REG(PCIE_LINK_CONTROL2_LINK_STATUS2_REG, reg);
+ 
+ 	wmb();
+ 
+ 	/* 10. Set LTSSM enable, app_ltssm_enable=0x1 */
+ 	reg = READ_PMU_REG(BK_PMU_PCIE_GENC);
+ 	reg |= PMU_PCIE_GENC_LTSSM_ENABLE;
+ 	WRITE_PMU_REG(BK_PMU_PCIE_GENC, reg);
+ 
+ 	/* 11-12 Analyze BK_PMU_PCIE_PMSC */
+ 	for (i = 0; i < PCIE_PHY_RETRIES; i++) {
+ 		reg = READ_PMU_REG(BK_PMU_PCIE_PMSC);
+ 		st = 0;
+ 		if ((reg & PMU_PCIE_PMSC_SMLH_LINKUP) == 0) {
+ 			st |= ERROR_MISMATCH3;
+ 		}
+ 
+ 		if ((reg & PMU_PCIE_PMSC_RDLH_LINKUP) == 0) {
+ 			st |= ERROR_MISMATCH4;
+ 		}
+ 
+ 		if ((reg & PMU_PCIE_PMSC_LTSSM_STATE_MASK) != LTSSM_L0) {
+ 			st |= ERROR_MISMATCH5;
+ 		}
+ 
+ 		if (!st) {
+ 			break;
+ 		}
+ 	}
+ 
+ 	pr_err("%s: PCIe error core = 0x%x\n", __func__, st);
+ 
+ 	/* Check the speed is set in PCIE_LINK_CONTROL_LINK_STATUS_REG. */
+ 	reg = READ_PCIE_REG(PCIE_LINK_CONTROL_LINK_STATUS_REG);
+ 	reg = ((reg & PCIE_CAP_LINK_SPEED_MASK) >> PCIE_CAP_LINK_SPEED_SHIFT);
+ 	pr_info("%s: PCIe link speed GEN%d\n", __func__, reg);
+ 
+ 	wmb();
+ 
+ 	return st;
+ }
+ 
+ void __init mips_pcibios_init(void)
+ {
+ 	struct pci_controller *controller;
+ 
+ 	if (dw_pcie_init()) {
+ 		pr_err("%s: Init DW PCI controller failed\n", __func__);
+ 		return;
+ 	}
+ 
+ #ifdef CONFIG_PCI_MSI
+ 	if (dw_msi_init()) {
+ 		pr_err("%s: Init DW PCI MSI failed\n", __func__);
+ 		return;
+ 	}
+ #endif /* CONFIG_PCI_MSI */
+ 
+ 	pci_set_flags(PCI_REASSIGN_ALL_RSRC);
+ 
+ 	/* Register PCI controller */
+ 	controller = &dw_controller;
+ 
+ 	iomem_resource.end &= 0xfffffffffULL;
+ 	ioport_resource.end = controller->io_resource->end;
+ 	controller->io_map_base = controller->io_resource->start;
+ 	controller->io_offset = 0;
+ 	register_pci_controller(controller);
+ 
+ #ifdef CONFIG_CPU_SUPPORTS_UNCACHED_ACCELERATED
+ 	baikal_find_vga_mem_init();
+ #endif /* CONFIG_CPU_SUPPORTS_UNCACHED_ACCELERATED */
+ }
+ 
+ #ifdef CONFIG_PCIEAER	
+ irqreturn_t aer_irq(int irq, void *context);
+ #endif /* CONFIG_PCIEAER */
+ 
+ irqreturn_t dw_aer_interrupt(int id, void *dev_id) 
+ {
+ #ifdef CONFIG_PCIEAER	
+ 	aer_irq(id, dev_id);
+ #endif /* CONFIG_PCIEAER */
+ 
+ 	return IRQ_HANDLED;
+ }
+ 
+ static int dw_pci_drv_probe(struct platform_device *pdev)
+ {
+ 
+ #ifdef CONFIG_PCI_MSI
+ 	if ((dw_msi_irq = platform_get_irq(pdev, 0)) < 0) {
+ 		dev_err(&pdev->dev, "There is no MSI IRQ resource specified.\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (request_irq(dw_msi_irq, dw_msi_interrupt, IRQF_SHARED, "MSI PCI", pdev)) {
+ 		dev_err(&pdev->dev, "Cannot request MSI irq %d.\n", dw_msi_irq);
+ 		return -ENXIO;
+ 	}
+ #endif /* CONFIG_PCI_MSI */
+ 
+ 	if ((dw_aer_irq = platform_get_irq(pdev, 1)) < 0) {
+ 		dev_err(&pdev->dev, "There is no AER IRQ resource specified.\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (request_irq(dw_aer_irq, dw_aer_interrupt, IRQF_SHARED, "AER PCI", pdev)) {
+ 		dev_err(&pdev->dev, "Cannot request AER irq %d.\n", dw_aer_irq);
+ 		return -ENXIO;
+ 	}
+ 
+ 	dev_info(&pdev->dev, "DW PCIe driver successfully loaded.\n");
+ 	dev_info(&pdev->dev, "MSI IRQ:%d   AER IRQ:%d\n", dw_msi_irq, dw_aer_irq);
+ 
+ 	/* Return success */
+ 	return 0;
+ }
+ 
+ static int dw_pci_drv_remove(struct platform_device *pdev)
+ {
+ #ifdef CONFIG_PCI_MSI
+         /* Free IRQ resource */
+         free_irq(dw_msi_irq, pdev);
+ #endif /* CONFIG_PCI_MSI */
+ 
+ 	free_irq(dw_aer_irq, pdev);
+ 
+ 	/* Return success */
+ 	return 0;
+ }
+ 
+ #ifdef CONFIG_OF
+ static const struct of_device_id dw_pci_of_match[] = {
+ 	{ .compatible = "be,baikal-pci", },
+ 	{ .compatible = "snps,dw-pci", },
+ 	{ /* sentinel */ }
+ };
+ MODULE_DEVICE_TABLE(of, dw_pci_of_match);
+ #endif
+ 
+ static struct platform_driver dw_pci_driver = {
+ 	.probe          = dw_pci_drv_probe,
+ 	.remove         = dw_pci_drv_remove,
+ 	.driver         = {
+ 		.name   = "dw_pci",
+ 		.owner  = THIS_MODULE,
+ #ifdef CONFIG_OF
+ 		.of_match_table = of_match_ptr(dw_pci_of_match),
+ #endif /* CONFIG_OF */
+         },
+ };
+ 
+ module_platform_driver(dw_pci_driver);
+ MODULE_VERSION("1.2");
+ MODULE_DESCRIPTION("Baikal Electronics PCIe Driver.");
+ MODULE_LICENSE("Proprietary");
+ MODULE_AUTHOR("Alexey Malakhov");
+ MODULE_ALIAS("platform:dw_pci");
+ 
diff -rcNP linux-4.4.24/arch/mips/pci/pci-baikal.h linux-4.4.24-baikal/arch/mips/pci/pci-baikal.h
*** linux-4.4.24/arch/mips/pci/pci-baikal.h	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/arch/mips/pci/pci-baikal.h	2016-11-11 14:49:51.000000000 +0300
***************
*** 0 ****
--- 1,681 ----
+ /*
+  *  Baikal-T SOC platform support code.
+  *
+  *  Copyright (C) 2015 Baikal Electronics.
+  *
+  *  This program is free software; you can distribute it and/or modify it
+  *  under the terms of the GNU General Public License (Version 2) as
+  *  published by the Free Software Foundation.
+  *
+  *  This program is distributed in the hope it will be useful, but WITHOUT
+  *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+  *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+  *  for more details.
+  *
+  *  You should have received a copy of the GNU General Public License along
+  *  with this program; if not, write to the Free Software Foundation, Inc.,
+  *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+  *
+  *  BAIKAL MIPS boards specific PCI support.
+  */
+ 
+ #ifndef __PCI_BAIKAL_H__
+ #define __PCI_BAIKAL_H__
+ 
+ #include <linux/interrupt.h>
+ 
+ /* Define DW_CHECK_ECRC to add checking CRC. */
+ //#define DW_CHECK_ECRC
+ 
+ #define PCIE_CFG_BASE                   0xBF052000
+ #define PMU_BASE                        0xBF04D000
+ /* Start enumerating the buses from 1 since IDT-switch oddly acts, when it's
+  * directly connected to the RC and has bus number 0 */
+ #define PCIE_ROOT_BUS_NUM      1
+ 
+ #define	PHYS_PCIMEM_BASE_ADDR		(0x08000000)
+ #define	PHYS_PCIMEM_LIMIT_ADDR		(0x18000000 - 1)
+ #define IATU_MEM_INDEX			2
+ 
+ #define	PHYS_PCI_RD0_BASE_ADDR		(0x18000000)
+ #define	PHYS_PCI_RD0_LIMIT_ADDR		(0x18010000 - 1)
+ #define PCI_RD0_BASE_ADDR		KSEG1ADDR(PHYS_PCI_RD0_BASE_ADDR)
+ #define IATU_RD0_INDEX			0
+ 
+ #define	PHYS_PCI_RD1_BASE_ADDR		(0x18010000)
+ #define	PHYS_PCI_RD1_LIMIT_ADDR		(0x18020000 - 1)
+ #define PCI_RD1_BASE_ADDR		KSEG1ADDR(PHYS_PCI_RD1_BASE_ADDR)
+ #define IATU_RD1_INDEX			1
+ 
+ #define	PHYS_PCIIO_BASE_ADDR		0x18020000
+ #define	PHYS_PCIIO_LIMIT_ADDR		(0x1BDB0000 - 1)
+ #define IATU_IO_INDEX			3
+ 
+ #define	PHYS_PCI_MSI_BASE_ADDR		(0x1BDB0000)
+ #define	PHYS_PCI_START_ADDR		(0x08000000)
+ #define	PHYS_PCI_END_ADDR		(0x1BDC0000)
+ 
+ #define PCIE_TYPE1_DEV_ID_VEND_ID_REG		(0x0)	/* Device ID and Vendor ID Register. */
+ #define PCIE_TYPE1_STATUS_COMMAND_REG		(0x4)	/* Command and Status Register. */
+ #define PCIE_TYPE1_CLASS_CODE_REV_ID_REG	(0x8)	/* Class Code and Revision ID Register. */
+ #define PCIE_TYPE1_BIST_HDR_TYPE_LAT_CACHE_LINE_SIZE_REG	(0xc)	/* BIST, Header Type, Cache Line Size, and Master Latency Timer Register. */
+ #define PCIE_SEC_LAT_TIMER_SUB_BUS_SEC_BUS_PRI_BUS_REG		(0x18)	/* Primary, Secondary, Subordinate Bus Numbers and Latency Timer Regisers . */
+ #define PCIE_SEC_STAT_IO_LIMIT_IO_BASE_REG	(0x1c)	/* Secondary Status and I/O Base and Limit Registers. */
+ #define PCIE_MEM_LIMIT_MEM_BASE_REG		(0x20)	/* Memory Base and Memory Limit Register. */
+ #define PCIE_PREF_MEM_LIMIT_PREF_MEM_BASE_REG	(0x24)	/* Prefetchable Memory Base and Limit Register. */
+ #define PCIE_PREF_BASE_UPPER_REG		(0x28)	/* Prefetchable Base Upper 32 Bits Register. */
+ #define PCIE_PREF_LIMIT_UPPER_REG		(0x2c)	/* I/O Base and Limit Upper 16 Bits Register. */
+ #define PCIE_IO_LIMIT_UPPER_IO_BASE_UPPER_REG	(0x30)	/* Expansion ROM BAR and Mask Register. */
+ #define PCIE_TYPE1_CAP_PTR_REG			(0x34)	/* Capability Pointer Register. */
+ #define PCIE_TYPE1_EXP_ROM_BASE_REG		(0x38)	/* Expansion ROM BAR and Mask Register. */
+ #define PCIE_BRIDGE_CTRL_INT_PIN_INT_LINE_REG	(0x3c)	/* Interrupt Line and Pin and Bridge Control Registers. */
+ #define PCIE_CAP_ID_NXT_PTR_REG			(0x40)	/* Power Management Capabilities Register. */
+ #define PCIE_CON_STATUS_REG			(0x44)	/* Power Management Control and Status Register. */
+ #define PCIE_PCI_MSI_CAP_ID_NEXT_CTRL_REG	(0x50)	/* MSI Capability ID, Next Pointer, Control Registers. */
+ #define PCIE_MSI_CAP_OFF_04H_REG		(0x54)	/* MSI Capability ID, Next Pointer, Control Registers. */
+ #define PCIE_MSI_CAP_OFF_08H_REG		(0x58)	/* MSI Capability ID, Next Pointer, Control Registers. */
+ #define PCIE_MSI_CAP_OFF_0CH_REG		(0x5c)	/* MSI Capability ID, Next Pointer, Control Registers. */
+ #define PCIE_MSI_CAP_OFF_10H_REG		(0x60)	/* MSI Capability ID, Next Pointer, Control Registers. */
+ #define PCIE_MSI_CAP_OFF_14H_REG		(0x64)	/* MSI Capability ID, Next Pointer, Control Registers. */
+ #define PCIE_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_REG	(0x70)	/* PCI Express Capabilities, ID, Next Pointer Register. */
+ #define PCIE_DEVICE_CAPABILITIES_REG		(0x74)	/* Device Capabilities Register. */
+ #define PCIE_DEVICE_CONTROL_DEVICE_STATUS	(0x78)	/* Device Control and Status Register. */
+ #define PCIE_LINK_CAPABILITIES_REG		(0x7c)	/* Link Capabilities Register. */
+ #define PCIE_LINK_CONTROL_LINK_STATUS_REG	(0x80)	/* Link Control and Status Register. */
+ #define PCIE_ROOT_CONTROL_ROOT_CAPABILITIES_REG	(0x8c)	/* Root Control and Capabilities Register. */
+ #define PCIE_ROOT_STATUS_REG			(0x90)	/* Root Status Register. */
+ #define PCIE_DEVICE_CAPABILITIES2_REG		(0x94)	/* Device Capabilities 2 Register. */
+ #define PCIE_DEVICE_CONTROL2_DEVICE_STATUS2_REG	(0x98)	/* Device Control 2 and Status 2 Register. */
+ #define PCIE_LINK_CAPABILITIES2_REG		(0x9c)	/* Link Capabilities 2 Register. */
+ #define PCIE_LINK_CONTROL2_LINK_STATUS2_REG	(0xa0)	/* Link Control 2 and Status 2 Register. */
+ #define PCIE_PCI_MSIX_CAP_ID_NEXT_CTRL_REG	(0xb0)	/* MSI-X Capability ID, Next Pointer, Control Registers. */
+ #define PCIE_MSIX_TABLE_OFFSET_REG		(0xb4)	/* MSI-X Table Offset and BIR Register. */
+ #define PCIE_MSIX_PBA_OFFSET_REG		(0xb8)	/* MSI-X PBA Offset and BIR Register. */
+ #define PCIE_SLOTNUM_BASE			(0xc0)	/* Slot Numbering Capabilities Register. */
+ #define PCIE_VPD_BASE				(0xd0)	/* VPD Control and Capabilities Register. */
+ #define PCIE_DATA_REG				(0xd4)	/* VPD Data Register. */
+ #define PCIE_AER_EXT_CAP_HDR_OFF		(0x100)	/* Advanced Error Reporting Extended Capability Header. */
+ #define PCIE_UNCORR_ERR_STATUS_OFF		(0x104)	/* Uncorrectable Error Status Register. */
+ #define PCIE_UNCORR_ERR_MASK_OFF		(0x108)	/* Uncorrectable Error Mask Register. */
+ #define PCIE_UNCORR_ERR_SEV_OFF			(0x10c)	/* Uncorrectable Error Severity Register. */
+ #define PCIE_CORR_ERR_STATUS_OFF		(0x110)	/* Correctable Error Status Register. */
+ #define PCIE_CORR_ERR_MASK_OFF			(0x114)	/* Correctable Error Mask Register. */
+ #define PCIE_ADV_ERR_CAP_CTRL_OFF		(0x118)	/* Advanced Error Capabilities and Control Register. */
+ #define PCIE_HDR_LOG_0_OFF			(0x11c)	/* Header Log Register 0. */
+ #define PCIE_HDR_LOG_1_OFF			(0x120)	/* Header Log Register 1. */
+ #define PCIE_HDR_LOG_2_OFF			(0x124)	/* Header Log Register 2. */
+ #define PCIE_HDR_LOG_3_OFF			(0x128)	/* Header Log Register 3. */
+ #define PCIE_ROOT_ERR_CMD_OFF			(0x12c)	/* Root Error Command Register. */
+ #define PCIE_ROOT_ERR_STATUS_OFF		(0x130)	/* Root Error Status Register. */
+ #define PCIE_ERR_SRC_ID_OFF			(0x134)	/* Error Source Identification Register. */
+ #define PCIE_TLP_PREFIX_LOG_OFF			(0x138)	/* TLP Prefix Log Register. */
+ #define PCIE_VC_BASE				(0x148)	/* VC Extended Capability Header. */
+ #define PCIE_VC_CAPABILITIES_REG_1		(0x14c)	/* Port VC Capability Register 1. */
+ #define PCIE_VC_CAPABILITIES_REG_2		(0x150)	/* Port VC Capability Register 2. */
+ #define PCIE_VC_STATUS_CONTROL_REG		(0x154)	/* Port VC Control and Status Register. */
+ #define PCIE_RESOURCE_CAP_REG_VC0		(0x158)	/* VC Resource Capability Register (0). */
+ #define PCIE_RESOURCE_CON_REG_VC0		(0x15c)	/* VC Resource Control Register (0). */
+ #define PCIE_RESOURCE_STATUS_REG_VC0		(0x160)	/* VC Resource Status Register (0). */
+ #define PCIE_RESOURCE_CAP_REG_VC1		(0x164)	/* VC Resource Capability Register (1). */
+ #define PCIE_RESOURCE_CON_REG_VC1		(0x168)	/* VC Resource Control Register (1). */
+ #define PCIE_RESOURCE_STATUS_REG_VC1		(0x16c)	/* For a description of this standard PCIe register field, see the PCI Express. */
+ #define PCIE_RESOURCE_CAP_REG_VC2		(0x170)	/* VC Resource Capability Register (2). */
+ #define PCIE_RESOURCE_CON_REG_VC2		(0x174)	/* VC Resource Control Register (2). */
+ #define PCIE_RESOURCE_STATUS_REG_VC2		(0x178)	/* For a description of this standard PCIe register field, see the PCI Express. */
+ #define PCIE_RESOURCE_CAP_REG_VC3		(0x17c)	/* VC Resource Capability Register (3). */
+ #define PCIE_RESOURCE_CON_REG_VC3		(0x180)	/* VC Resource Control Register (3). */
+ #define PCIE_RESOURCE_STATUS_REG_VC3		(0x184)	/* For a description of this standard PCIe register field, see the PCI Express. */
+ #define PCIE_RESOURCE_CAP_REG_VC4		(0x188)	/* VC Resource Capability Register (4). */
+ #define PCIE_RESOURCE_CON_REG_VC4		(0x18c)	/* VC Resource Control Register (4). */
+ #define PCIE_RESOURCE_STATUS_REG_VC4		(0x190)	/* For a description of this standard PCIe register field, see the PCI Express. */
+ #define PCIE_RESOURCE_CAP_REG_VC5		(0x194)	/* VC Resource Capability Register (5). */
+ #define PCIE_RESOURCE_CON_REG_VC5		(0x198)	/* VC Resource Control Register (5). */
+ #define PCIE_RESOURCE_STATUS_REG_VC5		(0x19c)	/* For a description of this standard PCIe register field, see the PCI Express. */
+ #define PCIE_RESOURCE_CAP_REG_VC6		(0x1a0)	/* VC Resource Capability Register (6). */
+ #define PCIE_RESOURCE_CON_REG_VC6		(0x1a4)	/* VC Resource Control Register (6). */
+ #define PCIE_RESOURCE_STATUS_REG_VC6		(0x1a8)	/* For a description of this standard PCIe register field, see the PCI Express. */
+ #define PCIE_RESOURCE_CAP_REG_VC7		(0x1ac)	/* VC Resource Capability Register (7). */
+ #define PCIE_RESOURCE_CON_REG_VC7		(0x1b0)	/* VC Resource Control Register (7). */
+ #define PCIE_RESOURCE_STATUS_REG_VC7		(0x1b4)	/* For a description of this standard PCIe register field, see the PCI Express. */
+ #define PCIE_SN_BASE				(0x168)	/* Device Serial Number Extended Capability Header. */
+ #define PCIE_SER_NUM_REG_DW_1			(0x16c)	/* Serial Number 1 Register. */
+ #define PCIE_SER_NUM_REG_DW_2			(0x170)	/* Serial Number 2 Register. */
+ #define PCIE_PB_BASE				(0x178)	/* Power Budgeting Extended Capability Header. */
+ #define PCIE_DATA_REG_PB			(0x180)	/* Data Register. */
+ #define PCIE_CAP_REG_PB				(0x184)	/* Power Budget Capability Register. */
+ #define PCIE_SPCIE_CAP_HEADER_REG		(0x198)	/* SPCIE Capability Header. */
+ #define PCIE_LINK_CONTROL3_REG			(0x19c)	/* Link Control 3 Register. */
+ #define PCIE_LANE_ERR_STATUS_REG		(0x1a0)	/* Lane Error Status Register. */
+ #define PCIE_LANE_EQUALIZATION_CONTROL01_REG	(0x1a4)	/* Equalization Control Register for Lanes 1-0. */
+ #define PCIE_LANE_EQUALIZATION_CONTROL23_REG	(0x1a8)	/* Equalization Control Register for Lanes 3-2. */
+ #define PCIE_LANE_EQUALIZATION_CONTROL45_REG	(0x1ac)	/* Equalization Control Register for Lanes 5-4. */
+ #define PCIE_LANE_EQUALIZATION_CONTROL67_REG	(0x1b0)	/* Equalization Control Register for Lanes 7-6. */
+ #define PCIE_LANE_EQUALIZATION_CONTROL89_REG	(0x1b4)	/* Equalization Control Register for Lanes 9-8. */
+ #define PCIE_LANE_EQUALIZATION_CONTROL1011_REG	(0x1b8)	/* Equalization Control Register for Lanes 11-10. */
+ #define PCIE_LANE_EQUALIZATION_CONTROL1213_REG	(0x1bc)	/* Equalization Control Register for Lanes 13-12. */
+ #define PCIE_LANE_EQUALIZATION_CONTROL1415_REG	(0x1c0)	/* Equalization Control Register for Lanes 15-14. */
+ #define PCIE_TPH_EXT_CAP_HDR_REG		(0x1f8)	/* TPH Extended Capability Header. */
+ #define PCIE_TPH_REQ_CAP_REG_REG		(0x1fc)	/* TPH Requestor Capability Register. */
+ #define PCIE_TPH_REQ_CONTROL_REG_REG		(0x200)	/* TPH Requestor Control Register. */
+ #define PCIE_TPH_ST_TABLE_REG_0			(0x204)	/* TPH ST Table Register 0. */
+ #define PCIE_TPH_ST_TABLE_REG_1			(0x208)	/* TPH ST Table Register 1. */
+ #define PCIE_TPH_ST_TABLE_REG_2			(0x20c)	/* TPH ST Table Register 2. */
+ #define PCIE_TPH_ST_TABLE_REG_3			(0x210)	/* TPH ST Table Register 3. */
+ #define PCIE_TPH_ST_TABLE_REG_4			(0x214)	/* TPH ST Table Register 4. */
+ #define PCIE_TPH_ST_TABLE_REG_5			(0x218)	/* TPH ST Table Register 5. */
+ #define PCIE_TPH_ST_TABLE_REG_6			(0x21c)	/* TPH ST Table Register 6. */
+ #define PCIE_TPH_ST_TABLE_REG_7			(0x220)	/* TPH ST Table Register 7. */
+ #define PCIE_L1SUB_CAP_HEADER_REG		(0x2e0)	/* L1 Substates Extended Capability Header. */
+ #define PCIE_L1SUB_CAPABILITY_REG		(0x2e4)	/* L1 Substates Capability Register. */
+ #define PCIE_L1SUB_CONTROL1_REG			(0x2e8)	/* L1 Substates Control 1 Register. */
+ #define PCIE_L1SUB_CONTROL2_REG			(0x2ec)	/* L1 Substates Control 2 Register. */
+ #define PCIE_ACK_LATENCY_TIMER_OFF		(0x700)	/* Ack Latency Timer and Replay Timer Register. */
+ #define PCIE_VENDOR_SPEC_DLLP_OFF		(0x704)	/* Vendor Specific DLLP Register. */
+ #define PCIE_PORT_FORCE_OFF			(0x708)	/* Port Force Link Register. */
+ #define PCIE_ACK_F_ASPM_CTRL_OFF		(0x70c)	/* Ack Frequency and L0-L1 ASPM Control Register. */
+ #define PCIE_PORT_LINK_CTRL_OFF			(0x710)	/* Port Link Control Register. */
+ #define PCIE_LANE_SKEW_OFF			(0x714)	/* Lane Skew Register. */
+ #define PCIE_TIMER_CTRL_MAX_FUNC_NUM_OFF	(0x718)	/* Timer Control and Max Function Number Register. */
+ #define PCIE_SYMBOL_TIMER_FILTER_1_OFF		(0x71c)	/* Symbol Timer Register and Filter Mask 1 . */
+ #define PCIE_FILTER_MASK_2_OFF			(0x720)	/* Filter Mask 2 . */
+ #define PCIE_AMBA_MUL_OB_DECOMP_NP_SUB_REQ_CTRL_OFF	(0x724)	/* AMBA Multiple Outbound Decomposed NP SubRequests Control Register. */
+ #define PCIE_PL_DEBUG0_OFF			(0x728)	/* Debug Register 0. */
+ #define PCIE_PL_DEBUG1_OFF			(0x72c)	/* Debug Register 1. */
+ #define PCIE_TX_P_FC_CREDIT_STATUS_OFF		(0x730)	/* Transmit Posted FC Credit Status. */
+ #define PCIE_TX_NP_FC_CREDIT_STATUS_OFF		(0x734)	/* Transmit Non-Posted FC Credit Status. */
+ #define PCIE_TX_CPL_FC_CREDIT_STATUS_OFF	(0x738)	/* Transmit Completion FC Credit Status. */
+ #define PCIE_QUEUE_STATUS_OFF			(0x73c)	/* Queue Status. */
+ #define PCIE_VC_TX_ARBI_1_OFF			(0x740)	/* VC Transmit Arbitration Register 1. */
+ #define PCIE_VC_TX_ARBI_2_OFF			(0x744)	/* VC Transmit Arbitration Register 2. */
+ #define PCIE_VC0_P_RX_Q_CTRL_OFF		(0x748)	/* Segmented-Buffer VC0 Posted Receive Queue Control . */
+ #define PCIE_VC0_NP_RX_Q_CTRL_OFF		(0x74c)	/* Segmented-Buffer VC0 Non-Posted Receive Queue Control . */
+ #define PCIE_VC0_CPL_RX_Q_CTRL_OFF		(0x750)	/* Segmented-Buffer VC0 Completion Receive Queue Control . */
+ #define PCIE_VC1_P_RX_Q_CTRL_OFF		(0x754)	/* Segmented-Buffer VC1 Posted Receive Queue Control . */
+ #define PCIE_VC1_NP_RX_Q_CTRL_OFF		(0x758)	/* Segmented-Buffer VC1 Non-Posted Receive Queue Control . */
+ #define PCIE_VC1_CPL_RX_Q_CTRL_OFF		(0x75c)	/* Segmented-Buffer VC1 Completion Receive Queue Control . */
+ #define PCIE_VC2_P_RX_Q_CTRL_OFF		(0x760)	/* Segmented-Buffer VC2 Posted Receive Queue Control. */
+ #define PCIE_VC2_NP_RX_Q_CTRL_OFF		(0x764)	/* Segmented-Buffer VC2 Non-Posted Receive Queue Control. */
+ #define PCIE_VC2_CPL_RX_Q_CTRL_OFF		(0x768)	/* Segmented-Buffer VC2 Completion Receive Queue Control. */
+ #define PCIE_VC3_P_RX_Q_CTRL_OFF		(0x76c)	/* Segmented-Buffer VC3 Posted Receive Queue Control. */
+ #define PCIE_VC3_NP_RX_Q_CTRL_OFF		(0x770)	/* Segmented-Buffer VC3 Non-Posted Receive Queue Control. */
+ #define PCIE_VC3_CPL_RX_Q_CTRL_OFF		(0x774)	/* Segmented-Buffer VC3 Completion Receive Queue Control. */
+ #define PCIE_VC4_P_RX_Q_CTRL_OFF		(0x778)	/* Segmented-Buffer VC4 Posted Receive Queue Control. */
+ #define PCIE_VC4_NP_RX_Q_CTRL_OFF		(0x77c)	/* Segmented-Buffer VC4 Non-Posted Receive Queue Control. */
+ #define PCIE_VC4_CPL_RX_Q_CTRL_OFF		(0x780)	/* Segmented-Buffer VC4 Completion Receive Queue Control. */
+ #define PCIE_VC5_P_RX_Q_CTRL_OFF		(0x784)	/* Segmented-Buffer VC5 Posted Receive Queue Control. */
+ #define PCIE_VC5_NP_RX_Q_CTRL_OFF		(0x788)	/* Segmented-Buffer VC5 Non-Posted Receive Queue Control. */
+ #define PCIE_VC5_CPL_RX_Q_CTRL_OFF		(0x78c)	/* Segmented-Buffer VC5 Completion Receive Queue Control. */
+ #define PCIE_VC6_P_RX_Q_CTRL_OFF		(0x790)	/* Segmented-Buffer VC6 Posted Receive Queue Control. */
+ #define PCIE_VC6_NP_RX_Q_CTRL_OFF		(0x794)	/* Segmented-Buffer VC6 Non-Posted Receive Queue Control. */
+ #define PCIE_VC6_CPL_RX_Q_CTRL_OFF		(0x798)	/* Segmented-Buffer VC6 Completion Receive Queue Control. */
+ #define PCIE_VC7_P_RX_Q_CTRL_OFF		(0x79c)	/* Segmented-Buffer VC7 Posted Receive Queue Control. */
+ #define PCIE_VC7_NP_RX_Q_CTRL_OFF		(0x7a0)	/* Segmented-Buffer VC7 Non-Posted Receive Queue Control. */
+ #define PCIE_VC7_CPL_RX_Q_CTRL_OFF		(0x7a4)	/* Segmented-Buffer VC7 Completion Receive Queue Control. */
+ #define PCIE_GEN2_CTRL_OFF			(0x80c)	/* Link Width and Speed Change Control Register. */
+ #define PCIE_PHY_STATUS_OFF			(0x810)	/* PHY Status Register. */
+ #define PCIE_PHY_CONTROL_OFF			(0x814)	/* PHY Control Register. */
+ #define PCIE_MSI_CTRL_ADDR_OFF			(0x820)	/* MSI Controller Address Register. */
+ #define PCIE_MSI_CTRL_UPPER_ADDR_OFF		(0x824)	/* MSI Controller Upper Address Register. */
+ #define MSI_INTERRUPT_OFF			(12)
+ #define PCIE_MSI_CTRL_INT_0_EN_OFF		(0x828)	/* MSI Controller Interrupt#0 Enable Register. */
+ #define PCIE_MSI_CTRL_INT_0_MASK_OFF		(0x82c)	/* MSI Controller Interrupt#0 Mask Register. */
+ #define PCIE_MSI_CTRL_INT_0_STATUS_OFF		(0x830)	/* MSI Controller Interrupt#0 Status Register. */
+ #define PCIE_MSI_CTRL_INT_1_EN_OFF		(0x834)	/* MSI Controller Interrupt#1 Enable Register. */
+ #define PCIE_MSI_CTRL_INT_1_MASK_OFF		(0x838)	/* MSI Controller Interrupt#1 Mask Register. */
+ #define PCIE_MSI_CTRL_INT_1_STATUS_OFF		(0x83c)	/* MSI Controller Interrupt#1 Status Register. */
+ #define PCIE_MSI_CTRL_INT_2_EN_OFF		(0x840)	/* MSI Controller Interrupt#2 Enable Register. */
+ #define PCIE_MSI_CTRL_INT_2_MASK_OFF		(0x844)	/* MSI Controller Interrupt#2 Mask Register. */
+ #define PCIE_MSI_CTRL_INT_2_STATUS_OFF		(0x848)	/* MSI Controller Interrupt#2 Status Register. */
+ #define PCIE_MSI_CTRL_INT_3_EN_OFF		(0x84c)	/* MSI Controller Interrupt#3 Enable Register. */
+ #define PCIE_MSI_CTRL_INT_3_MASK_OFF		(0x850)	/* MSI Controller Interrupt#3 Mask Register. */
+ #define PCIE_MSI_CTRL_INT_3_STATUS_OFF		(0x854)	/* MSI Controller Interrupt#3 Status Register. */
+ #define PCIE_MSI_CTRL_INT_4_EN_OFF		(0x858)	/* MSI Controller Interrupt#4 Enable Register. */
+ #define PCIE_MSI_CTRL_INT_4_MASK_OFF		(0x85c)	/* MSI Controller Interrupt#4 Mask Register. */
+ #define PCIE_MSI_CTRL_INT_4_STATUS_OFF		(0x860)	/* MSI Controller Interrupt#4 Status Register. */
+ #define PCIE_MSI_CTRL_INT_5_EN_OFF		(0x864)	/* MSI Controller Interrupt#5 Enable Register. */
+ #define PCIE_MSI_CTRL_INT_5_MASK_OFF		(0x868)	/* MSI Controller Interrupt#5 Mask Register. */
+ #define PCIE_MSI_CTRL_INT_5_STATUS_OFF		(0x86c)	/* MSI Controller Interrupt#5 Status Register. */
+ #define PCIE_MSI_CTRL_INT_6_EN_OFF		(0x870)	/* MSI Controller Interrupt#6 Enable Register. */
+ #define PCIE_MSI_CTRL_INT_6_MASK_OFF		(0x874)	/* MSI Controller Interrupt#6 Mask Register. */
+ #define PCIE_MSI_CTRL_INT_6_STATUS_OFF		(0x878)	/* MSI Controller Interrupt#6 Status Register. */
+ #define PCIE_MSI_CTRL_INT_7_EN_OFF		(0x87c)	/* MSI Controller Interrupt#7 Enable Register. */
+ #define PCIE_MSI_CTRL_INT_7_MASK_OFF		(0x880)	/* MSI Controller Interrupt#7 Mask Register. */
+ #define PCIE_MSI_CTRL_INT_7_STATUS_OFF		(0x884)	/* MSI Controller Interrupt#7 Status Register. */
+ #define PCIE_MSI_GPIO_IO_OFF			(0x888)	/* MSI Controller General Purpose IO Register. */
+ #define PCIE_GEN3_RELATED_OFF			(0x890)	/* Gen3 Control Register. */
+ #define PCIE_GEN3_EQ_LOCAL_FS_LF_OFF		(0x894)	/* Gen3 EQ FS and LF Register. */
+ #define PCIE_GEN3_EQ_PSET_INDEX_OFF		(0x89c)	/* Gen3 EQ Preset Index Register. */
+ #define PCIE_GEN3_EQ_COEFF_LEGALITY_STATUS_OFF	(0x8a4)	/* Gen3 EQ Status Register. */
+ #define PCIE_GEN3_EQ_CONTROL_OFF		(0x8a8)	/* Gen3 EQ Control Register. */
+ #define PCIE_GEN3_EQ_FB_MODE_DIR_CHANGE_OFF	(0x8ac)	/* Gen3 EQ Direction Change Feedback Mode Control Register. */
+ #define PCIE_PIPE_LOOPBACK_CONTROL_OFF		(0x8b8)	/* PIPE Loopback Control Register. */
+ #define PCIE_MISC_CONTROL_1_OFF			(0x8bc)	/* DBI Read-Only Write Enable Register. */
+ #define PCIE_AMBA_ERROR_RESPONSE_DEFAULT_OFF	(0x8d0)	/* AHB/AXI Bridge Slave Error Response Register. */
+ #define PCIE_AMBA_LINK_TIMEOUT_OFF		(0x8d4)	/* Link Down AXI Bridge Slave Timeout Register. */
+ #define PCIE_AMBA_ORDERING_CTRL_OFF		(0x8d8)	/* AMBA Ordering Control. */
+ #define PCIE_AMBA_ORDRMGR_WDOG_OFF		(0x8dc)	/* AHB/AXI Ordering Manager Watchdog Timer. */
+ #define PCIE_COHERENCY_CONTROL_1_OFF		(0x8e0)	/* ACE Cache Coherency Control Register 1. */
+ #define PCIE_COHERENCY_CONTROL_2_OFF		(0x8e4)	/* ACE Cache Coherency Control Register 2. */
+ #define PCIE_COHERENCY_CONTROL_3_OFF		(0x8e8)	/* ACE Cache Coherency Control Register 3. */
+ #define PCIE_PL_LAST_OFF			(0x8fc)	/* This is an internally reserved register. */
+ #define PCIE_IATU_VIEWPORT_OFF			(0x900)	/* iATU Index Register. */
+ #define PCIE_IATU_REGION_CTRL_1_OFF_OUTBOUND_0	(0x904)	/* iATU Region Control 1 Register. */
+ #define PCIE_IATU_REGION_CTRL_2_OFF_OUTBOUND_0	(0x908)	/* iATU Region Control 2 Register. */
+ #define PCIE_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_0	(0x90c) /* The start address of the address region to be translated.*/
+ #define PCIE_IATU_UPR_BASE_ADDR_OFF_OUTBOUND_0	(0x910)
+ #define PCIE_IATU_LIMIT_ADDR_OFF_OUTBOUND_0	(0x914) /* iATU Limit Address Register */
+ #define PCIE_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_0	(0x918) /* iATU Outbound Region#N Lower Offset Address Register */
+ #define PCIE_IATU_UPR_TARGET_ADDR_OFF_OUTBOUND_0	(0x91C)
+ #define PCIE_DMA_CTRL_OFF			(0x978)	/* DMA Number of Channels Register. */
+ #define PCIE_DMA_WRITE_ENGINE_EN_OFF		(0x97c)	/* DMA Write Engine Enable Register. */
+ #define PCIE_DMA_WRITE_DOORBELL_OFF		(0x980)	/* DMA Write Doorbell Register. */
+ #define PCIE_DMA_WRITE_CHANNEL_ARB_WEIGHT_LOW_OFF	(0x988)	/* DMA Write Engine Channel Arbitration Weight Low Register. */
+ #define PCIE_DMA_WRITE_CHANNEL_ARB_WEIGHT_HIGH_OFF	(0x98c)	/* DMA Write Engine Channel Arbitration Weight High Register. */
+ #define PCIE_DMA_WRITE_P_REQ_TIMER_OFF		(0x998)	/* DMA Write Posted Request Deadlock Timer Register. */
+ #define PCIE_DMA_READ_ENGINE_EN_OFF		(0x99c)	/* DMA Read Engine Enable Register. */
+ #define PCIE_DMA_READ_DOORBELL_OFF		(0x9a0)	/* DMA Read Doorbell Register. */
+ #define PCIE_DMA_READ_CHANNEL_ARB_WEIGHT_LOW_OFF	(0x9a8)	/* DMA Read Engine Channel Arbitration Weight Low Register. */
+ #define PCIE_DMA_READ_CHANNEL_ARB_WEIGHT_HIGH_OFF	(0x9ac)	/* DMA Read Engine Channel Arbitration Weight High Register. */
+ #define PCIE_DMA_WRITE_INT_STATUS_OFF		(0x9bc)	/* DMA Write Interrupt Status Register. */
+ #define PCIE_DMA_WRITE_INT_MASK_OFF		(0x9c4)	/* DMA Write Interrupt Mask Register. */
+ #define PCIE_DMA_WRITE_INT_CLEAR_OFF		(0x9c8)	/* DMA Write Interrupt Clear Register. */
+ #define PCIE_DMA_WRITE_ERR_STATUS_OFF		(0x9cc)	/* DMA Write Error Status Register. */
+ #define PCIE_DMA_WRITE_DONE_IMWR_LOW_OFF	(0x9d0)	/* DMA Write Done IMWr Address Low Register. */
+ #define PCIE_DMA_WRITE_DONE_IMWR_HIGH_OFF	(0x9d4)	/* DMA Write Done IMWr Interrupt Address High Register. */
+ #define PCIE_DMA_WRITE_ABORT_IMWR_LOW_OFF	(0x9d8)	/* DMA Write Abort IMWr Address Low Register. */
+ #define PCIE_DMA_WRITE_ABORT_IMWR_HIGH_OFF	(0x9dc)	/* DMA Write Abort IMWr Address High Register. */
+ #define PCIE_DMA_WRITE_CH01_IMWR_DATA_OFF	(0x9e0)	/* DMA Write Channel 1 and 0 IMWr Data Register. */
+ #define PCIE_DMA_WRITE_CH23_IMWR_DATA_OFF	(0x9e4)	/* DMA Write Channel 3 and 2 IMWr Data Register. */
+ #define PCIE_DMA_WRITE_CH45_IMWR_DATA_OFF	(0x9e8)	/* DMA Write Channel 5 and 4 IMWr Data Register. */
+ #define PCIE_DMA_WRITE_CH67_IMWR_DATA_OFF	(0x9ec)	/* DMA Write Channel 7 and 6 IMWr Data Register. */
+ #define PCIE_DMA_WRITE_LINKED_LIST_ERR_EN_OFF	(0xa00)	/* DMA Write Linked List Error Enable Register. */
+ #define PCIE_DMA_READ_INT_STATUS_OFF		(0xa10)	/* DMA Read Interrupt Status Register. */
+ #define PCIE_DMA_READ_INT_MASK_OFF		(0xa18)	/* DMA Read Interrupt Mask Register. */
+ #define PCIE_DMA_READ_INT_CLEAR_OFF		(0xa1c)	/* DMA Read Interrupt Clear Register. */
+ #define PCIE_DMA_READ_ERR_STATUS_LOW_OFF	(0xa24)	/* DMA Read Error Status Low Register. */
+ #define PCIE_DMA_READ_ERR_STATUS_HIGH_OFF	(0xa28)	/* DMA Read Error Status High Register. */
+ #define PCIE_DMA_READ_LINKED_LIST_ERR_EN_OFF	(0xa34)	/* DMA Read Linked List Error Enable Register. */
+ #define PCIE_DMA_READ_DONE_IMWR_LOW_OFF		(0xa3c)	/* DMA Read Done IMWr Address Low Register. */
+ #define PCIE_DMA_READ_DONE_IMWR_HIGH_OFF	(0xa40)	/* DMA Read Done IMWr Address High Register. */
+ #define PCIE_DMA_READ_ABORT_IMWR_LOW_OFF	(0xa44)	/* DMA Read Abort IMWr Address Low Register. */
+ #define PCIE_DMA_READ_ABORT_IMWR_HIGH_OFF	(0xa48)	/* DMA Read Abort IMWr Address High Register. */
+ #define PCIE_DMA_READ_CH01_IMWR_DATA_OFF	(0xa4c)	/* DMA Read Channel 1 and 0 IMWr Data Register. */
+ #define PCIE_DMA_READ_CH23_IMWR_DATA_OFF	(0xa50)	/* DMA Read Channel 3 and 2 IMWr Data Register. */
+ #define PCIE_DMA_READ_CH45_IMWR_DATA_OFF	(0xa54)	/* DMA Read Channel 5 and 4 IMWr Data Register. */
+ #define PCIE_DMA_READ_CH67_IMWR_DATA_OFF	(0xa58)	/* DMA Read Channel 7 and 6 IMWr Data Register. */
+ #define PCIE_DMA_VIEWPORT_SEL_OFF		(0xa6c)	/* DMA Channel Context Index Register. */
+ #define PCIE_PL_LTR_LATENCY_OFF			(0xb30)	/* LTR Latency Register. */
+ #define PCIE_AUX_CLK_FREQ_OFF			(0xb40)	/* Auxiliary Clock Frequency Control Register. */
+ #define PCIE_L1_SUBSTATES_OFF			(0xb44)	/* L1 Substates Timing Register. */
+ /* Baikal-specific registers. */
+ #define PCIE_BK_MGMT_SEL_LANE			(0xd04) /* Select lane. */
+ #define PCIE_BK_MGMT_CTRL			(0xd08) /* Control management register. */
+ #define PCIE_BK_MGMT_WRITE_DATA			(0xd0c) /* Data write register. */
+ #define PCIE_BK_MGMT_READ_DATA			(0xd10) /* Data read register. */
+ 
+ /* PCIE_BK_MGMT_CTRL */
+ #define BK_MGMT_CTRL_ADDR_MASK			(0x1FFFFF) /* [21:0] bits */
+ #define BK_MGMT_CTRL_READ			(0 << 29)
+ #define BK_MGMT_CTRL_WRITE			(1 << 29)
+ #define BK_MGMT_CTRL_DONE			(1 << 30)
+ #define BK_MGMT_CTRL_BUSY			(1 << 31)
+ 
+ /* PCIE_MISC_CONTROL_1_OFF */
+ #define DBI_RO_WR_EN				(1 << 0)	/* Write to RO Registers Using DBI. */
+ 
+ /* PCIE_PORT_LINK_CTRL_OFF */
+ #define FAST_LINK_MODE				(1 << 7)	/* Fast Link Mode. */
+ #define LINK_CAPABLE_SHIFT			(16)		/* Link Mode Enable. */
+ #define LINK_CAPABLE_MASK			0x3F0000
+ 
+ /* GEN2_CTRL_OFF */
+ #define NUM_OF_LANES_SHIFT			(8)		/* Predetermined Number of Lanes. */
+ #define NUM_OF_LANES_MASK			0x1FF00
+ 
+ /* GEN3_EQ_CONTROL_OFF */
+ #define GEN3_EQ_EVAL_2MS_DISABLE		(1 << 5)	/* Phase2_3 2 ms Timeout Disable. */
+ #define GEN3_EQ_FB_MODE_SHIFT			(0)		/* Feedback Mode */
+ #define GEN3_EQ_FB_MODE_MASK			0xF
+ #define GEN3_EQ_PSET_REQ_VEC_SHIFT		(8)		/* Preset Request Vector. */
+ #define GEN3_EQ_PSET_REQ_VEC_MASK		0xFFFF00
+ 
+ /* LINK_CONTROL_LINK_STATUS_REG */
+ #define PCIE_CAP_LINK_SPEED_SHIFT		16
+ #define PCIE_CAP_LINK_SPEED_MASK		0xF0000
+ #define PCIE_CAP_LINK_SPEED_GEN1		0x1
+ #define PCIE_CAP_LINK_SPEED_GEN2		0x2
+ #define PCIE_CAP_LINK_SPEED_GEN3		0x3
+ 
+ /* IATU_VIEWPORT_OFF */
+ #define REGION_DIR_SHIFT			(31)		/* Region Direction. */
+ #define REGION_INDEX_SHIFT			(0)		/* Region Index. */
+ #define REGION_DIR_OUTBOUND			(0)
+ #define REGION_DIR_INBOUND			(1)
+ 
+ /* TYPE1_STATUS_COMMAND_REG */
+ #define TYPE1_STATUS_COMMAND_REG_BME		(1 << 2)
+ #define TYPE1_STATUS_COMMAND_REG_MSE		(1 << 1)
+ #define TYPE1_STATUS_COMMAND_REG_IOSE		(1 << 0)
+ 
+ /* IATU_LWR_BASE_ADDR_OFF_OUTBOUND_0 */
+ #define LWR_BASE_RW_SHIFT			(16)
+ 
+ /* IATU_LIMIT_ADDR_OFF_OUTBOUND_0 */
+ #define LIMIT_ADDR_RW_SHIFT			(16)
+ 
+ /* IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_0 */
+ #define LWR_TARGET_RW_SHIFT			(16)
+ 
+ /* IATU_REGION_CTRL_1_OFF_OUTBOUND_0 */
+ #define IATU_REGION_CTRL_1_OFF_OUTBOUND_0_TYPE_SHIFT	(0)
+ #define TLP_TYPE_MEM				(0)
+ #define TLP_TYPE_IO				(2)
+ #define TLP_TYPE_CFGRD0				(4)
+ #define TLP_TYPE_CFGRD1				(5)
+ 
+ /* IATU_REGION_CTRL_2_OFF_OUTBOUND_0 */
+ #define IATU_REGION_CTRL_2_OFF_OUTBOUND_0_REGION_EN	(1 << 31)
+ 
+ /* PCIE_LINK_CONTROL2_LINK_STATUS2 */
+ #define PCIE_LINK_CONTROL2_GEN_MASK		(0xF)
+ #define PCIE_LINK_CONTROL2_GEN1			(1)
+ #define PCIE_LINK_CONTROL2_GEN2			(2)
+ #define PCIE_LINK_CONTROL2_GEN3			(3)
+ 
+ /* PHY control registers. */
+ #define PCIE_PHY_DWC_GLBL_PLL_CFG_0		(0x1c000)	/* PLL Global Configuration Register #0 */
+ #define PCIE_PHY_DWC_GLBL_PLL_CFG_1		(0x1c001)	/* PLL Global Configuration Register #1 */
+ #define PCIE_PHY_DWC_GLBL_PLL_CFG_2		(0x1c002)	/* PLL Global Configuration Register #2 */
+ #define PCIE_PHY_DWC_GLBL_PLL_CFG_3		(0x1c003)	/* PLL Global Configuration Register #3 */
+ #define PCIE_PHY_DWC_GLBL_PLL_CFG_4		(0x1c004)	/* PLL Global Configuration Register #4 */
+ #define PCIE_PHY_DWC_GLBL_MISC_CONFIG_0		(0x1c005)	/* Global Miscellaneous Configuration #0 */
+ #define PCIE_PHY_DWC_GLBL_MISC_CONFIG_1		(0x1c006)	/* Global Miscellaneous Configuration #1 */
+ #define PCIE_PHY_DWC_SLICE_CFG			(0x1c00c)	/* Slice Configuration */
+ #define PCIE_PHY_DWC_GLBL_REGU_CFG		(0x1c00d)	/* Global Regulator Configuration */
+ #define PCIE_PHY_DWC_GLBL_TERM_CFG		(0x1c00e)	/* Global Termination Calibration Configuration */
+ #define PCIE_PHY_DWC_GLBL_CAL_CFG		(0x1c00f)	/* Global PLL Calibration Configuration */
+ #define PCIE_PHY_DWC_GLBL_RD_SYNC_STATUS	(0x1c010)	/* Global Read Synchronization Status */
+ #define PCIE_PHY_DWC_RX_PWR_CTRL_P0		(0x1c014)	/* RX Power Controls in Power State P0 */
+ #define PCIE_PHY_DWC_RX_PWR_CTRL_P0S		(0x1c015)	/* RX Power Controls in Power State P0S */
+ #define PCIE_PHY_DWC_RX_PWR_CTRL_P1		(0x1c016)	/* RX Power Controls in Power State P1 */
+ #define PCIE_PHY_DWC_RX_PWR_CTRL_P2		(0x1c017)	/* RX Power Controls in Power State P2 */
+ #define PCIE_PHY_DWC_TX_PWR_CTRL_P0_P0S		(0x1c018)	/* TX Power Controls in Power States P0 and POS */
+ #define PCIE_PHY_DWC_TX_PWR_CTRL_P1_P2		(0x1c019)	/* TX Power Controls in Power States P1 and P2 */
+ #define PCIE_PHY_DWC_GLBL_PWR_CTRL		(0x1c01a)	/* Global Power State Machine Control Override */
+ #define PCIE_PHY_DWC_RX_TXDIR_CTRL_0		(0x1c01d)	/* Far-end TX Direction Control Register #0 */
+ #define PCIE_PHY_DWC_RX_TXDIR_CTRL_1		(0x1c01e)	/* Far-end TX Direction Control Register #1 */
+ #define PCIE_PHY_DWC_RX_TXDIR_CTRL_2		(0x1c01f)	/* Far-end TX Direction Control Register #2 */
+ #define PCIE_PHY_DWC_GLBL_PLL_MONITOR		(0x1c020)	/* Monitor for SerDes Global to Raw PCS Global Interface */
+ #define PCIE_PHY_DWC_GLBL_TERM_MON_1		(0x1c022)	/* Monitor for SerDes Global to Raw PCS Global Interface */
+ #define PCIE_PHY_DWC_GLBL_SDS_PIN_MON_0		(0x1c023)	/* Monitor for Raw PCS Global to SerDes Global to Raw PCS Interface */
+ #define PCIE_PHY_DWC_GLBL_SDS_PIN_MON_1		(0x1c024)	/* Monitor for Raw PCS Global to SerDes Global to Raw PCS Interface */
+ #define PCIE_PHY_DWC_GLBL_PWR_MON_0		(0x1c025)	/* Monitor of Global Power State Machine Values */
+ #define PCIE_PHY_DWC_GLBL_PWR_MON_1		(0x1c026)	/* Monitor of Global Power State Machine Values */
+ #define PCIE_PHY_DWC_GLBL_PWR_MON_2		(0x1c027)	/* Monitor of Global Power State Machine Values */
+ #define PCIE_PHY_DWC_GLBL_PLL_SSC_FRAC_BASE	(0x1c060)	/* Global PLL SSC Fractional Base */
+ #define PCIE_PHY_DWC_GLBL_PLL_SSC_CYCLES	(0x1c061)	/* Global PLL SSC Cycles Configuration */
+ #define PCIE_PHY_DWC_GLBL_PLL_SSC_FMFREQ	(0x1c062)	/* Global PLL SSC Modulation Frequency */
+ #define PCIE_PHY_DWC_GLBL_PLL_SSC_FREF		(0x1c063)	/* Global PLL SSC Reference Frequency */
+ #define PCIE_PHY_DWC_GLBL_PLL_SSC_PPM		(0x1c064)	/* Global PLL SSC PPM */
+ #define PCIE_PHY_DWC_GLBL_PLL_SSC_CFG		(0x1c065)	/* Global PLL SSC Configuration */
+ #define PCIE_PHY_DWC_GLBL_PLL_SSC_ALU_CMD	(0x1c067)	/* Global PLL SSC ALU Command */
+ #define PCIE_PHY_DWC_GLBL_PLL_SSC_MON		(0x1c069)	/* Global PLL SSC Monitor */
+ #define PCIE_PHY_DWC_GLBL_PLL_SSC_ALU_OUT_0	(0x1c06b)	/* Global PLL SSC ALU Output Register #0 */
+ #define PCIE_PHY_DWC_GLBL_PLL_SSC_ALU_OUT_1	(0x1c06c)	/* Global PLL SSC ALU Output Register #1 */
+ #define PCIE_PHY_DWC_GLBL_PLL_SSC_DIV		(0x1c06d)	/* Global PLL SSC Divider */
+ #define PCIE_PHY_DWC_GLBL_PLL_SSC_FRAC		(0x1c06e)	/* Global PLL SSC Fraction */
+ #define PCIE_PHY_DWC_GLBL_TAD			(0x1c080)	/* Global Test Analog and Digital Monitor */
+ #define PCIE_PHY_DWC_GLBL_TM_ADMON		(0x1c081)	/* Global Test Mode Analog/Digital Monitor Enable */
+ #define PCIE_PHY_DWC_EQ_WAIT_TIME		(0x3c000)	/* TX and RX Equalization Wait Times */
+ #define PCIE_PHY_DWC_RDET_TIME			(0x3c001)	/* Receiver Detect Wait Times */
+ #define PCIE_PHY_DWC_PCS_LANE_LINK_CFG		(0x3c002)	/* Link Configuration Override */
+ #define PCIE_PHY_DWC_PCS_PLL_CTLIFC_0		(0x3c003)	/* PLL Control Interface Override Register #0 */
+ #define PCIE_PHY_DWC_PCS_PLL_CTLIFC_1		(0x3c004)	/* PLL Control Interface Override Register #1 */
+ #define PCIE_PHY_DWC_PCS_REG_RD_TIMEOUT		(0x3c005)	/* Register Read Timeout */
+ #define PCIE_PHY_DWC_PCS_PLL_PCIE1_MODE_0	(0x3c006)	/* PLL Configuration Register #0 for PCIe1 */
+ #define PCIE_PHY_DWC_PCS_PLL_PCIE1_MODE_1	(0x3c007)	/* PLL Configuration Register #1 for PCIe1 */
+ #define PCIE_PHY_DWC_PCS_LANE_PCIE1_MODE_0	(0x3c008)	/* Lane Configuration Register #0 for PCIe1 */
+ #define PCIE_PHY_DWC_PCS_LANE_PCIE1_MODE_1	(0x3c009)	/* Lane Configuration Register #1 for PCIe1 */
+ #define PCIE_PHY_DWC_PCS_PLL_PCIE2_MODE_0	(0x3c00a)	/* PLL Configuration Register #0 for PCIe2 */
+ #define PCIE_PHY_DWC_PCS_PLL_PCIE2_MODE_1	(0x3c00b)	/* PLL Configuration Register #1 for PCIe2 */
+ #define PCIE_PHY_DWC_PCS_LANE_PCIE2_MODE_0	(0x3c00c)	/* Lane Configuration Register #0 for PCIe2 */
+ #define PCIE_PHY_DWC_PCS_LANE_PCIE2_MODE_1	(0x3c00d)	/* Lane Configuration Register #1 for PCIe2 */
+ #define PCIE_PHY_DWC_PCS_PLL_PCIE3_MODE_0	(0x3c00e)	/* PLL Configuration Register #0 for PCIe3 */
+ #define PCIE_PHY_DWC_PCS_PLL_PCIE3_MODE_1	(0x3c00f)	/* PLL Configuration Register #1 for PCIe3 */
+ #define PCIE_PHY_DWC_PCS_LANE_PCIE3_MODE_0	(0x3c010)	/* Lane Configuration Register #0 for PCIe3 */
+ #define PCIE_PHY_DWC_PCS_LANE_PCIE3_MODE_1	(0x3c011)	/* Lane Configuration Register #1 for PCIe3 */
+ #define PCIE_PHY_DWC_PCS_PLL_KX_MODE_1		(0x3c013)	/* PLL Configuration Register #1 for KX */
+ #define PCIE_PHY_DWC_PCS_LANE_KX_MODE_0		(0x3c014)	/* Lane Configuration Register #0 for KX */
+ #define PCIE_PHY_DWC_PCS_LANE_KX_MODE_1		(0x3c015)	/* Lane Configuration Register #1 for KX */
+ #define PCIE_PHY_DWC_PCS_PLL_KX4_MODE_0		(0x3c016)	/* PLL Configuration Register #0 for KX4 */
+ #define PCIE_PHY_DWC_PCS_PLL_KX4_MODE_1		(0x3c017)	/* PLL Configuration Register #1 for KX4 */
+ #define PCIE_PHY_DWC_PCS_LANE_KX4_MODE_0	(0x3c018)	/* Lane Configuration Register #0 for KX4 */
+ #define PCIE_PHY_DWC_PCS_LANE_KX4_MODE_1	(0x3c019)	/* Lane Configuration Register #1 for KX4 */
+ #define PCIE_PHY_DWC_PCS_PLL_KR_MODE_0		(0x3c01a)	/* PLL Configuration Register #0 for KR */
+ #define PCIE_PHY_DWC_PCS_PLL_KR_MODE_1		(0x3c01b)	/* PLL Configuration Register #1 for KR */
+ #define PCIE_PHY_DWC_PCS_LANE_KR_MODE_0		(0x3c01c)	/* Lane Configuration Register #0 for KR */
+ #define PCIE_PHY_DWC_PCS_LANE_KR_MODE_1		(0x3c01d)	/* Lane Configuration Register #1 for KR */
+ #define PCIE_PHY_DWC_PCS_PLL_SGMII_MODE_0	(0x3c01e)	/* PLL Configuration Register #0 for SGMII */
+ #define PCIE_PHY_DWC_PCS_PLL_SGMII_MODE_1	(0x3c01f)	/* PLL Configuration Register #1 for SGMII */
+ #define PCIE_PHY_DWC_PCS_LANE_SGMII_MODE_0	(0x3c020)	/* Lane Configuration Register #0 for SGMII */
+ #define PCIE_PHY_DWC_PCS_LANE_SGMII_MODE_1	(0x3c021)	/* Lane Configuration Register #1 for SGMII */
+ #define PCIE_PHY_DWC_PCS_PLL_QSGMII_MODE_0	(0x3c022)	/* PLL Configuration Register #0 for QSGMII */
+ #define PCIE_PHY_DWC_PCS_PLL_QSGMII_MODE_1	(0x3c023)	/* PLL Configuration Register #1 for QSGMII */
+ #define PCIE_PHY_DWC_PCS_LANE_QSGMII_MODE_0	(0x3c024)	/* Lane Configuration Register #0 for QSGMII */
+ #define PCIE_PHY_DWC_PCS_LANE_QSGMII_MODE_1	(0x3c025)	/* Lane Configuration Register #1 for QSGMII */
+ #define PCIE_PHY_DWC_PCS_PLL_CEI_MODE_0		(0x3c026)	/* PLL Configuration Register #0 for CEI */
+ #define PCIE_PHY_DWC_PCS_PLL_CEI_MODE_1		(0x3c027)	/* PLL Configuration Register #1 for CEI */
+ #define PCIE_PHY_DWC_PCS_LANE_CEI_MODE_0		(0x3c028)	/* Lane Configuration Register #0 for CEI */
+ #define PCIE_PHY_DWC_PCS_LANE_CEI_MODE_1		(0x3c029)	/* Lane Configuration Register #1 for CEI */
+ #define PCIE_PHY_DWC_PCS_PLL_PCIE1_125M_MODE_0		(0x3c02a)	/* PLL Configuration Register #0 for PCIe1 with 125MHz refclk */
+ #define PCIE_PHY_DWC_PCS_PLL_PCIE1_125M_MODE_1		(0x3c02b)	/* PLL Configuration Register #1 for PCIe1 with 125MHz refclk */
+ #define PCIE_PHY_DWC_PCS_LANE_PCIE1_125M_MODE_0		(0x3c02c)	/* Lane Configuration Register #0 for PCIe1 with 125MHz refclk */
+ #define PCIE_PHY_DWC_PCS_LANE_PCIE1_125M_MODE_1		(0x3c02d)	/* Lane Configuration Register #1 for PCIe1 with 125MHz refclk */
+ #define PCIE_PHY_DWC_PCS_PLL_PCIE2_125M_MODE_0		(0x3c02e)	/* PLL Configuration Register #0 for PCIe2 with 125MHz refclk */
+ #define PCIE_PHY_DWC_PCS_PLL_PCIE2_125M_MODE_1		(0x3c02f)	/* PLL Configuration Register #1 for PCIe2 with 125MHz refclk */
+ #define PCIE_PHY_DWC_PCS_LANE_PCIE2_125M_MODE_0		(0x3c030)	/* Lane Configuration Register #0 for PCIe2 with 125MHz refclk */
+ #define PCIE_PHY_DWC_PCS_LANE_PCIE2_125M_MODE_1		(0x3c031)	/* Lane Configuration Register #1 for PCIe2 with 125MHz refclk */
+ #define PCIE_PHY_DWC_PCS_PLL_PCIE3_125M_MODE_0		(0x3c032)	/* PLL Configuration Register #0 for PCIe3 with 125MHz refclk */
+ #define PCIE_PHY_DWC_PCS_PLL_PCIE3_125M_MODE_1		(0x3c033)	/* PLL Configuration Register #1 for PCIe3 with 125MHz refclk */
+ #define PCIE_PHY_DWC_PCS_LANE_PCIE3_125M_MODE_0		(0x3c034)	/* Lane Configuration Register #0 for PCIe3 with 125MHz refclk */
+ #define PCIE_PHY_DWC_PCS_LANE_PCIE3_125M_MODE_1		(0x3c035)	/* Lane Configuration Register #1 for PCIe3 with 125MHz refclk */
+ #define PCIE_PHY_DWC_PCS_LANE_VMA_COARSE_CTRL_0		(0x3c036)	/* Lane VMA Coarse Control Register #0 */
+ #define PCIE_PHY_DWC_PCS_LANE_VMA_COARSE_CTRL_1		(0x3c037)	/* Lane VMA Coarse Control Register #1 */
+ #define PCIE_PHY_DWC_PCS_LANE_VMA_COARSE_CTRL_2		(0x3c038)	/* Lane VMA Coarse Control Register #2 */
+ #define PCIE_PHY_DWC_PCS_LANE_VMA_FINE_CTRL_0		(0x3c039)	/* Lane VMA Fine Control Register #0 */
+ #define PCIE_PHY_DWC_PCS_LANE_VMA_FINE_CTRL_1		(0x3c03a)	/* Lane VMA Fine Control Register #1 */
+ #define PCIE_PHY_DWC_PCS_LANE_VMA_FINE_CTRL_2		(0x3c03b)	/* Lane VMA Fine Control Register #2 */
+ #define PCIE_PHY_DWC_PCS_LANE_MODE_OVRD			(0x3c03c)	/* Lane Mode Override in Raw PCS Global and Slice */
+ #define PCIE_PHY_DWC_PCS_LANE_LINK_MON			(0x3c040)	/* Monitor of MAC to Raw PCS Link Configuration Interface */
+ #define PCIE_PHY_DWC_PCS_MAC_PLLIFC_MON_2		(0x3c043)	/* Monitor of MAC to Raw PCS PLL_PCS Divider Value */
+ #define PCIE_PHY_DWC_PCS_MAC_PLLIFC_MON_3		(0x3c044)	/* Monitor of MAC to Raw PCS PLL OP_Range and Divider Values */
+ #define PCIE_PHY_DWC_SLICE_TRIM			(0x1c040)	/* Slice TX and RX Bias Trim Settings */
+ #define PCIE_PHY_DWC_RX_LDLL_CTRL		(0x1c043)	/* RX Lane DLL Test Controls */
+ #define PCIE_PHY_DWC_RX_SDLL_CTRL		(0x1c044)	/* RX Slice DLL test controls */
+ #define PCIE_PHY_DWC_SLICE_PCIE1_MODE		(0x1c045)	/* Slice Configuration Settings for PCIE1 @ 100MHz */
+ #define PCIE_PHY_DWC_SLICE_PCIE2_MODE		(0x1c046)	/* Slice Configuration Settings for PCIE2 @ 100Mhz */
+ #define PCIE_PHY_DWC_SLICE_PCIE3_MODE		(0x1c047)	/* Slice Configuration Settings for PCIE3 @ 100Mhz */
+ #define PCIE_PHY_DWC_SLICE_KX_MODE		(0x1c048)	/* Slice Configuration Settings for KX */
+ #define PCIE_PHY_DWC_SLICE_KX4_MODE		(0x1c049)	/* Slice Configuration Settings for KX4 */
+ #define PCIE_PHY_DWC_SLICE_KR_MODE		(0x1c04a)	/* Slice Configuration Settings for KR */
+ #define PCIE_PHY_DWC_SLICE_SGMII_MODE		(0x1c04b)	/* Slice Configuration Settings for SGMII */
+ #define PCIE_PHY_DWC_SLICE_QSGMII_MODE		(0x1c04c)	/* Slice Configuration Settings for QSGMII */
+ #define PCIE_PHY_DWC_SLICE_CEI_MODE		(0x1c04d)	/* Slice Configuration Settings for CEI */
+ #define PCIE_PHY_DWC_SLICE_PCIE1_125M_MODE	(0x1c04e)	/* Slice Configuration Settings for PCIE1 @ 125MHz */
+ #define PCIE_PHY_DWC_SLICE_PCIE2_125M_MODE	(0x1c04f)	/* Slice Configuration Settings for PCIE2 @ 125MHz */
+ #define PCIE_PHY_DWC_SLICE_PCIE3_125M_MODE	(0x1c050)	/* Slice Configuration Settings for PCIE3 @ 125MHz */
+ #define PCIE_PHY_DWC_SLICE_OVRD_MODE		(0x1c051)	/* Slice Configuration Settings Override */
+ #define PCIE_PHY_DWC_RX_CFG_0			(0x18000)	/* Lane RX Configuration Register #0 */
+ #define PCIE_PHY_DWC_RX_CFG_1			(0x18001)	/* Lane RX Configuration Register #1 */
+ #define PCIE_PHY_DWC_RX_CFG_2			(0x18002)	/* Lane RX Configuration Register #2 */
+ #define PCIE_PHY_DWC_RX_CFG_3			(0x18003)	/* Lane RX Configuration Register #3 */
+ #define PCIE_PHY_DWC_RX_CFG_4			(0x18004)	/* Lane RX Configuration Register #4 */
+ #define PCIE_PHY_DWC_RX_CFG_5			(0x18005)	/* Lane RX Configuration Register #5 */
+ #define PCIE_PHY_DWC_RX_CDR_CTRL_0		(0x18006)	/* Lane RX CDR Control Register #0 */
+ #define PCIE_PHY_DWC_RX_CDR_CTRL_1		(0x18007)	/* Lane RX CDR Control Register #1 */
+ #define PCIE_PHY_DWC_RX_CDR_CTRL_2		(0x18008)	/* Lane RX CDR Control Register #2 */
+ #define PCIE_PHY_DWC_RX_LOOP_CTRL		(0x18009)	/* Lane RX Loop Control */
+ #define PCIE_PHY_DWC_RX_MISC_CTRL		(0x1800a)	/* Lane RX Miscellaneous Control */
+ #define PCIE_PHY_DWC_RX_CTLE_CTRL		(0x1800b)	/* Lane RX CTLE Control */
+ #define PCIE_PHY_DWC_RX_PRECORR_CTRL		(0x1800c)	/* Lane RX Pre-Correlation Control */
+ #define PCIE_PHY_DWC_RX_PHS_ACCM_CTRL		(0x1800d)	/* Lane RX Phase Accumulator Control */
+ #define PCIE_PHY_DWC_RX_PHS_ACCM_FR_VAL		(0x1800e)	/* Lane RX Phase Accumulator Frequency Portion Control */
+ #define PCIE_PHY_DWC_RX_PRECORR_VAL		(0x1800f)	/* Lane RX Pre-Correlation Count */
+ #define PCIE_PHY_DWC_RX_DELTA_PM_0		(0x18010)	/* Lane RX VMA Performance Metric Register #0 */
+ #define PCIE_PHY_DWC_RX_DELTA_PM_1		(0x18011)	/* Lane RX VMA Performance Metric Register #1 */
+ #define PCIE_PHY_DWC_TX_CAPT_CTRL		(0x18012)	/* Lane TX Latch Control */
+ #define PCIE_PHY_DWC_TX_CFG_0			(0x18015)	/* Lane TX Configuration Register #0 */
+ #define PCIE_PHY_DWC_TX_CFG_1			(0x18016)	/* Lane TX Configuration Register #1 */
+ #define PCIE_PHY_DWC_TX_CFG_2			(0x18017)	/* Lane TX Configuration Register #2 */
+ #define PCIE_PHY_DWC_TX_CFG_3			(0x18018)	/* Lane TX Configuration Register #3 */
+ #define PCIE_PHY_DWC_TX_PREEMPH_0		(0x18019)	/* Lane TX Pre-Emphasis */
+ #define PCIE_PHY_DWC_PMA_LOOPBACK_CTRL		(0x1801a)	/* Lane PMA Loopback Control */
+ #define PCIE_PHY_DWC_LANE_PWR_CTRL		(0x1801b)	/* Lane Power Control */
+ #define PCIE_PHY_DWC_TERM_CTRL			(0x1801c)	/* Lane Termination Control */
+ #define PCIE_PHY_DWC_RX_MISC_STATUS		(0x18025)	/* RX Miscellaneous Status */
+ #define PCIE_PHY_DWC_SDS_PIN_MON_0		(0x18026)	/* SerDes Pin Monitor 0 */
+ #define PCIE_PHY_DWC_SDS_PIN_MON_1		(0x18027)	/* SerDes Pin Monitor 1 */
+ #define PCIE_PHY_DWC_SDS_PIN_MON_2		(0x18028)	/* SerDes Pin Monitor 2 */
+ #define PCIE_PHY_DWC_RX_PWR_MON_0		(0x18029)	/* RX Power State Machine Monitor 0 */
+ #define PCIE_PHY_DWC_RX_PWR_MON_1		(0x1802a)	/* RX Power State Machine Monitor 1 */
+ #define PCIE_PHY_DWC_RX_PWR_MON_2		(0x1802b)	/* RX Power State Machine Monitor 2 */
+ #define PCIE_PHY_DWC_TX_PWR_MON_0		(0x1802c)	/* TX Power State Machine Monitor 0 */
+ #define PCIE_PHY_DWC_TX_PWR_MON_1		(0x1802d)	/* TX Power State Machine Monitor 1 */
+ #define PCIE_PHY_DWC_TX_PWR_MON_2		(0x1802e)	/* TX Power State Machine Monitor 2 */
+ #define PCIE_PHY_DWC_RX_VMA_CTRL		(0x18040)	/* Lane RX VMA Control */
+ #define PCIE_PHY_DWC_RX_CDR_MISC_CTRL_0		(0x18041)	/* Lane RX CDR Miscellaneous Control Register #0 */
+ #define PCIE_PHY_DWC_RX_CDR_MISC_CTRL_1		(0x18042)	/* Lane RX CDR Miscellaneous Control Register #1 */
+ #define PCIE_PHY_DWC_RX_PWR_CTRL		(0x18043)	/* Lane RX Power Control */
+ #define PCIE_PHY_DWC_RX_OS_MVALBBD_0		(0x18045)	/* Lane RX Offset Calibration Manual Control Register #0 */
+ #define PCIE_PHY_DWC_RX_OS_MVALBBD_1		(0x18046)	/* Lane RX Offset Calibration Manual Control Register #1 */
+ #define PCIE_PHY_DWC_RX_OS_MVALBBD_2		(0x18047)	/* Lane RX Offset Calibration Manual Control Register #2 */
+ #define PCIE_PHY_DWC_RX_AEQ_VALBBD_0		(0x18048)	/* Lane RX Adaptive Equalizer Control Register #0 */
+ #define PCIE_PHY_DWC_RX_AEQ_VALBBD_1		(0x18049)	/* Lane RX Adaptive Equalizer Control Register #1 */
+ #define PCIE_PHY_DWC_RX_AEQ_VALBBD_2		(0x1804a)	/* Lane RX Adaptive Equalizer Control Register #2 */
+ #define PCIE_PHY_DWC_RX_MISC_OVRRD		(0x1804b)	/* Lane RX Miscellaneous Override Controls */
+ #define PCIE_PHY_DWC_RX_OVRRD_PHASE_ACCUM_ADJ	(0x1804c)	/* Lane RX Phase Accumulator Adjust Override */
+ #define PCIE_PHY_DWC_RX_AEQ_OUT_0		(0x18050)	/* Lane RX Adaptive Equalizer Status Register #0 */
+ #define PCIE_PHY_DWC_RX_AEQ_OUT_1		(0x18051)	/* Lane RX Adaptive Equalizer Status Register #1 */
+ #define PCIE_PHY_DWC_RX_AEQ_OUT_2		(0x18052)	/* Lane RX Adaptive Equalizer Status Register #2 */
+ #define PCIE_PHY_DWC_RX_OS_OUT_0		(0x18053)	/* Lane RX Offset Calibration Status Register #0 */
+ #define PCIE_PHY_DWC_RX_OS_OUT_1		(0x18054)	/* Lane RX Offset Calibration Status Register #1 */
+ #define PCIE_PHY_DWC_RX_OS_OUT_2		(0x18055)	/* Lane RX Offset Calibration Status Register #2 */
+ #define PCIE_PHY_DWC_RX_OS_OUT_3		(0x18056)	/* Lane RX Offset Calibration Status Register #3 */
+ #define PCIE_PHY_DWC_RX_VMA_STATUS_0		(0x18057)	/* Lane RX CDR Status Register #0 */
+ #define PCIE_PHY_DWC_RX_VMA_STATUS_1		(0x18058)	/* Lane RX CDR Status Register #1 */
+ #define PCIE_PHY_DWC_RX_CDR_STATUS_0		(0x18059)	/* Lane RX CDR Status Register #0 */
+ #define PCIE_PHY_DWC_RX_CDR_STATUS_1		(0x1805a)	/* Lane RX CDR Status Register #1 */
+ #define PCIE_PHY_DWC_RX_CDR_STATUS_2		(0x1805b)	/* Lane RX CDR Status Register #2 */
+ #define PCIE_PHY_DWC_PCS_MISC_CFG_0		(0x38000)	/* Lane Miscellaneous Configuration Register #0 */
+ #define PCIE_PHY_DWC_PCS_MISC_CFG_1		(0x38001)	/* Lane Raw PCS Miscellaneous Configuration Register #1 */
+ #define PCIE_PHY_DWC_PCS_LBERT_PAT_CFG		(0x38003)	/* LBERT Pattern Configuration */
+ #define PCIE_PHY_DWC_PCS_LBERT_CFG		(0x38004)	/* LBERT Configuration */
+ #define PCIE_PHY_DWC_PCS_LBERT_ECNT		(0x38005)	/* LBERT Error Counter */
+ #define PCIE_PHY_DWC_PCS_RESET_0		(0x38006)	/* Lane Raw PCS Reset Register #0 */
+ #define PCIE_PHY_DWC_PCS_RESET_1		(0x38007)	/* Lane Raw PCS Reset Register #1 */
+ #define PCIE_PHY_DWC_PCS_RESET_2		(0x38008)	/* Lane Raw PCS Reset Register #2 */
+ #define PCIE_PHY_DWC_PCS_RESET_3		(0x38009)	/* Lane Raw PCS Reset Register #3 */
+ #define PCIE_PHY_DWC_PCS_CTLIFC_CTRL_0		(0x3800c)	/* Lane Raw PCS Control Interface Configuration Register #0 */
+ #define PCIE_PHY_DWC_PCS_CTLIFC_CTRL_1		(0x3800d)	/* Lane Raw PCS Control Interface Configuration Register #1 */
+ #define PCIE_PHY_DWC_PCS_CTLIFC_CTRL_2		(0x3800e)	/* Lane Raw PCS Control Interface Configuration Register #2 */
+ #define PCIE_PHY_DWC_PCS_MACIFC_MON_0		(0x38021)	/* MAC to Raw PCS Interface Monitor Register #0 */
+ #define PCIE_PHY_DWC_PCS_MACIFC_MON_2		(0x38023)	/* MAC to Raw PCS Interface Monitor Register #1 */
+ 
+ /* DWC_GLBL_PLL_MONITOR */
+ #define SDS_PCS_CLOCK_READY			(1 << 6)	/* Clock status signal. */
+ 
+ /* DWC_GLBL_PLL_CFG_0 */
+ #define PCS_SDS_PLL_FTHRESH_SHIFT		6
+ #define PCS_SDS_PLL_FTHRESH_MASK		0xC0		/* PLL frequency comparison threshold */
+ 
+ /* DWC_GLBL_TERM_CFG */
+ #define FAST_TERM_CAL				(1 << 8)	/* Enable fast termination calibration. */
+ 
+ /* DWC_RX_LOOP_CTRL */
+ #define FAST_OFST_CNCL				(1 << 10)	/* Enable fast offset cancellation. */
+ #define FAST_DLL_LOCK				(1 << 11)	/* Enable fast DLL lock. */
+ 
+ /* Enable PCIe 3.0 PHY */
+ #define EN_PCIE3                                (1 << 10)
+ 
+ /* DWC_TX_CFG_0 */
+ #define FAST_TRISTATE_MODE			(1 << 1)	/* Enable fast Tristate power up. */
+ #define FAST_RDET_MODE				(1 << 2)	/* Enable fast RX Detection */
+ #define FAST_CM_MODE				(1 << 8)	/* Enable fast common-mode charge up. */
+ 
+ /* Macros to read/write PCIe registers. */
+ #define READ_PCIE_REG(r)	readl((const volatile void *)(PCIE_CFG_BASE + (r)))
+ #define WRITE_PCIE_REG(r, v)	writel((v), (volatile void *)(PCIE_CFG_BASE + (r)))
+ 
+ 
+ /* PMU registers */
+ 
+ #define BK_PMU_LOCK_BIT			(1 << 31)
+ #define BK_PMU_EN_BIT			(1 << 0)
+ #define BK_PMU_RST_BIT			(1 << 1)
+ #define BK_PMU_INIT_BIT			(1 << 2)
+ 
+ /* BK_PMU_AXI_PCIE_M_CTL */
+ #define PMU_AXI_PCIE_M_CTL_EN		(1 << 0)	/* Enable AXI PCIe Master clock. */
+ #define PMU_AXI_PCIE_M_CTL_RST		(1 << 1)	/* Software AXI PCIe Master clock domain reset. */
+ 
+ /* BK_PMU_AXI_PCIE_S_CTL */
+ #define PMU_AXI_PCIE_S_CTL_EN		(1 << 0)	/* Enable AXI PCIe Slave clock. */
+ #define PMU_AXI_PCIE_S_CTL_RST		(1 << 1)	/* Software AXI PCIe Slave clock domain reset. */
+ 
+ /* BK_PMU_PCIE_RSTC */
+ #define PMU_PCIE_RSTC_PHY_RESET		(1 << 0)	/* PCIe PHY phy_rts_n reset control bit. */
+ #define PMU_PCIE_RSTC_PIPE_RESET	(1 << 4)	/* PCIe PHY PCS pipe_reset_n reset control bit. */
+ #define PMU_PCIE_RSTC_CORE_RST		(1 << 8)	/* PCIe core core_rst_n reset control bit. */
+ #define PMU_PCIE_RSTC_PWR_RST		(1 << 9)	/* PCIe core pwr_rst_n reset control bit. */
+ #define PMU_PCIE_RSTC_STICKY_RST	(1 << 10)	/* PCIe core sticky_rst_n reset control bit. */
+ #define PMU_PCIE_RSTC_NONSTICKY_RST	(1 << 11)	/* PCIe core nonsticky_rst_n reset control bit. */
+ #define PMU_PCIE_RSTC_HOT_RESET		(1 << 12)	/* Hot Reset control bit. */
+ #define PMU_PCIE_RSTC_REQ_RESET		(1 << 13)	/* PCIe core link_req_rst_not ready for reset signal status bit */
+ #define PMU_PCIE_RSTC_BRIDGE_FLUSH	(1 << 19)	/* PCIe AXI bridge bridge_flush_not signal status bit. */
+ 
+ /* BK_PMU_PCIE_GENC */
+ #define PMU_PCIE_GENC_LTSSM_ENABLE	(1 << 1)	/* LTSSM enable bit. */
+ #define PMU_PCIE_GENC_DBI2_MODE		(1 << 2)	/* PCIe core registers access mode bit: DBI(=0) / DBI2(=1) */
+ #define PMU_PCIE_GENC_MGMT_ENABLE	(1 << 3)	/* PCIe PHY management interface enable bit. */
+ 
+ /* BK_PMU_PCIE_PMSC */
+ #define PMU_PCIE_PMSC_LTSSM_STATE_SHIFT	(0)		/* LTSSM state (smlh_ltssm_state[5:0] signal) */
+ #define PMU_PCIE_PMSC_LTSSM_STATE_MASK	(0x3F)
+ #define LTSSM_L0			0x11
+ #define PMU_PCIE_PMSC_SMLH_LINKUP	(1 << 6)	/* Physical level (PL) state bit (smlh_link_up signal) */
+ #define PMU_PCIE_PMSC_RDLH_LINKUP	(1 << 7)	/* Channel level (DLL) state bit (rdlh_link_up signal) */
+ 
+ /* Register map */
+ 
+ #define BK_COREPLL_CTL_OFFSET		0x000
+ #define BK_PCIEPLL_CTL_OFFSET		0x018
+ #define BK_PCIEPLL_CTL1_OFFSET		0x01C
+ #define BK_AXI_PCIE_M_CTL_OFFSET	0x048
+ #define BK_AXI_PCIE_S_CTL_OFFSET	0x04C
+ #define BK_PCIE_REF_CTL_OFFSET		0x05C
+ #define BK_PCIE_CLKC_OFFSET		0x140
+ #define BK_PCIE_RSTC_OFFSET		0x144
+ #define BK_PCIE_PMSC_OFFSET		0x148
+ #define BK_PCIE_GENC_OFFSET		0x14C
+ 
+ #define BK_PMU_COREPLL_CTL	(PMU_BASE + BK_COREPLL_CTL_OFFSET)
+ #define BK_PMU_PCIEPLL_CTL	(PMU_BASE + BK_PCIEPLL_CTL_OFFSET)
+ #define BK_PMU_PCIEPLL_CTL1	(PMU_BASE + BK_PCIEPLL_CTL1_OFFSET)
+ #define BK_PMU_AXI_PCIE_M_CTL	(PMU_BASE + BK_AXI_PCIE_M_CTL_OFFSET)
+ #define BK_PMU_AXI_PCIE_S_CTL	(PMU_BASE + BK_AXI_PCIE_S_CTL_OFFSET)
+ #define BK_PMU_PCIE_REF_CTL	(PMU_BASE + BK_PCIE_REF_CTL_OFFSET)
+ #define BK_PMU_PCIE_CLKC	(PMU_BASE + BK_PCIE_CLKC_OFFSET)
+ #define BK_PMU_PCIE_RSTC	(PMU_BASE + BK_PCIE_RSTC_OFFSET)
+ #define BK_PMU_PCIE_PMSC	(PMU_BASE + BK_PCIE_PMSC_OFFSET)
+ #define BK_PMU_PCIE_GENC	(PMU_BASE + BK_PCIE_GENC_OFFSET)
+ 
+ /* Macros to read/write PMU registers. */
+ #define READ_PMU_REG(r)		readl((const volatile void *)(r))
+ #define WRITE_PMU_REG(r, v)	writel(v, (volatile void *)(r))
+ 
+ void dw_set_iatu_region(int dir, int index, int base_addr, int limit_addr, int target_addr, int tlp_type);
+ irqreturn_t dw_msi_interrupt(int id, void *dev_id);
+ int dw_msi_init(void);
+ 
+ #endif /* __PCI_BAIKAL_H__ */
diff -rcNP linux-4.4.24/arch/mips/pci/pci.c linux-4.4.24-baikal/arch/mips/pci/pci.c
*** linux-4.4.24/arch/mips/pci/pci.c	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/arch/mips/pci/pci.c	2016-11-11 14:49:51.000000000 +0300
***************
*** 86,92 ****
  	if (!hose->iommu)
  		PCI_DMA_BUS_IS_PHYS = 1;
  
! 	if (hose->get_busno && pci_has_flag(PCI_PROBE_ONLY))
  		next_busno = (*hose->get_busno)();
  
  	pci_add_resource_offset(&resources,
--- 86,92 ----
  	if (!hose->iommu)
  		PCI_DMA_BUS_IS_PHYS = 1;
  
!     if (hose->get_busno)
  		next_busno = (*hose->get_busno)();
  
  	pci_add_resource_offset(&resources,
diff -rcNP linux-4.4.24/drivers/clk/clk-baikal.c linux-4.4.24-baikal/drivers/clk/clk-baikal.c
*** linux-4.4.24/drivers/clk/clk-baikal.c	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/drivers/clk/clk-baikal.c	2016-11-11 14:49:51.000000000 +0300
***************
*** 0 ****
--- 1,594 ----
+ /*
+  * clk-baikal.c - Baikal Electronics clock driver.
+  *
+  * Copyright (C) 2015,2016 Baikal Electronics JSC
+  * 
+  * Author:
+  *   Dmitry Dunaev <dmitry.dunaev@baikalelectronics.ru>
+  *
+  * This program is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU General Public License
+  * as published by the Free Software Foundation; either version 2
+  * of the License, or (at your option) any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; if not, write to the Free Software
+  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+  */
+ #include <linux/module.h>
+ #include <linux/spinlock.h>
+ #include <linux/io.h>
+ #include <linux/of.h>
+ #include <linux/clkdev.h>
+ #include <linux/clk-provider.h>
+ #include <linux/of_address.h>
+ #include <linux/delay.h>
+ #include <asm/setup.h>
+ 
+ #define VERSION	"1.03"
+ 
+ #define BE_CLK_ENABLE_MASK 		(1 << 0)
+ #define BE_CLK_RESET_MASK 		(1 << 1)
+ #define BE_CLK_SET_MASK 		(1 << 2)
+ #define BE_CLK_BYPASS_MASK 		(1 << 30)
+ #define BE_CLK_LOCK_MASK 		(1 << 31)
+ 
+ #define BE_CLKR_SHFT			2
+ #define BE_DIV_SHFT				4
+ #define BE_CLKF_SHFT			8
+ #define BE_CLKOD_SHFT			21
+ 
+ #define BE_CLK_DIV_MAX_WIDTH	17
+ #define BE_CLK_DIV_MASK			(((1 << BE_CLK_DIV_MAX_WIDTH) - 1) \
+  									<< BE_DIV_SHFT)
+ 
+ #define BE_RD_CLKR(SRC)			(((SRC) & 0x000000FC) >> BE_CLKR_SHFT)
+ #define BE_RD_CLKF(SRC)			(((SRC) & 0x001FFF00) >> BE_CLKF_SHFT)
+ #define BE_RD_CLKOD(SRC)		(((SRC) & 0x01E00000) >> BE_CLKOD_SHFT)
+ 
+ #define BE_CLKR_VAL(NR)			((NR - 1) << BE_CLKR_SHFT)
+ #define BE_CLKF_VAL(NF)			((NF - 1) << BE_CLKF_SHFT)
+ #define BE_CLKOD_VAL(OD)		((OD - 1) << BE_CLKOD_SHFT)
+ 
+ #define BE_PLL_CLK_VAL(NR, NF, OD)	\
+ 	(BE_CLKR_VAL(NR) | BE_CLKF_VAL(NF) | BE_CLKOD_VAL(OD))
+ 
+ #define BE_PLL_DIV_MASK 		0x01FFFFFC
+ #define BE_PLL_LATENCY			100000000 /* ns */
+ #define BE_PLL_FREQ_STEP		25000000
+ 
+ static DEFINE_SPINLOCK(clk_lock);
+ 
+ struct be_clk_pll {
+ 	struct clk_hw   hw;
+ 	void __iomem    *reg;
+ 	spinlock_t      *lock;
+ 	const char      *name;
+ 	unsigned int 	latency; /* ns */
+ 	unsigned int    min, max, step;
+ };
+ #define to_be_clk_pll(_hw) container_of(_hw, struct be_clk_pll, hw)
+ 
+ /*
+  * Common functions
+  */
+ static inline unsigned int be_clk_read(void *csr)
+ {
+         return readl(csr);
+ }
+ 
+ static inline void be_clk_write(unsigned int data, void *csr)
+ {
+         return writel(data, csr);
+ }
+ 
+ static int be_clk_pll_reset(struct clk_hw *hw)
+ {
+ 	struct be_clk_pll *pllclk = to_be_clk_pll(hw);
+ 	unsigned int reg, count;
+ 
+ 	reg = be_clk_read(pllclk->reg);
+ 	reg |= BE_CLK_RESET_MASK;
+ 	be_clk_write(reg, pllclk->reg);
+ 	wmb();
+ 
+ 	count = 50;
+ 	do {
+ 		udelay(pllclk->latency / 1000);
+ 		reg = be_clk_read(pllclk->reg);
+ 	} while (!(reg & BE_CLK_LOCK_MASK) && --count);
+ 
+ 	if (!(reg & BE_CLK_LOCK_MASK))
+ 		return -ETIMEDOUT;
+ 
+ 	return 0;
+ }
+ 
+ static int be_clk_pll_is_enabled(struct clk_hw *hw)
+ {
+ 	struct be_clk_pll *pllclk = to_be_clk_pll(hw);
+ 	unsigned int reg;
+ 
+ 	reg = be_clk_read(pllclk->reg);
+ 
+ 	return !!(reg & BE_CLK_ENABLE_MASK);
+ }
+ 
+ static int be_clk_pll_enable(struct clk_hw *hw)
+ {
+ 	struct be_clk_pll *pllclk = to_be_clk_pll(hw);
+ 	unsigned int reg;
+ 
+ 	reg = be_clk_read(pllclk->reg);
+ 	reg |= BE_CLK_ENABLE_MASK;
+ 	be_clk_write(reg, pllclk->reg);
+ 	wmb();
+ 
+ 	return 0;
+ }
+ 
+ static unsigned long be_clk_pll_recalc_rate(struct clk_hw *hw,
+                                 unsigned long parent_rate)
+ {
+ 	struct be_clk_pll *pllclk = to_be_clk_pll(hw);
+ 	unsigned long fref, fout;
+ 	unsigned int reg, nr, nf, od;
+ 
+ 	/* Read pll ctrl reg */
+ 	reg = be_clk_read(pllclk->reg);
+ 	/* Fetch pll parameters */
+ 	nr = BE_RD_CLKR(reg) + 1;
+ 	nf = BE_RD_CLKF(reg) + 1;
+ 	od = BE_RD_CLKOD(reg) + 1;
+ 	/* ref dividers */
+ 	fref = parent_rate / nr / od;
+ 	/* pll multiplier */
+ 	fout = fref * nf;
+ 
+ 	return fout;
+ }
+ 
+ long be_clk_pll_round_rate(struct clk_hw *hw, unsigned long rate,
+ 					unsigned long *parent_rate)
+ {
+ 	struct be_clk_pll *pllclk = to_be_clk_pll(hw);
+ 
+ 	if (!pllclk->max) {
+ 		rate = be_clk_pll_recalc_rate(hw, *parent_rate);
+ 		pllclk->max = rate;
+ 		pllclk->min = rate;
+ 	}
+ 
+ 	if (rate > pllclk->max)
+ 		return pllclk->max;
+ 
+ 	if (rate < pllclk->min)
+ 		return pllclk->min;
+ 
+ 	return pllclk->min + ((rate - pllclk->min) / pllclk->step) *
+ 		pllclk->step;
+ }
+ 
+ int be_clk_pll_set_rate(struct clk_hw *hw, unsigned long rate,
+ 					unsigned long parent_rate)
+ {
+ 	struct be_clk_pll *pllclk = to_be_clk_pll(hw);
+ 	unsigned int reg, nf, od, mul;
+ 
+ 	mul = (rate / parent_rate) & 0x7f;
+ 	od = ((68 / mul) << 1) & 0x3f; 
+ 	nf = (mul * od) & 0x1fff;
+ 
+ 	reg = be_clk_read(pllclk->reg);
+ 	reg &= ~BE_PLL_DIV_MASK;
+ 	reg |= 	BE_PLL_CLK_VAL(1, nf, od);
+ 
+ 	be_clk_write(reg, pllclk->reg);
+ 	wmb();
+ 
+ 	return be_clk_pll_reset(hw);
+ }
+ 
+ const struct clk_ops be_clk_pll_ops = {
+ 		.enable      = be_clk_pll_enable,
+ 		.is_enabled  = be_clk_pll_is_enabled,
+ 		.recalc_rate = be_clk_pll_recalc_rate,
+ 		.round_rate  = be_clk_pll_round_rate,
+ 		.set_rate    = be_clk_pll_set_rate,
+ };
+ 
+ static __init int be_clk_pll_setup(struct device_node *np,
+ 	struct be_clk_pll *pmuclk)
+ {
+ 
+ 	if (of_property_read_u32(np, "clock-latency",
+ 				&pmuclk->latency))
+ 		pmuclk->latency = BE_PLL_LATENCY;
+ 
+ 	if (of_property_read_u32_index(np, "clock-frequency-range", 0,
+ 		&pmuclk->min))
+ 		pmuclk->min = 0;
+ 	if (of_property_read_u32_index(np, "clock-frequency-range", 1,
+ 		&pmuclk->max))
+ 		pmuclk->max = 0;
+ 	if (of_property_read_u32_index(np, "clock-frequency-range", 2,
+ 		&pmuclk->step) || !pmuclk->step)
+ 		pmuclk->step = BE_PLL_FREQ_STEP;
+ 
+ 	if (pmuclk->min > pmuclk->max)
+ 		return -EINVAL;
+ 
+ 	return 0;
+ }
+ 
+ static __init void be_pllclk_init(struct device_node *np)
+ {
+ 	struct clk *clk;
+ 	struct clk_init_data init;
+ 	struct be_clk_pll *pmuclk;
+ 	const char *clk_name = np->name;
+ 	const char *parent_name;
+ 	void *res;
+ 
+ 	/* allocate the APM clock structure */
+ 	pmuclk = kzalloc(sizeof(*pmuclk), GFP_KERNEL);
+ 	if (!pmuclk) {
+ 		pr_err("PMU: Could not allocate clock %s\n", np->full_name);
+ 		return;
+ 	}
+ 
+ 	res = of_iomap(np, 0);
+ 	if (res == NULL) {
+ 		pr_err("PMU: Unable to map CSR register for %s\n", np->full_name);
+ 		goto __err;
+ 	}
+ 
+ 	if (be_clk_pll_setup(np, pmuclk)) {
+ 		pr_err("PMU: Unable setup clock %s\n", np->full_name);
+ 		goto __err;
+ 	}
+ 
+ 	/* Get clock name */
+ 	of_property_read_string(np, "clock-output-names", &clk_name);
+ 	if (!clk_name)
+ 		clk_name = np->full_name;
+ 
+ 	/* Set clock init parameters */
+ 	init.name = clk_name;
+ 	init.ops = &be_clk_pll_ops;
+ 	init.flags = CLK_SET_RATE_NO_REPARENT | CLK_IGNORE_UNUSED;
+ 	parent_name = of_clk_get_parent_name(np, 0);
+ 	init.parent_names = &parent_name;
+ 	init.num_parents = 1;
+ 
+ 	/* Baikal pll parameters */
+ 	pmuclk->reg = res;
+ 	pmuclk->lock = &clk_lock;
+ 	pmuclk->hw.init = &init;
+ 	pmuclk->name = clk_name;
+ 
+ 	clk = clk_register(NULL, &pmuclk->hw);
+ 	if (IS_ERR(clk)) {
+ 		pr_err("PMU: could not register clk %s\n", clk_name);
+ 		goto __err;
+ 	}
+ 
+ 	of_clk_add_provider(np, of_clk_src_simple_get, clk);
+ 	clk_register_clkdev(clk, clk_name, NULL);
+ 
+ 	pr_debug("PMU: Add %s PLL clock \n", clk_name);
+ 
+ 	return;
+ 
+ __err:
+ 	kfree(pmuclk);
+ }
+ CLK_OF_DECLARE(be_pll_clock, "be,pmu-pll-clock", be_pllclk_init);
+ 
+ struct be_dev_params {
+ 	unsigned int 	width;		/* Divider width */
+ 	unsigned int    nobypass; 	/* Disable clock div=1 */
+ };
+ 
+ struct be_clk {
+ 	struct clk_hw   hw;
+ 	const char      *name;
+ 	spinlock_t      *lock;
+ 	void __iomem    *reg;
+ 	struct be_dev_params params;
+ };
+ 
+ #define to_be_clk(_hw) container_of(_hw, struct be_clk, hw)
+ 
+ static int be_clk_enable(struct clk_hw *hw)
+ {
+ 	struct be_clk *pclk = to_be_clk(hw);
+ 	unsigned long flags = 0;
+ 	unsigned int data;
+ 	/* Lock clock */
+ 	if (pclk->lock)
+ 		spin_lock_irqsave(pclk->lock, flags);
+ 	/* If clock valid */
+ 	if (pclk->reg != NULL) {
+ 		/* Debug info */
+ 		pr_debug("%s clock enabled\n", pclk->name);
+ 		/* Get CSR register */
+ 		data = be_clk_read(pclk->reg);
+ 		/* Enable the clock */
+ 		data |= BE_CLK_ENABLE_MASK;
+ 		/* Set CSR register */
+ 		be_clk_write(data, pclk->reg);
+ 		/* Debug info */
+ 		pr_debug("%s clock PADDR base 0x%08lX clk value 0x%08X\n",
+ 			pclk->name, __pa(pclk->reg), data);
+ 	}
+ 	/* Unlock clock */
+ 	if (pclk->lock)
+ 		spin_unlock_irqrestore(pclk->lock, flags);
+ 	/* Return success */
+ 	return 0;
+ }
+ 
+ static void be_clk_disable(struct clk_hw *hw)
+ {
+ 	struct be_clk *pclk = to_be_clk(hw);
+ 	unsigned long flags = 0;
+ 	unsigned int data;
+ 	/* Lock clock */
+ 	if (pclk->lock)
+ 		spin_lock_irqsave(pclk->lock, flags);
+ 	/* If clock valid */
+ 	if (pclk->reg != NULL) {
+ 		/* Debug info */
+ 		pr_debug("%s clock disabled\n", pclk->name);
+ 		/* Get CSR register */
+ 		data = be_clk_read(pclk->reg);
+ 		/* Disable the clock */
+ 		data &= ~BE_CLK_ENABLE_MASK;
+ 		/* Set CSR register */
+ 		be_clk_write(data, pclk->reg);
+ 		/* Debug info */
+ 		pr_debug("%s clock PADDR base 0x%08lX clk value 0x%08X\n",
+ 			pclk->name, __pa(pclk->reg), data);
+ 	}
+ 	/* Unlock clock */
+ 	if (pclk->lock)
+ 		spin_unlock_irqrestore(pclk->lock, flags);
+ }
+ 
+ static int be_clk_is_enabled(struct clk_hw *hw)
+ {
+ 	struct be_clk *pclk = to_be_clk(hw);
+ 	unsigned int data = 0;
+ 
+ 	/* If clock valid */
+ 	if (pclk->reg != NULL) {
+ 		/* Debug info */
+ 		pr_debug("%s clock checking\n", pclk->name);
+ 		/* Get CSR register */
+ 		data = be_clk_read(pclk->reg);
+ 		/* Debug info */
+ 		pr_debug("%s clock PADDR base 0x%08lX clk value 0x%08X\n",
+ 			pclk->name, __pa(pclk->reg), data);
+ 		/* Debug info */
+ 		pr_debug("%s clock is %sabled\n", pclk->name,
+ 			data & BE_CLK_ENABLE_MASK ? "en" : "dis");
+ 	}
+ 	/* Enabled and not controlled */
+ 	else
+ 		return 1;
+ 	return data & BE_CLK_ENABLE_MASK ? 1 : 0;
+ }
+ 
+ static unsigned long be_clk_recalc_rate(struct clk_hw *hw,
+                                 unsigned long parent_rate)
+ {
+ 	struct be_clk *pclk = to_be_clk(hw);
+ 	unsigned int data;
+ 
+ 	/* If clock valid */
+ 	if ((pclk->reg != NULL) &&
+ 	    (pclk->params.width != 0)) {
+ 		/* Get CSR register */
+ 		data = be_clk_read(pclk->reg);
+ 		/* Apply global mask and shift data */
+ 		data = (data & BE_CLK_DIV_MASK) >> BE_DIV_SHFT;
+ 		/* Apply divider width mask */
+ 		data &= (1 << pclk->params.width) - 1;
+ 		/* Debug info */
+ 		pr_debug("%s clock recalc rate %ld parent %ld\n",
+ 				pclk->name, parent_rate / data, parent_rate);
+ 		return parent_rate / data;
+ 	} else {
+ 		pr_debug("%s clock recalc rate %ld parent %ld\n",
+ 			pclk->name, parent_rate, parent_rate);
+ 		return parent_rate;
+ 	}
+ }
+ 
+ static int be_clk_set_rate(struct clk_hw *hw, unsigned long rate,
+ 								unsigned long parent_rate)
+ {
+ 	struct be_clk *pclk = to_be_clk(hw);
+ 	unsigned long flags = 0;
+ 	unsigned int data;
+ 	unsigned int divider;
+ 	/* Lock clock */
+ 	if (pclk->lock)
+ 		spin_lock_irqsave(pclk->lock, flags);
+ 	/* If clock valid */
+ 	if ((pclk->reg != NULL) &&
+ 	    (pclk->params.width != 0)) {
+ 		/* Let's compute the divider */
+ 		if (rate > parent_rate)
+ 			rate = parent_rate;
+ 		/* Calc divider rounded down */
+ 		divider = parent_rate / rate;
+ 		/* Apply divider width mask */
+ 		divider &= (1 << pclk->params.width) - 1;
+ 		/* Why so may be ? */
+ 		if (!divider)
+ 			divider = 1;
+ 		/* Check nobypass flag */
+ 		if ((divider == 1) && pclk->params.nobypass)
+ 			divider = 2;
+ 		/* Get current state */
+ 		data = be_clk_read(pclk->reg);
+ 		/* Clear divide field */
+ 		data &= ~BE_CLK_DIV_MASK;
+ 		/* Set new divider */
+ 		data |= divider << BE_DIV_SHFT;
+ 		/* Set new value */
+ 		be_clk_write(data, pclk->reg);
+ 		/* Set restart pulse */
+ 		data |= BE_CLK_SET_MASK;
+ 		/* Restart divider */
+ 		be_clk_write(data, pclk->reg);
+ 		/* Debug info */
+ 		pr_debug("%s clock set rate %ld\n", pclk->name,
+ 				parent_rate / divider);
+ 	} else {
+ 		/* bypass mode */
+ 		divider = 1;
+ 	}
+ 	/* Unlock clock */
+ 	if (pclk->lock)
+ 		spin_unlock_irqrestore(pclk->lock, flags);
+ 	/* Return new rate */
+ 	return parent_rate / divider;
+ }
+ 
+ static long be_clk_round_rate(struct clk_hw *hw, unsigned long rate,
+                                 unsigned long *prate)
+ {
+ 	struct be_clk *pclk = to_be_clk(hw);
+ 	unsigned long parent_rate = *prate;
+ 	unsigned int divider;
+ 	/* If clock valid */
+ 	if (pclk->reg) {
+ 		/* Let's compute the divider */
+ 		if (rate > parent_rate)
+ 			rate = parent_rate;
+ 		/* Calc divider rounded down */
+ 		divider = parent_rate / rate;
+ 	} else {
+ 		divider = 1;
+ 	}
+ 	/* Return actual freq */
+ 	return parent_rate / divider;
+ }
+ 
+ const struct clk_ops be_clk_ops = {
+         .enable = be_clk_enable,
+         .disable = be_clk_disable,
+         .is_enabled = be_clk_is_enabled,
+         .recalc_rate = be_clk_recalc_rate,
+         .set_rate = be_clk_set_rate,
+         .round_rate = be_clk_round_rate,
+ };
+ 
+ static struct clk *be_register_clk(struct device *dev,
+ 				const char *name, const char *parent_name,
+ 				struct be_dev_params *params, void __iomem *reg,
+ 				spinlock_t *lock)
+ {
+ 	struct be_clk *pmuclk;
+ 	struct clk *clk;
+ 	struct clk_init_data init;
+ 	int rc;
+ 
+ 	/* Allocate the APM clock structure */
+ 	pmuclk = kzalloc(sizeof(*pmuclk), GFP_KERNEL);
+ 	if (!pmuclk) {
+ 		/* Error */
+ 		pr_err("%s: could not allocate PMU clk\n", __func__);
+ 		return ERR_PTR(-ENOMEM);
+ 	}
+ 	/* Setup clock init structure */
+ 	init.name = name;
+ 	init.ops = &be_clk_ops;
+ 	init.flags = 0;
+ 	init.parent_names = parent_name ? &parent_name : NULL;
+ 	init.num_parents = parent_name ? 1 : 0;
+ 	/* Setup IP clock structure */
+ 	pmuclk->reg = reg;
+ 	pmuclk->name = name;
+ 	pmuclk->lock = lock;
+ 	pmuclk->hw.init = &init;
+ 	pmuclk->params = *params;
+ 
+ 	/* Register the clock */
+ 	clk = clk_register(dev, &pmuclk->hw);
+ 	if (IS_ERR(clk)) {
+ 		/* Error */
+ 		pr_err("%s: could not register clk %s\n", __func__, name);
+ 		/* Free memory */
+ 		kfree(pmuclk);
+ 		return clk;
+ 	}
+ 
+ 	/* Register the clock for lookup */
+ 	rc = clk_register_clkdev(clk, name, NULL);
+ 	if (rc != 0) {
+ 		/* Error */
+ 		pr_err("%s: could not register lookup clk %s\n",
+ 			__func__, name);
+ 	}
+ 	return clk;
+ }
+ 
+ static void __init be_devclk_init(struct device_node *np)
+ {
+ 	const char *clk_name = np->full_name;
+ 	struct clk *clk;
+ 	struct be_dev_params params;
+ 	void *reg;
+ 	int rc;
+ 
+ 	/* Check if the entry is disabled */
+ 	if (!of_device_is_available(np))
+ 		return;
+ 
+ 	/* Remap ctrl reg mem */
+ 	reg = of_iomap(np, 0);
+ 	if (reg == NULL) {
+ 		/* Error */
+ 		pr_err("Unable to map CSR register for %s\n", np->full_name);
+ 		return;
+ 	}
+ 	/* Check nobypass property */
+ 	params.nobypass = of_property_read_bool(np, "nobypass");
+ 	/* Get divider width */
+ 	if (of_property_read_u32(np, "divider-width", &params.width))
+ 				params.width = BE_CLK_DIV_MAX_WIDTH;
+ 	/* Get clock name */
+ 	of_property_read_string(np, "clock-output-names", &clk_name);
+ 	/* Register clock */
+ 	clk = be_register_clk(NULL, clk_name, of_clk_get_parent_name(np, 0),
+ 						&params, reg, &clk_lock);
+ 	/* Check error */
+ 	if (IS_ERR(clk))
+ 		goto err;
+ 	/* Debug error */
+ 	pr_debug("Add %s clock\n", clk_name);
+ 	/* Add clock provider */
+ 	rc = of_clk_add_provider(np, of_clk_src_simple_get, clk);
+ 	if (rc != 0)
+ 		pr_err("%s: could register provider clk %s\n", __func__,
+ 				np->full_name);
+ 	return;
+ err:
+ 	if (reg)
+ 		iounmap(reg);
+ }
+ CLK_OF_DECLARE(be_dev_clock, "be,pmu-device-clock", be_devclk_init);
+ 
+ MODULE_VERSION(VERSION);
+ MODULE_AUTHOR("Dmitry Dunaev");
+ MODULE_DESCRIPTION("Baikal Electronics clock driver");
+ MODULE_LICENSE("GPL");
diff -rcNP linux-4.4.24/drivers/clk/Kconfig linux-4.4.24-baikal/drivers/clk/Kconfig
*** linux-4.4.24/drivers/clk/Kconfig	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/clk/Kconfig	2016-11-11 14:49:51.000000000 +0300
***************
*** 188,193 ****
--- 188,200 ----
  	---help---
  	  This driver supports TI CDCE706 programmable 3-PLL clock synthesizer.
  
+ config COMMON_CLK_BAIKAL
+ 	bool "Clock driver for Baikal SoCs"
+ 	default y
+ 	depends on ARCH_BAIKAL && OF
+ 	---help---
+ 	  Support for the Baikal Electronicse SoC reference, PLL, and device clocks.
+ 
  source "drivers/clk/bcm/Kconfig"
  source "drivers/clk/hisilicon/Kconfig"
  source "drivers/clk/qcom/Kconfig"
diff -rcNP linux-4.4.24/drivers/clk/Makefile linux-4.4.24-baikal/drivers/clk/Makefile
*** linux-4.4.24/drivers/clk/Makefile	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/clk/Makefile	2016-11-11 14:49:51.000000000 +0300
***************
*** 20,25 ****
--- 20,26 ----
  obj-$(CONFIG_MACH_ASM9260)		+= clk-asm9260.o
  obj-$(CONFIG_COMMON_CLK_AXI_CLKGEN)	+= clk-axi-clkgen.o
  obj-$(CONFIG_ARCH_AXXIA)		+= clk-axm5516.o
+ obj-$(CONFIG_COMMON_CLK_BAIKAL)		+= clk-baikal.o
  obj-$(CONFIG_COMMON_CLK_CDCE706)	+= clk-cdce706.o
  obj-$(CONFIG_ARCH_CLPS711X)		+= clk-clps711x.o
  obj-$(CONFIG_ARCH_EFM32)		+= clk-efm32gg.o
diff -rcNP linux-4.4.24/drivers/clocksource/mips-gic-timer.c linux-4.4.24-baikal/drivers/clocksource/mips-gic-timer.c
*** linux-4.4.24/drivers/clocksource/mips-gic-timer.c	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/clocksource/mips-gic-timer.c	2016-11-11 14:49:51.000000000 +0300
***************
*** 192,197 ****
--- 192,198 ----
  		}
  
  		gic_frequency = clk_get_rate(clk);
+ 		pr_info("GIC: timer frequency %d MHZ\n", gic_frequency / 1000000);
  	} else if (of_property_read_u32(node, "clock-frequency",
  					&gic_frequency)) {
  		pr_err("GIC frequency not specified.\n");
diff -rcNP linux-4.4.24/drivers/gpu/drm/smi/ctrl.h linux-4.4.24-baikal/drivers/gpu/drm/smi/ctrl.h
*** linux-4.4.24/drivers/gpu/drm/smi/ctrl.h	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/drivers/gpu/drm/smi/ctrl.h	2016-11-11 14:49:51.000000000 +0300
***************
*** 0 ****
--- 1,321 ----
+ #ifndef _CTRL_H
+ #define _CTRL_H
+ 
+ #include <linux/bitops.h>
+ #include <drm/drm_os_linux.h>
+ 
+ #define VGA_CONFIGURATION                             0x000088
+ #define VGA_CONFIGURATION_USER_DEFINE_MASK            (0x3<<4)
+ #define VGA_CONFIGURATION_PLL                         BIT(2)
+ #define VGA_CONFIGURATION_MODE                        BIT(1)
+ 
+ #define MXCLK_PLL_CTRL                                0x000070
+ #define MXCLK_PLL_CTRL_BYPASS                         BIT(18)
+ #define MXCLK_PLL_CTRL_POWER                          BIT(17)
+ #define MXCLK_PLL_CTRL_INPUT                          BIT(16)
+ 
+ #define PANEL_PLL_CTRL                                0x00005C
+ #define PANEL_PLL_CTRL_BYPASS                         BIT(18)
+ #define PANEL_PLL_CTRL_POWER                          BIT(17)
+ #define PANEL_PLL_CTRL_INPUT                          BIT(16)
+ /*#ifdef VALIDATION_CHIP
+     #define PLL_CTRL_OD_SHIFT                         14
+     #define PLL_CTRL_OD_MASK                          (0x3<<14)
+ #else
+     #define PLL_CTRL_POD_SHIFT                        14
+     #define PLL_CTRL_POD_MASK                         (0x3<<14)
+     #define PLL_CTRL_OD_SHIFT                         12
+     #define PLL_CTRL_OD_MASK                          (0x3<<12)
+ #endif
+ #define PLL_CTRL_N_SHIFT                              8
+ #define PLL_CTRL_N_MASK                               (0xf<<8)
+ #define PLL_CTRL_M_SHIFT                              0
+ #define PLL_CTRL_M_MASK                               0xff*/
+ 
+ 
+ #define MODE0_GATE                                    0x000044
+ #define MODE0_GATE_MCLK_MASK                          (0x3<<14)
+ #define MODE0_GATE_MCLK_112MHZ                        (0x0<<14)
+ #define MODE0_GATE_MCLK_84MHZ                         (0x1<<14)
+ #define MODE0_GATE_MCLK_56MHZ                         (0x2<<14)
+ #define MODE0_GATE_MCLK_42MHZ                         (0x3<<14)
+ #define MODE0_GATE_M2XCLK_MASK                        (0x3<<12)
+ #define MODE0_GATE_M2XCLK_336MHZ                      (0x0<<12)
+ #define MODE0_GATE_M2XCLK_168MHZ                      (0x1<<12)
+ #define MODE0_GATE_M2XCLK_112MHZ                      (0x2<<12)
+ #define MODE0_GATE_M2XCLK_84MHZ                       (0x3<<12)
+ #define MODE0_GATE_VGA                                BIT(10)
+ #define MODE0_GATE_PWM                                BIT(9)
+ #define MODE0_GATE_I2C                                BIT(8)
+ #define MODE0_GATE_SSP                                BIT(7)
+ #define MODE0_GATE_GPIO                               BIT(6)
+ #define MODE0_GATE_ZVPORT                             BIT(5)
+ #define MODE0_GATE_CSC                                BIT(4)
+ #define MODE0_GATE_DE                                 BIT(3)
+ #define MODE0_GATE_DISPLAY                            BIT(2)
+ #define MODE0_GATE_LOCALMEM                           BIT(1)
+ #define MODE0_GATE_DMA                                BIT(0)
+ 
+ #define MISC_CTRL                                     0x000004
+ #define MISC_CTRL_DRAM_RERESH_COUNT                   BIT(27)
+ #define MISC_CTRL_DRAM_REFRESH_TIME_MASK              (0x3<<25)
+ #define MISC_CTRL_DRAM_REFRESH_TIME_8                 (0x0<<25)
+ #define MISC_CTRL_DRAM_REFRESH_TIME_16                (0x1<<25)
+ #define MISC_CTRL_DRAM_REFRESH_TIME_32                (0x2<<25)
+ #define MISC_CTRL_DRAM_REFRESH_TIME_64                (0x3<<25)
+ #define MISC_CTRL_INT_OUTPUT_INVERT                   BIT(24)
+ #define MISC_CTRL_PLL_CLK_COUNT                       BIT(23)
+ #define MISC_CTRL_DAC_POWER_OFF                       BIT(20)
+ #define MISC_CTRL_CLK_SELECT_TESTCLK                  BIT(16)
+ #define MISC_CTRL_DRAM_COLUMN_SIZE_MASK               (0x3<<14)
+ #define MISC_CTRL_DRAM_COLUMN_SIZE_256                (0x0<<14)
+ #define MISC_CTRL_DRAM_COLUMN_SIZE_512                (0x1<<14)
+ #define MISC_CTRL_DRAM_COLUMN_SIZE_1024               (0x2<<14)
+ #define MISC_CTRL_LOCALMEM_SIZE_MASK                  (0x3<<12)
+ #define MISC_CTRL_LOCALMEM_SIZE_8M                    (0x3<<12)
+ #define MISC_CTRL_LOCALMEM_SIZE_16M                   (0x0<<12)
+ #define MISC_CTRL_LOCALMEM_SIZE_32M                   (0x1<<12)
+ #define MISC_CTRL_LOCALMEM_SIZE_64M                   (0x2<<12)
+ #define MISC_CTRL_DRAM_TWTR                           BIT(11)
+ #define MISC_CTRL_DRAM_TWR                            BIT(10)
+ #define MISC_CTRL_DRAM_TRP                            BIT(9)
+ #define MISC_CTRL_DRAM_TRFC                           BIT(8)
+ #define MISC_CTRL_DRAM_TRAS                           BIT(7)
+ #define MISC_CTRL_LOCALMEM_RESET                      BIT(6)
+ #define MISC_CTRL_LOCALMEM_STATE_INACTIVE             BIT(5)
+ #define MISC_CTRL_CPU_CAS_LATENCY                     BIT(4)
+ #define MISC_CTRL_DLL_OFF                             BIT(3)
+ #define MISC_CTRL_DRAM_OUTPUT_HIGH                    BIT(2)
+ #define MISC_CTRL_LOCALMEM_BUS_SIZE                   BIT(1)
+ #define MISC_CTRL_EMBEDDED_LOCALMEM_OFF               BIT(0)
+ 
+ #define SYSTEM_CTRL                                   0x000000
+ #define SYSTEM_CTRL_DPMS_MASK                         (0x3<<30)
+ #define SYSTEM_CTRL_DPMS_VPHP                         (0x0<<30)
+ #define SYSTEM_CTRL_DPMS_VPHN                         (0x1<<30)
+ #define SYSTEM_CTRL_DPMS_VNHP                         (0x2<<30)
+ #define SYSTEM_CTRL_DPMS_VNHN                         (0x3<<30)
+ #define SYSTEM_CTRL_PCI_BURST                         BIT(29)
+ #define SYSTEM_CTRL_PCI_MASTER                        BIT(25)
+ #define SYSTEM_CTRL_LATENCY_TIMER_OFF                 BIT(24)
+ #define SYSTEM_CTRL_DE_FIFO_EMPTY                     BIT(23)
+ #define SYSTEM_CTRL_DE_STATUS_BUSY                    BIT(22)
+ #define SYSTEM_CTRL_DE_MEM_FIFO_EMPTY                 BIT(21)
+ #define SYSTEM_CTRL_CSC_STATUS_BUSY                   BIT(20)
+ #define SYSTEM_CTRL_CRT_VSYNC_ACTIVE                  BIT(19)
+ #define SYSTEM_CTRL_PANEL_VSYNC_ACTIVE                BIT(18)
+ #define SYSTEM_CTRL_CURRENT_BUFFER_FLIP_PENDING       BIT(17)
+ #define SYSTEM_CTRL_DMA_STATUS_BUSY                   BIT(16)
+ #define SYSTEM_CTRL_PCI_BURST_READ                    BIT(15)
+ #define SYSTEM_CTRL_DE_ABORT                          BIT(13)
+ #define SYSTEM_CTRL_PCI_SUBSYS_ID_LOCK                BIT(11)
+ #define SYSTEM_CTRL_PCI_RETRY_OFF                     BIT(7)
+ #define SYSTEM_CTRL_PCI_SLAVE_BURST_READ_SIZE_MASK    (0x3<<4)
+ #define SYSTEM_CTRL_PCI_SLAVE_BURST_READ_SIZE_1       (0x0<<4)
+ #define SYSTEM_CTRL_PCI_SLAVE_BURST_READ_SIZE_2       (0x1<<4)
+ #define SYSTEM_CTRL_PCI_SLAVE_BURST_READ_SIZE_4       (0x2<<4)
+ #define SYSTEM_CTRL_PCI_SLAVE_BURST_READ_SIZE_8       (0x3<<4)
+ #define SYSTEM_CTRL_CRT_TRISTATE                      BIT(3)
+ #define SYSTEM_CTRL_PCIMEM_TRISTATE                   BIT(2)
+ #define SYSTEM_CTRL_LOCALMEM_TRISTATE                 BIT(1)
+ #define SYSTEM_CTRL_PANEL_TRISTATE                    BIT(0)
+ 
+ #define PANEL_HORIZONTAL_TOTAL                        0x080024
+ #define PANEL_HORIZONTAL_TOTAL_TOTAL_SHIFT            16
+ #define PANEL_HORIZONTAL_TOTAL_TOTAL_MASK             (0xfff<<16)
+ #define PANEL_HORIZONTAL_TOTAL_DISPLAY_END_MASK       0xfff
+ 
+ #define PANEL_HORIZONTAL_SYNC                         0x080028
+ #define PANEL_HORIZONTAL_SYNC_WIDTH_SHIFT             16
+ #define PANEL_HORIZONTAL_SYNC_WIDTH_MASK              (0xff<<16)
+ #define PANEL_HORIZONTAL_SYNC_START_MASK              0xfff
+ 
+ #define PANEL_VERTICAL_TOTAL                          0x08002C
+ #define PANEL_VERTICAL_TOTAL_TOTAL_SHIFT              16
+ #define PANEL_VERTICAL_TOTAL_TOTAL_MASK               (0x7ff<<16)
+ #define PANEL_VERTICAL_TOTAL_DISPLAY_END_MASK         0x7ff
+ 
+ #define PANEL_VERTICAL_SYNC                           0x080030
+ #define PANEL_VERTICAL_SYNC_HEIGHT_SHIFT              16
+ #define PANEL_VERTICAL_SYNC_HEIGHT_MASK               (0x3f<<16)
+ #define PANEL_VERTICAL_SYNC_START_MASK                0x7ff
+ 
+ #define PANEL_DISPLAY_CTRL                            0x080000
+ #define PANEL_DISPLAY_CTRL_RESERVED_MASK              0xc0f08000
+ #define PANEL_DISPLAY_CTRL_SELECT_SHIFT               28
+ #define PANEL_DISPLAY_CTRL_SELECT_MASK                (0x3<<28)
+ #define PANEL_DISPLAY_CTRL_SELECT_PANEL               (0x0<<28)
+ #define PANEL_DISPLAY_CTRL_SELECT_VGA                 (0x1<<28)
+ #define PANEL_DISPLAY_CTRL_SELECT_CRT                 (0x2<<28)
+ #define PANEL_DISPLAY_CTRL_FPEN                       BIT(27)
+ #define PANEL_DISPLAY_CTRL_VBIASEN                    BIT(26)
+ #define PANEL_DISPLAY_CTRL_DATA                       BIT(25)
+ #define PANEL_DISPLAY_CTRL_FPVDDEN                    BIT(24)
+ #define PANEL_DISPLAY_CTRL_DUAL_DISPLAY               BIT(19)
+ #define PANEL_DISPLAY_CTRL_DOUBLE_PIXEL               BIT(18)
+ #define PANEL_DISPLAY_CTRL_FIFO                       (0x3<<16)
+ #define PANEL_DISPLAY_CTRL_FIFO_1                     (0x0<<16)
+ #define PANEL_DISPLAY_CTRL_FIFO_3                     (0x1<<16)
+ #define PANEL_DISPLAY_CTRL_FIFO_7                     (0x2<<16)
+ #define PANEL_DISPLAY_CTRL_FIFO_11                    (0x3<<16)
+ #define DISPLAY_CTRL_CLOCK_PHASE                      BIT(14)
+ #define DISPLAY_CTRL_VSYNC_PHASE                      BIT(13)
+ #define DISPLAY_CTRL_HSYNC_PHASE                      BIT(12)
+ #define PANEL_DISPLAY_CTRL_VSYNC                      BIT(11)
+ #define PANEL_DISPLAY_CTRL_CAPTURE_TIMING             BIT(10)
+ #define PANEL_DISPLAY_CTRL_COLOR_KEY                  BIT(9)
+ #define DISPLAY_CTRL_TIMING                           BIT(8)
+ #define PANEL_DISPLAY_CTRL_VERTICAL_PAN_DIR           BIT(7)
+ #define PANEL_DISPLAY_CTRL_VERTICAL_PAN               BIT(6)
+ #define PANEL_DISPLAY_CTRL_HORIZONTAL_PAN_DIR         BIT(5)
+ #define PANEL_DISPLAY_CTRL_HORIZONTAL_PAN             BIT(4)
+ #define DISPLAY_CTRL_GAMMA                            BIT(3)
+ #define DISPLAY_CTRL_PLANE                            BIT(2)
+ #define PANEL_DISPLAY_CTRL_FORMAT_MASK                (0x3<<0)
+ #define PANEL_DISPLAY_CTRL_FORMAT_8                   (0x0<<0)
+ #define PANEL_DISPLAY_CTRL_FORMAT_16                  (0x1<<0)
+ #define PANEL_DISPLAY_CTRL_FORMAT_32                  (0x2<<0)
+ 
+ #define PANEL_FB_ADDRESS                              0x08000C
+ #define PANEL_FB_ADDRESS_STATUS                       BIT(31)
+ #define PANEL_FB_ADDRESS_EXT                          BIT(27)
+ #define PANEL_FB_ADDRESS_ADDRESS_MASK                 0x1ffffff
+ 
+ #define PANEL_FB_WIDTH                                0x080010
+ #define PANEL_FB_WIDTH_WIDTH_SHIFT                    16
+ #define PANEL_FB_WIDTH_WIDTH_MASK                     (0x3fff<<16)
+ #define PANEL_FB_WIDTH_OFFSET_MASK                    0x3fff
+ 
+ #define PANEL_WINDOW_WIDTH                            0x080014
+ #define PANEL_WINDOW_WIDTH_WIDTH_SHIFT                16
+ #define PANEL_WINDOW_WIDTH_WIDTH_MASK                 (0xfff<<16)
+ #define PANEL_WINDOW_WIDTH_X_MASK                     0xfff
+ 
+ #define PANEL_WINDOW_HEIGHT                           0x080018
+ #define PANEL_WINDOW_HEIGHT_HEIGHT_SHIFT              16
+ #define PANEL_WINDOW_HEIGHT_HEIGHT_MASK               (0xfff<<16)
+ #define PANEL_WINDOW_HEIGHT_Y_MASK                    0xfff
+ 
+ #define PANEL_PLANE_TL                                0x08001C
+ #define PANEL_PLANE_TL_TOP_SHIFT                      16
+ #define PANEL_PLANE_TL_TOP_MASK                       (0xeff<<16)
+ #define PANEL_PLANE_TL_LEFT_MASK                      0xeff
+ 
+ #define PANEL_PLANE_BR                                0x080020
+ #define PANEL_PLANE_BR_BOTTOM_SHIFT                   16
+ #define PANEL_PLANE_BR_BOTTOM_MASK                    (0xeff<<16)
+ #define PANEL_PLANE_BR_RIGHT_MASK                     0xeff
+ 
+ 
+ 
+ #define CRT_DISPLAY_CTRL                              0x080200
+ #define CRT_DISPLAY_CTRL_RESERVED_MASK                0xfb008200
+ 
+ /* SM750LE definition */
+ #define CRT_DISPLAY_CTRL_DPMS_SHIFT                   30
+ #define CRT_DISPLAY_CTRL_DPMS_MASK                    (0x3<<30)
+ #define CRT_DISPLAY_CTRL_DPMS_0                       (0x0<<30)
+ #define CRT_DISPLAY_CTRL_DPMS_1                       (0x1<<30)
+ #define CRT_DISPLAY_CTRL_DPMS_2                       (0x2<<30)
+ #define CRT_DISPLAY_CTRL_DPMS_3                       (0x3<<30)
+ #define CRT_DISPLAY_CTRL_CLK_MASK                     (0x7<<27)
+ #define CRT_DISPLAY_CTRL_CLK_PLL25                    (0x0<<27)
+ #define CRT_DISPLAY_CTRL_CLK_PLL41                    (0x1<<27)
+ #define CRT_DISPLAY_CTRL_CLK_PLL62                    (0x2<<27)
+ #define CRT_DISPLAY_CTRL_CLK_PLL65                    (0x3<<27)
+ #define CRT_DISPLAY_CTRL_CLK_PLL74                    (0x4<<27)
+ #define CRT_DISPLAY_CTRL_CLK_PLL80                    (0x5<<27)
+ #define CRT_DISPLAY_CTRL_CLK_PLL108                   (0x6<<27)
+ #define CRT_DISPLAY_CTRL_CLK_RESERVED                 (0x7<<27)
+ #define CRT_DISPLAY_CTRL_SHIFT_VGA_DAC                BIT(26)
+ 
+ /* SM750LE definition */
+ #define CRT_DISPLAY_CTRL_CRTSELECT                    BIT(25)
+ #define CRT_DISPLAY_CTRL_RGBBIT                       BIT(24)
+ 
+ #ifndef VALIDATION_CHIP
+     #define CRT_DISPLAY_CTRL_CENTERING                BIT(24)
+ #endif
+ #define CRT_DISPLAY_CTRL_LOCK_TIMING                  BIT(23)
+ #define CRT_DISPLAY_CTRL_EXPANSION                    BIT(22)
+ #define CRT_DISPLAY_CTRL_VERTICAL_MODE                BIT(21)
+ #define CRT_DISPLAY_CTRL_HORIZONTAL_MODE              BIT(20)
+ #define CRT_DISPLAY_CTRL_SELECT_SHIFT                 18
+ #define CRT_DISPLAY_CTRL_SELECT_MASK                  (0x3<<18)
+ #define CRT_DISPLAY_CTRL_SELECT_PANEL                 (0x0<<18)
+ #define CRT_DISPLAY_CTRL_SELECT_VGA                   (0x1<<18)
+ #define CRT_DISPLAY_CTRL_SELECT_CRT                   (0x2<<18)
+ #define CRT_DISPLAY_CTRL_FIFO_MASK                    (0x3<<16)
+ #define CRT_DISPLAY_CTRL_FIFO_1                       (0x0<<16)
+ #define CRT_DISPLAY_CTRL_FIFO_3                       (0x1<<16)
+ #define CRT_DISPLAY_CTRL_FIFO_7                       (0x2<<16)
+ #define CRT_DISPLAY_CTRL_FIFO_11                      (0x3<<16)
+ #define CRT_DISPLAY_CTRL_BLANK                        BIT(10)
+ #define CRT_DISPLAY_CTRL_PIXEL_MASK                   (0xf<<4)
+ #define CRT_DISPLAY_CTRL_FORMAT_MASK                  (0x3<<0)
+ #define CRT_DISPLAY_CTRL_FORMAT_8                     (0x0<<0)
+ #define CRT_DISPLAY_CTRL_FORMAT_16                    (0x1<<0)
+ #define CRT_DISPLAY_CTRL_FORMAT_32                    (0x2<<0)
+ 
+ 
+ static inline void ctrl_update(struct drm_device *dev, u32 reg, u32 val) {
+     struct _device *dev_priv = dev->dev_private;
+     //pr_info(">>%s:%d %08x:%08x\n", __func__, __LINE__, DRM_READ32(dev_priv->mmio, reg), val);
+     DRM_WRITE32(dev_priv->mmio, reg, DRM_READ32(dev_priv->mmio, reg)|val);
+ }
+ static inline void ctrl_clear(struct drm_device *dev, u32 reg, u32 val) {
+     struct _device *dev_priv = dev->dev_private;
+     //pr_info(">>%s:%d\n", __func__, __LINE__);
+     DRM_WRITE32(dev_priv->mmio, reg, DRM_READ32(dev_priv->mmio, reg)&~val);
+ }
+ /*static inline void ctrl_flip(struct drm_device *dev, u32 reg, u32 val) {
+     struct _device *dev_priv = dev->dev_private;
+     pr_info(">>%s:%d\n", __func__, __LINE__);
+     DRM_WRITE32(dev_priv->mmio, reg, DRM_READ32(dev_priv->mmio, reg)|val);
+ }*/
+ 
+ static inline void ctrl_write(struct drm_device *dev, u32 reg, u32 val) {
+     struct _device *dev_priv = dev->dev_private;
+     //pr_info(">>%s:%d %08x:%08x\n", __func__, __LINE__, val, DRM_READ32(dev_priv->mmio, reg));
+     DRM_WRITE32(dev_priv->mmio, reg, val);
+ }
+ /*static inline void ctrl_write_hl(struct drm_device *dev, u32 reg, u32 hight, u32 low) {
+     struct _device *dev_priv = dev->dev_private;
+     DRM_WRITE32(dev_priv->mmio, reg, hight<<16|low);
+ }*/
+ // TODO: rewrite this function with exta parameter "shift/offset" = 20
+ static inline void ctrl_wrup(struct drm_device *dev, u32 reg, u32 val) {	// TODO: weakly realization, u should tinlk about algo a bit.
+     struct _device *dev_priv = dev->dev_private;
+     //pr_info(">>%s:%d\n", __func__, __LINE__);
+     DRM_WRITE32(dev_priv->mmio, reg, val|((DRM_READ32(dev_priv->mmio, reg)<<20)>>20));
+ }
+ 
+ static inline u32 ctrl_read(struct drm_device *dev, u32 reg) {
+     struct _device *dev_priv = dev->dev_private;
+     //pr_info(">>%s:%d\n", __func__, __LINE__);
+     return DRM_READ32(dev_priv->mmio, reg);
+ }
+ static inline void pr_ctrl(struct drm_device *dev) {
+     pr_info(">>%s:%d vga:%08x mxclk:%08x mode0:%08x misc:%08x sys:%08x pll:%08x htotal:%08x hsync:%08x vtotal:%08x vsync:%08x disp:%08x fbadrr:%08x fbw:%08x ww:%08x wh:%08x pbr:%08x crt:%08x\n",
+ 	__func__, __LINE__, 
+ 	ctrl_read(dev, VGA_CONFIGURATION),
+ 	ctrl_read(dev, MXCLK_PLL_CTRL),
+ 	ctrl_read(dev, MODE0_GATE),
+ 	ctrl_read(dev, MISC_CTRL),
+ 	ctrl_read(dev, SYSTEM_CTRL),
+ 	ctrl_read(dev, PANEL_PLL_CTRL),
+ 	ctrl_read(dev, PANEL_HORIZONTAL_TOTAL),
+ 	ctrl_read(dev, PANEL_HORIZONTAL_SYNC),
+ 	ctrl_read(dev, PANEL_VERTICAL_TOTAL),
+ 	ctrl_read(dev, PANEL_VERTICAL_SYNC),
+ 	ctrl_read(dev, PANEL_DISPLAY_CTRL),
+ 	ctrl_read(dev, PANEL_FB_ADDRESS),
+ 	ctrl_read(dev, PANEL_FB_WIDTH),
+ 	ctrl_read(dev, PANEL_WINDOW_WIDTH),
+ 	ctrl_read(dev, PANEL_WINDOW_HEIGHT),
+ 	ctrl_read(dev, PANEL_PLANE_BR),
+ 	ctrl_read(dev, CRT_DISPLAY_CTRL)
+     );
+ }
+ 
+ #endif /* _CTRL_H */
\ В конце файла нет новой строки
diff -rcNP linux-4.4.24/drivers/gpu/drm/smi/drv.c linux-4.4.24-baikal/drivers/gpu/drm/smi/drv.c
*** linux-4.4.24/drivers/gpu/drm/smi/drv.c	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/drivers/gpu/drm/smi/drv.c	2016-11-11 14:49:51.000000000 +0300
***************
*** 0 ****
--- 1,188 ----
+ #include <linux/mm.h>
+ #include <linux/module.h>
+ #include <linux/slab.h>
+ 
+ #include <linux/dma-mapping.h>
+ 
+ #include <drm/drm_gem_cma_helper.h>
+ 
+ #include "smi.h"
+ #include "ctrl.h"
+ #include "fbdev.h"
+ 
+ static int _driver_unload(struct drm_device *dev) {
+     struct _device *private = dev->dev_private;
+ 
+     pr_info("%s:%d\n", __func__, __LINE__);
+     kfree(private);
+     dev->dev_private = NULL;
+     return 0;
+ }
+ 
+ static inline u32 pll_fmt(unsigned od, unsigned n, unsigned m) {
+     return (((od<<4)|n)<<8)|m;
+ }
+ static inline void _ctrl_init(struct drm_device *dev) {
+     pr_info(">>%s:%d\n", __func__, __LINE__);
+ 
+     ctrl_update(dev, VGA_CONFIGURATION, VGA_CONFIGURATION_PLL|VGA_CONFIGURATION_MODE);	// set panel pll and graphic mode via mmio_88
+ 
+     //ctrl_write(dev, MXCLK_PLL_CTRL, MXCLK_PLL_CTRL_POWER|compute_pll(290000));		// set main chip clock. Master Clock Control: MXCLK_PLL
+     ctrl_write(dev, MXCLK_PLL_CTRL, MXCLK_PLL_CTRL_POWER|pll_fmt(0, 12, 243));		// set main chip clock. Master Clock Control: MXCLK_PLL @290MHz
+     ctrl_wrup(dev, MODE0_GATE, MODE0_GATE_MCLK_112MHZ|MODE0_GATE_M2XCLK_336MHZ);	// set memory and master clocks
+ 
+     ctrl_clear(dev, MISC_CTRL, MISC_CTRL_LOCALMEM_RESET);				// Reset the memory controller. If the memory controller is not reset in SM750, the system might hang when sw accesses the memory.
+     ctrl_update(dev, MISC_CTRL, MISC_CTRL_LOCALMEM_RESET);				// The memory should be resetted after changing the MXCLK.
+ 
+     ctrl_update(dev, SYSTEM_CTRL, SYSTEM_CTRL_DE_ABORT);				/* engine reset */
+     ctrl_clear(dev, SYSTEM_CTRL, SYSTEM_CTRL_DE_ABORT);
+ }
+ 
+ static inline void pr_local_map(drm_local_map_t *map) {
+     pr_info("type:%d mtrr:%d handle:%p flags:%08x size:%08lx offset:%08llx\n", map->type, map->mtrr, map->handle, map->flags, map->size, map->offset);
+ }
+ 
+ static int _driver_load(struct drm_device *dev, unsigned long flags) {
+ 	struct _device *dev_priv = dev->dev_private;
+ 	struct pci_dev *pdev = dev->pdev;
+ 	int ret;
+ 
+ 	pr_info(">>%s:%d\n", __func__, __LINE__);
+ 	dev_priv = kzalloc(sizeof(*dev_priv), GFP_KERNEL);
+ 	if (dev_priv == NULL)
+ 		return -ENOMEM;
+ 	dev_priv->drm = dev;
+ 	dev->dev_private = dev_priv;
+ 
+ 	pci_set_master(pdev);
+ 
+ 
+ 	//ret = drm_legacy_addmap(dev, pci_resource_start(pdev, 0), pci_resource_len(pdev, 0), _DRM_REGISTERS/*_DRM_FRAME_BUFFER*/, _DRM_WRITE_COMBINING, &dev_priv->fb);
+ 	//if (ret)
+ 	//    return ret;
+ 	ret = drm_legacy_addmap(dev, pci_resource_start(dev->pdev, 1), pci_resource_len(dev->pdev, 1), _DRM_REGISTERS, _DRM_READ_ONLY|_DRM_DRIVER, &dev_priv->mmio);
+ 	if (ret) {
+ 		return ret;
+ 	}
+ 	pr_local_map(dev_priv->mmio);
+ 	//ret = drm_legacy_addmap(dev, pci_resource_start(pdev, 6), pci_resource_len(pdev, 6), _DRM_FRAME_BUFFER, _DRM_WRITE_COMBINING, &dev_priv->aperture);
+ 	//if (ret)
+ 	//    return ret;
+ 
+ 	_ctrl_init(dev);	// hw_init?
+ 
+ 	ret = _kms_init(dev);
+ 	if (ret)
+ 	    goto err;
+ 
+ 	ret = _fbdev_init(dev);
+ 	if (ret)
+ 	    goto err;
+ 	//drm_kms_helper_poll_init(dev);	// init kms poll for handling hpd
+ 
+ 	return 0;
+ 
+ err:
+ 	_driver_unload(dev);
+ 	return ret;
+ 
+ }
+ 
+ 
+ static int _drm_enable_vblank(struct drm_device *dev, unsigned int pipe) {
+     pr_info("%s:%d\n", __func__, __LINE__);
+     return 0;
+ }
+ static void _drm_disable_vblank(struct drm_device *dev, unsigned int pipe) {
+     pr_info("%s:%d\n", __func__, __LINE__);
+ }
+ 
+ static const struct file_operations fops = {
+     .owner              = THIS_MODULE,
+     .open               = drm_open,
+     .release            = drm_release,
+     .unlocked_ioctl     = drm_ioctl,
+ #ifdef CONFIG_COMPAT
+     .compat_ioctl       = drm_compat_ioctl,
+ #endif
+     .poll               = drm_poll,
+     .read               = drm_read,
+     .llseek             = no_llseek,
+     .mmap               = drm_gem_cma_mmap,
+ };
+ 
+ static int _kick_out_firmware_fb(struct pci_dev *pdev) {
+     struct apertures_struct *ap;
+ 
+     pr_info("%s:%d\n", __func__, __LINE__);
+     return 0;
+     ap = alloc_apertures(1);
+     if (!ap)
+ 	return -ENOMEM;
+ 
+     ap->ranges[0].base = pci_resource_start(pdev, 0);
+     ap->ranges[0].size = pci_resource_len(pdev, 0);
+     remove_conflicting_framebuffers(ap, DRIVER_NAME"drmfb", pdev->resource[PCI_ROM_RESOURCE].flags & IORESOURCE_ROM_SHADOW); // sm750fb
+     kfree(ap);
+ 
+     return 0;
+ }
+ 
+ static struct drm_driver _drm_driver = {
+     .driver_features	= DRIVER_GEM | DRIVER_MODESET,
+     .load		= _driver_load,
+     .unload		= _driver_unload,
+     .set_busid		= drm_pci_set_busid,
+     .get_vblank_counter = drm_vblank_no_hw_counter,
+     .enable_vblank	= _drm_enable_vblank,
+     .disable_vblank	= _drm_disable_vblank,
+     .dumb_create	= drm_gem_cma_dumb_create,
+     .dumb_map_offset	= drm_gem_cma_dumb_map_offset,
+     .dumb_destroy	= drm_gem_dumb_destroy,
+     .fops = &fops,
+     .name		= DRIVER_NAME,
+     .desc		= "silicon motion display engine",
+     .date		= "20160715",
+     .major		= 1,
+     .minor		= 0,
+ };
+ 
+ static int _pci_probe(struct pci_dev *pdev, const struct pci_device_id *pid) {
+     int ret;
+ 
+     pr_info("%s:%d\n", __func__, __LINE__);
+     ret = _kick_out_firmware_fb(pdev);
+     if (ret)
+ 	return ret;
+ 
+     return drm_get_pci_dev(pdev, pid, &_drm_driver);	// pci_enable_device->pci_set_drvdata
+ }
+ 
+ static void _pci_remove(struct pci_dev *pdev) {
+     pr_info("%s:%d\n", __func__, __LINE__);
+     drm_put_dev(pci_get_drvdata(pdev));
+ }
+ 
+ static const struct pci_device_id _ids[] = {
+     {PCI_DEVICE(0x126f, 0x718),},
+     {PCI_DEVICE(0x126f, 0x750),},
+     {PCI_DEVICE(0x126f, 0x501),},
+     {0,}
+ };
+ 
+ static struct pci_driver _pci_driver = {
+     .name = DRIVER_NAME,
+     .id_table = _ids,
+     .probe = _pci_probe,
+     .remove = _pci_remove,
+ };
+ 
+ static int __init smi_init(void){
+     return drm_pci_init(&_drm_driver, &_pci_driver);
+ }
+ static void __exit smi_exit(void) {drm_pci_exit(&_drm_driver, &_pci_driver);}
+ 
+ module_init(smi_init);
+ module_exit(smi_exit);
+ 
+ MODULE_AUTHOR("Andrew Khorolsky <a.khorolsky@baikalelectronics.ru>");
diff -rcNP linux-4.4.24/drivers/gpu/drm/smi/fbdev.c linux-4.4.24-baikal/drivers/gpu/drm/smi/fbdev.c
*** linux-4.4.24/drivers/gpu/drm/smi/fbdev.c	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/drivers/gpu/drm/smi/fbdev.c	2016-11-11 14:49:51.000000000 +0300
***************
*** 0 ****
--- 1,132 ----
+ #include <drm/drm_crtc.h>
+ #include <drm/drm_fb_helper.h>
+ #include <drm/drmP.h>
+ 
+ #include "smi.h"
+ #include "fbdev.h"
+ 
+ 
+ static void _fb_destroy(struct drm_framebuffer *fb) {
+     pr_info(">>%s:%d FB ID: %d (%p)\n", __func__, __LINE__, fb->base.id, fb);
+ 
+     drm_framebuffer_cleanup(fb);
+ }
+ 
+ static int _fb_create_handle(struct drm_framebuffer *fb, struct drm_file *file_priv, unsigned int *handle) {
+     pr_info(">>%s:%d\n", __func__, __LINE__);
+     return 0;
+ }
+ static int _fb_dirty(struct drm_framebuffer *fb, struct drm_file *file, unsigned flags, unsigned color, struct drm_clip_rect *clips, unsigned num_clips) {
+     pr_info(">>%s:%d x[%d, %d], y[%d, %d]\n", __func__, __LINE__, clips->x1, clips->x2, clips->y1, clips->y2);
+     return 0;
+ }
+ 
+ static const struct drm_framebuffer_funcs _fb_funcs = {
+     .destroy = _fb_destroy,
+     .create_handle = _fb_create_handle,
+     .dirty = _fb_dirty,
+ };
+ 
+ 
+ static struct fb_ops _fb_ops = {
+     .owner		= THIS_MODULE,
+     .fb_fillrect	= drm_fb_helper_sys_fillrect,
+     .fb_copyarea	= drm_fb_helper_sys_copyarea,
+     .fb_imageblit	= drm_fb_helper_sys_imageblit,
+     .fb_check_var	= drm_fb_helper_check_var,
+     .fb_set_par		= drm_fb_helper_set_par,
+     .fb_blank		= drm_fb_helper_blank,
+     .fb_pan_display	= drm_fb_helper_pan_display,
+     .fb_setcmap		= drm_fb_helper_setcmap,
+ };
+ 
+ 
+ static int _fb_create(struct drm_fb_helper *helper, struct drm_fb_helper_surface_size *sizes) {
+     struct drm_device *dev = helper->dev;
+     struct fb_info *info;
+     struct drm_framebuffer *fb = helper->fb;
+     struct drm_mode_fb_cmd2 mode_cmd;
+     int ret;
+ 
+     pr_info(">>%s:%d surface width(%d), height(%d) and bpp(%d)\n", __func__, __LINE__, sizes->surface_width, sizes->surface_height, sizes->surface_bpp);
+ 
+     mode_cmd.width = sizes->surface_width;
+     mode_cmd.height = sizes->surface_height;
+     mode_cmd.pitches[0] = mode_cmd.width * ((sizes->surface_bpp + 7) / 8);
+     mode_cmd.pixel_format = drm_mode_legacy_fb_format(sizes->surface_bpp, sizes->surface_depth);
+ 
+     info = drm_fb_helper_alloc_fbi(helper);
+     if (IS_ERR(info)) {
+ 	    return PTR_ERR(info);
+     }
+ 
+     pr_info(">>%s:%d\n", __func__, __LINE__);
+     drm_helper_mode_fill_fb_struct(fb, &mode_cmd);
+ 
+     ret = drm_framebuffer_init(dev, fb, &_fb_funcs);
+     if (ret) {
+ 	dev_err(dev->dev, "Failed to initialize framebuffer: %d\n", ret);
+ 	return ret;
+     }
+ 
+     info->par = helper;
+     info->flags = FBINFO_DEFAULT;
+     info->fbops = &_fb_ops;
+ 
+     //pr_info(">>%s:%d %d:%d:%d:%d\n", __func__, __LINE__, DIV_ROUND_UP(sizes->surface_bpp, 8), info->var.xoffset, info->var.yoffset, fb->pitches[0]);
+     //4:0:0:7680
+     //unsigned bytes_per_pixel = DIV_ROUND_UP(sizes->surface_bpp, 8);
+     /*unsigned long offset;
+     offset = fbi->var.xoffset * bytes_per_pixel;
+     offset += fbi->var.yoffset * fb->pitches[0];*/
+ 
+ 
+     info->fix.smem_start = pci_resource_start(dev->pdev, 0);
+     info->fix.smem_len = pci_resource_len(dev->pdev, 0);
+ 
+     info->screen_base = ioremap_wc(info->fix.smem_start, info->fix.smem_len);
+     info->screen_size = info->fix.smem_len;
+ 
+     strcpy(info->fix.id, "smidrmfb");
+ 
+     drm_fb_helper_fill_fix(info, fb->pitches[0], fb->depth);
+     drm_fb_helper_fill_var(info, helper, sizes->fb_width, sizes->fb_height);
+ 
+     return 0;
+ }
+ 
+ 
+ static struct drm_fb_helper_funcs _helper_funcs = {
+     .fb_probe = _fb_create,
+ };
+ 
+ int _fbdev_init(struct drm_device *dev) {
+     struct _device *priv = dev->dev_private;
+     struct drm_fb_helper *helper = &priv->helper;
+     int ret;
+ 
+     pr_info(">>%s:%d\n", __func__, __LINE__);
+     drm_fb_helper_prepare(dev, helper, &_helper_funcs);
+     ret = drm_fb_helper_init(dev, helper, 1, 1);
+     if (ret) {
+ 	return ret;
+     }
+     helper->fb = &priv->fb;
+     drm_fb_helper_single_add_all_connectors(helper);
+ 
+     return drm_fb_helper_initial_config(helper, dev->mode_config.preferred_depth);
+ }
+ 
+ //static 
+ void _fbdev_fini(struct drm_device *dev) {
+     struct _device *private = dev->dev_private;
+     struct drm_fb_helper *helper = &private->helper;
+ 
+     drm_fb_helper_unregister_fbi(helper);
+     drm_fb_helper_release_fbi(helper);
+ 
+     if (helper->fb)
+ 	drm_framebuffer_unreference(helper->fb);
+ 
+     drm_fb_helper_fini(helper);
+ }
diff -rcNP linux-4.4.24/drivers/gpu/drm/smi/fbdev.h linux-4.4.24-baikal/drivers/gpu/drm/smi/fbdev.h
*** linux-4.4.24/drivers/gpu/drm/smi/fbdev.h	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/drivers/gpu/drm/smi/fbdev.h	2016-11-11 14:49:51.000000000 +0300
***************
*** 0 ****
--- 1,27 ----
+ /*
+  * Copyright (C) Baikal Electronics Co.Ltd
+  * Author:Andrew Khorolsky <a.khorolsky@baikal-electronics.com>
+  *
+  * This software is licensed under the terms of the GNU General Public
+  * License version 2, as published by the Free Software Foundation, and
+  * may be copied, distributed, and modified under those terms.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  */
+ 
+ #ifndef _FBDEV_H
+ #define _FBDEV_H
+ 
+ #ifdef CONFIG_DRM_FBDEV_EMULATION
+ int _fbdev_init(struct drm_device *dev);
+ void _fbdev_fini(struct drm_device *dev);
+ #else
+ static inline int _fbdev_init(struct drm_device *dev) {return 0;}
+ 
+ static inline void _fbdev_fini(struct drm_device *dev) {}
+ #endif
+ 
+ #endif /* _FBDEV_H */
diff -rcNP linux-4.4.24/drivers/gpu/drm/smi/Kconfig linux-4.4.24-baikal/drivers/gpu/drm/smi/Kconfig
*** linux-4.4.24/drivers/gpu/drm/smi/Kconfig	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/drivers/gpu/drm/smi/Kconfig	2016-11-11 14:49:51.000000000 +0300
***************
*** 0 ****
--- 1,8 ----
+ config DRM_SMI
+ 	tristate "Silicon Motion video cards"
+ 	depends on DRM && PCI
+ 	select DRM_GEM_CMA_HELPER
+ 	select DRM_KMS_CMA_HELPER
+ 	help
+ 	  Choose this option to enable DRM on sm750/718/501 chipset.
+ 
diff -rcNP linux-4.4.24/drivers/gpu/drm/smi/kms.c linux-4.4.24-baikal/drivers/gpu/drm/smi/kms.c
*** linux-4.4.24/drivers/gpu/drm/smi/kms.c	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/drivers/gpu/drm/smi/kms.c	2016-11-11 14:49:51.000000000 +0300
***************
*** 0 ****
--- 1,413 ----
+ #include "smi.h"
+ #include "ctrl.h"
+ 
+ /* These provide the minimum set of functions required to handle a CRTC */
+ static int _crtc_page_flip(struct drm_crtc *crtc, struct drm_framebuffer *fb, struct drm_pending_vblank_event *event, uint32_t page_flip_flags) {
+     pr_info(">>%s:%d\n", __func__, __LINE__);
+     return 0;
+ }
+ 
+ static const struct drm_crtc_funcs _crtc_funcs = {
+     .set_config = drm_crtc_helper_set_config,
+     .destroy = drm_crtc_cleanup,
+     .page_flip = _crtc_page_flip,
+ };
+ 
+ static void _crtc_dpms(struct drm_crtc *crtc, int mode) {
+     struct drm_device *dev = crtc->dev;
+ 
+     pr_info(">>%s:%d %d\n", __func__, __LINE__, mode);
+     if(mode == DRM_MODE_DPMS_STANDBY) {
+ 	ctrl_clear(dev, PANEL_DISPLAY_CTRL, PANEL_DISPLAY_CTRL_DATA);
+ 	ctrl_update(dev, CRT_DISPLAY_CTRL, CRT_DISPLAY_CTRL_BLANK);
+     } else {
+ 	// 0,3
+ 	pr_info(">>%s:%d %d <- UNRECOGNIZED POWER MODE\n", __func__, __LINE__, mode);
+     }
+     /*unsigned pps = 0;
+     switch (mode) {
+     case DRM_MODE_DPMS_ON:
+ 	// 0: enable video ports
+ 	pps = PANEL_DISPLAY_CTRL_DATA;
+ 	break;
+     case DRM_MODE_DPMS_STANDBY:
+ 	// 1: ?
+ 	break;
+     case DRM_MODE_DPMS_SUSPEND:
+ 	// 2: ?
+ 	break;
+     case DRM_MODE_DPMS_OFF:
+ 	// 3: disable video ports
+ 	//reg_write(priv, REG_ENA_VP_0, 0x00);
+ 	break;
+     }*/
+ 
+     //pdc_write(crtc->dev, (pdc_read(crtc->dev)&~PANEL_DISPLAY_CTRL_DATA)|mode?0:PANEL_DISPLAY_CTRL_DATA);
+ }
+ static inline u32 calc_pll(unsigned request_freq) {
+     // as sm750 register definition, N located in 2,15 and M located in 1,255
+     static unsigned od, n, m, pod;
+     int N, M, X, d;
+     int mini_diff = ~0;
+     unsigned RN, quo, rem, fl_quo;
+     unsigned input, request;
+     unsigned tmpClock, adjusted_clock = 0;
+     const int max_OD = 3;
+     const unsigned input_freq = 14318181;
+ 
+     request = request_freq/1000;
+     input = input_freq/1000;
+     pr_info(">>%s:%d request:%d input:%d\n", __func__, __LINE__, request, input);
+ 
+     for (N = 15; N > 1; N--) {
+ 	// RN will not exceed maximum long if @request <= 285 MHZ (for 32bit cpu)
+ 	RN = N * request;
+ 	quo = RN/input;
+ 	rem = RN % input;// rem always small than 14318181
+ 	fl_quo = (rem * 10000/input);
+ 
+ 	for (d = 6; d >= 0; d--) {
+ 	    X = (1<<d);
+ 	    M = quo * X;
+ 	    M += fl_quo * X/10000;
+ 	    // round step
+ 	    M += (fl_quo * X % 10000) > 5000?1:0;
+ 	    if (M < 256 && M > 0) {
+ 		unsigned int diff;
+ 
+ 		tmpClock = input_freq * M/N/X;
+ 		diff = abs(tmpClock - request_freq);
+ 		if (diff < mini_diff) {
+ 		    m = M;
+ 		    n = N;
+ 		    pod = 0;
+ 		    if (d > max_OD)
+ 			pod = d - max_OD;
+ 		    od = d - pod;
+ 		    mini_diff = diff;
+ 		    adjusted_clock = tmpClock;
+ 		}
+ 	    }
+ 	}
+     }
+     pr_info(">>%s:%d clk:: request:%d adjusted:%d pll:: pod:%d od:%d n:%d m:%d\n", __func__, __LINE__, request_freq, adjusted_clock, pod, od, n, m);
+     return (((od<<4)|n)<<8)|m;
+ }
+ 
+ static bool _crtc_mode_fixup(struct drm_crtc *crtc, const struct drm_display_mode *mode, struct drm_display_mode *adjusted_mode) {
+     struct drm_device *dev = crtc->dev;
+ 
+     pr_info(">>%s:%d (%d,%d) => (%d,%d)\n", __func__, __LINE__, mode->hdisplay, mode->vdisplay, adjusted_mode->hdisplay, adjusted_mode->vdisplay);
+     ctrl_write(dev, PANEL_PLL_CTRL, PANEL_PLL_CTRL_POWER|calc_pll(1000*mode->clock));
+     //ctrl_write(dev, PANEL_PLL_CTRL, PANEL_PLL_CTRL_POWER|calc_pll(148500000));
+     return true;
+ }
+ 
+ static void _crtc_prepare(struct drm_crtc *crtc) {
+     pr_info(">>%s:%d\n", __func__, __LINE__);
+ }
+ static void _crtc_commit(struct drm_crtc *crtc) {
+     pr_info(">>%s:%d\n", __func__, __LINE__);
+ }
+ 
+ static inline void pr_display_mode(struct drm_display_mode *mode) {
+     pr_info(">>%s:%d name:%s clock:%d hdisplay:%d hsync_start:%d hsync_end:%d htotal:%d hskew:%d vdisplay:%d vsync_start:%d vsync_end:%d vtotal:%d vscan:%d flags:%08x vrefresh:%d hsync:%d\n", __func__, __LINE__,
+ 	mode->name,
+ 	mode->clock,
+ 	mode->hdisplay,
+ 	mode->hsync_start,
+ 	mode->hsync_end,
+ 	mode->htotal,
+ 	mode->hskew,
+ 	mode->vdisplay,
+ 	mode->vsync_start,
+ 	mode->vsync_end,
+ 	mode->vtotal,
+ 	mode->vscan,
+ 	mode->flags,
+ 	mode->vrefresh,
+ 	mode->hsync
+     );
+ }
+ 
+ static void _crtc_mode_set_nofb(struct drm_crtc *crtc)  {
+     struct drm_display_mode *mode;
+     struct drm_device *dev = crtc->dev;
+     uint32_t bpp = dev->mode_config.preferred_depth;
+ 
+     pr_info(">>%s:%d\n", __func__, __LINE__);
+ 
+     /*pr_display_mode(&crtc->mode);
+     pr_display_mode(&crtc->hwmode);*/
+     mode = &crtc->mode;
+ 
+     ctrl_write(dev, PANEL_HORIZONTAL_TOTAL, (mode->htotal - 1)<<16|(mode->hdisplay - 1));
+     ctrl_write(dev, PANEL_HORIZONTAL_SYNC, (mode->hsync_end - mode->hsync_start)<<16|(mode->hsync_start - 1));	//?
+     ctrl_write(dev, PANEL_VERTICAL_TOTAL, (mode->vtotal-1)<<16|(mode->vdisplay - 1));
+     ctrl_write(dev, PANEL_VERTICAL_SYNC, (mode->vsync_end - mode->vsync_start)<<16|(mode->vsync_start - 1));	//?
+ 
+     ctrl_update(dev, PANEL_DISPLAY_CTRL, DISPLAY_CTRL_CLOCK_PHASE|DISPLAY_CTRL_TIMING|DISPLAY_CTRL_PLANE);	// white screen begins here
+     ctrl_write(dev, PANEL_FB_ADDRESS, 0);
+     ctrl_write(dev, PANEL_FB_WIDTH, (mode->hdisplay*(bpp>3))<<16|(mode->hdisplay*(bpp>>3)));	// TODO: u should use smth<<16|fb->pitches[0]
+     ctrl_write(dev, PANEL_WINDOW_WIDTH, (mode->hdisplay-1)<<16|0);				// TODO: add hoffset
+     ctrl_write(dev, PANEL_WINDOW_HEIGHT, (mode->vdisplay-1)<<16|0);				// TODO: add voffset
+     ctrl_write(dev, PANEL_PLANE_BR, (mode->vdisplay-1)<<16|((mode->hdisplay-1)&PANEL_PLANE_BR_RIGHT_MASK));
+     ctrl_update(dev, PANEL_DISPLAY_CTRL, (bpp>>4)&PANEL_DISPLAY_CTRL_FORMAT_MASK);
+     //ctrl_update(dev, PANEL_DISPLAY_CTRL, PANEL_DISPLAY_CTRL_FORMAT_16|PANEL_DISPLAY_CTRL_FPEN|PANEL_DISPLAY_CTRL_DATA|PANEL_DISPLAY_CTRL_VBIASEN|PANEL_DISPLAY_CTRL_FPVDDEN);
+     ctrl_update(dev, PANEL_DISPLAY_CTRL, PANEL_DISPLAY_CTRL_FPEN|PANEL_DISPLAY_CTRL_DATA|PANEL_DISPLAY_CTRL_VBIASEN|PANEL_DISPLAY_CTRL_FPVDDEN);
+     pr_ctrl(dev);
+ }
+ 
+ 
+ static const struct drm_crtc_helper_funcs _crtc_helper_funcs = {
+     .dpms		= _crtc_dpms,
+     .prepare		= _crtc_prepare,
+     .commit		= _crtc_commit,
+     .mode_fixup		= _crtc_mode_fixup,
+     .mode_set		= drm_helper_crtc_mode_set,
+     .mode_set_nofb	= _crtc_mode_set_nofb,
+     .mode_set_base	= drm_helper_crtc_mode_set_base,
+ };
+ 
+ //int drm_crtc_init(struct drm_device *dev, struct drm_crtc *crtc, const struct drm_crtc_funcs *funcs);
+ 
+ static const u32 _formats[] = {
+     DRM_FORMAT_RGB565,
+     DRM_FORMAT_RGB888,
+     DRM_FORMAT_XRGB8888,
+     DRM_FORMAT_ARGB8888,
+     DRM_FORMAT_XRGB4444,
+     DRM_FORMAT_ARGB4444,
+     DRM_FORMAT_XRGB1555,
+     DRM_FORMAT_ARGB1555,
+     DRM_FORMAT_YUV422,
+ 
+     /*DRM_FORMAT_ARGB8888,
+     DRM_FORMAT_XRGB8888,
+     DRM_FORMAT_RGB888,*/
+ };
+ 
+ static int _plane_atomic_check(struct drm_plane *plane, struct drm_plane_state *state) {
+     pr_info(">>%s:%d\n", __func__, __LINE__);
+     return 0;
+ }
+ 
+ static void _plane_atomic_update(struct drm_plane *plane, struct drm_plane_state *state) {
+     pr_info(">>%s:%d\n", __func__, __LINE__);
+ }
+ 
+ static const struct drm_plane_helper_funcs _plane_helper_funcs = {
+     .atomic_check = _plane_atomic_check,
+     .atomic_update = _plane_atomic_update,
+ };
+ 
+ static void _plane_destroy(struct drm_plane *plane) {
+     drm_plane_helper_disable(plane);
+     drm_plane_cleanup(plane);
+ }
+ 
+ static const struct drm_plane_funcs _plane_funcs = {
+     /*.update_plane	= drm_atomic_helper_update_plane,
+     .disable_plane	= drm_atomic_helper_disable_plane,*/
+     .destroy		= _plane_destroy,
+     /*.reset		= drm_atomic_helper_plane_reset,
+     .atomic_duplicate_state = drm_atomic_helper_plane_duplicate_state,
+     .atomic_destroy_state = drm_atomic_helper_plane_destroy_state,*/
+ };
+ 
+ 
+ static void _crtc_init(struct drm_device *drm) {
+     int ret;
+     struct _device *private = drm->dev_private;
+     struct drm_plane *plane = &private->plane;
+     struct drm_crtc *crtc = &private->crtc;
+ 
+     pr_info(">>%s:%d\n", __func__, __LINE__);
+     /*ret = drm_crtc_init(drm, crtc, &_crtc_funcs);
+     if (ret < 0) {
+ 	pr_info(">>>>drm_crt_init failed!!!\n");
+ 	drm_crtc_cleanup(crtc);
+ 	return;
+     }*/
+     /*struct drm_plane *primary = create_primary_plane(drm);			// cuurent point*/
+     //drm_crtc_init_with_planes(drm, crtc, primary, NULL, _crtc_funcs, NULL);	// current point*/
+ 
+     plane->format_default = true;
+     /* possible_crtc's will be filled in later by crtc_init */
+     ret = drm_universal_plane_init(drm, plane, 0, &_plane_funcs, _formats, ARRAY_SIZE(_formats), DRM_PLANE_TYPE_PRIMARY);
+     if (ret)
+ 	return;
+     drm_plane_helper_add(plane, &_plane_helper_funcs);
+ 
+     ret = drm_crtc_init_with_planes(drm, crtc, plane, NULL, &_crtc_funcs);
+     if (ret < 0) {
+ 	drm_crtc_cleanup(crtc);
+ 	return;
+     }
+ 
+     //drm_mode_crtc_set_gamma_size(crtc, 256);
+     drm_crtc_helper_add(crtc, &_crtc_helper_funcs);	// TODO
+ }
+ 
+ static void _encoder_disable(struct drm_encoder *encoder) {
+     pr_info(">>%s:%d\n", __func__, __LINE__);
+ }
+ static void _encoder_enable(struct drm_encoder *encoder) {
+     pr_info(">>%s:%d\n", __func__, __LINE__);
+ }
+ 
+ static void _encoder_prepare(struct drm_encoder *encoder) {
+     pr_info(">>%s:%d\n", __func__, __LINE__);
+ }
+ static void _encoder_mode_set(struct drm_encoder *encoder, struct drm_display_mode *mode, struct drm_display_mode *adjusted_mode) {
+     pr_info(">>%s:%d\n", __func__, __LINE__);
+ }
+ static void _encoder_commit(struct drm_encoder *encoder) {
+     pr_info(">>%s:%d\n", __func__, __LINE__);
+ }
+ 
+ static bool _encoder_mode_fixup(struct drm_encoder *encoder, const struct drm_display_mode *mode, struct drm_display_mode *adj_mode) {
+     pr_info(">>%s:%d\n", __func__, __LINE__);
+     return true;
+ }
+ static const struct drm_encoder_helper_funcs _encoder_helper_funcs = {
+     .mode_fixup = _encoder_mode_fixup,
+     .prepare = _encoder_prepare,
+     .mode_set = _encoder_mode_set,
+     .disable = _encoder_disable,
+     .enable = _encoder_enable,
+     .commit = _encoder_commit,
+ };
+ static const struct drm_encoder_funcs _encoder_funcs = {
+     .destroy = drm_encoder_cleanup,
+ };
+ 
+ static struct drm_encoder *_encoder_init(struct drm_device *drm) {
+     struct _device *private =  drm->dev_private;
+     struct drm_encoder *encoder = &private->encoder;
+ 
+     pr_info(">>%s:%d\n", __func__, __LINE__);
+     encoder->possible_crtcs = 0x1;	// 1 << drm_crtc_index(crtc)
+     //encoder->possible_crtcs |= drm_crtc_mask(crtc);
+     drm_encoder_init(drm, encoder, &_encoder_funcs, DRM_MODE_ENCODER_DAC); //TODO: add extra params "char *name"
+     drm_encoder_helper_add(encoder, &_encoder_helper_funcs);
+     return encoder;
+ }
+ 
+ static inline void pr_cmdline_mode(struct drm_cmdline_mode *mode) {
+     pr_info(">>%s:%d %dx%d-%d@%d\n", __func__, __LINE__, mode->xres, mode->yres, mode->bpp, mode->refresh);
+ }
+ static int _connector_get_modes(struct drm_connector *connector) {
+     int width = 1920, height = 1080;
+     /*struct drm_display_mode *mode = drm_mode_create(dev);
+     mode->hdisplay = 320;
+     mode->vdisplay = 240;
+ 
+     mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+     drm_mode_set_name(mode);*/
+ 
+     //struct drm_display_mode *mode = drm_cvt_mode(connector->dev, width, height, 60, false, false, false);	// TODO: try GTF formula (drm_gtf_mode)
+     struct drm_display_mode *mode = drm_gtf_mode(connector->dev, width, height, 60, false, false);	// TODO: try GTF formula (drm_gtf_mode)
+ 
+     pr_info(">>%s:%d\n", __func__, __LINE__);
+     pr_cmdline_mode(&connector->cmdline_mode);
+     mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+     drm_mode_probed_add(connector, mode);
+ 
+     return 1;
+ }
+ static int _connector_mode_valid(struct drm_connector *connector, struct drm_display_mode *mode) {
+     //struct drm_device *dev = connector->dev;
+     int bpp = 32;
+ 
+     pr_info(">>%s:%d\n", __func__, __LINE__);
+     pr_cmdline_mode(&connector->cmdline_mode);
+     /*if ((mode->hdisplay % 8) != 0 || (mode->hsync_start % 8) != 0 || (mode->hsync_end % 8) != 0 || (mode->htotal % 8) != 0) {return MODE_H_ILLEGAL;}
+     if (mode->crtc_hdisplay > 2048 || mode->crtc_hsync_start > 4096 || mode->crtc_hsync_end > 4096 || mode->crtc_htotal > 4096 || mode->crtc_vdisplay > 2048 || mode->crtc_vsync_start > 4096 || mode->crtc_vsync_end > 4096 || mode->crtc_vtotal > 4096) {return MODE_BAD;}*/
+ 
+     if (connector->cmdline_mode.specified) {	// Validate the mode input by the user
+ 	if (connector->cmdline_mode.bpp_specified)
+ 		bpp = connector->cmdline_mode.bpp;
+     }
+     /*if ((mode->hdisplay * mode->vdisplay * (bpp/8)) > mdev->mc.vram_size) {
+ 	if (connector->cmdline_mode.specified)
+ 	    connector->cmdline_mode.specified = false;
+ 	return MODE_BAD;
+     }*/
+     return MODE_OK;
+ }
+ 
+ static struct drm_encoder *_connector_best_encoder(struct drm_connector *connector) {
+     int enc_id = connector->encoder_ids[0];
+     pr_info(">>%s:%d\n", __func__, __LINE__);
+     if (enc_id)
+ 	return drm_encoder_find(connector->dev, enc_id);
+     return NULL;
+ }
+ //static struct drm_encoder *_connector_best_encoder(struct drm_connector *connector) {return drm_encoder_find(connector->dev, connector->encoder_ids[0]);}
+ static const struct drm_connector_helper_funcs _connector_helper_funcs = {
+     .get_modes = _connector_get_modes,
+     .mode_valid = _connector_mode_valid,
+     .best_encoder = _connector_best_encoder,
+     //.best_encoder = drm_atomic_helper_best_encoder,
+ };
+ 
+ static enum drm_connector_status _connector_detect(struct drm_connector *connector, bool force) {
+     pr_info(">>%s:%d\n", __func__, __LINE__);
+     return connector_status_connected;
+ }
+ static const struct drm_connector_funcs _connector_funcs = {
+     .dpms = drm_helper_connector_dpms,
+     .detect = _connector_detect,
+     .fill_modes = drm_helper_probe_single_connector_modes,
+     .destroy = drm_connector_cleanup,
+ };
+ 
+ 
+ static struct drm_connector *_connector_init(struct drm_device *drm) {
+     struct _device *private =  drm->dev_private;
+     struct drm_connector *connector = &private->connector;
+ 
+     pr_info(">>%s:%d\n", __func__, __LINE__);
+     drm_connector_init(drm, connector, &_connector_funcs, DRM_MODE_CONNECTOR_VGA);
+     drm_connector_helper_add(connector, &_connector_helper_funcs);
+     drm_connector_register(connector);
+     return connector;
+ }
+ 
+ 
+ static const struct drm_mode_config_funcs mode_funcs = {
+     .fb_create = drm_fb_cma_create,
+ };
+ 
+ int _kms_init(struct drm_device *drm) {
+     //struct _device *private = drm->dev_private;
+     pr_info(">>%s:%d\n", __func__, __LINE__);
+     drm_mode_config_init(drm);
+     //
+     drm->mode_config.min_width = 0;
+     drm->mode_config.min_height = 0;
+     drm->mode_config.max_width = 1920;
+     drm->mode_config.max_height = 1080;
+     //
+     drm->mode_config.funcs = &mode_funcs;
+     // dumb ioctl
+     drm->mode_config.preferred_depth = 32;	//  here the place to change "bpp" global
+     drm->mode_config.prefer_shadow = 1;	// 0|1?
+     //
+     drm->mode_config.fb_base = pci_resource_start(drm->pdev, 0); //  to remove
+     //
+     _crtc_init(drm);
+ 
+     drm_mode_connector_attach_encoder(_connector_init(drm), _encoder_init(drm));
+     drm_mode_config_reset(drm);			// reset all the states of crtc/plane/encoder/connector*/
+     drm_helper_disable_unused_functions(drm);	// disable all the possible outputs/crtcs before entering KMS mode
+     drm_kms_helper_poll_init(drm);		// init kms poll for handling hpd
+ 
+     return 0;
+ }
+ 
+ void _kms_fini(struct drm_device *drm) {
+     pr_info(">>%s:%d\n", __func__, __LINE__);
+     drm_mode_config_cleanup(drm);
+ }
diff -rcNP linux-4.4.24/drivers/gpu/drm/smi/Makefile linux-4.4.24-baikal/drivers/gpu/drm/smi/Makefile
*** linux-4.4.24/drivers/gpu/drm/smi/Makefile	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/drivers/gpu/drm/smi/Makefile	2016-11-11 14:49:51.000000000 +0300
***************
*** 0 ****
--- 1,6 ----
+ ccflags-y := -Iinclude/drm
+ smi-y := drv.o kms.o
+ 
+ smi-$(CONFIG_DRM_FBDEV_EMULATION) += fbdev.o
+ 
+ obj-$(CONFIG_DRM_SMI) += smi.o
diff -rcNP linux-4.4.24/drivers/gpu/drm/smi/smi.h linux-4.4.24-baikal/drivers/gpu/drm/smi/smi.h
*** linux-4.4.24/drivers/gpu/drm/smi/smi.h	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/drivers/gpu/drm/smi/smi.h	2016-11-11 14:49:51.000000000 +0300
***************
*** 0 ****
--- 1,45 ----
+ #ifndef _SMI_H
+ #define _SMI_H
+ 
+ #include <linux/io.h>
+ #include <linux/fb.h>
+ #include <linux/console.h>
+ 
+ #include <drm/drmP.h>
+ #include <drm/drm_crtc.h>
+ #include <drm/drm_crtc_helper.h>
+ #include <drm/drm_fb_helper.h>
+ #include <drm/drm_fb_cma_helper.h>
+ #include <drm/drm_plane_helper.h>
+ #include <drm/drm_gem.h>
+ #include <drm/drm_legacy.h>
+ 
+ struct _device {
+     struct device	*dev;
+     struct drm_device	*drm;
+     //struct pci_dev	*pdev;
+ 
+ 
+     struct drm_plane plane;
+     struct drm_crtc crtc;
+ 
+     struct drm_encoder encoder;
+     struct drm_connector connector;
+ 
+     //struct drm_fbdev_cma *fbdev;
+     struct drm_fb_helper helper;
+     struct drm_framebuffer fb;
+ 
+     //drm_local_map_t *mmio;
+     //void __iomem *mmio;
+     //drm_local_map_t *fb;
+     drm_local_map_t *mmio;
+     //drm_local_map_t *aperture;	// sarea;? // video area??
+ };
+ 
+ #define DRIVER_NAME "smi"
+ 
+ int _kms_init(struct drm_device *drm);
+ void _kms_fini(struct drm_device *drm);
+ 
+ #endif /* _SMI_H */
\ В конце файла нет новой строки
diff -rcNP linux-4.4.24/drivers/irqchip/irq-mips-gic.c linux-4.4.24-baikal/drivers/irqchip/irq-mips-gic.c
*** linux-4.4.24/drivers/irqchip/irq-mips-gic.c	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/irqchip/irq-mips-gic.c	2016-11-11 14:49:51.000000000 +0300
***************
*** 229,234 ****
--- 229,350 ----
  }
  
  #endif
+ #ifdef CONFIG_WDT_MIPS_GIC
+ unsigned int gic_read_wd_ctrl(void)
+ {
+ 	return 	gic_read32(GIC_REG(VPE_LOCAL, GIC_VPE_WD_CONFIG0));
+ }
+ 
+ void gic_write_wd_ctrl(unsigned int ctrl)
+ {
+ 	gic_write32(GIC_REG(VPE_LOCAL, GIC_VPE_WD_CONFIG0), ctrl);
+ }
+ 
+ void gic_write_cpu_wd_ctrl(unsigned int ctrl, int cpu)
+ {
+ 	unsigned long flags;
+ 
+ 	local_irq_save(flags);
+ 
+ 	gic_write(GIC_REG(VPE_LOCAL, GIC_VPE_OTHER_ADDR), cpu);
+ 	gic_write32(GIC_REG(VPE_OTHER, GIC_VPE_WD_CONFIG0), ctrl);
+ 
+ 	local_irq_restore(flags);
+ }
+ void gic_start_wd(void)
+ {
+ 	u32 gicconfig;
+ 
+ 	/* Start watchdog */
+ 	gicconfig = gic_read32(GIC_REG(VPE_LOCAL, GIC_VPE_WD_CONFIG0));
+ 	gicconfig |= GIC_WD_CTRL_START_MSK;
+ 	gic_write32(GIC_REG(VPE_LOCAL, GIC_VPE_WD_CONFIG0), gicconfig);
+ }
+ 
+ void gic_start_cpu_wd(int cpu)
+ {
+ 	u32 gicconfig;
+ 	unsigned long flags;
+ 
+ 	local_irq_save(flags);
+ 
+ 	gic_write(GIC_REG(VPE_LOCAL, GIC_VPE_OTHER_ADDR), cpu);
+ 
+ 	/* Start watchdog */
+ 	gicconfig = gic_read32(GIC_REG(VPE_OTHER, GIC_VPE_WD_CONFIG0));
+ 	gicconfig |= GIC_WD_CTRL_START_MSK;
+ 	gic_write32(GIC_REG(VPE_OTHER, GIC_VPE_WD_CONFIG0), gicconfig);
+ 
+ 	local_irq_restore(flags);
+ }
+ 
+ void gic_stop_wd(void)
+ {
+ 	u32 gicconfig;
+ 
+ 	/* Stop watchdog */
+ 	gicconfig = gic_read32(GIC_REG(VPE_LOCAL, GIC_VPE_WD_CONFIG0));
+ 	gicconfig &= ~GIC_WD_CTRL_START_MSK;
+ 	gic_write32(GIC_REG(VPE_LOCAL, GIC_VPE_WD_CONFIG0), gicconfig);
+ }
+ 
+ void gic_stop_cpu_wd(int cpu)
+ {
+ 	u32 gicconfig;
+ 	unsigned long flags;
+ 
+ 	local_irq_save(flags);
+ 
+ 	gic_write(GIC_REG(VPE_LOCAL, GIC_VPE_OTHER_ADDR), cpu);
+ 
+ 	/* Start watchdog */
+ 	gicconfig = gic_read32(GIC_REG(VPE_OTHER, GIC_VPE_WD_CONFIG0));
+ 	gicconfig &= ~GIC_WD_CTRL_START_MSK;
+ 	gic_write32(GIC_REG(VPE_OTHER, GIC_VPE_WD_CONFIG0), gicconfig);
+ 
+ 	local_irq_restore(flags);
+ }
+ 
+ unsigned int gic_read_wd_count(void)
+ {
+ 	return gic_read32(GIC_REG(VPE_LOCAL, GIC_VPE_WD_COUNT0));
+ }
+ 
+ unsigned int gic_read_wd_initial(void)
+ {
+ 	return gic_read32(GIC_REG(VPE_LOCAL, GIC_VPE_WD_INITIAL0));
+ }
+ 
+ void gic_write_wd_initial(unsigned int cnt)
+ {
+ 	unsigned int ctrl;
+ 
+ 	ctrl = gic_read32(GIC_REG(VPE_LOCAL, GIC_VPE_WD_CONFIG0));
+ 	gic_write32(GIC_REG(VPE_LOCAL, GIC_VPE_WD_CONFIG0),
+ 			ctrl & ~GIC_WD_CTRL_START_MSK);
+ 
+ 	gic_write32(GIC_REG(VPE_LOCAL, GIC_VPE_WD_INITIAL0), cnt);
+ 	gic_write32(GIC_REG(VPE_LOCAL, GIC_VPE_WD_CONFIG0), ctrl);
+ }
+ 
+ void gic_write_cpu_wd_initial(unsigned int cnt, int cpu)
+ {
+ 	unsigned long flags;
+ 	unsigned int ctrl; 
+ 
+ 	local_irq_save(flags);
+ 
+ 	gic_write(GIC_REG(VPE_LOCAL, GIC_VPE_OTHER_ADDR), cpu);
+ 
+ 	ctrl = gic_read32(GIC_REG(VPE_OTHER, GIC_VPE_WD_CONFIG0));
+ 	gic_write32(GIC_REG(VPE_OTHER, GIC_VPE_WD_CONFIG0),
+ 			ctrl & ~GIC_WD_CTRL_START_MSK);
+ 	gic_write32(GIC_REG(VPE_OTHER, GIC_VPE_WD_INITIAL0), cnt);
+ 	gic_write32(GIC_REG(VPE_OTHER, GIC_VPE_WD_CONFIG0), ctrl);
+ 
+ 	local_irq_restore(flags);
+ }
+ #endif
  
  static bool gic_local_irq_is_routable(int intr)
  {
***************
*** 269,274 ****
--- 385,396 ----
  	gic_write(GIC_REG(SHARED, GIC_SH_WEDGE), GIC_SH_WEDGE_SET(intr));
  }
  
+ int gic_get_c0_wd_int(void)
+ {
+ 	return irq_create_mapping(gic_irq_domain,
+ 				  GIC_LOCAL_TO_HWIRQ(GIC_LOCAL_INT_WD));
+ }
+ 
  int gic_get_c0_compare_int(void)
  {
  	if (!gic_local_irq_is_routable(GIC_LOCAL_INT_TIMER))
***************
*** 349,359 ****
  	while (intr != gic_shared_intrs) {
  		virq = irq_linear_revmap(gic_irq_domain,
  					 GIC_SHARED_TO_HWIRQ(intr));
  		if (chained)
  			generic_handle_irq(virq);
  		else
  			do_IRQ(virq);
! 
  		/* go to next pending bit */
  		bitmap_clear(pending, intr, 1);
  		intr = find_first_bit(pending, gic_shared_intrs);
--- 471,487 ----
  	while (intr != gic_shared_intrs) {
  		virq = irq_linear_revmap(gic_irq_domain,
  					 GIC_SHARED_TO_HWIRQ(intr));
+ 
+ 		if (!virq) {
+ 			pr_info("gic_handle_local_int: chained=%d  intr=%d  virq=%d\n", chained, intr, virq);
+ 			goto __next;
+ 		}
+ 
  		if (chained)
  			generic_handle_irq(virq);
  		else
  			do_IRQ(virq);
! __next:
  		/* go to next pending bit */
  		bitmap_clear(pending, intr, 1);
  		intr = find_first_bit(pending, gic_shared_intrs);
***************
*** 495,505 ****
  	while (intr != GIC_NUM_LOCAL_INTRS) {
  		virq = irq_linear_revmap(gic_irq_domain,
  					 GIC_LOCAL_TO_HWIRQ(intr));
  		if (chained)
  			generic_handle_irq(virq);
  		else
  			do_IRQ(virq);
! 
  		/* go to next pending bit */
  		bitmap_clear(&pending, intr, 1);
  		intr = find_first_bit(&pending, GIC_NUM_LOCAL_INTRS);
--- 623,637 ----
  	while (intr != GIC_NUM_LOCAL_INTRS) {
  		virq = irq_linear_revmap(gic_irq_domain,
  					 GIC_LOCAL_TO_HWIRQ(intr));
+ 		if (!virq) {
+ 			pr_info("gic_handle_local_int: chained=%d  intr=%d  virq=%d\n", chained, intr, virq);
+ 			goto __next;
+ 		}
  		if (chained)
  			generic_handle_irq(virq);
  		else
  			do_IRQ(virq);
! __next:
  		/* go to next pending bit */
  		bitmap_clear(&pending, intr, 1);
  		intr = find_first_bit(&pending, GIC_NUM_LOCAL_INTRS);
***************
*** 634,642 ****
--- 766,780 ----
  {
  	int i;
  
+ #ifdef CONFIG_MIPS_GIC_IPI_LOW
+ 	/* Use low 2 * NR_CPUS interrupts as IPIs */
+ 	gic_resched_int_base = 1;
+ 	gic_call_int_base = nr_cpu_ids + gic_resched_int_base;
+ #else
  	/* Use last 2 * NR_CPUS interrupts as IPIs */
  	gic_resched_int_base = gic_shared_intrs - nr_cpu_ids;
  	gic_call_int_base = gic_resched_int_base - nr_cpu_ids;
+ #endif
  
  	for (i = 0; i < nr_cpu_ids; i++) {
  		gic_ipi_init_one(gic_call_int_base + i, i, &irq_call);
***************
*** 809,814 ****
--- 947,953 ----
  			      struct device_node *node)
  {
  	unsigned int gicconfig;
+ 	int i;
  
  	__gic_base_addr = gic_base_addr;
  
***************
*** 827,832 ****
--- 966,978 ----
  		/* Always use vector 1 in EIC mode */
  		gic_cpu_pin = 0;
  		timer_cpu_pin = gic_cpu_pin;
+ 		for (i = 0; i < gic_vpes; i++) {
+ 			/* Set core other segment */
+ 			gic_write(GIC_REG(VPE_LOCAL, GIC_VPE_OTHER_ADDR), i);
+ 			/* Set EIC mode */
+ 			gic_write(GIC_REG(VPE_OTHER, GIC_VPE_CTL), GIC_VPE_CTL_EIC_MODE_MSK);
+ 		}
+ 
  		set_vi_handler(gic_cpu_pin + GIC_PIN_TO_VEC_OFFSET,
  			       __gic_irq_dispatch);
  	} else {
diff -rcNP linux-4.4.24/drivers/mmc/host/Kconfig linux-4.4.24-baikal/drivers/mmc/host/Kconfig
*** linux-4.4.24/drivers/mmc/host/Kconfig	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/mmc/host/Kconfig	2016-11-11 14:49:52.000000000 +0300
***************
*** 482,488 ****
  
  config MMC_SPI
  	tristate "MMC/SD/SDIO over SPI"
! 	depends on SPI_MASTER && !HIGHMEM && HAS_DMA
  	select CRC7
  	select CRC_ITU_T
  	help
--- 482,488 ----
  
  config MMC_SPI
  	tristate "MMC/SD/SDIO over SPI"
! 	depends on SPI_MASTER && HAS_DMA
  	select CRC7
  	select CRC_ITU_T
  	help
diff -rcNP linux-4.4.24/drivers/net/ethernet/baikal/Kconfig linux-4.4.24-baikal/drivers/net/ethernet/baikal/Kconfig
*** linux-4.4.24/drivers/net/ethernet/baikal/Kconfig	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/drivers/net/ethernet/baikal/Kconfig	2016-11-11 14:49:52.000000000 +0300
***************
*** 0 ****
--- 1,35 ----
+ #
+ # AMD network device configuration
+ #
+ 
+ config NET_VENDOR_BAIKAL
+ 	bool "Baikal Electronics SoC"
+ 	default y
+ 	depends on ARCH_BAIKAL || MIPS_BAIKAL || ARM64_BAIKAL || \
+ 		   ARM64 || MIPS
+ 	---help---
+ 	  If you have a Baikal Electronics SoC with network (Ethernet)
+ 	  controller say Y.
+ 
+ 	  Note that the answer to this question does not directly affect
+ 	  the kernel: saying N will just case the configurator to skip all
+ 	  the questions regarding Baikal SoCs. If you say Y, you will be asked
+ 	  for your specific driver in the following questions.
+ 
+ if NET_VENDOR_BAIKAL
+ 
+ config BAIKAL_XGBE
+ 	tristate "Baikal 10GbE Ethernet driver"
+ 	depends on OF_NET && HAS_IOMEM
+ 	select PHYLIB
+ 	select BITREVERSE
+ 	select CRC32
+ 	select PTP_1588_CLOCK
+ 	---help---
+ 	  This driver supports the Baikal 10GbE Ethernet device found on an
+ 	  Baikal SoC.
+ 
+ 	  To compile this driver as a module, choose M here: the module
+ 	  will be called baikal-xgbe.
+ 
+ endif # NET_VENDOR_BAIKAL
diff -rcNP linux-4.4.24/drivers/net/ethernet/baikal/Makefile linux-4.4.24-baikal/drivers/net/ethernet/baikal/Makefile
*** linux-4.4.24/drivers/net/ethernet/baikal/Makefile	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/drivers/net/ethernet/baikal/Makefile	2016-11-11 14:49:52.000000000 +0300
***************
*** 0 ****
--- 1,5 ----
+ #
+ # Makefile for the Baikal network device drivers.
+ #
+ 
+ obj-$(CONFIG_BAIKAL_XGBE) += xgbe/
diff -rcNP linux-4.4.24/drivers/net/ethernet/baikal/xgbe/Makefile linux-4.4.24-baikal/drivers/net/ethernet/baikal/xgbe/Makefile
*** linux-4.4.24/drivers/net/ethernet/baikal/xgbe/Makefile	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/drivers/net/ethernet/baikal/xgbe/Makefile	2016-11-11 14:49:52.000000000 +0300
***************
*** 0 ****
--- 1,31 ----
+ # 
+ # MAkefile for Baikal Electronics 10Gb Ethernet driver
+ #
+ # Copyright (C) 2014-2016 Baikal Electronics JSC
+ # 
+ # Adopted by:
+ #   Dmitry Dunaev <dmitry.dunaev@baikalelectronics.ru>
+ #
+ # This program is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU General Public License
+ # as published by the Free Software Foundation; either version 2
+ # of the License, or (at your option) any later version.
+ #
+ # This program is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ # GNU General Public License for more details.
+ #
+ # You should have received a copy of the GNU General Public License
+ # along with this program; if not, write to the Free Software
+ # Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ #
+ 
+ 
+ obj-$(CONFIG_BAIKAL_XGBE) += baikal-xgbe.o
+ 
+ baikal-xgbe-objs := xgbe-main.o xgbe-drv.o xgbe-dev.o \
+ 		 xgbe-desc.o xgbe-ethtool.o xgbe-mdio.o \
+ 		 xgbe-ptp.o
+ 
+ baikal-xgbe-$(CONFIG_DEBUG_FS) += xgbe-debugfs.o
diff -rcNP linux-4.4.24/drivers/net/ethernet/baikal/xgbe/xgbe-common.h linux-4.4.24-baikal/drivers/net/ethernet/baikal/xgbe/xgbe-common.h
*** linux-4.4.24/drivers/net/ethernet/baikal/xgbe/xgbe-common.h	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/drivers/net/ethernet/baikal/xgbe/xgbe-common.h	2016-11-11 14:49:52.000000000 +0300
***************
*** 0 ****
--- 1,1397 ----
+ /*
+  * Baikal Electronics 10Gb Ethernet driver
+  *
+  * Based on AMD 10Gb Ethernet driver
+  * drivers/net/ethernet/amd/xgbe
+  *
+  * This file is available to you under your choice of the following two
+  * licenses:
+  *
+  * License 1: GPLv2
+  *
+  * Copyright (c) 2015,2016 Baikal Electronics JSC.
+  * Copyright (c) 2014 Advanced Micro Devices, Inc.
+  *
+  * Adopted by:
+  *   Dmitry Dunaev <dmitry.dunaev@baikalelectronics.ru>
+  *
+  * This file is free software; you may copy, redistribute and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation, either version 2 of the License, or (at
+  * your option) any later version.
+  *
+  * This file is distributed in the hope that it will be useful, but
+  * WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+  * General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+  *
+  * This file incorporates work covered by the following copyright and
+  * permission notice:
+  *     The Synopsys DWC ETHER XGMAC Software Driver and documentation
+  *     (hereinafter "Software") is an unsupported proprietary work of Synopsys,
+  *     Inc. unless otherwise expressly agreed to in writing between Synopsys
+  *     and you.
+  *
+  *     The Software IS NOT an item of Licensed Software or Licensed Product
+  *     under any End User Software License Agreement or Agreement for Licensed
+  *     Product with Synopsys or any supplement thereto.  Permission is hereby
+  *     granted, free of charge, to any person obtaining a copy of this software
+  *     annotated with this license and the Software, to deal in the Software
+  *     without restriction, including without limitation the rights to use,
+  *     copy, modify, merge, publish, distribute, sublicense, and/or sell copies
+  *     of the Software, and to permit persons to whom the Software is furnished
+  *     to do so, subject to the following conditions:
+  *
+  *     The above copyright notice and this permission notice shall be included
+  *     in all copies or substantial portions of the Software.
+  *
+  *     THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS"
+  *     BASIS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  *     TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  *     PARTICULAR PURPOSE ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS
+  *     BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  *     CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  *     SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  *     INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  *     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  *     ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  *     THE POSSIBILITY OF SUCH DAMAGE.
+  *
+  *
+  * License 2: Modified BSD
+  *
+  * Copyright (c) 2015,2016 Baikal Electronics JSC.
+  * Copyright (c) 2014 Advanced Micro Devices, Inc.
+  * All rights reserved.
+  *
+  * Redistribution and use in source and binary forms, with or without
+  * modification, are permitted provided that the following conditions are met:
+  *     * Redistributions of source code must retain the above copyright
+  *       notice, this list of conditions and the following disclaimer.
+  *     * Redistributions in binary form must reproduce the above copyright
+  *       notice, this list of conditions and the following disclaimer in the
+  *       documentation and/or other materials provided with the distribution.
+  *     * Neither the name of Advanced Micro Devices, Inc. nor the
+  *       names of its contributors may be used to endorse or promote products
+  *       derived from this software without specific prior written permission.
+  *
+  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+  * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
+  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+  *
+  * This file incorporates work covered by the following copyright and
+  * permission notice:
+  *     The Synopsys DWC ETHER XGMAC Software Driver and documentation
+  *     (hereinafter "Software") is an unsupported proprietary work of Synopsys,
+  *     Inc. unless otherwise expressly agreed to in writing between Synopsys
+  *     and you.
+  *
+  *     The Software IS NOT an item of Licensed Software or Licensed Product
+  *     under any End User Software License Agreement or Agreement for Licensed
+  *     Product with Synopsys or any supplement thereto.  Permission is hereby
+  *     granted, free of charge, to any person obtaining a copy of this software
+  *     annotated with this license and the Software, to deal in the Software
+  *     without restriction, including without limitation the rights to use,
+  *     copy, modify, merge, publish, distribute, sublicense, and/or sell copies
+  *     of the Software, and to permit persons to whom the Software is furnished
+  *     to do so, subject to the following conditions:
+  *
+  *     The above copyright notice and this permission notice shall be included
+  *     in all copies or substantial portions of the Software.
+  *
+  *     THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS"
+  *     BASIS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  *     TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  *     PARTICULAR PURPOSE ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS
+  *     BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  *     CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  *     SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  *     INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  *     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  *     ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  *     THE POSSIBILITY OF SUCH DAMAGE.
+  */
+ 
+ #ifndef __XGBE_COMMON_H__
+ #define __XGBE_COMMON_H__
+ 
+ /* DMA register offsets */
+ #define DMA_MR				0x3000
+ #define DMA_SBMR			0x3004
+ #define DMA_ISR				0x3008
+ #define DMA_AXIARCR			0x3010
+ #define DMA_AXIAWCR			0x3018
+ #define DMA_DSR0			0x3020
+ #define DMA_DSR1			0x3024
+ 
+ /* DMA register entry bit positions and sizes */
+ #define DMA_AXIARCR_DRC_INDEX		0
+ #define DMA_AXIARCR_DRC_WIDTH		4
+ #define DMA_AXIARCR_DRD_INDEX		4
+ #define DMA_AXIARCR_DRD_WIDTH		2
+ #define DMA_AXIARCR_TEC_INDEX		8
+ #define DMA_AXIARCR_TEC_WIDTH		4
+ #define DMA_AXIARCR_TED_INDEX		12
+ #define DMA_AXIARCR_TED_WIDTH		2
+ #define DMA_AXIARCR_THC_INDEX		16
+ #define DMA_AXIARCR_THC_WIDTH		4
+ #define DMA_AXIARCR_THD_INDEX		20
+ #define DMA_AXIARCR_THD_WIDTH		2
+ #define DMA_AXIAWCR_DWC_INDEX		0
+ #define DMA_AXIAWCR_DWC_WIDTH		4
+ #define DMA_AXIAWCR_DWD_INDEX		4
+ #define DMA_AXIAWCR_DWD_WIDTH		2
+ #define DMA_AXIAWCR_RPC_INDEX		8
+ #define DMA_AXIAWCR_RPC_WIDTH		4
+ #define DMA_AXIAWCR_RPD_INDEX		12
+ #define DMA_AXIAWCR_RPD_WIDTH		2
+ #define DMA_AXIAWCR_RHC_INDEX		16
+ #define DMA_AXIAWCR_RHC_WIDTH		4
+ #define DMA_AXIAWCR_RHD_INDEX		20
+ #define DMA_AXIAWCR_RHD_WIDTH		2
+ #define DMA_AXIAWCR_TDC_INDEX		24
+ #define DMA_AXIAWCR_TDC_WIDTH		4
+ #define DMA_AXIAWCR_TDD_INDEX		28
+ #define DMA_AXIAWCR_TDD_WIDTH		2
+ #define DMA_ISR_MACIS_INDEX		17
+ #define DMA_ISR_MACIS_WIDTH		1
+ #define DMA_ISR_MTLIS_INDEX		16
+ #define DMA_ISR_MTLIS_WIDTH		1
+ #define DMA_MR_SWR_INDEX		0
+ #define DMA_MR_SWR_WIDTH		1
+ #define DMA_SBMR_EAME_INDEX		11
+ #define DMA_SBMR_EAME_WIDTH		1
+ #define DMA_SBMR_BLEN_16_INDEX		3
+ #define DMA_SBMR_BLEN_16_WIDTH		1
+ #define DMA_SBMR_BLEN_256_INDEX		7
+ #define DMA_SBMR_BLEN_256_WIDTH		1
+ #define DMA_SBMR_UNDEF_INDEX		0
+ #define DMA_SBMR_UNDEF_WIDTH		1
+ 
+ /* DMA register values */
+ #define DMA_DSR_RPS_WIDTH		4
+ #define DMA_DSR_TPS_WIDTH		4
+ #define DMA_DSR_Q_WIDTH			(DMA_DSR_RPS_WIDTH + DMA_DSR_TPS_WIDTH)
+ #define DMA_DSR0_RPS_START		8
+ #define DMA_DSR0_TPS_START		12
+ #define DMA_DSRX_FIRST_QUEUE		3
+ #define DMA_DSRX_INC			4
+ #define DMA_DSRX_QPR			4
+ #define DMA_DSRX_RPS_START		0
+ #define DMA_DSRX_TPS_START		4
+ #define DMA_TPS_STOPPED			0x00
+ #define DMA_TPS_SUSPENDED		0x06
+ 
+ /* DMA channel register offsets
+  *   Multiple channels can be active.  The first channel has registers
+  *   that begin at 0x3100.  Each subsequent channel has registers that
+  *   are accessed using an offset of 0x80 from the previous channel.
+  */
+ #define DMA_CH_BASE			0x3100
+ #define DMA_CH_INC			0x80
+ 
+ #define DMA_CH_CR			0x00
+ #define DMA_CH_TCR			0x04
+ #define DMA_CH_RCR			0x08
+ #define DMA_CH_TDLR_HI			0x10
+ #define DMA_CH_TDLR_LO			0x14
+ #define DMA_CH_RDLR_HI			0x18
+ #define DMA_CH_RDLR_LO			0x1c
+ #define DMA_CH_TDTR_LO			0x24
+ #define DMA_CH_RDTR_LO			0x2c
+ #define DMA_CH_TDRLR			0x30
+ #define DMA_CH_RDRLR			0x34
+ #define DMA_CH_IER			0x38
+ #define DMA_CH_RIWT			0x3c
+ #define DMA_CH_CATDR_LO			0x44
+ #define DMA_CH_CARDR_LO			0x4c
+ #define DMA_CH_CATBR_HI			0x50
+ #define DMA_CH_CATBR_LO			0x54
+ #define DMA_CH_CARBR_HI			0x58
+ #define DMA_CH_CARBR_LO			0x5c
+ #define DMA_CH_SR			0x60
+ 
+ /* DMA channel register entry bit positions and sizes */
+ #define DMA_CH_CR_PBLX8_INDEX		16
+ #define DMA_CH_CR_PBLX8_WIDTH		1
+ #define DMA_CH_CR_SPH_INDEX		24
+ #define DMA_CH_CR_SPH_WIDTH		1
+ #define DMA_CH_IER_AIE_INDEX		15
+ #define DMA_CH_IER_AIE_WIDTH		1
+ #define DMA_CH_IER_FBEE_INDEX		12
+ #define DMA_CH_IER_FBEE_WIDTH		1
+ #define DMA_CH_IER_NIE_INDEX		16
+ #define DMA_CH_IER_NIE_WIDTH		1
+ #define DMA_CH_IER_RBUE_INDEX		7
+ #define DMA_CH_IER_RBUE_WIDTH		1
+ #define DMA_CH_IER_RIE_INDEX		6
+ #define DMA_CH_IER_RIE_WIDTH		1
+ #define DMA_CH_IER_RSE_INDEX		8
+ #define DMA_CH_IER_RSE_WIDTH		1
+ #define DMA_CH_IER_TBUE_INDEX		2
+ #define DMA_CH_IER_TBUE_WIDTH		1
+ #define DMA_CH_IER_TIE_INDEX		0
+ #define DMA_CH_IER_TIE_WIDTH		1
+ #define DMA_CH_IER_TXSE_INDEX		1
+ #define DMA_CH_IER_TXSE_WIDTH		1
+ #define DMA_CH_RCR_PBL_INDEX		16
+ #define DMA_CH_RCR_PBL_WIDTH		6
+ #define DMA_CH_RCR_RBSZ_INDEX		1
+ #define DMA_CH_RCR_RBSZ_WIDTH		14
+ #define DMA_CH_RCR_SR_INDEX		0
+ #define DMA_CH_RCR_SR_WIDTH		1
+ #define DMA_CH_RIWT_RWT_INDEX		0
+ #define DMA_CH_RIWT_RWT_WIDTH		8
+ #define DMA_CH_SR_FBE_INDEX		12
+ #define DMA_CH_SR_FBE_WIDTH		1
+ #define DMA_CH_SR_RBU_INDEX		7
+ #define DMA_CH_SR_RBU_WIDTH		1
+ #define DMA_CH_SR_RI_INDEX		6
+ #define DMA_CH_SR_RI_WIDTH		1
+ #define DMA_CH_SR_RPS_INDEX		8
+ #define DMA_CH_SR_RPS_WIDTH		1
+ #define DMA_CH_SR_TBU_INDEX		2
+ #define DMA_CH_SR_TBU_WIDTH		1
+ #define DMA_CH_SR_TI_INDEX		0
+ #define DMA_CH_SR_TI_WIDTH		1
+ #define DMA_CH_SR_TPS_INDEX		1
+ #define DMA_CH_SR_TPS_WIDTH		1
+ #define DMA_CH_TCR_OSP_INDEX		4
+ #define DMA_CH_TCR_OSP_WIDTH		1
+ #define DMA_CH_TCR_PBL_INDEX		16
+ #define DMA_CH_TCR_PBL_WIDTH		6
+ #define DMA_CH_TCR_ST_INDEX		0
+ #define DMA_CH_TCR_ST_WIDTH		1
+ #define DMA_CH_TCR_TSE_INDEX		12
+ #define DMA_CH_TCR_TSE_WIDTH		1
+ 
+ /* DMA channel register values */
+ #define DMA_OSP_DISABLE			0x00
+ #define DMA_OSP_ENABLE			0x01
+ #define DMA_PBL_1			1
+ #define DMA_PBL_2			2
+ #define DMA_PBL_4			4
+ #define DMA_PBL_8			8
+ #define DMA_PBL_16			16
+ #define DMA_PBL_32			32
+ #define DMA_PBL_64			64      /* 8 x 8 */
+ #define DMA_PBL_128			128     /* 8 x 16 */
+ #define DMA_PBL_256			256     /* 8 x 32 */
+ #define DMA_PBL_X8_DISABLE		0x00
+ #define DMA_PBL_X8_ENABLE		0x01
+ 
+ /* MAC register offsets */
+ #define MAC_TCR				0x0000
+ #define MAC_RCR				0x0004
+ #define MAC_PFR				0x0008
+ #define MAC_WTR				0x000c
+ #define MAC_HTR0			0x0010
+ #define MAC_VLANTR			0x0050
+ #define MAC_VLANHTR			0x0058
+ #define MAC_VLANIR			0x0060
+ #define MAC_IVLANIR			0x0064
+ #define MAC_RETMR			0x006c
+ #define MAC_Q0TFCR			0x0070
+ #define MAC_RFCR			0x0090
+ #define MAC_RQC0R			0x00a0
+ #define MAC_RQC1R			0x00a4
+ #define MAC_RQC2R			0x00a8
+ #define MAC_RQC3R			0x00ac
+ #define MAC_ISR				0x00b0
+ #define MAC_IER				0x00b4
+ #define MAC_RTSR			0x00b8
+ #define MAC_PMTCSR			0x00c0
+ #define MAC_RWKPFR			0x00c4
+ #define MAC_LPICSR			0x00d0
+ #define MAC_LPITCR			0x00d4
+ #define MAC_VR				0x0110
+ #define MAC_DR				0x0114
+ #define MAC_HWF0R			0x011c
+ #define MAC_HWF1R			0x0120
+ #define MAC_HWF2R			0x0124
+ #define MAC_GPIOCR			0x0278
+ #define MAC_GPIOSR			0x027c
+ #define MAC_MACA0HR			0x0300
+ #define MAC_MACA0LR			0x0304
+ #define MAC_MACA1HR			0x0308
+ #define MAC_MACA1LR			0x030c
+ #define MAC_RSSCR			0x0c80
+ #define MAC_RSSAR			0x0c88
+ #define MAC_RSSDR			0x0c8c
+ #define MAC_TSCR			0x0d00
+ #define MAC_SSIR			0x0d04
+ #define MAC_STSR			0x0d08
+ #define MAC_STNR			0x0d0c
+ #define MAC_STSUR			0x0d10
+ #define MAC_STNUR			0x0d14
+ #define MAC_TSAR			0x0d18
+ #define MAC_TSSR			0x0d20
+ #define MAC_TXSNR			0x0d30
+ #define MAC_TXSSR			0x0d34
+ 
+ #define MAC_QTFCR_INC			4
+ #define MAC_MACA_INC			4
+ #define MAC_HTR_INC			4
+ 
+ #define MAC_RQC2_INC			4
+ #define MAC_RQC2_Q_PER_REG		4
+ 
+ /* MAC register entry bit positions and sizes */
+ #define MAC_HWF0R_ADDMACADRSEL_INDEX	18
+ #define MAC_HWF0R_ADDMACADRSEL_WIDTH	5
+ #define MAC_HWF0R_ARPOFFSEL_INDEX	9
+ #define MAC_HWF0R_ARPOFFSEL_WIDTH	1
+ #define MAC_HWF0R_EEESEL_INDEX		13
+ #define MAC_HWF0R_EEESEL_WIDTH		1
+ #define MAC_HWF0R_GMIISEL_INDEX		1
+ #define MAC_HWF0R_GMIISEL_WIDTH		1
+ #define MAC_HWF0R_MGKSEL_INDEX		7
+ #define MAC_HWF0R_MGKSEL_WIDTH		1
+ #define MAC_HWF0R_MMCSEL_INDEX		8
+ #define MAC_HWF0R_MMCSEL_WIDTH		1
+ #define MAC_HWF0R_RWKSEL_INDEX		6
+ #define MAC_HWF0R_RWKSEL_WIDTH		1
+ #define MAC_HWF0R_RXCOESEL_INDEX	16
+ #define MAC_HWF0R_RXCOESEL_WIDTH	1
+ #define MAC_HWF0R_SAVLANINS_INDEX	27
+ #define MAC_HWF0R_SAVLANINS_WIDTH	1
+ #define MAC_HWF0R_SMASEL_INDEX		5
+ #define MAC_HWF0R_SMASEL_WIDTH		1
+ #define MAC_HWF0R_TSSEL_INDEX		12
+ #define MAC_HWF0R_TSSEL_WIDTH		1
+ #define MAC_HWF0R_TSSTSSEL_INDEX	25
+ #define MAC_HWF0R_TSSTSSEL_WIDTH	2
+ #define MAC_HWF0R_TXCOESEL_INDEX	14
+ #define MAC_HWF0R_TXCOESEL_WIDTH	1
+ #define MAC_HWF0R_VLHASH_INDEX		4
+ #define MAC_HWF0R_VLHASH_WIDTH		1
+ #define MAC_HWF1R_ADDR64_INDEX		14
+ #define MAC_HWF1R_ADDR64_WIDTH		2
+ #define MAC_HWF1R_ADVTHWORD_INDEX	13
+ #define MAC_HWF1R_ADVTHWORD_WIDTH	1
+ #define MAC_HWF1R_DBGMEMA_INDEX		19
+ #define MAC_HWF1R_DBGMEMA_WIDTH		1
+ #define MAC_HWF1R_DCBEN_INDEX		16
+ #define MAC_HWF1R_DCBEN_WIDTH		1
+ #define MAC_HWF1R_HASHTBLSZ_INDEX	24
+ #define MAC_HWF1R_HASHTBLSZ_WIDTH	3
+ #define MAC_HWF1R_L3L4FNUM_INDEX	27
+ #define MAC_HWF1R_L3L4FNUM_WIDTH	4
+ #define MAC_HWF1R_NUMTC_INDEX		21
+ #define MAC_HWF1R_NUMTC_WIDTH		3
+ #define MAC_HWF1R_RSSEN_INDEX		20
+ #define MAC_HWF1R_RSSEN_WIDTH		1
+ #define MAC_HWF1R_RXFIFOSIZE_INDEX	0
+ #define MAC_HWF1R_RXFIFOSIZE_WIDTH	5
+ #define MAC_HWF1R_SPHEN_INDEX		17
+ #define MAC_HWF1R_SPHEN_WIDTH		1
+ #define MAC_HWF1R_TSOEN_INDEX		18
+ #define MAC_HWF1R_TSOEN_WIDTH		1
+ #define MAC_HWF1R_TXFIFOSIZE_INDEX	6
+ #define MAC_HWF1R_TXFIFOSIZE_WIDTH	5
+ #define MAC_HWF2R_AUXSNAPNUM_INDEX	28
+ #define MAC_HWF2R_AUXSNAPNUM_WIDTH	3
+ #define MAC_HWF2R_PPSOUTNUM_INDEX	24
+ #define MAC_HWF2R_PPSOUTNUM_WIDTH	3
+ #define MAC_HWF2R_RXCHCNT_INDEX		12
+ #define MAC_HWF2R_RXCHCNT_WIDTH		4
+ #define MAC_HWF2R_RXQCNT_INDEX		0
+ #define MAC_HWF2R_RXQCNT_WIDTH		4
+ #define MAC_HWF2R_TXCHCNT_INDEX		18
+ #define MAC_HWF2R_TXCHCNT_WIDTH		4
+ #define MAC_HWF2R_TXQCNT_INDEX		6
+ #define MAC_HWF2R_TXQCNT_WIDTH		4
+ #define MAC_IER_TSIE_INDEX		12
+ #define MAC_IER_TSIE_WIDTH		1
+ #define MAC_ISR_MMCRXIS_INDEX		9
+ #define MAC_ISR_MMCRXIS_WIDTH		1
+ #define MAC_ISR_MMCTXIS_INDEX		10
+ #define MAC_ISR_MMCTXIS_WIDTH		1
+ #define MAC_ISR_PMTIS_INDEX		4
+ #define MAC_ISR_PMTIS_WIDTH		1
+ #define MAC_ISR_TSIS_INDEX		12
+ #define MAC_ISR_TSIS_WIDTH		1
+ #define MAC_MACA1HR_AE_INDEX		31
+ #define MAC_MACA1HR_AE_WIDTH		1
+ #define MAC_PFR_HMC_INDEX		2
+ #define MAC_PFR_HMC_WIDTH		1
+ #define MAC_PFR_HPF_INDEX		10
+ #define MAC_PFR_HPF_WIDTH		1
+ #define MAC_PFR_HUC_INDEX		1
+ #define MAC_PFR_HUC_WIDTH		1
+ #define MAC_PFR_PM_INDEX		4
+ #define MAC_PFR_PM_WIDTH		1
+ #define MAC_PFR_PR_INDEX		0
+ #define MAC_PFR_PR_WIDTH		1
+ #define MAC_PFR_VTFE_INDEX		16
+ #define MAC_PFR_VTFE_WIDTH		1
+ #define MAC_PMTCSR_MGKPKTEN_INDEX	1
+ #define MAC_PMTCSR_MGKPKTEN_WIDTH	1
+ #define MAC_PMTCSR_PWRDWN_INDEX		0
+ #define MAC_PMTCSR_PWRDWN_WIDTH		1
+ #define MAC_PMTCSR_RWKFILTRST_INDEX	31
+ #define MAC_PMTCSR_RWKFILTRST_WIDTH	1
+ #define MAC_PMTCSR_RWKPKTEN_INDEX	2
+ #define MAC_PMTCSR_RWKPKTEN_WIDTH	1
+ #define MAC_Q0TFCR_PT_INDEX		16
+ #define MAC_Q0TFCR_PT_WIDTH		16
+ #define MAC_Q0TFCR_TFE_INDEX		1
+ #define MAC_Q0TFCR_TFE_WIDTH		1
+ #define MAC_RCR_ACS_INDEX		1
+ #define MAC_RCR_ACS_WIDTH		1
+ #define MAC_RCR_CST_INDEX		2
+ #define MAC_RCR_CST_WIDTH		1
+ #define MAC_RCR_DCRCC_INDEX		3
+ #define MAC_RCR_DCRCC_WIDTH		1
+ #define MAC_RCR_HDSMS_INDEX		12
+ #define MAC_RCR_HDSMS_WIDTH		3
+ #define MAC_RCR_IPC_INDEX		9
+ #define MAC_RCR_IPC_WIDTH		1
+ #define MAC_RCR_JE_INDEX		8
+ #define MAC_RCR_JE_WIDTH		1
+ #define MAC_RCR_LM_INDEX		10
+ #define MAC_RCR_LM_WIDTH		1
+ #define MAC_RCR_RE_INDEX		0
+ #define MAC_RCR_RE_WIDTH		1
+ #define MAC_RFCR_PFCE_INDEX		8
+ #define MAC_RFCR_PFCE_WIDTH		1
+ #define MAC_RFCR_RFE_INDEX		0
+ #define MAC_RFCR_RFE_WIDTH		1
+ #define MAC_RFCR_UP_INDEX		1
+ #define MAC_RFCR_UP_WIDTH		1
+ #define MAC_RQC0R_RXQ0EN_INDEX		0
+ #define MAC_RQC0R_RXQ0EN_WIDTH		2
+ #define MAC_RSSAR_ADDRT_INDEX		2
+ #define MAC_RSSAR_ADDRT_WIDTH		1
+ #define MAC_RSSAR_CT_INDEX		1
+ #define MAC_RSSAR_CT_WIDTH		1
+ #define MAC_RSSAR_OB_INDEX		0
+ #define MAC_RSSAR_OB_WIDTH		1
+ #define MAC_RSSAR_RSSIA_INDEX		8
+ #define MAC_RSSAR_RSSIA_WIDTH		8
+ #define MAC_RSSCR_IP2TE_INDEX		1
+ #define MAC_RSSCR_IP2TE_WIDTH		1
+ #define MAC_RSSCR_RSSE_INDEX		0
+ #define MAC_RSSCR_RSSE_WIDTH		1
+ #define MAC_RSSCR_TCP4TE_INDEX		2
+ #define MAC_RSSCR_TCP4TE_WIDTH		1
+ #define MAC_RSSCR_UDP4TE_INDEX		3
+ #define MAC_RSSCR_UDP4TE_WIDTH		1
+ #define MAC_RSSDR_DMCH_INDEX		0
+ #define MAC_RSSDR_DMCH_WIDTH		4
+ #define MAC_SSIR_SNSINC_INDEX		8
+ #define MAC_SSIR_SNSINC_WIDTH		8
+ #define MAC_SSIR_SSINC_INDEX		16
+ #define MAC_SSIR_SSINC_WIDTH		8
+ #define MAC_TCR_SS_INDEX		29
+ #define MAC_TCR_SS_WIDTH		2
+ #define MAC_TCR_TE_INDEX		0
+ #define MAC_TCR_TE_WIDTH		1
+ #define MAC_TSCR_AV8021ASMEN_INDEX	28
+ #define MAC_TSCR_AV8021ASMEN_WIDTH	1
+ #define MAC_TSCR_SNAPTYPSEL_INDEX	16
+ #define MAC_TSCR_SNAPTYPSEL_WIDTH	2
+ #define MAC_TSCR_TSADDREG_INDEX		5
+ #define MAC_TSCR_TSADDREG_WIDTH		1
+ #define MAC_TSCR_TSCFUPDT_INDEX		1
+ #define MAC_TSCR_TSCFUPDT_WIDTH		1
+ #define MAC_TSCR_TSCTRLSSR_INDEX	9
+ #define MAC_TSCR_TSCTRLSSR_WIDTH	1
+ #define MAC_TSCR_TSENA_INDEX		0
+ #define MAC_TSCR_TSENA_WIDTH		1
+ #define MAC_TSCR_TSENALL_INDEX		8
+ #define MAC_TSCR_TSENALL_WIDTH		1
+ #define MAC_TSCR_TSEVNTENA_INDEX	14
+ #define MAC_TSCR_TSEVNTENA_WIDTH	1
+ #define MAC_TSCR_TSINIT_INDEX		2
+ #define MAC_TSCR_TSINIT_WIDTH		1
+ #define MAC_TSCR_TSIPENA_INDEX		11
+ #define MAC_TSCR_TSIPENA_WIDTH		1
+ #define MAC_TSCR_TSIPV4ENA_INDEX	13
+ #define MAC_TSCR_TSIPV4ENA_WIDTH	1
+ #define MAC_TSCR_TSIPV6ENA_INDEX	12
+ #define MAC_TSCR_TSIPV6ENA_WIDTH	1
+ #define MAC_TSCR_TSMSTRENA_INDEX	15
+ #define MAC_TSCR_TSMSTRENA_WIDTH	1
+ #define MAC_TSCR_TSVER2ENA_INDEX	10
+ #define MAC_TSCR_TSVER2ENA_WIDTH	1
+ #define MAC_TSCR_TXTSSTSM_INDEX		24
+ #define MAC_TSCR_TXTSSTSM_WIDTH		1
+ #define MAC_TSSR_TXTSC_INDEX		15
+ #define MAC_TSSR_TXTSC_WIDTH		1
+ #define MAC_TXSNR_TXTSSTSMIS_INDEX	31
+ #define MAC_TXSNR_TXTSSTSMIS_WIDTH	1
+ #define MAC_VLANHTR_VLHT_INDEX		0
+ #define MAC_VLANHTR_VLHT_WIDTH		16
+ #define MAC_VLANIR_VLTI_INDEX		20
+ #define MAC_VLANIR_VLTI_WIDTH		1
+ #define MAC_VLANIR_CSVL_INDEX		19
+ #define MAC_VLANIR_CSVL_WIDTH		1
+ #define MAC_VLANTR_DOVLTC_INDEX		20
+ #define MAC_VLANTR_DOVLTC_WIDTH		1
+ #define MAC_VLANTR_ERSVLM_INDEX		19
+ #define MAC_VLANTR_ERSVLM_WIDTH		1
+ #define MAC_VLANTR_ESVL_INDEX		18
+ #define MAC_VLANTR_ESVL_WIDTH		1
+ #define MAC_VLANTR_ETV_INDEX		16
+ #define MAC_VLANTR_ETV_WIDTH		1
+ #define MAC_VLANTR_EVLS_INDEX		21
+ #define MAC_VLANTR_EVLS_WIDTH		2
+ #define MAC_VLANTR_EVLRXS_INDEX		24
+ #define MAC_VLANTR_EVLRXS_WIDTH		1
+ #define MAC_VLANTR_VL_INDEX		0
+ #define MAC_VLANTR_VL_WIDTH		16
+ #define MAC_VLANTR_VTHM_INDEX		25
+ #define MAC_VLANTR_VTHM_WIDTH		1
+ #define MAC_VLANTR_VTIM_INDEX		17
+ #define MAC_VLANTR_VTIM_WIDTH		1
+ #define MAC_VR_DEVID_INDEX		8
+ #define MAC_VR_DEVID_WIDTH		8
+ #define MAC_VR_SNPSVER_INDEX		0
+ #define MAC_VR_SNPSVER_WIDTH		8
+ #define MAC_VR_USERVER_INDEX		16
+ #define MAC_VR_USERVER_WIDTH		8
+ 
+ /* MMC register offsets */
+ #define MMC_CR				0x0800
+ #define MMC_RISR			0x0804
+ #define MMC_TISR			0x0808
+ #define MMC_RIER			0x080c
+ #define MMC_TIER			0x0810
+ #define MMC_TXOCTETCOUNT_GB_LO		0x0814
+ #define MMC_TXOCTETCOUNT_GB_HI		0x0818
+ #define MMC_TXFRAMECOUNT_GB_LO		0x081c
+ #define MMC_TXFRAMECOUNT_GB_HI		0x0820
+ #define MMC_TXBROADCASTFRAMES_G_LO	0x0824
+ #define MMC_TXBROADCASTFRAMES_G_HI	0x0828
+ #define MMC_TXMULTICASTFRAMES_G_LO	0x082c
+ #define MMC_TXMULTICASTFRAMES_G_HI	0x0830
+ #define MMC_TX64OCTETS_GB_LO		0x0834
+ #define MMC_TX64OCTETS_GB_HI		0x0838
+ #define MMC_TX65TO127OCTETS_GB_LO	0x083c
+ #define MMC_TX65TO127OCTETS_GB_HI	0x0840
+ #define MMC_TX128TO255OCTETS_GB_LO	0x0844
+ #define MMC_TX128TO255OCTETS_GB_HI	0x0848
+ #define MMC_TX256TO511OCTETS_GB_LO	0x084c
+ #define MMC_TX256TO511OCTETS_GB_HI	0x0850
+ #define MMC_TX512TO1023OCTETS_GB_LO	0x0854
+ #define MMC_TX512TO1023OCTETS_GB_HI	0x0858
+ #define MMC_TX1024TOMAXOCTETS_GB_LO	0x085c
+ #define MMC_TX1024TOMAXOCTETS_GB_HI	0x0860
+ #define MMC_TXUNICASTFRAMES_GB_LO	0x0864
+ #define MMC_TXUNICASTFRAMES_GB_HI	0x0868
+ #define MMC_TXMULTICASTFRAMES_GB_LO	0x086c
+ #define MMC_TXMULTICASTFRAMES_GB_HI	0x0870
+ #define MMC_TXBROADCASTFRAMES_GB_LO	0x0874
+ #define MMC_TXBROADCASTFRAMES_GB_HI	0x0878
+ #define MMC_TXUNDERFLOWERROR_LO		0x087c
+ #define MMC_TXUNDERFLOWERROR_HI		0x0880
+ #define MMC_TXOCTETCOUNT_G_LO		0x0884
+ #define MMC_TXOCTETCOUNT_G_HI		0x0888
+ #define MMC_TXFRAMECOUNT_G_LO		0x088c
+ #define MMC_TXFRAMECOUNT_G_HI		0x0890
+ #define MMC_TXPAUSEFRAMES_LO		0x0894
+ #define MMC_TXPAUSEFRAMES_HI		0x0898
+ #define MMC_TXVLANFRAMES_G_LO		0x089c
+ #define MMC_TXVLANFRAMES_G_HI		0x08a0
+ #define MMC_RXFRAMECOUNT_GB_LO		0x0900
+ #define MMC_RXFRAMECOUNT_GB_HI		0x0904
+ #define MMC_RXOCTETCOUNT_GB_LO		0x0908
+ #define MMC_RXOCTETCOUNT_GB_HI		0x090c
+ #define MMC_RXOCTETCOUNT_G_LO		0x0910
+ #define MMC_RXOCTETCOUNT_G_HI		0x0914
+ #define MMC_RXBROADCASTFRAMES_G_LO	0x0918
+ #define MMC_RXBROADCASTFRAMES_G_HI	0x091c
+ #define MMC_RXMULTICASTFRAMES_G_LO	0x0920
+ #define MMC_RXMULTICASTFRAMES_G_HI	0x0924
+ #define MMC_RXCRCERROR_LO		0x0928
+ #define MMC_RXCRCERROR_HI		0x092c
+ #define MMC_RXRUNTERROR			0x0930
+ #define MMC_RXJABBERERROR		0x0934
+ #define MMC_RXUNDERSIZE_G		0x0938
+ #define MMC_RXOVERSIZE_G		0x093c
+ #define MMC_RX64OCTETS_GB_LO		0x0940
+ #define MMC_RX64OCTETS_GB_HI		0x0944
+ #define MMC_RX65TO127OCTETS_GB_LO	0x0948
+ #define MMC_RX65TO127OCTETS_GB_HI	0x094c
+ #define MMC_RX128TO255OCTETS_GB_LO	0x0950
+ #define MMC_RX128TO255OCTETS_GB_HI	0x0954
+ #define MMC_RX256TO511OCTETS_GB_LO	0x0958
+ #define MMC_RX256TO511OCTETS_GB_HI	0x095c
+ #define MMC_RX512TO1023OCTETS_GB_LO	0x0960
+ #define MMC_RX512TO1023OCTETS_GB_HI	0x0964
+ #define MMC_RX1024TOMAXOCTETS_GB_LO	0x0968
+ #define MMC_RX1024TOMAXOCTETS_GB_HI	0x096c
+ #define MMC_RXUNICASTFRAMES_G_LO	0x0970
+ #define MMC_RXUNICASTFRAMES_G_HI	0x0974
+ #define MMC_RXLENGTHERROR_LO		0x0978
+ #define MMC_RXLENGTHERROR_HI		0x097c
+ #define MMC_RXOUTOFRANGETYPE_LO		0x0980
+ #define MMC_RXOUTOFRANGETYPE_HI		0x0984
+ #define MMC_RXPAUSEFRAMES_LO		0x0988
+ #define MMC_RXPAUSEFRAMES_HI		0x098c
+ #define MMC_RXFIFOOVERFLOW_LO		0x0990
+ #define MMC_RXFIFOOVERFLOW_HI		0x0994
+ #define MMC_RXVLANFRAMES_GB_LO		0x0998
+ #define MMC_RXVLANFRAMES_GB_HI		0x099c
+ #define MMC_RXWATCHDOGERROR		0x09a0
+ 
+ /* MMC register entry bit positions and sizes */
+ #define MMC_CR_CR_INDEX				0
+ #define MMC_CR_CR_WIDTH				1
+ #define MMC_CR_CSR_INDEX			1
+ #define MMC_CR_CSR_WIDTH			1
+ #define MMC_CR_ROR_INDEX			2
+ #define MMC_CR_ROR_WIDTH			1
+ #define MMC_CR_MCF_INDEX			3
+ #define MMC_CR_MCF_WIDTH			1
+ #define MMC_CR_MCT_INDEX			4
+ #define MMC_CR_MCT_WIDTH			2
+ #define MMC_RIER_ALL_INTERRUPTS_INDEX		0
+ #define MMC_RIER_ALL_INTERRUPTS_WIDTH		23
+ #define MMC_RISR_RXFRAMECOUNT_GB_INDEX		0
+ #define MMC_RISR_RXFRAMECOUNT_GB_WIDTH		1
+ #define MMC_RISR_RXOCTETCOUNT_GB_INDEX		1
+ #define MMC_RISR_RXOCTETCOUNT_GB_WIDTH		1
+ #define MMC_RISR_RXOCTETCOUNT_G_INDEX		2
+ #define MMC_RISR_RXOCTETCOUNT_G_WIDTH		1
+ #define MMC_RISR_RXBROADCASTFRAMES_G_INDEX	3
+ #define MMC_RISR_RXBROADCASTFRAMES_G_WIDTH	1
+ #define MMC_RISR_RXMULTICASTFRAMES_G_INDEX	4
+ #define MMC_RISR_RXMULTICASTFRAMES_G_WIDTH	1
+ #define MMC_RISR_RXCRCERROR_INDEX		5
+ #define MMC_RISR_RXCRCERROR_WIDTH		1
+ #define MMC_RISR_RXRUNTERROR_INDEX		6
+ #define MMC_RISR_RXRUNTERROR_WIDTH		1
+ #define MMC_RISR_RXJABBERERROR_INDEX		7
+ #define MMC_RISR_RXJABBERERROR_WIDTH		1
+ #define MMC_RISR_RXUNDERSIZE_G_INDEX		8
+ #define MMC_RISR_RXUNDERSIZE_G_WIDTH		1
+ #define MMC_RISR_RXOVERSIZE_G_INDEX		9
+ #define MMC_RISR_RXOVERSIZE_G_WIDTH		1
+ #define MMC_RISR_RX64OCTETS_GB_INDEX		10
+ #define MMC_RISR_RX64OCTETS_GB_WIDTH		1
+ #define MMC_RISR_RX65TO127OCTETS_GB_INDEX	11
+ #define MMC_RISR_RX65TO127OCTETS_GB_WIDTH	1
+ #define MMC_RISR_RX128TO255OCTETS_GB_INDEX	12
+ #define MMC_RISR_RX128TO255OCTETS_GB_WIDTH	1
+ #define MMC_RISR_RX256TO511OCTETS_GB_INDEX	13
+ #define MMC_RISR_RX256TO511OCTETS_GB_WIDTH	1
+ #define MMC_RISR_RX512TO1023OCTETS_GB_INDEX	14
+ #define MMC_RISR_RX512TO1023OCTETS_GB_WIDTH	1
+ #define MMC_RISR_RX1024TOMAXOCTETS_GB_INDEX	15
+ #define MMC_RISR_RX1024TOMAXOCTETS_GB_WIDTH	1
+ #define MMC_RISR_RXUNICASTFRAMES_G_INDEX	16
+ #define MMC_RISR_RXUNICASTFRAMES_G_WIDTH	1
+ #define MMC_RISR_RXLENGTHERROR_INDEX		17
+ #define MMC_RISR_RXLENGTHERROR_WIDTH		1
+ #define MMC_RISR_RXOUTOFRANGETYPE_INDEX		18
+ #define MMC_RISR_RXOUTOFRANGETYPE_WIDTH		1
+ #define MMC_RISR_RXPAUSEFRAMES_INDEX		19
+ #define MMC_RISR_RXPAUSEFRAMES_WIDTH		1
+ #define MMC_RISR_RXFIFOOVERFLOW_INDEX		20
+ #define MMC_RISR_RXFIFOOVERFLOW_WIDTH		1
+ #define MMC_RISR_RXVLANFRAMES_GB_INDEX		21
+ #define MMC_RISR_RXVLANFRAMES_GB_WIDTH		1
+ #define MMC_RISR_RXWATCHDOGERROR_INDEX		22
+ #define MMC_RISR_RXWATCHDOGERROR_WIDTH		1
+ #define MMC_TIER_ALL_INTERRUPTS_INDEX		0
+ #define MMC_TIER_ALL_INTERRUPTS_WIDTH		18
+ #define MMC_TISR_TXOCTETCOUNT_GB_INDEX		0
+ #define MMC_TISR_TXOCTETCOUNT_GB_WIDTH		1
+ #define MMC_TISR_TXFRAMECOUNT_GB_INDEX		1
+ #define MMC_TISR_TXFRAMECOUNT_GB_WIDTH		1
+ #define MMC_TISR_TXBROADCASTFRAMES_G_INDEX	2
+ #define MMC_TISR_TXBROADCASTFRAMES_G_WIDTH	1
+ #define MMC_TISR_TXMULTICASTFRAMES_G_INDEX	3
+ #define MMC_TISR_TXMULTICASTFRAMES_G_WIDTH	1
+ #define MMC_TISR_TX64OCTETS_GB_INDEX		4
+ #define MMC_TISR_TX64OCTETS_GB_WIDTH		1
+ #define MMC_TISR_TX65TO127OCTETS_GB_INDEX	5
+ #define MMC_TISR_TX65TO127OCTETS_GB_WIDTH	1
+ #define MMC_TISR_TX128TO255OCTETS_GB_INDEX	6
+ #define MMC_TISR_TX128TO255OCTETS_GB_WIDTH	1
+ #define MMC_TISR_TX256TO511OCTETS_GB_INDEX	7
+ #define MMC_TISR_TX256TO511OCTETS_GB_WIDTH	1
+ #define MMC_TISR_TX512TO1023OCTETS_GB_INDEX	8
+ #define MMC_TISR_TX512TO1023OCTETS_GB_WIDTH	1
+ #define MMC_TISR_TX1024TOMAXOCTETS_GB_INDEX	9
+ #define MMC_TISR_TX1024TOMAXOCTETS_GB_WIDTH	1
+ #define MMC_TISR_TXUNICASTFRAMES_GB_INDEX	10
+ #define MMC_TISR_TXUNICASTFRAMES_GB_WIDTH	1
+ #define MMC_TISR_TXMULTICASTFRAMES_GB_INDEX	11
+ #define MMC_TISR_TXMULTICASTFRAMES_GB_WIDTH	1
+ #define MMC_TISR_TXBROADCASTFRAMES_GB_INDEX	12
+ #define MMC_TISR_TXBROADCASTFRAMES_GB_WIDTH	1
+ #define MMC_TISR_TXUNDERFLOWERROR_INDEX		13
+ #define MMC_TISR_TXUNDERFLOWERROR_WIDTH		1
+ #define MMC_TISR_TXOCTETCOUNT_G_INDEX		14
+ #define MMC_TISR_TXOCTETCOUNT_G_WIDTH		1
+ #define MMC_TISR_TXFRAMECOUNT_G_INDEX		15
+ #define MMC_TISR_TXFRAMECOUNT_G_WIDTH		1
+ #define MMC_TISR_TXPAUSEFRAMES_INDEX		16
+ #define MMC_TISR_TXPAUSEFRAMES_WIDTH		1
+ #define MMC_TISR_TXVLANFRAMES_G_INDEX		17
+ #define MMC_TISR_TXVLANFRAMES_G_WIDTH		1
+ 
+ /* MTL register offsets */
+ #define MTL_OMR				0x1000
+ #define MTL_FDCR			0x1008
+ #define MTL_FDSR			0x100c
+ #define MTL_FDDR			0x1010
+ #define MTL_ISR				0x1020
+ #define MTL_RQDCM0R			0x1030
+ #define MTL_TCPM0R			0x1040
+ #define MTL_TCPM1R			0x1044
+ 
+ #define MTL_RQDCM_INC			4
+ #define MTL_RQDCM_Q_PER_REG		4
+ #define MTL_TCPM_INC			4
+ #define MTL_TCPM_TC_PER_REG		4
+ 
+ /* MTL register entry bit positions and sizes */
+ #define MTL_OMR_ETSALG_INDEX		5
+ #define MTL_OMR_ETSALG_WIDTH		2
+ #define MTL_OMR_RAA_INDEX		2
+ #define MTL_OMR_RAA_WIDTH		1
+ 
+ /* MTL queue register offsets
+  *   Multiple queues can be active.  The first queue has registers
+  *   that begin at 0x1100.  Each subsequent queue has registers that
+  *   are accessed using an offset of 0x80 from the previous queue.
+  */
+ #define MTL_Q_BASE			0x1100
+ #define MTL_Q_INC			0x80
+ 
+ #define MTL_Q_TQOMR			0x00
+ #define MTL_Q_TQUR			0x04
+ #define MTL_Q_TQDR			0x08
+ #define MTL_Q_RQOMR			0x40
+ #define MTL_Q_RQMPOCR			0x44
+ #define MTL_Q_RQDR			0x4c
+ #define MTL_Q_RQFCR			0x50
+ #define MTL_Q_IER			0x70
+ #define MTL_Q_ISR			0x74
+ 
+ /* MTL queue register entry bit positions and sizes */
+ #define MTL_Q_RQFCR_RFA_INDEX		1
+ #define MTL_Q_RQFCR_RFA_WIDTH		6
+ #define MTL_Q_RQFCR_RFD_INDEX		17
+ #define MTL_Q_RQFCR_RFD_WIDTH		6
+ #define MTL_Q_RQOMR_EHFC_INDEX		7
+ #define MTL_Q_RQOMR_EHFC_WIDTH		1
+ #define MTL_Q_RQOMR_RQS_INDEX		16
+ #define MTL_Q_RQOMR_RQS_WIDTH		9
+ #define MTL_Q_RQOMR_RSF_INDEX		5
+ #define MTL_Q_RQOMR_RSF_WIDTH		1
+ #define MTL_Q_RQOMR_RTC_INDEX		0
+ #define MTL_Q_RQOMR_RTC_WIDTH		2
+ #define MTL_Q_TQOMR_FTQ_INDEX		0
+ #define MTL_Q_TQOMR_FTQ_WIDTH		1
+ #define MTL_Q_TQOMR_Q2TCMAP_INDEX	8
+ #define MTL_Q_TQOMR_Q2TCMAP_WIDTH	3
+ #define MTL_Q_TQOMR_TQS_INDEX		16
+ #define MTL_Q_TQOMR_TQS_WIDTH		10
+ #define MTL_Q_TQOMR_TSF_INDEX		1
+ #define MTL_Q_TQOMR_TSF_WIDTH		1
+ #define MTL_Q_TQOMR_TTC_INDEX		4
+ #define MTL_Q_TQOMR_TTC_WIDTH		3
+ #define MTL_Q_TQOMR_TXQEN_INDEX		2
+ #define MTL_Q_TQOMR_TXQEN_WIDTH		2
+ 
+ /* MTL queue register value */
+ #define MTL_RSF_DISABLE			0x00
+ #define MTL_RSF_ENABLE			0x01
+ #define MTL_TSF_DISABLE			0x00
+ #define MTL_TSF_ENABLE			0x01
+ 
+ #define MTL_RX_THRESHOLD_64		0x00
+ #define MTL_RX_THRESHOLD_96		0x02
+ #define MTL_RX_THRESHOLD_128		0x03
+ #define MTL_TX_THRESHOLD_32		0x01
+ #define MTL_TX_THRESHOLD_64		0x00
+ #define MTL_TX_THRESHOLD_96		0x02
+ #define MTL_TX_THRESHOLD_128		0x03
+ #define MTL_TX_THRESHOLD_192		0x04
+ #define MTL_TX_THRESHOLD_256		0x05
+ #define MTL_TX_THRESHOLD_384		0x06
+ #define MTL_TX_THRESHOLD_512		0x07
+ 
+ #define MTL_ETSALG_WRR			0x00
+ #define MTL_ETSALG_WFQ			0x01
+ #define MTL_ETSALG_DWRR			0x02
+ #define MTL_RAA_SP			0x00
+ #define MTL_RAA_WSP			0x01
+ 
+ #define MTL_Q_DISABLED			0x00
+ #define MTL_Q_ENABLED			0x02
+ 
+ /* MTL traffic class register offsets
+  *   Multiple traffic classes can be active.  The first class has registers
+  *   that begin at 0x1100.  Each subsequent queue has registers that
+  *   are accessed using an offset of 0x80 from the previous queue.
+  */
+ #define MTL_TC_BASE			MTL_Q_BASE
+ #define MTL_TC_INC			MTL_Q_INC
+ 
+ #define MTL_TC_ETSCR			0x10
+ #define MTL_TC_ETSSR			0x14
+ #define MTL_TC_QWR			0x18
+ 
+ /* MTL traffic class register entry bit positions and sizes */
+ #define MTL_TC_ETSCR_TSA_INDEX		0
+ #define MTL_TC_ETSCR_TSA_WIDTH		2
+ #define MTL_TC_QWR_QW_INDEX		0
+ #define MTL_TC_QWR_QW_WIDTH		21
+ 
+ /* MTL traffic class register value */
+ #define MTL_TSA_SP			0x00
+ #define MTL_TSA_ETS			0x02
+ 
+ /* PCS MMD select register offset
+  *  The MMD select register is used for accessing PCS registers
+  *  when the underlying APB3 interface is using indirect addressing.
+  *  Indirect addressing requires accessing registers in two phases,
+  *  an address phase and a data phase.  The address phases requires
+  *  writing an address selection value to the MMD select regiesters.
+  */
+ #define PCS_MMD_SELECT			0xff
+ 
+ /* Descriptor/Packet entry bit positions and sizes */
+ #define RX_PACKET_ERRORS_CRC_INDEX		2
+ #define RX_PACKET_ERRORS_CRC_WIDTH		1
+ #define RX_PACKET_ERRORS_FRAME_INDEX		3
+ #define RX_PACKET_ERRORS_FRAME_WIDTH		1
+ #define RX_PACKET_ERRORS_LENGTH_INDEX		0
+ #define RX_PACKET_ERRORS_LENGTH_WIDTH		1
+ #define RX_PACKET_ERRORS_OVERRUN_INDEX		1
+ #define RX_PACKET_ERRORS_OVERRUN_WIDTH		1
+ 
+ #define RX_PACKET_ATTRIBUTES_CSUM_DONE_INDEX	0
+ #define RX_PACKET_ATTRIBUTES_CSUM_DONE_WIDTH	1
+ #define RX_PACKET_ATTRIBUTES_VLAN_CTAG_INDEX	1
+ #define RX_PACKET_ATTRIBUTES_VLAN_CTAG_WIDTH	1
+ #define RX_PACKET_ATTRIBUTES_INCOMPLETE_INDEX	2
+ #define RX_PACKET_ATTRIBUTES_INCOMPLETE_WIDTH	1
+ #define RX_PACKET_ATTRIBUTES_CONTEXT_NEXT_INDEX	3
+ #define RX_PACKET_ATTRIBUTES_CONTEXT_NEXT_WIDTH	1
+ #define RX_PACKET_ATTRIBUTES_CONTEXT_INDEX	4
+ #define RX_PACKET_ATTRIBUTES_CONTEXT_WIDTH	1
+ #define RX_PACKET_ATTRIBUTES_RX_TSTAMP_INDEX	5
+ #define RX_PACKET_ATTRIBUTES_RX_TSTAMP_WIDTH	1
+ #define RX_PACKET_ATTRIBUTES_RSS_HASH_INDEX	6
+ #define RX_PACKET_ATTRIBUTES_RSS_HASH_WIDTH	1
+ 
+ #define RX_NORMAL_DESC0_OVT_INDEX		0
+ #define RX_NORMAL_DESC0_OVT_WIDTH		16
+ #define RX_NORMAL_DESC2_HL_INDEX		0
+ #define RX_NORMAL_DESC2_HL_WIDTH		10
+ #define RX_NORMAL_DESC3_CDA_INDEX		27
+ #define RX_NORMAL_DESC3_CDA_WIDTH		1
+ #define RX_NORMAL_DESC3_CTXT_INDEX		30
+ #define RX_NORMAL_DESC3_CTXT_WIDTH		1
+ #define RX_NORMAL_DESC3_ES_INDEX		15
+ #define RX_NORMAL_DESC3_ES_WIDTH		1
+ #define RX_NORMAL_DESC3_ETLT_INDEX		16
+ #define RX_NORMAL_DESC3_ETLT_WIDTH		4
+ #define RX_NORMAL_DESC3_FD_INDEX		29
+ #define RX_NORMAL_DESC3_FD_WIDTH		1
+ #define RX_NORMAL_DESC3_INTE_INDEX		30
+ #define RX_NORMAL_DESC3_INTE_WIDTH		1
+ #define RX_NORMAL_DESC3_L34T_INDEX		20
+ #define RX_NORMAL_DESC3_L34T_WIDTH		4
+ #define RX_NORMAL_DESC3_LD_INDEX		28
+ #define RX_NORMAL_DESC3_LD_WIDTH		1
+ #define RX_NORMAL_DESC3_OWN_INDEX		31
+ #define RX_NORMAL_DESC3_OWN_WIDTH		1
+ #define RX_NORMAL_DESC3_PL_INDEX		0
+ #define RX_NORMAL_DESC3_PL_WIDTH		14
+ #define RX_NORMAL_DESC3_RSV_INDEX		26
+ #define RX_NORMAL_DESC3_RSV_WIDTH		1
+ 
+ #define RX_DESC3_L34T_IPV4_TCP			1
+ #define RX_DESC3_L34T_IPV4_UDP			2
+ #define RX_DESC3_L34T_IPV4_ICMP			3
+ #define RX_DESC3_L34T_IPV6_TCP			9
+ #define RX_DESC3_L34T_IPV6_UDP			10
+ #define RX_DESC3_L34T_IPV6_ICMP			11
+ 
+ #define RX_CONTEXT_DESC3_TSA_INDEX		4
+ #define RX_CONTEXT_DESC3_TSA_WIDTH		1
+ #define RX_CONTEXT_DESC3_TSD_INDEX		6
+ #define RX_CONTEXT_DESC3_TSD_WIDTH		1
+ 
+ #define TX_PACKET_ATTRIBUTES_CSUM_ENABLE_INDEX	0
+ #define TX_PACKET_ATTRIBUTES_CSUM_ENABLE_WIDTH	1
+ #define TX_PACKET_ATTRIBUTES_TSO_ENABLE_INDEX	1
+ #define TX_PACKET_ATTRIBUTES_TSO_ENABLE_WIDTH	1
+ #define TX_PACKET_ATTRIBUTES_VLAN_CTAG_INDEX	2
+ #define TX_PACKET_ATTRIBUTES_VLAN_CTAG_WIDTH	1
+ #define TX_PACKET_ATTRIBUTES_PTP_INDEX		3
+ #define TX_PACKET_ATTRIBUTES_PTP_WIDTH		1
+ 
+ #define TX_CONTEXT_DESC2_MSS_INDEX		0
+ #define TX_CONTEXT_DESC2_MSS_WIDTH		15
+ #define TX_CONTEXT_DESC3_CTXT_INDEX		30
+ #define TX_CONTEXT_DESC3_CTXT_WIDTH		1
+ #define TX_CONTEXT_DESC3_TCMSSV_INDEX		26
+ #define TX_CONTEXT_DESC3_TCMSSV_WIDTH		1
+ #define TX_CONTEXT_DESC3_VLTV_INDEX		16
+ #define TX_CONTEXT_DESC3_VLTV_WIDTH		1
+ #define TX_CONTEXT_DESC3_VT_INDEX		0
+ #define TX_CONTEXT_DESC3_VT_WIDTH		16
+ 
+ #define TX_NORMAL_DESC2_HL_B1L_INDEX		0
+ #define TX_NORMAL_DESC2_HL_B1L_WIDTH		14
+ #define TX_NORMAL_DESC2_IC_INDEX		31
+ #define TX_NORMAL_DESC2_IC_WIDTH		1
+ #define TX_NORMAL_DESC2_TTSE_INDEX		30
+ #define TX_NORMAL_DESC2_TTSE_WIDTH		1
+ #define TX_NORMAL_DESC2_VTIR_INDEX		14
+ #define TX_NORMAL_DESC2_VTIR_WIDTH		2
+ #define TX_NORMAL_DESC3_CIC_INDEX		16
+ #define TX_NORMAL_DESC3_CIC_WIDTH		2
+ #define TX_NORMAL_DESC3_CPC_INDEX		26
+ #define TX_NORMAL_DESC3_CPC_WIDTH		2
+ #define TX_NORMAL_DESC3_CTXT_INDEX		30
+ #define TX_NORMAL_DESC3_CTXT_WIDTH		1
+ #define TX_NORMAL_DESC3_FD_INDEX		29
+ #define TX_NORMAL_DESC3_FD_WIDTH		1
+ #define TX_NORMAL_DESC3_FL_INDEX		0
+ #define TX_NORMAL_DESC3_FL_WIDTH		15
+ #define TX_NORMAL_DESC3_LD_INDEX		28
+ #define TX_NORMAL_DESC3_LD_WIDTH		1
+ #define TX_NORMAL_DESC3_OWN_INDEX		31
+ #define TX_NORMAL_DESC3_OWN_WIDTH		1
+ #define TX_NORMAL_DESC3_TCPHDRLEN_INDEX		19
+ #define TX_NORMAL_DESC3_TCPHDRLEN_WIDTH		4
+ #define TX_NORMAL_DESC3_TCPPL_INDEX		0
+ #define TX_NORMAL_DESC3_TCPPL_WIDTH		18
+ #define TX_NORMAL_DESC3_TSE_INDEX		18
+ #define TX_NORMAL_DESC3_TSE_WIDTH		1
+ 
+ #define TX_NORMAL_DESC2_VLAN_INSERT		0x2
+ 
+ /* MDIO undefined or vendor specific registers */
+ #ifndef MDIO_AN_COMP_STAT
+ #define MDIO_AN_COMP_STAT		0x0030
+ #endif
+ 
+ /* Bit setting and getting macros
+  *  The get macro will extract the current bit field value from within
+  *  the variable
+  *
+  *  The set macro will clear the current bit field value within the
+  *  variable and then set the bit field of the variable to the
+  *  specified value
+  */
+ #define GET_BITS(_var, _index, _width)					\
+ 	(((_var) >> (_index)) & ((0x1 << (_width)) - 1))
+ 
+ #define SET_BITS(_var, _index, _width, _val)				\
+ do {									\
+ 	(_var) &= ~(((0x1 << (_width)) - 1) << (_index));		\
+ 	(_var) |= (((_val) & ((0x1 << (_width)) - 1)) << (_index));	\
+ } while (0)
+ 
+ #define GET_BITS_LE(_var, _index, _width)				\
+ 	((le32_to_cpu((_var)) >> (_index)) & ((0x1 << (_width)) - 1))
+ 
+ #define SET_BITS_LE(_var, _index, _width, _val)				\
+ do {									\
+ 	(_var) &= cpu_to_le32(~(((0x1 << (_width)) - 1) << (_index)));	\
+ 	(_var) |= cpu_to_le32((((_val) &				\
+ 			      ((0x1 << (_width)) - 1)) << (_index)));	\
+ } while (0)
+ 
+ /* Bit setting and getting macros based on register fields
+  *  The get macro uses the bit field definitions formed using the input
+  *  names to extract the current bit field value from within the
+  *  variable
+  *
+  *  The set macro uses the bit field definitions formed using the input
+  *  names to set the bit field of the variable to the specified value
+  */
+ #define XGMAC_GET_BITS(_var, _prefix, _field)				\
+ 	GET_BITS((_var),						\
+ 		 _prefix##_##_field##_INDEX,				\
+ 		 _prefix##_##_field##_WIDTH)
+ 
+ #define XGMAC_SET_BITS(_var, _prefix, _field, _val)			\
+ 	SET_BITS((_var),						\
+ 		 _prefix##_##_field##_INDEX,				\
+ 		 _prefix##_##_field##_WIDTH, (_val))
+ 
+ #define XGMAC_GET_BITS_LE(_var, _prefix, _field)			\
+ 	GET_BITS_LE((_var),						\
+ 		 _prefix##_##_field##_INDEX,				\
+ 		 _prefix##_##_field##_WIDTH)
+ 
+ #define XGMAC_SET_BITS_LE(_var, _prefix, _field, _val)			\
+ 	SET_BITS_LE((_var),						\
+ 		 _prefix##_##_field##_INDEX,				\
+ 		 _prefix##_##_field##_WIDTH, (_val))
+ 
+ /* Macros for reading or writing registers
+  *  The ioread macros will get bit fields or full values using the
+  *  register definitions formed using the input names
+  *
+  *  The iowrite macros will set bit fields or full values using the
+  *  register definitions formed using the input names
+  */
+ #define XGMAC_IOREAD(_pdata, _reg)					\
+ 	ioread32((_pdata)->xgmac_regs + _reg)
+ 
+ #define XGMAC_IOREAD_BITS(_pdata, _reg, _field)				\
+ 	GET_BITS(XGMAC_IOREAD((_pdata), _reg),				\
+ 		 _reg##_##_field##_INDEX,				\
+ 		 _reg##_##_field##_WIDTH)
+ 
+ #define XGMAC_IOWRITE(_pdata, _reg, _val)				\
+ 	iowrite32((_val), (_pdata)->xgmac_regs + _reg)
+ 
+ #define XGMAC_IOWRITE_BITS(_pdata, _reg, _field, _val)			\
+ do {									\
+ 	u32 reg_val = XGMAC_IOREAD((_pdata), _reg);			\
+ 	SET_BITS(reg_val,						\
+ 		 _reg##_##_field##_INDEX,				\
+ 		 _reg##_##_field##_WIDTH, (_val));			\
+ 	XGMAC_IOWRITE((_pdata), _reg, reg_val);				\
+ } while (0)
+ 
+ /* Macros for reading or writing MTL queue or traffic class registers
+  *  Similar to the standard read and write macros except that the
+  *  base register value is calculated by the queue or traffic class number
+  */
+ #define XGMAC_MTL_IOREAD(_pdata, _n, _reg)				\
+ 	ioread32((_pdata)->xgmac_regs +					\
+ 		 MTL_Q_BASE + ((_n) * MTL_Q_INC) + _reg)
+ 
+ #define XGMAC_MTL_IOREAD_BITS(_pdata, _n, _reg, _field)			\
+ 	GET_BITS(XGMAC_MTL_IOREAD((_pdata), (_n), _reg),		\
+ 		 _reg##_##_field##_INDEX,				\
+ 		 _reg##_##_field##_WIDTH)
+ 
+ #define XGMAC_MTL_IOWRITE(_pdata, _n, _reg, _val)			\
+ 	iowrite32((_val), (_pdata)->xgmac_regs +			\
+ 		  MTL_Q_BASE + ((_n) * MTL_Q_INC) + _reg)
+ 
+ #define XGMAC_MTL_IOWRITE_BITS(_pdata, _n, _reg, _field, _val)		\
+ do {									\
+ 	u32 reg_val = XGMAC_MTL_IOREAD((_pdata), (_n), _reg);		\
+ 	SET_BITS(reg_val,						\
+ 		 _reg##_##_field##_INDEX,				\
+ 		 _reg##_##_field##_WIDTH, (_val));			\
+ 	XGMAC_MTL_IOWRITE((_pdata), (_n), _reg, reg_val);		\
+ } while (0)
+ 
+ /* Macros for reading or writing DMA channel registers
+  *  Similar to the standard read and write macros except that the
+  *  base register value is obtained from the ring
+  */
+ #define XGMAC_DMA_IOREAD(_channel, _reg)				\
+ 	ioread32((_channel)->dma_regs + _reg)
+ 
+ #define XGMAC_DMA_IOREAD_BITS(_channel, _reg, _field)			\
+ 	GET_BITS(XGMAC_DMA_IOREAD((_channel), _reg),			\
+ 		 _reg##_##_field##_INDEX,				\
+ 		 _reg##_##_field##_WIDTH)
+ 
+ #define XGMAC_DMA_IOWRITE(_channel, _reg, _val)				\
+ 	iowrite32((_val), (_channel)->dma_regs + _reg)
+ 
+ #define XGMAC_DMA_IOWRITE_BITS(_channel, _reg, _field, _val)		\
+ do {									\
+ 	u32 reg_val = XGMAC_DMA_IOREAD((_channel), _reg);		\
+ 	SET_BITS(reg_val,						\
+ 		 _reg##_##_field##_INDEX,				\
+ 		 _reg##_##_field##_WIDTH, (_val));			\
+ 	XGMAC_DMA_IOWRITE((_channel), _reg, reg_val);			\
+ } while (0)
+ 
+ /* Macros for building, reading or writing register values or bits
+  * within the register values of XPCS registers.
+  */
+ #define XPCS_IOWRITE(_pdata, _off, _val)				\
+ 	iowrite32(_val, (_pdata)->xpcs_regs + (_off))
+ 
+ #define XPCS_IOREAD(_pdata, _off)					\
+ 	ioread32((_pdata)->xpcs_regs + (_off))
+ 
+ /* Macros for building, reading or writing register values or bits
+  * using MDIO.  Different from above because of the use of standardized
+  * Linux include values.  No shifting is performed with the bit
+  * operations, everything works on mask values.
+  */
+ #define XMDIO_READ(_pdata, _mmd, _reg)					\
+ 	((_pdata)->hw_if.read_mmd_regs((_pdata), 0,			\
+ 		MII_ADDR_C45 | (_mmd << 16) | ((_reg) & 0xffff)))
+ 
+ #define XMDIO_READ_BITS(_pdata, _mmd, _reg, _mask)			\
+ 	(XMDIO_READ((_pdata), _mmd, _reg) & _mask)
+ 
+ #define XMDIO_WRITE(_pdata, _mmd, _reg, _val)				\
+ 	((_pdata)->hw_if.write_mmd_regs((_pdata), 0,			\
+ 		MII_ADDR_C45 | (_mmd << 16) | ((_reg) & 0xffff), (_val)))
+ 
+ #define XMDIO_WRITE_BITS(_pdata, _mmd, _reg, _mask, _val)		\
+ do {									\
+ 	u32 mmd_val = XMDIO_READ((_pdata), _mmd, _reg);			\
+ 	mmd_val &= ~_mask;						\
+ 	mmd_val |= (_val);						\
+ 	XMDIO_WRITE((_pdata), _mmd, _reg, mmd_val);			\
+ } while (0)
+ 
+ /*
+  * TEST_XGMAC_READ macro returns 0 if the reg register can be read.
+  */
+ /* xPSC access */
+ #define XGMAC_XPCS_BASE				0xbf05d000
+ #define XGMAC_BASE				0xbf054000
+ 
+ #define APB_ADDR				(XGMAC_XPCS_BASE + (0xFF << 2))
+ 
+ #define DEVICE_PMA				0x1
+ #define DEVICE_PCS				0x3
+ #define DEVICE_AN				0x7
+ #define DEVICE_Vendor_Specific			0x1E
+ 
+ #define SR_XS_or_PCS_MMD_Control1		0x0
+ #define SR_PCS_Control2				0x7
+ #define VR_XS_PMA_MII_Ent_Gen5_Gen_Ctl		0x809C
+ #define VR_XS_or_PCS_MMD_Digital_Ctl1		0x8000
+ #define SR_XS_or_PCS_MMD_Status1		0x1
+ #define SR_AN_MMD_Control			0x0
+ #define SR_PMA_MMD_Control1			0x0
+ 
+ #define SR_XS_or_PCS_MMD_Control1_RST			(1 << 15)
+ #define SR_PCS_Control2_PCS_TYPE_SEL_MASK		0x3
+ #define SR_PCS_Control2_PCS_TYPE_SEL_KX4		0x1
+ #define SR_PCS_Control2_PCS_TYPE_SEL_KR			0x0
+ #define VR_XS_PMA_MII_Ent_Gen5_Gen_Ctl_LANE_MODE_MASK	0xF
+ #define VR_XS_PMA_MII_Ent_Gen5_Gen_Ctl_LANE_MODE_KX4	4
+ #define VR_XS_PMA_MII_Ent_Gen5_Gen_Ctl_LINK_WIDTH_MASK	0x7
+ #define VR_XS_PMA_MII_Ent_Gen5_Gen_Ctl_LINK_WIDTH_SHIFT	8
+ #define VR_XS_PMA_MII_Ent_Gen5_Gen_Ctl_LINK_WIDTH_4	2
+ #define VR_XS_or_PCS_MMD_Digital_Ctl1_VR_RST		(1 << 15)
+ #define SR_XS_or_PCS_MMD_Status1_RLU			(1 << 2)
+ #define SR_AN_MMD_Control_AN_EN				(1 << 12)
+ #define SR_PMA_MMD_Control1_LB				(1 << 0)
+ 
+ #define FULL_XPCS_ADDR(device, offset)		((device << 16) | offset)
+ #define XPCS_ADDR_LOW_MASK			0xFF
+ 
+ #define SR_Ctl_MMD_PMA_Dev_Id_1			0x0000
+ #define SR_Ctl_MMD_PMA_Dev_Id_2			0x0001
+ #define SR_Ctl_MMD_Dev_Id_1			0x0002
+ #define SR_Ctl_MMD_Dev_Id_2			0x0003
+ #define SR_Ctl_MMD_PCS_Dev_Id_1			0x0004
+ #define SR_Ctl_MMD_PCS_Dev_Id_2			0x0005
+ #define SR_Ctl_MMD_AN_Dev_Id_1			0x0006
+ #define SR_Ctl_MMD_AN_Dev_Id_2			0x0007
+ #define SR_Ctl_MMD_Package_Id_1			0x00E
+ #define SR_Ctl_MMD_Package_Id_2			0x00F
+ 
+ #define SR_Ctl_MMD_REG_1_VAL			0xa294
+ #define SR_Ctl_MMD_PMA_Dev_Id_2_VAL		0x4c00
+ #define SR_Ctl_MMD_Dev_Id_2_VAL 		0x4c11
+ #define SR_Ctl_MMD_PCS_Dev_Id_2_VAL 		0x4c22
+ #define SR_Ctl_MMD_AN_Dev_Id_2_VAL 		0x4c33
+ #define SR_Ctl_MMD_Package_Id_2_VAL		0x4c44
+ 
+ 
+ #define READ_MEMORY_REG(r)       (*((volatile uint32_t *) (r)))
+ #define WRITE_MEMORY_REG(r, v)   (*((volatile uint32_t *) (r)) = v)
+ 
+ #define READ_XPCS_REG(device, offset)	({	\
+ 		WRITE_MEMORY_REG(APB_ADDR, FULL_XPCS_ADDR(device, offset) >> 8); \
+ 		READ_MEMORY_REG(((FULL_XPCS_ADDR(device, offset) & XPCS_ADDR_LOW_MASK) << 2) + XGMAC_XPCS_BASE );})
+ 
+ #define WRITE_XPCS_REG(device, offset, val)	({	\
+ 		WRITE_MEMORY_REG(APB_ADDR, FULL_XPCS_ADDR(device, offset) >> 8); \
+ 		WRITE_MEMORY_REG(((FULL_XPCS_ADDR(device, offset) & XPCS_ADDR_LOW_MASK) << 2) + XGMAC_XPCS_BASE, val);})
+ 
+ #define MAX_POLLING_TIMES 100000
+ 
+ /* DMA Registers Map */
+ #define DMA_Mode				(XGMAC_BASE + 0x3000)
+ #define DMA_SysBus_Mode				(XGMAC_BASE + 0x3004)
+ #define DMA_Interrupt_Status			(XGMAC_BASE + 0x3008)
+ #define AXI_ARCache_Control			(XGMAC_BASE + 0x3010)
+ #define AXI_AWCache_Control			(XGMAC_BASE + 0x3018)
+ #define DMA_Debug_Status0			(XGMAC_BASE + 0x3020)
+ #define DMA_Debug_Status1			(XGMAC_BASE + 0x3024)
+ #define DMA_Debug_Status2			(XGMAC_BASE + 0x3028)
+ #define DMA_Debug_Status3			(XGMAC_BASE + 0x302C)
+ #define DMA_Debug_Status4			(XGMAC_BASE + 0x3030)
+ 
+ #define DMA_CH_OFFSET				0x80
+ 
+ /* Channel n Registers */
+ #define DMA_CH_Control(n)			(XGMAC_BASE + (n) * DMA_CH_OFFSET + 0x3100)
+ #define DMA_CH_Tx_Control(n)			(XGMAC_BASE + (n) * DMA_CH_OFFSET + 0x3104)
+ #define DMA_CH_Rx_Control(n)			(XGMAC_BASE + (n) * DMA_CH_OFFSET + 0x3108)
+ #define DMA_CH_TxDesc_List_HAddress(n)		(XGMAC_BASE + (n) * DMA_CH_OFFSET + 0x3110)
+ #define DMA_CH_TxDesc_List_LAddress(n)		(XGMAC_BASE + (n) * DMA_CH_OFFSET + 0x3114)
+ #define DMA_CH_RxDesc_List_HAddress(n)		(XGMAC_BASE + (n) * DMA_CH_OFFSET + 0x3118)
+ #define DMA_CH_RxDesc_List_LAddress(n)		(XGMAC_BASE + (n) * DMA_CH_OFFSET + 0x311C)
+ #define DMA_CH_TxDesc_Tail_LPointer(n)		(XGMAC_BASE + (n) * DMA_CH_OFFSET + 0x3124)
+ #define DMA_CH_RxDesc_Tail_LPointer(n)		(XGMAC_BASE + (n) * DMA_CH_OFFSET + 0x312C)
+ #define DMA_CH_TxDesc_Ring_Length(n)		(XGMAC_BASE + (n) * DMA_CH_OFFSET + 0x3130)
+ #define DMA_CH_RxDesc_Ring_Length(n)		(XGMAC_BASE + (n) * DMA_CH_OFFSET + 0x3134)
+ #define DMA_CH_Interrupt_Enable(n)		(XGMAC_BASE + (n) * DMA_CH_OFFSET + 0x3138)
+ #define DMA_CH_Rx_Interrupt_Watchdog_Timer(n)	(XGMAC_BASE + (n) * DMA_CH_OFFSET + 0x313C)
+ #define DMA_CH_Current_App_TxDesc_L(n)		(XGMAC_BASE + (n) * DMA_CH_OFFSET + 0x3144)
+ #define DMA_CH_Current_App_RxDesc_L(n)		(XGMAC_BASE + (n) * DMA_CH_OFFSET + 0x314C)
+ #define DMA_CH_Current_App_TxBuffer_H(n)	(XGMAC_BASE + (n) * DMA_CH_OFFSET + 0x3150)
+ #define DMA_CH_Current_App_TxBuffer_L(n)	(XGMAC_BASE + (n) * DMA_CH_OFFSET + 0x3154)
+ #define DMA_CH_Current_App_RxBuffer_H(n)	(XGMAC_BASE + (n) * DMA_CH_OFFSET + 0x3158)
+ #define DMA_CH_Current_App_RxBuffer_L(n)	(XGMAC_BASE + (n) * DMA_CH_OFFSET + 0x315C)
+ #define DMA_CH_Status(n)			(XGMAC_BASE + (n) * DMA_CH_OFFSET + 0x3160)
+ 
+ /* MTL Registers Map */
+ #define MTL_Operation_Mode			(XGMAC_BASE + 0x1000)
+ #define MTL_Debug_Control			(XGMAC_BASE + 0x1008)
+ #define MTL_Debug_Status			(XGMAC_BASE + 0x100C)
+ #define MTL_FIFO_Debug_Data			(XGMAC_BASE + 0x1010)
+ #define MTL_Interrupt_Status			(XGMAC_BASE + 0x1020)
+ #define MTL_RxQ_DMA_Map0			(XGMAC_BASE + 0x1030)
+ #define MTL_RxQ_DMA_Map1			(XGMAC_BASE + 0x1034)
+ #define MTL_RxQ_DMA_Map2			(XGMAC_BASE + 0x1038)
+ #define MTL_TC_Prty_Map0			(XGMAC_BASE + 0x1040)
+ #define MTL_TC_Prty_Map1			(XGMAC_BASE + 0x1044)
+ 
+ #define MTL_Q_OFFSET				0x80
+ /* MTL Traffic Class/Queue n Registers */
+ #define MTL_TxQ_Operation_Mode(n)		(XGMAC_BASE + (n) * MTL_Q_OFFSET + 0x1100)
+ #define MTL_TxQ_Underflow(n)			(XGMAC_BASE + (n) * MTL_Q_OFFSET + 0x1104)
+ #define MTL_TxQ_Debug(n)			(XGMAC_BASE + (n) * MTL_Q_OFFSET + 0x1108)
+ #define MTL_TC_ETS_Control(n)			(XGMAC_BASE + (n) * MTL_Q_OFFSET + 0x1110)
+ #define MTL_TC_ETS_Status(n)			(XGMAC_BASE + (n) * MTL_Q_OFFSET + 0x1114)
+ #define MTL_TC_Quantum_Weight(n)		(XGMAC_BASE + (n) * MTL_Q_OFFSET + 0x1118)
+ #define MTL_RxQ_Operation_Mode(n)		(XGMAC_BASE + (n) * MTL_Q_OFFSET + 0x1140)
+ #define MTL_RxQ_Missed_Pkt_Overflow_Cnt(n)	(XGMAC_BASE + (n) * MTL_Q_OFFSET + 0x1144)
+ #define MTL_RxQ_Debug(n)			(XGMAC_BASE + (n) * MTL_Q_OFFSET + 0x1148)
+ #define MTL_RxQ_Control(n)			(XGMAC_BASE + (n) * MTL_Q_OFFSET + 0x114C)
+ #define MTL_RxQ_Flow_Control(n)			(XGMAC_BASE + (n) * MTL_Q_OFFSET + 0x1150)
+ #define MTL_Q_Interrupt_Enable(n)		(XGMAC_BASE + (n) * MTL_Q_OFFSET + 0x1170)
+ #define MTL_Q_Interrupt_Status(n)		(XGMAC_BASE + (n) * MTL_Q_OFFSET + 0x1174)
+ 
+ /* MAC Registers Map */
+ #define MAC_Tx_Configuration			(XGMAC_BASE + 0x0000)
+ #define MAC_Rx_Configuration			(XGMAC_BASE + 0x0004)
+ #define MAC_Packet_Filter			(XGMAC_BASE + 0x0008)
+ #define MAC_Watchdog_Timeout			(XGMAC_BASE + 0x000C)
+ #define MAC_Hash_Table_Reg0			(XGMAC_BASE + 0x0010)
+ #define MAC_Hash_Table_Reg1			(XGMAC_BASE + 0x0014)
+ #define MAC_Hash_Table_Reg2			(XGMAC_BASE + 0x0018)
+ #define MAC_Hash_Table_Reg3			(XGMAC_BASE + 0x001C)
+ #define MAC_Hash_Table_Reg4			(XGMAC_BASE + 0x0020)
+ #define MAC_Hash_Table_Reg5			(XGMAC_BASE + 0x0024)
+ #define MAC_Hash_Table_Reg6			(XGMAC_BASE + 0x0028)
+ #define MAC_Hash_Table_Reg7			(XGMAC_BASE + 0x002C)
+ #define MAC_VLAN_Tag				(XGMAC_BASE + 0x0050)
+ #define MAC_VLAN_Hash_Table			(XGMAC_BASE + 0x0058)
+ #define MAC_VLAN_Incl				(XGMAC_BASE + 0x0060)
+ #define MAC_Inner_VLAN_Incl			(XGMAC_BASE + 0x0064)
+ #define MAC_Rx_Eth_Type_Match			(XGMAC_BASE + 0x006C)
+ #define MAC_Q0_Tx_Flow_Ctrl			(XGMAC_BASE + 0x0070)
+ #define MAC_Q1_Tx_Flow_Ctrl			(XGMAC_BASE + 0x0074)
+ #define MAC_Q2_Tx_Flow_Ctrl			(XGMAC_BASE + 0x0078)
+ #define MAC_Q3_Tx_Flow_Ctrl			(XGMAC_BASE + 0x007C)
+ #define MAC_Q4_Tx_Flow_Ctrl			(XGMAC_BASE + 0x0080)
+ #define MAC_Q5_Tx_Flow_Ctrl			(XGMAC_BASE + 0x0084)
+ #define MAC_Q6_Tx_Flow_Ctrl			(XGMAC_BASE + 0x0088)
+ #define MAC_Q7_Tx_Flow_Ctrl			(XGMAC_BASE + 0x008C)
+ #define MAC_Rx_Flow_Ctrl			(XGMAC_BASE + 0x0090)
+ #define MAC_RxQ_Ctrl0				(XGMAC_BASE + 0x00A0)
+ #define MAC_RxQ_Ctrl1				(XGMAC_BASE + 0x00A4)
+ #define MAC_RxQ_Ctrl2				(XGMAC_BASE + 0x00A8)
+ #define MAC_RxQ_Ctrl3				(XGMAC_BASE + 0x00AC)
+ #define MAC_Interrupt_Status			(XGMAC_BASE + 0x00B0)
+ #define MAC_Interrupt_Enable			(XGMAC_BASE + 0x00B4)
+ #define MAC_RX_TX_Status			(XGMAC_BASE + 0x00B8)
+ #define MAC_PMT_Control_Status			(XGMAC_BASE + 0x00C0)
+ #define MAC_RWK_Packet_Filter			(XGMAC_BASE + 0x00C4)
+ #define MAC_LPI_Control_Status			(XGMAC_BASE + 0x00D0)
+ #define MAC_LPI_Timers_Control			(XGMAC_BASE + 0x00D4)
+ #define MAC_Version				(XGMAC_BASE + 0x0110)
+ #define MAC_Debug				(XGMAC_BASE + 0x0114)
+ #define MAC_HW_Feature0				(XGMAC_BASE + 0x011C)
+ #define MAC_HW_Feature1				(XGMAC_BASE + 0x0120)
+ #define MAC_HW_Feature2				(XGMAC_BASE + 0x0124)
+ #define MAC_GPIO_Control			(XGMAC_BASE + 0x0278)
+ #define MAC_GPIO_Status				(XGMAC_BASE + 0x027C)
+ 
+ /* MAC Address Registers */
+ #define MAC_Address_High(ch)			(XGMAC_BASE + 0x0300 + 8 * (ch))
+ #define MAC_Address_Low(ch)			(XGMAC_BASE + 0x0304 + 8 * (ch))
+ 
+ /* L3-L4 Function Registers */
+ #define MAC_L3_L4_Address_Control		(XGMAC_BASE + 0x0C00)
+ #define MAC_L3_L4_Data				(XGMAC_BASE + 0x0C04)
+ #define MAC_ARP_Address				(XGMAC_BASE + 0x0C10)
+ #define MAC_RSS_Control				(XGMAC_BASE + 0x0C80)
+ #define MAC_RSS_Address				(XGMAC_BASE + 0x0C88)
+ #define MAC_RSS_Data				(XGMAC_BASE + 0x0C8C)
+ 
+ /* IEEE 1588 Registers */
+ #define MAC_Timestamp_Control			(XGMAC_BASE + 0x0D00)
+ #define MAC_Sub_Second_Increment		(XGMAC_BASE + 0x0D04)
+ #define MAC_System_Time_Seconds			(XGMAC_BASE + 0x0D08)
+ #define MAC_System_Time_Nanoseconds		(XGMAC_BASE + 0x0D0C)
+ #define MAC_System_Time_Seconds_Update		(XGMAC_BASE + 0x0D10)
+ #define MAC_System_Time_Nanoseconds_Update	(XGMAC_BASE + 0x0D14)
+ #define MAC_Timestamp_Addend			(XGMAC_BASE + 0x0D18)
+ #define MAC_System_Time_Higher_Word_Seconds	(XGMAC_BASE + 0x0D1C)
+ #define MAC_Timestamp_Status			(XGMAC_BASE + 0x0D20)
+ #define MAC_TxTimestamp_Status_Nanoseconds	(XGMAC_BASE + 0x0D30)
+ #define MAC_TxTimestamp_Status_Seconds		(XGMAC_BASE + 0x0D34)
+ #define MAC_Auxiliary_Control			(XGMAC_BASE + 0x0D40)
+ #define MAC_Auxiliary_Timestamp_Nanoseconds	(XGMAC_BASE + 0x0D48)
+ #define MAC_Auxiliary_Timestamp_Seconds		(XGMAC_BASE + 0x0D4C)
+ #define MAC_Timestamp_Ingress_Asym_Corr		(XGMAC_BASE + 0x0D50)
+ #define MAC_Timestamp_Egress_Asym_Corr		(XGMAC_BASE + 0x0D54)
+ #define MAC_Timestamp_Ingress_Corr_Nanosecond	(XGMAC_BASE + 0x0D58)
+ #define MAC_Timestamp_Ingress_Corr_Subnanosecond	(XGMAC_BASE + 0x0D5C)
+ #define MAC_Timestamp_Egress_Corr_Nanosecond		(XGMAC_BASE + 0x0D60)
+ #define MAC_Timestamp_Egress_Corr_Subnanosecond		(XGMAC_BASE + 0x0D64)
+ #define MAC_PPS0_Target_Time_Seconds			(XGMAC_BASE + 0x0D80)
+ #define MAC_PPS0_Target_Time_Nanoseconds		(XGMAC_BASE + 0x0D84)
+ #define MAC_PPS0_Interval				(XGMAC_BASE + 0x0D88)
+ #define MAC_PPS0_Width					(XGMAC_BASE + 0x0D8C)
+ #define MAC_PPS1_Target_Time_Seconds			(XGMAC_BASE + 0x0D90)
+ #define MAC_PPS1_Target_Time_Nanoseconds		(XGMAC_BASE + 0x0D94)
+ #define MAC_PPS_Control					(XGMAC_BASE + 0x0D94)
+ #define MAC_PPS1_Interval				(XGMAC_BASE + 0x0D98)
+ #define MAC_PPS1_Width					(XGMAC_BASE + 0x0D9C)
+ #define MAC_PPS2_Target_Time_Seconds			(XGMAC_BASE + 0x0DA0)
+ #define MAC_PPS2_Target_Time_Nanoseconds		(XGMAC_BASE + 0x0DA4)
+ #define MAC_PPS2_Interval				(XGMAC_BASE + 0x0DA8)
+ #define MAC_PPS2_Width					(XGMAC_BASE + 0x0DAC)
+ #define MAC_PPS3_Target_Time_Seconds			(XGMAC_BASE + 0x0DB0)
+ #define MAC_PPS3_Target_Time_Nanoseconds		(XGMAC_BASE + 0x0DB4)
+ #define MAC_PPS3_Interval				(XGMAC_BASE + 0x0DB8)
+ #define MAC_PPS3_Width					(XGMAC_BASE + 0x0DBC)
+ #define MAC_PTO_Control					(XGMAC_BASE + 0x0DC0)
+ #define MAC_Source_Port_Identity0			(XGMAC_BASE + 0x0DC4)
+ #define MAC_Source_Port_Identity1			(XGMAC_BASE + 0x0DC8)
+ #define MAC_Source_Port_Identity2			(XGMAC_BASE + 0x0DCC)
+ #define MAC_Log_Message_Interval			(XGMAC_BASE + 0x0DD0)
+ 
+ 
+ /* Macros to read/write XGMAC registers. */
+ #define READ_XGMAC_REG(r)		READ_MEMORY_REG(r)
+ #define WRITE_XGMAC_REG(r, v)		WRITE_MEMORY_REG(r, v)
+ 
+ #endif
diff -rcNP linux-4.4.24/drivers/net/ethernet/baikal/xgbe/xgbe-dcb.c linux-4.4.24-baikal/drivers/net/ethernet/baikal/xgbe/xgbe-dcb.c
*** linux-4.4.24/drivers/net/ethernet/baikal/xgbe/xgbe-dcb.c	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/drivers/net/ethernet/baikal/xgbe/xgbe-dcb.c	2016-11-11 14:49:52.000000000 +0300
***************
*** 0 ****
--- 1,276 ----
+ /*
+  * Baikal Electronics 10Gb Ethernet driver
+  *
+  * Based on AMD 10Gb Ethernet driver
+  * drivers/net/ethernet/amd/xgbe
+  *
+  * This file is available to you under your choice of the following two
+  * licenses:
+  *
+  * License 1: GPLv2
+  *
+  * Copyright (c) 2015,2016 Baikal Electronics JSC.
+  * Copyright (c) 2014 Advanced Micro Devices, Inc.
+  *
+  * Adopted by:
+  *   Dmitry Dunaev <dmitry.dunaev@baikalelectronics.ru>
+  *
+  * This file is free software; you may copy, redistribute and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation, either version 2 of the License, or (at
+  * your option) any later version.
+  *
+  * This file is distributed in the hope that it will be useful, but
+  * WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+  * General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+  *
+  * This file incorporates work covered by the following copyright and
+  * permission notice:
+  *     The Synopsys DWC ETHER XGMAC Software Driver and documentation
+  *     (hereinafter "Software") is an unsupported proprietary work of Synopsys,
+  *     Inc. unless otherwise expressly agreed to in writing between Synopsys
+  *     and you.
+  *
+  *     The Software IS NOT an item of Licensed Software or Licensed Product
+  *     under any End User Software License Agreement or Agreement for Licensed
+  *     Product with Synopsys or any supplement thereto.  Permission is hereby
+  *     granted, free of charge, to any person obtaining a copy of this software
+  *     annotated with this license and the Software, to deal in the Software
+  *     without restriction, including without limitation the rights to use,
+  *     copy, modify, merge, publish, distribute, sublicense, and/or sell copies
+  *     of the Software, and to permit persons to whom the Software is furnished
+  *     to do so, subject to the following conditions:
+  *
+  *     The above copyright notice and this permission notice shall be included
+  *     in all copies or substantial portions of the Software.
+  *
+  *     THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS"
+  *     BASIS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  *     TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  *     PARTICULAR PURPOSE ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS
+  *     BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  *     CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  *     SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  *     INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  *     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  *     ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  *     THE POSSIBILITY OF SUCH DAMAGE.
+  *
+  *
+  * License 2: Modified BSD
+  *
+  * Copyright (c) 2014 Advanced Micro Devices, Inc.
+  * All rights reserved.
+  *
+  * Redistribution and use in source and binary forms, with or without
+  * modification, are permitted provided that the following conditions are met:
+  *     * Redistributions of source code must retain the above copyright
+  *       notice, this list of conditions and the following disclaimer.
+  *     * Redistributions in binary form must reproduce the above copyright
+  *       notice, this list of conditions and the following disclaimer in the
+  *       documentation and/or other materials provided with the distribution.
+  *     * Neither the name of Advanced Micro Devices, Inc. nor the
+  *       names of its contributors may be used to endorse or promote products
+  *       derived from this software without specific prior written permission.
+  *
+  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+  * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
+  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+  *
+  * This file incorporates work covered by the following copyright and
+  * permission notice:
+  *     The Synopsys DWC ETHER XGMAC Software Driver and documentation
+  *     (hereinafter "Software") is an unsupported proprietary work of Synopsys,
+  *     Inc. unless otherwise expressly agreed to in writing between Synopsys
+  *     and you.
+  *
+  *     The Software IS NOT an item of Licensed Software or Licensed Product
+  *     under any End User Software License Agreement or Agreement for Licensed
+  *     Product with Synopsys or any supplement thereto.  Permission is hereby
+  *     granted, free of charge, to any person obtaining a copy of this software
+  *     annotated with this license and the Software, to deal in the Software
+  *     without restriction, including without limitation the rights to use,
+  *     copy, modify, merge, publish, distribute, sublicense, and/or sell copies
+  *     of the Software, and to permit persons to whom the Software is furnished
+  *     to do so, subject to the following conditions:
+  *
+  *     The above copyright notice and this permission notice shall be included
+  *     in all copies or substantial portions of the Software.
+  *
+  *     THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS"
+  *     BASIS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  *     TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  *     PARTICULAR PURPOSE ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS
+  *     BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  *     CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  *     SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  *     INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  *     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  *     ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  *     THE POSSIBILITY OF SUCH DAMAGE.
+  */
+ 
+ #include <linux/netdevice.h>
+ #include <net/dcbnl.h>
+ 
+ #include "xgbe.h"
+ #include "xgbe-common.h"
+ 
+ static int xgbe_dcb_ieee_getets(struct net_device *netdev,
+ 				struct ieee_ets *ets)
+ {
+ 	struct xgbe_prv_data *pdata = netdev_priv(netdev);
+ 
+ 	/* Set number of supported traffic classes */
+ 	ets->ets_cap = pdata->hw_feat.tc_cnt;
+ 
+ 	if (pdata->ets) {
+ 		ets->cbs = pdata->ets->cbs;
+ 		memcpy(ets->tc_tx_bw, pdata->ets->tc_tx_bw,
+ 		       sizeof(ets->tc_tx_bw));
+ 		memcpy(ets->tc_tsa, pdata->ets->tc_tsa,
+ 		       sizeof(ets->tc_tsa));
+ 		memcpy(ets->prio_tc, pdata->ets->prio_tc,
+ 		       sizeof(ets->prio_tc));
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int xgbe_dcb_ieee_setets(struct net_device *netdev,
+ 				struct ieee_ets *ets)
+ {
+ 	struct xgbe_prv_data *pdata = netdev_priv(netdev);
+ 	unsigned int i, tc_ets, tc_ets_weight;
+ 
+ 	tc_ets = 0;
+ 	tc_ets_weight = 0;
+ 	for (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {
+ 		DBGPR("  TC%u: tx_bw=%hhu, rx_bw=%hhu, tsa=%hhu\n", i,
+ 		      ets->tc_tx_bw[i], ets->tc_rx_bw[i], ets->tc_tsa[i]);
+ 		DBGPR("  PRIO%u: TC=%hhu\n", i, ets->prio_tc[i]);
+ 
+ 		if ((ets->tc_tx_bw[i] || ets->tc_tsa[i]) &&
+ 		    (i >= pdata->hw_feat.tc_cnt))
+ 				return -EINVAL;
+ 
+ 		if (ets->prio_tc[i] >= pdata->hw_feat.tc_cnt)
+ 			return -EINVAL;
+ 
+ 		switch (ets->tc_tsa[i]) {
+ 		case IEEE_8021QAZ_TSA_STRICT:
+ 			break;
+ 		case IEEE_8021QAZ_TSA_ETS:
+ 			tc_ets = 1;
+ 			tc_ets_weight += ets->tc_tx_bw[i];
+ 			break;
+ 
+ 		default:
+ 			return -EINVAL;
+ 		}
+ 	}
+ 
+ 	/* Weights must add up to 100% */
+ 	if (tc_ets && (tc_ets_weight != 100))
+ 		return -EINVAL;
+ 
+ 	if (!pdata->ets) {
+ 		pdata->ets = devm_kzalloc(pdata->dev, sizeof(*pdata->ets),
+ 					  GFP_KERNEL);
+ 		if (!pdata->ets)
+ 			return -ENOMEM;
+ 	}
+ 
+ 	memcpy(pdata->ets, ets, sizeof(*pdata->ets));
+ 
+ 	pdata->hw_if.config_dcb_tc(pdata);
+ 
+ 	return 0;
+ }
+ 
+ static int xgbe_dcb_ieee_getpfc(struct net_device *netdev,
+ 				struct ieee_pfc *pfc)
+ {
+ 	struct xgbe_prv_data *pdata = netdev_priv(netdev);
+ 
+ 	/* Set number of supported PFC traffic classes */
+ 	pfc->pfc_cap = pdata->hw_feat.tc_cnt;
+ 
+ 	if (pdata->pfc) {
+ 		pfc->pfc_en = pdata->pfc->pfc_en;
+ 		pfc->mbc = pdata->pfc->mbc;
+ 		pfc->delay = pdata->pfc->delay;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int xgbe_dcb_ieee_setpfc(struct net_device *netdev,
+ 				struct ieee_pfc *pfc)
+ {
+ 	struct xgbe_prv_data *pdata = netdev_priv(netdev);
+ 
+ 	DBGPR("  cap=%hhu, en=%hhx, mbc=%hhu, delay=%hhu\n",
+ 	      pfc->pfc_cap, pfc->pfc_en, pfc->mbc, pfc->delay);
+ 
+ 	if (!pdata->pfc) {
+ 		pdata->pfc = devm_kzalloc(pdata->dev, sizeof(*pdata->pfc),
+ 					  GFP_KERNEL);
+ 		if (!pdata->pfc)
+ 			return -ENOMEM;
+ 	}
+ 
+ 	memcpy(pdata->pfc, pfc, sizeof(*pdata->pfc));
+ 
+ 	pdata->hw_if.config_dcb_pfc(pdata);
+ 
+ 	return 0;
+ }
+ 
+ static u8 xgbe_dcb_getdcbx(struct net_device *netdev)
+ {
+ 	return DCB_CAP_DCBX_HOST | DCB_CAP_DCBX_VER_IEEE;
+ }
+ 
+ static u8 xgbe_dcb_setdcbx(struct net_device *netdev, u8 dcbx)
+ {
+ 	u8 support = xgbe_dcb_getdcbx(netdev);
+ 
+ 	DBGPR("  DCBX=%#hhx\n", dcbx);
+ 
+ 	if (dcbx & ~support)
+ 		return 1;
+ 
+ 	if ((dcbx & support) != support)
+ 		return 1;
+ 
+ 	return 0;
+ }
+ 
+ static const struct dcbnl_rtnl_ops xgbe_dcbnl_ops = {
+ 	/* IEEE 802.1Qaz std */
+ 	.ieee_getets = xgbe_dcb_ieee_getets,
+ 	.ieee_setets = xgbe_dcb_ieee_setets,
+ 	.ieee_getpfc = xgbe_dcb_ieee_getpfc,
+ 	.ieee_setpfc = xgbe_dcb_ieee_setpfc,
+ 
+ 	/* DCBX configuration */
+ 	.getdcbx     = xgbe_dcb_getdcbx,
+ 	.setdcbx     = xgbe_dcb_setdcbx,
+ };
+ 
+ const struct dcbnl_rtnl_ops *xgbe_get_dcbnl_ops(void)
+ {
+ 	return &xgbe_dcbnl_ops;
+ }
diff -rcNP linux-4.4.24/drivers/net/ethernet/baikal/xgbe/xgbe-debugfs.c linux-4.4.24-baikal/drivers/net/ethernet/baikal/xgbe/xgbe-debugfs.c
*** linux-4.4.24/drivers/net/ethernet/baikal/xgbe/xgbe-debugfs.c	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/drivers/net/ethernet/baikal/xgbe/xgbe-debugfs.c	2016-11-11 14:49:52.000000000 +0300
***************
*** 0 ****
--- 1,381 ----
+ /*
+  * Baikal Electronics 10Gb Ethernet driver
+  *
+  * Based on AMD 10Gb Ethernet driver
+  * drivers/net/ethernet/amd/xgbe
+  *
+  * This file is available to you under your choice of the following two
+  * licenses:
+  *
+  * License 1: GPLv2
+  *
+  * Copyright (c) 2015,2016 Baikal Electronics JSC.
+  * Copyright (c) 2014 Advanced Micro Devices, Inc.
+  *
+  * Adopted by:
+  *   Dmitry Dunaev <dmitry.dunaev@baikalelectronics.ru>
+  *
+  * This file is free software; you may copy, redistribute and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation, either version 2 of the License, or (at
+  * your option) any later version.
+  *
+  * This file is distributed in the hope that it will be useful, but
+  * WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+  * General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+  *
+  * This file incorporates work covered by the following copyright and
+  * permission notice:
+  *     The Synopsys DWC ETHER XGMAC Software Driver and documentation
+  *     (hereinafter "Software") is an unsupported proprietary work of Synopsys,
+  *     Inc. unless otherwise expressly agreed to in writing between Synopsys
+  *     and you.
+  *
+  *     The Software IS NOT an item of Licensed Software or Licensed Product
+  *     under any End User Software License Agreement or Agreement for Licensed
+  *     Product with Synopsys or any supplement thereto.  Permission is hereby
+  *     granted, free of charge, to any person obtaining a copy of this software
+  *     annotated with this license and the Software, to deal in the Software
+  *     without restriction, including without limitation the rights to use,
+  *     copy, modify, merge, publish, distribute, sublicense, and/or sell copies
+  *     of the Software, and to permit persons to whom the Software is furnished
+  *     to do so, subject to the following conditions:
+  *
+  *     The above copyright notice and this permission notice shall be included
+  *     in all copies or substantial portions of the Software.
+  *
+  *     THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS"
+  *     BASIS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  *     TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  *     PARTICULAR PURPOSE ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS
+  *     BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  *     CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  *     SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  *     INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  *     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  *     ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  *     THE POSSIBILITY OF SUCH DAMAGE.
+  *
+  *
+  * License 2: Modified BSD
+  *
+  * Copyright (c) 2015,2016 Baikal Electronics JSC.
+  * Copyright (c) 2014 Advanced Micro Devices, Inc.
+  * All rights reserved.
+  *
+  * Redistribution and use in source and binary forms, with or without
+  * modification, are permitted provided that the following conditions are met:
+  *     * Redistributions of source code must retain the above copyright
+  *       notice, this list of conditions and the following disclaimer.
+  *     * Redistributions in binary form must reproduce the above copyright
+  *       notice, this list of conditions and the following disclaimer in the
+  *       documentation and/or other materials provided with the distribution.
+  *     * Neither the name of Advanced Micro Devices, Inc. nor the
+  *       names of its contributors may be used to endorse or promote products
+  *       derived from this software without specific prior written permission.
+  *
+  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+  * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
+  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+  *
+  * This file incorporates work covered by the following copyright and
+  * permission notice:
+  *     The Synopsys DWC ETHER XGMAC Software Driver and documentation
+  *     (hereinafter "Software") is an unsupported proprietary work of Synopsys,
+  *     Inc. unless otherwise expressly agreed to in writing between Synopsys
+  *     and you.
+  *
+  *     The Software IS NOT an item of Licensed Software or Licensed Product
+  *     under any End User Software License Agreement or Agreement for Licensed
+  *     Product with Synopsys or any supplement thereto.  Permission is hereby
+  *     granted, free of charge, to any person obtaining a copy of this software
+  *     annotated with this license and the Software, to deal in the Software
+  *     without restriction, including without limitation the rights to use,
+  *     copy, modify, merge, publish, distribute, sublicense, and/or sell copies
+  *     of the Software, and to permit persons to whom the Software is furnished
+  *     to do so, subject to the following conditions:
+  *
+  *     The above copyright notice and this permission notice shall be included
+  *     in all copies or substantial portions of the Software.
+  *
+  *     THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS"
+  *     BASIS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  *     TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  *     PARTICULAR PURPOSE ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS
+  *     BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  *     CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  *     SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  *     INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  *     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  *     ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  *     THE POSSIBILITY OF SUCH DAMAGE.
+  */
+ 
+ #include <linux/debugfs.h>
+ #include <linux/module.h>
+ #include <linux/slab.h>
+ 
+ #include "xgbe.h"
+ #include "xgbe-common.h"
+ 
+ static ssize_t xgbe_common_read(char __user *buffer, size_t count,
+ 				loff_t *ppos, unsigned int value)
+ {
+ 	char *buf;
+ 	ssize_t len;
+ 
+ 	if (*ppos != 0)
+ 		return 0;
+ 
+ 	buf = kasprintf(GFP_KERNEL, "0x%08x\n", value);
+ 	if (!buf)
+ 		return -ENOMEM;
+ 
+ 	if (count < strlen(buf)) {
+ 		kfree(buf);
+ 		return -ENOSPC;
+ 	}
+ 
+ 	len = simple_read_from_buffer(buffer, count, ppos, buf, strlen(buf));
+ 	kfree(buf);
+ 
+ 	return len;
+ }
+ 
+ static ssize_t xgbe_common_write(const char __user *buffer, size_t count,
+ 				 loff_t *ppos, unsigned int *value)
+ {
+ 	char workarea[32];
+ 	ssize_t len;
+ 	int ret;
+ 
+ 	if (*ppos != 0)
+ 		return 0;
+ 
+ 	if (count >= sizeof(workarea))
+ 		return -ENOSPC;
+ 
+ 	len = simple_write_to_buffer(workarea, sizeof(workarea) - 1, ppos,
+ 				     buffer, count);
+ 	if (len < 0)
+ 		return len;
+ 
+ 	workarea[len] = '\0';
+ 	ret = kstrtouint(workarea, 16, value);
+ 	if (ret)
+ 		return -EIO;
+ 
+ 	return len;
+ }
+ 
+ static ssize_t xgmac_reg_addr_read(struct file *filp, char __user *buffer,
+ 				   size_t count, loff_t *ppos)
+ {
+ 	struct xgbe_prv_data *pdata = filp->private_data;
+ 
+ 	return xgbe_common_read(buffer, count, ppos, pdata->debugfs_xgmac_reg);
+ }
+ 
+ static ssize_t xgmac_reg_addr_write(struct file *filp,
+ 				    const char __user *buffer,
+ 				    size_t count, loff_t *ppos)
+ {
+ 	struct xgbe_prv_data *pdata = filp->private_data;
+ 
+ 	return xgbe_common_write(buffer, count, ppos,
+ 				 &pdata->debugfs_xgmac_reg);
+ }
+ 
+ static ssize_t xgmac_reg_value_read(struct file *filp, char __user *buffer,
+ 				    size_t count, loff_t *ppos)
+ {
+ 	struct xgbe_prv_data *pdata = filp->private_data;
+ 	unsigned int value;
+ 
+ 	value = XGMAC_IOREAD(pdata, pdata->debugfs_xgmac_reg);
+ 
+ 	return xgbe_common_read(buffer, count, ppos, value);
+ }
+ 
+ static ssize_t xgmac_reg_value_write(struct file *filp,
+ 				     const char __user *buffer,
+ 				     size_t count, loff_t *ppos)
+ {
+ 	struct xgbe_prv_data *pdata = filp->private_data;
+ 	unsigned int value;
+ 	ssize_t len;
+ 
+ 	len = xgbe_common_write(buffer, count, ppos, &value);
+ 	if (len < 0)
+ 		return len;
+ 
+ 	XGMAC_IOWRITE(pdata, pdata->debugfs_xgmac_reg, value);
+ 
+ 	return len;
+ }
+ 
+ static const struct file_operations xgmac_reg_addr_fops = {
+ 	.owner = THIS_MODULE,
+ 	.open = simple_open,
+ 	.read =  xgmac_reg_addr_read,
+ 	.write = xgmac_reg_addr_write,
+ };
+ 
+ static const struct file_operations xgmac_reg_value_fops = {
+ 	.owner = THIS_MODULE,
+ 	.open = simple_open,
+ 	.read =  xgmac_reg_value_read,
+ 	.write = xgmac_reg_value_write,
+ };
+ 
+ static ssize_t xpcs_mmd_read(struct file *filp, char __user *buffer,
+ 			     size_t count, loff_t *ppos)
+ {
+ 	struct xgbe_prv_data *pdata = filp->private_data;
+ 
+ 	return xgbe_common_read(buffer, count, ppos, pdata->debugfs_xpcs_mmd);
+ }
+ 
+ static ssize_t xpcs_mmd_write(struct file *filp, const char __user *buffer,
+ 			      size_t count, loff_t *ppos)
+ {
+ 	struct xgbe_prv_data *pdata = filp->private_data;
+ 
+ 	return xgbe_common_write(buffer, count, ppos,
+ 				 &pdata->debugfs_xpcs_mmd);
+ }
+ 
+ static ssize_t xpcs_reg_addr_read(struct file *filp, char __user *buffer,
+ 				  size_t count, loff_t *ppos)
+ {
+ 	struct xgbe_prv_data *pdata = filp->private_data;
+ 
+ 	return xgbe_common_read(buffer, count, ppos, pdata->debugfs_xpcs_reg);
+ }
+ 
+ static ssize_t xpcs_reg_addr_write(struct file *filp, const char __user *buffer,
+ 				   size_t count, loff_t *ppos)
+ {
+ 	struct xgbe_prv_data *pdata = filp->private_data;
+ 
+ 	return xgbe_common_write(buffer, count, ppos,
+ 				 &pdata->debugfs_xpcs_reg);
+ }
+ 
+ static ssize_t xpcs_reg_value_read(struct file *filp, char __user *buffer,
+ 				   size_t count, loff_t *ppos)
+ {
+ 	struct xgbe_prv_data *pdata = filp->private_data;
+ 	unsigned int value;
+ 
+ 	value = XMDIO_READ(pdata, pdata->debugfs_xpcs_mmd,
+ 			   pdata->debugfs_xpcs_reg);
+ 
+ 	return xgbe_common_read(buffer, count, ppos, value);
+ }
+ 
+ static ssize_t xpcs_reg_value_write(struct file *filp,
+ 				    const char __user *buffer,
+ 				    size_t count, loff_t *ppos)
+ {
+ 	struct xgbe_prv_data *pdata = filp->private_data;
+ 	unsigned int value;
+ 	ssize_t len;
+ 
+ 	len = xgbe_common_write(buffer, count, ppos, &value);
+ 	if (len < 0)
+ 		return len;
+ 
+ 	XMDIO_WRITE(pdata, pdata->debugfs_xpcs_mmd, pdata->debugfs_xpcs_reg,
+ 		    value);
+ 
+ 	return len;
+ }
+ 
+ static const struct file_operations xpcs_mmd_fops = {
+ 	.owner = THIS_MODULE,
+ 	.open = simple_open,
+ 	.read =  xpcs_mmd_read,
+ 	.write = xpcs_mmd_write,
+ };
+ 
+ static const struct file_operations xpcs_reg_addr_fops = {
+ 	.owner = THIS_MODULE,
+ 	.open = simple_open,
+ 	.read =  xpcs_reg_addr_read,
+ 	.write = xpcs_reg_addr_write,
+ };
+ 
+ static const struct file_operations xpcs_reg_value_fops = {
+ 	.owner = THIS_MODULE,
+ 	.open = simple_open,
+ 	.read =  xpcs_reg_value_read,
+ 	.write = xpcs_reg_value_write,
+ };
+ 
+ void xgbe_debugfs_init(struct xgbe_prv_data *pdata)
+ {
+ 	struct dentry *pfile;
+ 	char *buf;
+ 
+ 	/* Set defaults */
+ 	pdata->debugfs_xgmac_reg = 0;
+ 	pdata->debugfs_xpcs_mmd = 1;
+ 	pdata->debugfs_xpcs_reg = 0;
+ 
+ 	buf = kasprintf(GFP_KERNEL, "amd-xgbe-%s", pdata->netdev->name);
+ 	pdata->xgbe_debugfs = debugfs_create_dir(buf, NULL);
+ 	if (pdata->xgbe_debugfs == NULL) {
+ 		netdev_err(pdata->netdev, "debugfs_create_dir failed\n");
+ 		return;
+ 	}
+ 
+ 	pfile = debugfs_create_file("xgmac_register", 0600,
+ 				    pdata->xgbe_debugfs, pdata,
+ 				    &xgmac_reg_addr_fops);
+ 	if (!pfile)
+ 		netdev_err(pdata->netdev, "debugfs_create_file failed\n");
+ 
+ 	pfile = debugfs_create_file("xgmac_register_value", 0600,
+ 				    pdata->xgbe_debugfs, pdata,
+ 				    &xgmac_reg_value_fops);
+ 	if (!pfile)
+ 		netdev_err(pdata->netdev, "debugfs_create_file failed\n");
+ 
+ 	pfile = debugfs_create_file("xpcs_mmd", 0600,
+ 				    pdata->xgbe_debugfs, pdata,
+ 				    &xpcs_mmd_fops);
+ 	if (!pfile)
+ 		netdev_err(pdata->netdev, "debugfs_create_file failed\n");
+ 
+ 	pfile = debugfs_create_file("xpcs_register", 0600,
+ 				    pdata->xgbe_debugfs, pdata,
+ 				    &xpcs_reg_addr_fops);
+ 	if (!pfile)
+ 		netdev_err(pdata->netdev, "debugfs_create_file failed\n");
+ 
+ 	pfile = debugfs_create_file("xpcs_register_value", 0600,
+ 				    pdata->xgbe_debugfs, pdata,
+ 				    &xpcs_reg_value_fops);
+ 	if (!pfile)
+ 		netdev_err(pdata->netdev, "debugfs_create_file failed\n");
+ 
+ 	kfree(buf);
+ }
+ 
+ void xgbe_debugfs_exit(struct xgbe_prv_data *pdata)
+ {
+ 	debugfs_remove_recursive(pdata->xgbe_debugfs);
+ 	pdata->xgbe_debugfs = NULL;
+ }
diff -rcNP linux-4.4.24/drivers/net/ethernet/baikal/xgbe/xgbe-desc.c linux-4.4.24-baikal/drivers/net/ethernet/baikal/xgbe/xgbe-desc.c
*** linux-4.4.24/drivers/net/ethernet/baikal/xgbe/xgbe-desc.c	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/drivers/net/ethernet/baikal/xgbe/xgbe-desc.c	2016-11-11 14:49:52.000000000 +0300
***************
*** 0 ****
--- 1,677 ----
+ /*
+  * Baikal Electronics 10Gb Ethernet driver
+  *
+  * Based on AMD 10Gb Ethernet driver
+  * drivers/net/ethernet/amd/xgbe
+  *
+  * This file is available to you under your choice of the following two
+  * licenses:
+  *
+  * License 1: GPLv2
+  *
+  * Copyright (c) 2015,2016 Baikal Electronics JSC.
+  * Copyright (c) 2014 Advanced Micro Devices, Inc.
+  *
+  * Adopted by:
+  *   Dmitry Dunaev <dmitry.dunaev@baikalelectronics.ru>
+  *
+  * This file is free software; you may copy, redistribute and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation, either version 2 of the License, or (at
+  * your option) any later version.
+  *
+  * This file is distributed in the hope that it will be useful, but
+  * WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+  * General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+  *
+  * This file incorporates work covered by the following copyright and
+  * permission notice:
+  *     The Synopsys DWC ETHER XGMAC Software Driver and documentation
+  *     (hereinafter "Software") is an unsupported proprietary work of Synopsys,
+  *     Inc. unless otherwise expressly agreed to in writing between Synopsys
+  *     and you.
+  *
+  *     The Software IS NOT an item of Licensed Software or Licensed Product
+  *     under any End User Software License Agreement or Agreement for Licensed
+  *     Product with Synopsys or any supplement thereto.  Permission is hereby
+  *     granted, free of charge, to any person obtaining a copy of this software
+  *     annotated with this license and the Software, to deal in the Software
+  *     without restriction, including without limitation the rights to use,
+  *     copy, modify, merge, publish, distribute, sublicense, and/or sell copies
+  *     of the Software, and to permit persons to whom the Software is furnished
+  *     to do so, subject to the following conditions:
+  *
+  *     The above copyright notice and this permission notice shall be included
+  *     in all copies or substantial portions of the Software.
+  *
+  *     THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS"
+  *     BASIS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  *     TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  *     PARTICULAR PURPOSE ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS
+  *     BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  *     CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  *     SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  *     INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  *     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  *     ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  *     THE POSSIBILITY OF SUCH DAMAGE.
+  *
+  *
+  * License 2: Modified BSD
+  *
+  * Copyright (c) 2015,2016 Baikal Electronics JSC.
+  * Copyright (c) 2014 Advanced Micro Devices, Inc.
+  * All rights reserved.
+  *
+  * Redistribution and use in source and binary forms, with or without
+  * modification, are permitted provided that the following conditions are met:
+  *     * Redistributions of source code must retain the above copyright
+  *       notice, this list of conditions and the following disclaimer.
+  *     * Redistributions in binary form must reproduce the above copyright
+  *       notice, this list of conditions and the following disclaimer in the
+  *       documentation and/or other materials provided with the distribution.
+  *     * Neither the name of Advanced Micro Devices, Inc. nor the
+  *       names of its contributors may be used to endorse or promote products
+  *       derived from this software without specific prior written permission.
+  *
+  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+  * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
+  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+  *
+  * This file incorporates work covered by the following copyright and
+  * permission notice:
+  *     The Synopsys DWC ETHER XGMAC Software Driver and documentation
+  *     (hereinafter "Software") is an unsupported proprietary work of Synopsys,
+  *     Inc. unless otherwise expressly agreed to in writing between Synopsys
+  *     and you.
+  *
+  *     The Software IS NOT an item of Licensed Software or Licensed Product
+  *     under any End User Software License Agreement or Agreement for Licensed
+  *     Product with Synopsys or any supplement thereto.  Permission is hereby
+  *     granted, free of charge, to any person obtaining a copy of this software
+  *     annotated with this license and the Software, to deal in the Software
+  *     without restriction, including without limitation the rights to use,
+  *     copy, modify, merge, publish, distribute, sublicense, and/or sell copies
+  *     of the Software, and to permit persons to whom the Software is furnished
+  *     to do so, subject to the following conditions:
+  *
+  *     The above copyright notice and this permission notice shall be included
+  *     in all copies or substantial portions of the Software.
+  *
+  *     THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS"
+  *     BASIS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  *     TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  *     PARTICULAR PURPOSE ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS
+  *     BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  *     CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  *     SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  *     INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  *     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  *     ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  *     THE POSSIBILITY OF SUCH DAMAGE.
+  */
+ 
+ #include "xgbe.h"
+ #include "xgbe-common.h"
+ 
+ static void xgbe_unmap_rdata(struct xgbe_prv_data *, struct xgbe_ring_data *);
+ 
+ static void xgbe_free_ring(struct xgbe_prv_data *pdata,
+ 			   struct xgbe_ring *ring)
+ {
+ 	struct xgbe_ring_data *rdata;
+ 	unsigned int i;
+ 
+ 	if (!ring)
+ 		return;
+ 
+ 	if (ring->rdata) {
+ 		for (i = 0; i < ring->rdesc_count; i++) {
+ 			rdata = XGBE_GET_DESC_DATA(ring, i);
+ 			xgbe_unmap_rdata(pdata, rdata);
+ 		}
+ 
+ 		kfree(ring->rdata);
+ 		ring->rdata = NULL;
+ 	}
+ 
+ 	if (ring->rx_hdr_pa.pages) {
+ 		dma_unmap_page(pdata->dev, ring->rx_hdr_pa.pages_dma,
+ 			       ring->rx_hdr_pa.pages_len, DMA_FROM_DEVICE);
+ 		put_page(ring->rx_hdr_pa.pages);
+ 
+ 		ring->rx_hdr_pa.pages = NULL;
+ 		ring->rx_hdr_pa.pages_len = 0;
+ 		ring->rx_hdr_pa.pages_offset = 0;
+ 		ring->rx_hdr_pa.pages_dma = 0;
+ 	}
+ 
+ 	if (ring->rx_buf_pa.pages) {
+ 		dma_unmap_page(pdata->dev, ring->rx_buf_pa.pages_dma,
+ 			       ring->rx_buf_pa.pages_len, DMA_FROM_DEVICE);
+ 		put_page(ring->rx_buf_pa.pages);
+ 
+ 		ring->rx_buf_pa.pages = NULL;
+ 		ring->rx_buf_pa.pages_len = 0;
+ 		ring->rx_buf_pa.pages_offset = 0;
+ 		ring->rx_buf_pa.pages_dma = 0;
+ 	}
+ 
+ 	if (ring->rdesc) {
+ 		dma_free_coherent(pdata->dev,
+ 				  (sizeof(struct xgbe_ring_desc) *
+ 				   ring->rdesc_count),
+ 				  ring->rdesc, ring->rdesc_dma);
+ 		ring->rdesc = NULL;
+ 	}
+ }
+ 
+ static void xgbe_free_ring_resources(struct xgbe_prv_data *pdata)
+ {
+ 	struct xgbe_channel *channel;
+ 	unsigned int i;
+ 
+ 	DBGPR("-->xgbe_free_ring_resources\n");
+ 
+ 	channel = pdata->channel;
+ 	for (i = 0; i < pdata->channel_count; i++, channel++) {
+ 		xgbe_free_ring(pdata, channel->tx_ring);
+ 		xgbe_free_ring(pdata, channel->rx_ring);
+ 	}
+ 
+ 	DBGPR("<--xgbe_free_ring_resources\n");
+ }
+ 
+ static int xgbe_init_ring(struct xgbe_prv_data *pdata,
+ 			  struct xgbe_ring *ring, unsigned int rdesc_count)
+ {
+ 	DBGPR("-->xgbe_init_ring\n");
+ 
+ 	if (!ring)
+ 		return 0;
+ 
+ 	/* Descriptors */
+ 	ring->rdesc_count = rdesc_count;
+ 	ring->rdesc = dma_alloc_coherent(pdata->dev,
+ 					 (sizeof(struct xgbe_ring_desc) *
+ 					  rdesc_count), &ring->rdesc_dma,
+ 					 GFP_KERNEL);
+ 	if (!ring->rdesc)
+ 		return -ENOMEM;
+ 
+ 	/* Descriptor information */
+ 	ring->rdata = kcalloc(rdesc_count, sizeof(struct xgbe_ring_data),
+ 			      GFP_KERNEL);
+ 	if (!ring->rdata)
+ 		return -ENOMEM;
+ 
+ 	DBGPR("    rdesc=0x%p, rdesc_dma=0x%llx, rdata=0x%p\n",
+ 	      ring->rdesc->desc0, ring->rdesc_dma, ring->rdata);
+ 
+ 	DBGPR("<--xgbe_init_ring\n");
+ 
+ 	return 0;
+ }
+ 
+ static int xgbe_alloc_ring_resources(struct xgbe_prv_data *pdata)
+ {
+ 	struct xgbe_channel *channel;
+ 	unsigned int i;
+ 	int ret;
+ 
+ 	DBGPR("-->xgbe_alloc_ring_resources\n");
+ 
+ 	channel = pdata->channel;
+ 	for (i = 0; i < pdata->channel_count; i++, channel++) {
+ 		DBGPR("  %s - tx_ring:\n", channel->name);
+ 		ret = xgbe_init_ring(pdata, channel->tx_ring,
+ 				     pdata->tx_desc_count);
+ 		if (ret) {
+ 			netdev_alert(pdata->netdev,
+ 				     "error initializing Tx ring\n");
+ 			goto err_ring;
+ 		}
+ 
+ 		DBGPR("  %s - rx_ring:\n", channel->name);
+ 		ret = xgbe_init_ring(pdata, channel->rx_ring,
+ 				     pdata->rx_desc_count);
+ 		if (ret) {
+ 			netdev_alert(pdata->netdev,
+ 				     "error initializing Tx ring\n");
+ 			goto err_ring;
+ 		}
+ 	}
+ 
+ 	DBGPR("<--xgbe_alloc_ring_resources\n");
+ 
+ 	return 0;
+ 
+ err_ring:
+ 	xgbe_free_ring_resources(pdata);
+ 
+ 	return ret;
+ }
+ 
+ static int xgbe_alloc_pages(struct xgbe_prv_data *pdata,
+ 			    struct xgbe_page_alloc *pa, gfp_t gfp, int order)
+ {
+ 	struct page *pages = NULL;
+ 	dma_addr_t pages_dma;
+ 	int ret;
+ DBGPR("-->%s\n", __func__);
+ 	/* Try to obtain pages, decreasing order if necessary */
+ 	gfp |= __GFP_COLD | __GFP_COMP;
+ 	while (order >= 0) {
+ 		pages = alloc_pages(gfp, order);
+ 		if (pages)
+ 			break;
+ 
+ 		order--;
+ 	}
+ 	if (!pages)
+ 		return -ENOMEM;
+ 
+ 	/* Map the pages */
+ 	pages_dma = dma_map_page(pdata->dev, pages, 0,
+ 				 PAGE_SIZE << order, DMA_FROM_DEVICE);
+ 	ret = dma_mapping_error(pdata->dev, pages_dma);
+ 	if (ret) {
+ 		put_page(pages);
+ 		return ret;
+ 	}
+ 
+ 	pa->pages = pages;
+ 	pa->pages_len = PAGE_SIZE << order;
+ 	pa->pages_offset = 0;
+ 	pa->pages_dma = pages_dma;
+ 
+ 	return 0;
+ }
+ 
+ static void xgbe_set_buffer_data(struct xgbe_buffer_data *bd,
+ 				 struct xgbe_page_alloc *pa,
+ 				 unsigned int len)
+ {
+ //	DBGPR("-->%s\n", __func__);
+ 	get_page(pa->pages);
+ 	bd->pa = *pa;
+ 
+ 	bd->dma = pa->pages_dma + pa->pages_offset;
+ 	bd->dma_len = len;
+ 
+ 	pa->pages_offset += len;
+ 	if ((pa->pages_offset + len) > pa->pages_len) {
+ 		/* This data descriptor is responsible for unmapping page(s) */
+ 		bd->pa_unmap = *pa;
+ 
+ 		/* Get a new allocation next time */
+ 		pa->pages = NULL;
+ 		pa->pages_len = 0;
+ 		pa->pages_offset = 0;
+ 		pa->pages_dma = 0;
+ 	}
+ }
+ 
+ static int xgbe_map_rx_buffer(struct xgbe_prv_data *pdata,
+ 			      struct xgbe_ring *ring,
+ 			      struct xgbe_ring_data *rdata)
+ {
+ 	int order, ret;
+ //	DBGPR("-->%s\n", __func__);
+ 	if (!ring->rx_hdr_pa.pages) {
+ 		ret = xgbe_alloc_pages(pdata, &ring->rx_hdr_pa, GFP_ATOMIC, 0);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	if (!ring->rx_buf_pa.pages) {
+ 		order = max_t(int, PAGE_ALLOC_COSTLY_ORDER - 1, 0);
+ 		ret = xgbe_alloc_pages(pdata, &ring->rx_buf_pa, GFP_ATOMIC,
+ 				       order);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	/* Set up the header page info */
+ 	xgbe_set_buffer_data(&rdata->rx.hdr, &ring->rx_hdr_pa,
+ 			     XGBE_SKB_ALLOC_SIZE);
+ 
+ 	/* Set up the buffer page info */
+ 	xgbe_set_buffer_data(&rdata->rx.buf, &ring->rx_buf_pa,
+ 			     pdata->rx_buf_size);
+ 
+ 	return 0;
+ }
+ 
+ static void xgbe_wrapper_tx_descriptor_init(struct xgbe_prv_data *pdata)
+ {
+ 	struct xgbe_hw_if *hw_if = &pdata->hw_if;
+ 	struct xgbe_channel *channel;
+ 	struct xgbe_ring *ring;
+ 	struct xgbe_ring_data *rdata;
+ 	struct xgbe_ring_desc *rdesc;
+ 	dma_addr_t rdesc_dma;
+ 	unsigned int i, j;
+ 
+ 	DBGPR("-->xgbe_wrapper_tx_descriptor_init\n");
+ 
+ 	channel = pdata->channel;
+ 	for (i = 0; i < pdata->channel_count; i++, channel++) {
+ 		ring = channel->tx_ring;
+ 		if (!ring)
+ 			break;
+ 
+ 		rdesc = ring->rdesc;
+ 		rdesc_dma = ring->rdesc_dma;
+ 
+ 		for (j = 0; j < ring->rdesc_count; j++) {
+ 			rdata = XGBE_GET_DESC_DATA(ring, j);
+ 
+ 			rdata->rdesc = rdesc;
+ 			rdata->rdesc_dma = rdesc_dma;
+ 
+ 			rdesc++;
+ 			rdesc_dma += sizeof(struct xgbe_ring_desc);
+ 		}
+ 
+ 		ring->cur = 0;
+ 		ring->dirty = 0;
+ 		memset(&ring->tx, 0, sizeof(ring->tx));
+ 
+ 		hw_if->tx_desc_init(channel);
+ 	}
+ 
+ 	DBGPR("<--xgbe_wrapper_tx_descriptor_init\n");
+ }
+ 
+ static void xgbe_wrapper_rx_descriptor_init(struct xgbe_prv_data *pdata)
+ {
+ 	struct xgbe_hw_if *hw_if = &pdata->hw_if;
+ 	struct xgbe_channel *channel;
+ 	struct xgbe_ring *ring;
+ 	struct xgbe_ring_desc *rdesc;
+ 	struct xgbe_ring_data *rdata;
+ 	dma_addr_t rdesc_dma;
+ 	unsigned int i, j;
+ 
+ 	DBGPR("-->xgbe_wrapper_rx_descriptor_init\n");
+ 
+ 	channel = pdata->channel;
+ 	for (i = 0; i < pdata->channel_count; i++, channel++) {
+ 		ring = channel->rx_ring;
+ 		if (!ring)
+ 			break;
+ 
+ 		rdesc = ring->rdesc;
+ 		rdesc_dma = ring->rdesc_dma;
+ 		DBGPR("-->xgbe_wrapper_rx rdesc_count = %d\n", ring->rdesc_count);
+ 		for (j = 0; j < ring->rdesc_count; j++) {
+ 			rdata = XGBE_GET_DESC_DATA(ring, j);
+ 
+ 			rdata->rdesc = rdesc;
+ 			rdata->rdesc_dma = rdesc_dma;
+ 
+ 
+ 			if (xgbe_map_rx_buffer(pdata, ring, rdata))
+ 				break;
+ 
+ 			rdesc++;
+ 			rdesc_dma += sizeof(struct xgbe_ring_desc);
+ 		}
+ 
+ 		ring->cur = 0;
+ 		ring->dirty = 0;
+ 		memset(&ring->rx, 0, sizeof(ring->rx));
+ 
+ 		hw_if->rx_desc_init(channel);
+ 	}
+ 
+ 	DBGPR("<--xgbe_wrapper_rx_descriptor_init\n");
+ }
+ 
+ static void xgbe_unmap_rdata(struct xgbe_prv_data *pdata,
+ 			     struct xgbe_ring_data *rdata)
+ {
+ 	DBGPR("-->%s\n", __func__);
+ 	if (rdata->skb_dma) {
+ 		if (rdata->mapped_as_page) {
+ 			dma_unmap_page(pdata->dev, rdata->skb_dma,
+ 				       rdata->skb_dma_len, DMA_TO_DEVICE);
+ 		} else {
+ 			dma_unmap_single(pdata->dev, rdata->skb_dma,
+ 					 rdata->skb_dma_len, DMA_TO_DEVICE);
+ 		}
+ 		rdata->skb_dma = 0;
+ 		rdata->skb_dma_len = 0;
+ 	}
+ 
+ 	if (rdata->skb) {
+ 		dev_kfree_skb_any(rdata->skb);
+ 		rdata->skb = NULL;
+ 	}
+ 
+ 	if (rdata->rx.hdr.pa.pages)
+ 		put_page(rdata->rx.hdr.pa.pages);
+ 
+ 	if (rdata->rx.hdr.pa_unmap.pages) {
+ 		dma_unmap_page(pdata->dev, rdata->rx.hdr.pa_unmap.pages_dma,
+ 			       rdata->rx.hdr.pa_unmap.pages_len,
+ 			       DMA_FROM_DEVICE);
+ 		put_page(rdata->rx.hdr.pa_unmap.pages);
+ 	}
+ 
+ 	if (rdata->rx.buf.pa.pages)
+ 		put_page(rdata->rx.buf.pa.pages);
+ 
+ 	if (rdata->rx.buf.pa_unmap.pages) {
+ 		dma_unmap_page(pdata->dev, rdata->rx.buf.pa_unmap.pages_dma,
+ 			       rdata->rx.buf.pa_unmap.pages_len,
+ 			       DMA_FROM_DEVICE);
+ 		put_page(rdata->rx.buf.pa_unmap.pages);
+ 	}
+ 
+ 	memset(&rdata->tx, 0, sizeof(rdata->tx));
+ 	memset(&rdata->rx, 0, sizeof(rdata->rx));
+ 
+ 	rdata->mapped_as_page = 0;
+ 
+ 	if (rdata->state_saved) {
+ 		rdata->state_saved = 0;
+ 		rdata->state.incomplete = 0;
+ 		rdata->state.context_next = 0;
+ 		rdata->state.skb = NULL;
+ 		rdata->state.len = 0;
+ 		rdata->state.error = 0;
+ 	}
+ }
+ 
+ static int xgbe_map_tx_skb(struct xgbe_channel *channel, struct sk_buff *skb)
+ {
+ 	struct xgbe_prv_data *pdata = channel->pdata;
+ 	struct xgbe_ring *ring = channel->tx_ring;
+ 	struct xgbe_ring_data *rdata;
+ 	struct xgbe_packet_data *packet;
+ 	struct skb_frag_struct *frag;
+ 	dma_addr_t skb_dma;
+ 	unsigned int start_index, cur_index;
+ 	unsigned int offset, tso, vlan, datalen, len;
+ 	unsigned int i;
+ 
+ 	DBGPR("-->xgbe_map_tx_skb: cur = %d\n", ring->cur);
+ 
+ 	offset = 0;
+ 	start_index = ring->cur;
+ 	cur_index = ring->cur;
+ 
+ 	packet = &ring->packet_data;
+ 	packet->rdesc_count = 0;
+ 	packet->length = 0;
+ 
+ 	tso = XGMAC_GET_BITS(packet->attributes, TX_PACKET_ATTRIBUTES,
+ 			     TSO_ENABLE);
+ 	vlan = XGMAC_GET_BITS(packet->attributes, TX_PACKET_ATTRIBUTES,
+ 			      VLAN_CTAG);
+ 
+ 	/* Save space for a context descriptor if needed */
+ 	if ((tso && (packet->mss != ring->tx.cur_mss)) ||
+ 	    (vlan && (packet->vlan_ctag != ring->tx.cur_vlan_ctag)))
+ 		cur_index++;
+ 	rdata = XGBE_GET_DESC_DATA(ring, cur_index);
+ 
+ 	if (tso) {
+ 		DBGPR("  TSO packet\n");
+ 
+ 		/* Map the TSO header */
+ 		skb_dma = dma_map_single(pdata->dev, skb->data,
+ 					 packet->header_len, DMA_TO_DEVICE);
+ 		if (dma_mapping_error(pdata->dev, skb_dma)) {
+ 			netdev_alert(pdata->netdev, "dma_map_single failed\n");
+ 			goto err_out;
+ 		}
+ 		rdata->skb_dma = skb_dma;
+ 		rdata->skb_dma_len = packet->header_len;
+ 
+ 		offset = packet->header_len;
+ 
+ 		packet->length += packet->header_len;
+ 
+ 		cur_index++;
+ 		rdata = XGBE_GET_DESC_DATA(ring, cur_index);
+ 	}
+ 
+ 	/* Map the (remainder of the) packet */
+ 	for (datalen = skb_headlen(skb) - offset; datalen; ) {
+ 		len = min_t(unsigned int, datalen, XGBE_TX_MAX_BUF_SIZE);
+ 
+ 		skb_dma = dma_map_single(pdata->dev, skb->data + offset, len,
+ 					 DMA_TO_DEVICE);
+ 		if (dma_mapping_error(pdata->dev, skb_dma)) {
+ 			netdev_alert(pdata->netdev, "dma_map_single failed\n");
+ 			goto err_out;
+ 		}
+ 		rdata->skb_dma = skb_dma;
+ 		rdata->skb_dma_len = len;
+ 		DBGPR("  skb data: index=%u, dma=0x%llx, len=%u\n",
+ 		      cur_index, skb_dma, len);
+ 
+ 		datalen -= len;
+ 		offset += len;
+ 
+ 		packet->length += len;
+ 
+ 		cur_index++;
+ 		rdata = XGBE_GET_DESC_DATA(ring, cur_index);
+ 	}
+ 
+ 	for (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {
+ 		DBGPR("  mapping frag %u\n", i);
+ 
+ 		frag = &skb_shinfo(skb)->frags[i];
+ 		offset = 0;
+ 
+ 		for (datalen = skb_frag_size(frag); datalen; ) {
+ 			len = min_t(unsigned int, datalen,
+ 				    XGBE_TX_MAX_BUF_SIZE);
+ 
+ 			skb_dma = skb_frag_dma_map(pdata->dev, frag, offset,
+ 						   len, DMA_TO_DEVICE);
+ 			if (dma_mapping_error(pdata->dev, skb_dma)) {
+ 				netdev_alert(pdata->netdev,
+ 					     "skb_frag_dma_map failed\n");
+ 				goto err_out;
+ 			}
+ 			rdata->skb_dma = skb_dma;
+ 			rdata->skb_dma_len = len;
+ 			rdata->mapped_as_page = 1;
+ 			DBGPR("  skb data: index=%u, dma=0x%llx, len=%u\n",
+ 			      cur_index, skb_dma, len);
+ 
+ 			datalen -= len;
+ 			offset += len;
+ 
+ 			packet->length += len;
+ 
+ 			cur_index++;
+ 			rdata = XGBE_GET_DESC_DATA(ring, cur_index);
+ 		}
+ 	}
+ 
+ 	/* Save the skb address in the last entry. We always have some data
+ 	 * that has been mapped so rdata is always advanced past the last
+ 	 * piece of mapped data - use the entry pointed to by cur_index - 1.
+ 	 */
+ 	rdata = XGBE_GET_DESC_DATA(ring, cur_index - 1);
+ 	rdata->skb = skb;
+ 
+ 	/* Save the number of descriptor entries used */
+ 	packet->rdesc_count = cur_index - start_index;
+ 
+ 	DBGPR("<--xgbe_map_tx_skb: count=%u\n", packet->rdesc_count);
+ 
+ 	return packet->rdesc_count;
+ 
+ err_out:
+ 	while (start_index < cur_index) {
+ 		rdata = XGBE_GET_DESC_DATA(ring, start_index++);
+ 		xgbe_unmap_rdata(pdata, rdata);
+ 	}
+ 
+ 	DBGPR("<--xgbe_map_tx_skb: count=0\n");
+ 
+ 	return 0;
+ }
+ 
+ static void xgbe_realloc_rx_buffer(struct xgbe_channel *channel)
+ {
+ 	struct xgbe_prv_data *pdata = channel->pdata;
+ 	struct xgbe_hw_if *hw_if = &pdata->hw_if;
+ 	struct xgbe_ring *ring = channel->rx_ring;
+ 	struct xgbe_ring_data *rdata;
+ 	int i;
+ 
+ 	DBGPR("-->xgbe_realloc_rx_buffer: rx_ring->rx.realloc_index = %u\n",
+ 	      ring->rx.realloc_index);
+ 
+ 	for (i = 0; i < ring->dirty; i++) {
+ 		rdata = XGBE_GET_DESC_DATA(ring, ring->rx.realloc_index);
+ 
+ 		/* Reset rdata values */
+ 		xgbe_unmap_rdata(pdata, rdata);
+ 
+ 		if (xgbe_map_rx_buffer(pdata, ring, rdata))
+ 			break;
+ 
+ 		hw_if->rx_desc_reset(rdata);
+ 
+ 		ring->rx.realloc_index++;
+ 	}
+ 	ring->dirty = 0;
+ 
+ 	DBGPR("<--xgbe_realloc_rx_buffer\n");
+ }
+ 
+ void xgbe_init_function_ptrs_desc(struct xgbe_desc_if *desc_if)
+ {
+ 	DBGPR("-->xgbe_init_function_ptrs_desc\n");
+ 
+ 	desc_if->alloc_ring_resources = xgbe_alloc_ring_resources;
+ 	desc_if->free_ring_resources = xgbe_free_ring_resources;
+ 	desc_if->map_tx_skb = xgbe_map_tx_skb;
+ 	desc_if->realloc_rx_buffer = xgbe_realloc_rx_buffer;
+ 	desc_if->unmap_rdata = xgbe_unmap_rdata;
+ 	desc_if->wrapper_tx_desc_init = xgbe_wrapper_tx_descriptor_init;
+ 	desc_if->wrapper_rx_desc_init = xgbe_wrapper_rx_descriptor_init;
+ 
+ 	DBGPR("<--xgbe_init_function_ptrs_desc\n");
+ }
diff -rcNP linux-4.4.24/drivers/net/ethernet/baikal/xgbe/xgbe-dev.c linux-4.4.24-baikal/drivers/net/ethernet/baikal/xgbe/xgbe-dev.c
*** linux-4.4.24/drivers/net/ethernet/baikal/xgbe/xgbe-dev.c	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/drivers/net/ethernet/baikal/xgbe/xgbe-dev.c	2016-11-11 14:49:52.000000000 +0300
***************
*** 0 ****
--- 1,2786 ----
+ /*
+  * Baikal Electronics 10Gb Ethernet driver
+  *
+  * Based on AMD 10Gb Ethernet driver
+  * drivers/net/ethernet/amd/xgbe
+  *
+  * This file is available to you under your choice of the following two
+  * licenses:
+  *
+  * License 1: GPLv2
+  *
+  * Copyright (c) 2015,2016 Baikal Electronics JSC.
+  * Copyright (c) 2014 Advanced Micro Devices, Inc.
+  *
+  * Adopted by:
+  *   Dmitry Dunaev <dmitry.dunaev@baikalelectronics.ru>
+  *
+  * This file is free software; you may copy, redistribute and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation, either version 2 of the License, or (at
+  * your option) any later version.
+  *
+  * This file is distributed in the hope that it will be useful, but
+  * WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+  * General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+  *
+  * This file incorporates work covered by the following copyright and
+  * permission notice:
+  *     The Synopsys DWC ETHER XGMAC Software Driver and documentation
+  *     (hereinafter "Software") is an unsupported proprietary work of Synopsys,
+  *     Inc. unless otherwise expressly agreed to in writing between Synopsys
+  *     and you.
+  *
+  *     The Software IS NOT an item of Licensed Software or Licensed Product
+  *     under any End User Software License Agreement or Agreement for Licensed
+  *     Product with Synopsys or any supplement thereto.  Permission is hereby
+  *     granted, free of charge, to any person obtaining a copy of this software
+  *     annotated with this license and the Software, to deal in the Software
+  *     without restriction, including without limitation the rights to use,
+  *     copy, modify, merge, publish, distribute, sublicense, and/or sell copies
+  *     of the Software, and to permit persons to whom the Software is furnished
+  *     to do so, subject to the following conditions:
+  *
+  *     The above copyright notice and this permission notice shall be included
+  *     in all copies or substantial portions of the Software.
+  *
+  *     THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS"
+  *     BASIS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  *     TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  *     PARTICULAR PURPOSE ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS
+  *     BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  *     CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  *     SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  *     INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  *     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  *     ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  *     THE POSSIBILITY OF SUCH DAMAGE.
+  *
+  *
+  * License 2: Modified BSD
+  *
+  * Copyright (c) 2015,2016 Baikal Electronics JSC.
+  * Copyright (c) 2014 Advanced Micro Devices, Inc.
+  * All rights reserved.
+  *
+  * Redistribution and use in source and binary forms, with or without
+  * modification, are permitted provided that the following conditions are met:
+  *     * Redistributions of source code must retain the above copyright
+  *       notice, this list of conditions and the following disclaimer.
+  *     * Redistributions in binary form must reproduce the above copyright
+  *       notice, this list of conditions and the following disclaimer in the
+  *       documentation and/or other materials provided with the distribution.
+  *     * Neither the name of Advanced Micro Devices, Inc. nor the
+  *       names of its contributors may be used to endorse or promote products
+  *       derived from this software without specific prior written permission.
+  *
+  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+  * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
+  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+  *
+  * This file incorporates work covered by the following copyright and
+  * permission notice:
+  *     The Synopsys DWC ETHER XGMAC Software Driver and documentation
+  *     (hereinafter "Software") is an unsupported proprietary work of Synopsys,
+  *     Inc. unless otherwise expressly agreed to in writing between Synopsys
+  *     and you.
+  *
+  *     The Software IS NOT an item of Licensed Software or Licensed Product
+  *     under any End User Software License Agreement or Agreement for Licensed
+  *     Product with Synopsys or any supplement thereto.  Permission is hereby
+  *     granted, free of charge, to any person obtaining a copy of this software
+  *     annotated with this license and the Software, to deal in the Software
+  *     without restriction, including without limitation the rights to use,
+  *     copy, modify, merge, publish, distribute, sublicense, and/or sell copies
+  *     of the Software, and to permit persons to whom the Software is furnished
+  *     to do so, subject to the following conditions:
+  *
+  *     The above copyright notice and this permission notice shall be included
+  *     in all copies or substantial portions of the Software.
+  *
+  *     THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS"
+  *     BASIS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  *     TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  *     PARTICULAR PURPOSE ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS
+  *     BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  *     CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  *     SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  *     INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  *     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  *     ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  *     THE POSSIBILITY OF SUCH DAMAGE.
+  */
+ 
+ #include <linux/phy.h>
+ #include <linux/clk.h>
+ #include <linux/bitrev.h>
+ #include <linux/crc32.h>
+ 
+ #include "xgbe.h"
+ #include "xgbe-common.h"
+ 
+ static unsigned int xgbe_usec_to_riwt(struct xgbe_prv_data *pdata,
+ 				      unsigned int usec)
+ {
+ 	unsigned long rate;
+ 	unsigned int ret;
+ 
+ 	DBGPR("-->xgbe_usec_to_riwt\n");
+ 
+ 	rate = clk_get_rate(pdata->sysclk);
+ 
+ 	/*
+ 	 * Convert the input usec value to the watchdog timer value. Each
+ 	 * watchdog timer value is equivalent to 256 clock cycles.
+ 	 * Calculate the required value as:
+ 	 *   ( usec * ( system_clock_mhz / 10^6 ) / 256
+ 	 */
+ 	ret = (usec * (rate / 1000000)) / 256;
+ 
+ 	DBGPR("<--xgbe_usec_to_riwt\n");
+ 
+ 	return ret;
+ }
+ 
+ static unsigned int xgbe_riwt_to_usec(struct xgbe_prv_data *pdata,
+ 				      unsigned int riwt)
+ {
+ 	unsigned long rate;
+ 	unsigned int ret;
+ 
+ 	DBGPR("-->xgbe_riwt_to_usec\n");
+ 
+ 	rate = clk_get_rate(pdata->sysclk);
+ 
+ 	/*
+ 	 * Convert the input watchdog timer value to the usec value. Each
+ 	 * watchdog timer value is equivalent to 256 clock cycles.
+ 	 * Calculate the required value as:
+ 	 *   ( riwt * 256 ) / ( system_clock_mhz / 10^6 )
+ 	 */
+ 	ret = (riwt * 256) / (rate / 1000000);
+ 
+ 	DBGPR("<--xgbe_riwt_to_usec\n");
+ 
+ 	return ret;
+ }
+ 
+ static int xgbe_config_pblx8(struct xgbe_prv_data *pdata)
+ {
+ 	struct xgbe_channel *channel;
+ 	unsigned int i;
+ DBGPR("-->%s\n", __func__);
+ 	channel = pdata->channel;
+ 	for (i = 0; i < pdata->channel_count; i++, channel++)
+ 		XGMAC_DMA_IOWRITE_BITS(channel, DMA_CH_CR, PBLX8,
+ 				       pdata->pblx8);
+ 
+ 	return 0;
+ }
+ 
+ static int xgbe_get_tx_pbl_val(struct xgbe_prv_data *pdata)
+ {
+ DBGPR("-->%s\n", __func__);
+ 	return XGMAC_DMA_IOREAD_BITS(pdata->channel, DMA_CH_TCR, PBL);
+ }
+ 
+ static int xgbe_config_tx_pbl_val(struct xgbe_prv_data *pdata)
+ {
+ 	struct xgbe_channel *channel;
+ 	unsigned int i;
+ DBGPR("-->%s\n", __func__);
+ 	channel = pdata->channel;
+ 	for (i = 0; i < pdata->channel_count; i++, channel++) {
+ 		if (!channel->tx_ring)
+ 			break;
+ 
+ 		XGMAC_DMA_IOWRITE_BITS(channel, DMA_CH_TCR, PBL,
+ 				       pdata->tx_pbl);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int xgbe_get_rx_pbl_val(struct xgbe_prv_data *pdata)
+ {
+ DBGPR("-->%s\n", __func__);
+ 	return XGMAC_DMA_IOREAD_BITS(pdata->channel, DMA_CH_RCR, PBL);
+ }
+ 
+ static int xgbe_config_rx_pbl_val(struct xgbe_prv_data *pdata)
+ {
+ 	struct xgbe_channel *channel;
+ 	unsigned int i;
+ DBGPR("-->%s\n", __func__);
+ 	channel = pdata->channel;
+ 	for (i = 0; i < pdata->channel_count; i++, channel++) {
+ 		if (!channel->rx_ring)
+ 			break;
+ 
+ 		XGMAC_DMA_IOWRITE_BITS(channel, DMA_CH_RCR, PBL,
+ 				       pdata->rx_pbl);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int xgbe_config_osp_mode(struct xgbe_prv_data *pdata)
+ {
+ 	struct xgbe_channel *channel;
+ 	unsigned int i;
+ DBGPR("-->%s\n", __func__);
+ 	channel = pdata->channel;
+ 	for (i = 0; i < pdata->channel_count; i++, channel++) {
+ 		if (!channel->tx_ring)
+ 			break;
+ 
+ 		XGMAC_DMA_IOWRITE_BITS(channel, DMA_CH_TCR, OSP,
+ 				       pdata->tx_osp_mode);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int xgbe_config_rsf_mode(struct xgbe_prv_data *pdata, unsigned int val)
+ {
+ 	unsigned int i;
+ DBGPR("-->%s\n", __func__);
+ 	for (i = 0; i < pdata->rx_q_count; i++)
+ 		XGMAC_MTL_IOWRITE_BITS(pdata, i, MTL_Q_RQOMR, RSF, val);
+ 
+ 	return 0;
+ }
+ 
+ static int xgbe_config_tsf_mode(struct xgbe_prv_data *pdata, unsigned int val)
+ {
+ 	unsigned int i;
+ DBGPR("-->%s\n", __func__);
+ 	for (i = 0; i < pdata->tx_q_count; i++)
+ 		XGMAC_MTL_IOWRITE_BITS(pdata, i, MTL_Q_TQOMR, TSF, val);
+ 
+ 	return 0;
+ }
+ 
+ static int xgbe_config_rx_threshold(struct xgbe_prv_data *pdata,
+ 				    unsigned int val)
+ {
+ 	unsigned int i;
+ DBGPR("-->%s\n", __func__);
+ 	for (i = 0; i < pdata->rx_q_count; i++)
+ 		XGMAC_MTL_IOWRITE_BITS(pdata, i, MTL_Q_RQOMR, RTC, val);
+ 
+ 	return 0;
+ }
+ 
+ static int xgbe_config_tx_threshold(struct xgbe_prv_data *pdata,
+ 				    unsigned int val)
+ {
+ 	unsigned int i;
+ DBGPR("-->%s\n", __func__);
+ 	for (i = 0; i < pdata->tx_q_count; i++)
+ 		XGMAC_MTL_IOWRITE_BITS(pdata, i, MTL_Q_TQOMR, TTC, val);
+ 
+ 	return 0;
+ }
+ 
+ static int xgbe_config_rx_coalesce(struct xgbe_prv_data *pdata)
+ {
+ 	struct xgbe_channel *channel;
+ 	unsigned int i;
+ //DBGPR("-->%s\n", __func__);
+ 	channel = pdata->channel;
+ 	for (i = 0; i < pdata->channel_count; i++, channel++) {
+ 		if (!channel->rx_ring)
+ 			break;
+ DBGPR("-->%s riwt = %d frames = %d\n", __func__, pdata->rx_riwt, pdata->rx_frames);
+ 
+ 		XGMAC_DMA_IOWRITE_BITS(channel, DMA_CH_RIWT, RWT,
+ 				       pdata->rx_riwt);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int xgbe_config_tx_coalesce(struct xgbe_prv_data *pdata)
+ {
+ 	return 0;
+ }
+ 
+ static void xgbe_config_rx_buffer_size(struct xgbe_prv_data *pdata)
+ {
+ 	struct xgbe_channel *channel;
+ 	unsigned int i;
+ DBGPR("-->%s\n", __func__);
+ 	channel = pdata->channel;
+ 	for (i = 0; i < pdata->channel_count; i++, channel++) {
+ 		if (!channel->rx_ring)
+ 			break;
+ 
+ 		XGMAC_DMA_IOWRITE_BITS(channel, DMA_CH_RCR, RBSZ,
+ 				       pdata->rx_buf_size);
+ 	}
+ }
+ 
+ static void xgbe_config_tso_mode(struct xgbe_prv_data *pdata)
+ {
+ 	struct xgbe_channel *channel;
+ 	unsigned int i;
+ DBGPR("-->%s\n", __func__);
+ 	channel = pdata->channel;
+ 	for (i = 0; i < pdata->channel_count; i++, channel++) {
+ 		if (!channel->tx_ring)
+ 			break;
+ 
+ 		XGMAC_DMA_IOWRITE_BITS(channel, DMA_CH_TCR, TSE, 1);
+ 	}
+ }
+ 
+ static void xgbe_config_sph_mode(struct xgbe_prv_data *pdata)
+ {
+ 	struct xgbe_channel *channel;
+ 	unsigned int i;
+ DBGPR("-->%s\n", __func__);
+ 	channel = pdata->channel;
+ 	for (i = 0; i < pdata->channel_count; i++, channel++) {
+ 		if (!channel->rx_ring)
+ 			break;
+ 
+ 		XGMAC_DMA_IOWRITE_BITS(channel, DMA_CH_CR, SPH, 1);
+ 	}
+ 
+ 	XGMAC_IOWRITE_BITS(pdata, MAC_RCR, HDSMS, XGBE_SPH_HDSMS_SIZE);
+ }
+ 
+ static int xgbe_write_rss_reg(struct xgbe_prv_data *pdata, unsigned int type,
+ 			      unsigned int index, unsigned int val)
+ {
+ 	unsigned int wait;
+ 	int ret = 0;
+ 
+ 	mutex_lock(&pdata->rss_mutex);
+ 
+ 	if (XGMAC_IOREAD_BITS(pdata, MAC_RSSAR, OB)) {
+ 		ret = -EBUSY;
+ 		goto unlock;
+ 	}
+ 
+ 	XGMAC_IOWRITE(pdata, MAC_RSSDR, val);
+ 
+ 	XGMAC_IOWRITE_BITS(pdata, MAC_RSSAR, RSSIA, index);
+ 	XGMAC_IOWRITE_BITS(pdata, MAC_RSSAR, ADDRT, type);
+ 	XGMAC_IOWRITE_BITS(pdata, MAC_RSSAR, CT, 0);
+ 	XGMAC_IOWRITE_BITS(pdata, MAC_RSSAR, OB, 1);
+ 
+ 	wait = 1000;
+ 	while (wait--) {
+ 		if (!XGMAC_IOREAD_BITS(pdata, MAC_RSSAR, OB))
+ 			goto unlock;
+ 
+ 		usleep_range(1000, 1500);
+ 	}
+ 
+ 	ret = -EBUSY;
+ 
+ unlock:
+ 	mutex_unlock(&pdata->rss_mutex);
+ 
+ 	return ret;
+ }
+ 
+ static int xgbe_write_rss_hash_key(struct xgbe_prv_data *pdata)
+ {
+ 	unsigned int key_regs = sizeof(pdata->rss_key) / sizeof(u32);
+ 	unsigned int *key = (unsigned int *)&pdata->rss_key;
+ 	int ret;
+ DBGPR("-->%s\n", __func__);
+ 	while (key_regs--) {
+ 		ret = xgbe_write_rss_reg(pdata, XGBE_RSS_HASH_KEY_TYPE,
+ 					 key_regs, *key++);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int xgbe_write_rss_lookup_table(struct xgbe_prv_data *pdata)
+ {
+ 	unsigned int i;
+ 	int ret;
+ DBGPR("-->%s\n", __func__);
+ 	for (i = 0; i < ARRAY_SIZE(pdata->rss_table); i++) {
+ 		ret = xgbe_write_rss_reg(pdata,
+ 					 XGBE_RSS_LOOKUP_TABLE_TYPE, i,
+ 					 pdata->rss_table[i]);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int xgbe_set_rss_hash_key(struct xgbe_prv_data *pdata, const u8 *key)
+ {
+ DBGPR("-->%s\n", __func__);
+ 	memcpy(pdata->rss_key, key, sizeof(pdata->rss_key));
+ 
+ 	return xgbe_write_rss_hash_key(pdata);
+ }
+ 
+ static int xgbe_set_rss_lookup_table(struct xgbe_prv_data *pdata,
+ 				     const u32 *table)
+ {
+ 	unsigned int i;
+ DBGPR("-->%s\n", __func__);
+ 	for (i = 0; i < ARRAY_SIZE(pdata->rss_table); i++)
+ 		XGMAC_SET_BITS(pdata->rss_table[i], MAC_RSSDR, DMCH, table[i]);
+ 
+ 	return xgbe_write_rss_lookup_table(pdata);
+ }
+ 
+ static int xgbe_enable_rss(struct xgbe_prv_data *pdata)
+ {
+ 	int ret;
+ DBGPR("-->%s\n", __func__);
+ 	if (!pdata->hw_feat.rss)
+ 		return -EOPNOTSUPP;
+ 
+ 	/* Program the hash key */
+ 	ret = xgbe_write_rss_hash_key(pdata);
+ 	if (ret)
+ 		return ret;
+ 
+ 	/* Program the lookup table */
+ 	ret = xgbe_write_rss_lookup_table(pdata);
+ 	if (ret)
+ 		return ret;
+ 
+ 	/* Set the RSS options */
+ 	XGMAC_IOWRITE(pdata, MAC_RSSCR, pdata->rss_options);
+ 
+ 	/* Enable RSS */
+ 	XGMAC_IOWRITE_BITS(pdata, MAC_RSSCR, RSSE, 1);
+ 
+ 	return 0;
+ }
+ 
+ static int xgbe_disable_rss(struct xgbe_prv_data *pdata)
+ {
+ DBGPR("-->%s\n", __func__);
+ 	if (!pdata->hw_feat.rss)
+ 		return -EOPNOTSUPP;
+ 
+ 	XGMAC_IOWRITE_BITS(pdata, MAC_RSSCR, RSSE, 0);
+ 
+ 	return 0;
+ }
+ 
+ static void xgbe_config_rss(struct xgbe_prv_data *pdata)
+ {
+ 	int ret;
+ DBGPR("-->%s\n", __func__);
+ 	if (!pdata->hw_feat.rss)
+ 		return;
+ 
+ 	if (pdata->netdev->features & NETIF_F_RXHASH)
+ 		ret = xgbe_enable_rss(pdata);
+ 	else
+ 		ret = xgbe_disable_rss(pdata);
+ 
+ 	if (ret)
+ 		netdev_err(pdata->netdev,
+ 			   "error configuring RSS, RSS disabled\n");
+ }
+ 
+ static int xgbe_disable_tx_flow_control(struct xgbe_prv_data *pdata)
+ {
+ 	unsigned int max_q_count, q_count;
+ 	unsigned int reg, reg_val;
+ 	unsigned int i;
+ DBGPR("-->%s\n", __func__);
+ 	/* Clear MTL flow control */
+ 	for (i = 0; i < pdata->rx_q_count; i++)
+ 		XGMAC_MTL_IOWRITE_BITS(pdata, i, MTL_Q_RQOMR, EHFC, 0);
+ 
+ 	/* Clear MAC flow control */
+ 	max_q_count = XGMAC_MAX_FLOW_CONTROL_QUEUES;
+ 	q_count = min_t(unsigned int, pdata->tx_q_count, max_q_count);
+ 	reg = MAC_Q0TFCR;
+ 	for (i = 0; i < q_count; i++) {
+ 		reg_val = XGMAC_IOREAD(pdata, reg);
+ 		XGMAC_SET_BITS(reg_val, MAC_Q0TFCR, TFE, 0);
+ 		XGMAC_IOWRITE(pdata, reg, reg_val);
+ 
+ 		reg += MAC_QTFCR_INC;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int xgbe_enable_tx_flow_control(struct xgbe_prv_data *pdata)
+ {
+ 	unsigned int max_q_count, q_count;
+ 	unsigned int reg, reg_val;
+ 	unsigned int i;
+ DBGPR("-->%s\n", __func__);
+ 	/* Set MTL flow control */
+ 	for (i = 0; i < pdata->rx_q_count; i++)
+ 		XGMAC_MTL_IOWRITE_BITS(pdata, i, MTL_Q_RQOMR, EHFC, 1);
+ 
+ 	/* Set MAC flow control */
+ 	max_q_count = XGMAC_MAX_FLOW_CONTROL_QUEUES;
+ 	q_count = min_t(unsigned int, pdata->tx_q_count, max_q_count);
+ 	reg = MAC_Q0TFCR;
+ 	for (i = 0; i < q_count; i++) {
+ 		reg_val = XGMAC_IOREAD(pdata, reg);
+ 
+ 		/* Enable transmit flow control */
+ 		XGMAC_SET_BITS(reg_val, MAC_Q0TFCR, TFE, 1);
+ 		/* Set pause time */
+ 		XGMAC_SET_BITS(reg_val, MAC_Q0TFCR, PT, 0xffff);
+ 
+ 		XGMAC_IOWRITE(pdata, reg, reg_val);
+ 
+ 		reg += MAC_QTFCR_INC;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int xgbe_disable_rx_flow_control(struct xgbe_prv_data *pdata)
+ {
+ DBGPR("-->%s\n", __func__);
+ 	XGMAC_IOWRITE_BITS(pdata, MAC_RFCR, RFE, 0);
+ 
+ 	return 0;
+ }
+ 
+ static int xgbe_enable_rx_flow_control(struct xgbe_prv_data *pdata)
+ {
+ DBGPR("-->%s\n", __func__);
+ 	XGMAC_IOWRITE_BITS(pdata, MAC_RFCR, RFE, 1);
+ 
+ 	return 0;
+ }
+ 
+ static int xgbe_config_tx_flow_control(struct xgbe_prv_data *pdata)
+ {
+ 	struct ieee_pfc *pfc = pdata->pfc;
+ DBGPR("-->%s\n", __func__);
+ 	if (pdata->tx_pause || (pfc && pfc->pfc_en))
+ 		xgbe_enable_tx_flow_control(pdata);
+ 	else
+ 		xgbe_disable_tx_flow_control(pdata);
+ 
+ 	return 0;
+ }
+ 
+ static int xgbe_config_rx_flow_control(struct xgbe_prv_data *pdata)
+ {
+ 	struct ieee_pfc *pfc = pdata->pfc;
+ DBGPR("-->%s\n", __func__);
+ 	if (pdata->rx_pause || (pfc && pfc->pfc_en))
+ 		xgbe_enable_rx_flow_control(pdata);
+ 	else
+ 		xgbe_disable_rx_flow_control(pdata);
+ 
+ 	return 0;
+ }
+ 
+ static void xgbe_config_flow_control(struct xgbe_prv_data *pdata)
+ {
+ 	struct ieee_pfc *pfc = pdata->pfc;
+ DBGPR("-->%s\n", __func__);
+ 	xgbe_config_tx_flow_control(pdata);
+ 	xgbe_config_rx_flow_control(pdata);
+ 
+ 	XGMAC_IOWRITE_BITS(pdata, MAC_RFCR, PFCE,
+ 			   (pfc && pfc->pfc_en) ? 1 : 0);
+ }
+ 
+ static void xgbe_enable_dma_interrupts(struct xgbe_prv_data *pdata)
+ {
+ 	struct xgbe_channel *channel;
+ 	unsigned int dma_ch_isr, dma_ch_ier;
+ 	unsigned int i;
+ DBGPR("-->%s\n", __func__);
+ 	channel = pdata->channel;
+ 	for (i = 0; i < pdata->channel_count; i++, channel++) {
+ 		/* Clear all the interrupts which are set */
+ 		dma_ch_isr = XGMAC_DMA_IOREAD(channel, DMA_CH_SR);
+ 		XGMAC_DMA_IOWRITE(channel, DMA_CH_SR, dma_ch_isr);
+ 
+ 		/* Clear all interrupt enable bits */
+ 		dma_ch_ier = 0;
+ 
+ 		/* Enable following interrupts
+ 		 *   NIE  - Normal Interrupt Summary Enable
+ 		 *   AIE  - Abnormal Interrupt Summary Enable
+ 		 *   FBEE - Fatal Bus Error Enable
+ 		 */
+ 		XGMAC_SET_BITS(dma_ch_ier, DMA_CH_IER, NIE, 1);
+ 		XGMAC_SET_BITS(dma_ch_ier, DMA_CH_IER, AIE, 1);
+ 		XGMAC_SET_BITS(dma_ch_ier, DMA_CH_IER, FBEE, 1);
+ 
+ 		if (channel->tx_ring) {
+ 			/* Enable the following Tx interrupts
+ 			 *   TIE  - Transmit Interrupt Enable (unless using
+ 			 *          per channel interrupts)
+ 			 */
+ 			if (!pdata->per_channel_irq)
+ 				XGMAC_SET_BITS(dma_ch_ier, DMA_CH_IER, TIE, 1);
+ 		}
+ 		if (channel->rx_ring) {
+ 			/* Enable following Rx interrupts
+ 			 *   RBUE - Receive Buffer Unavailable Enable
+ 			 *   RIE  - Receive Interrupt Enable (unless using
+ 			 *          per channel interrupts)
+ 			 */
+ 			XGMAC_SET_BITS(dma_ch_ier, DMA_CH_IER, RBUE, 1);
+ 			if (!pdata->per_channel_irq)
+ 				XGMAC_SET_BITS(dma_ch_ier, DMA_CH_IER, RIE, 1);
+ 		}
+ 
+ 		XGMAC_DMA_IOWRITE(channel, DMA_CH_IER, dma_ch_ier);
+ 	}
+ }
+ 
+ static void xgbe_enable_mtl_interrupts(struct xgbe_prv_data *pdata)
+ {
+ 	unsigned int mtl_q_isr;
+ 	unsigned int q_count, i;
+ DBGPR("-->%s\n", __func__);
+ 	q_count = max(pdata->hw_feat.tx_q_cnt, pdata->hw_feat.rx_q_cnt);
+ 	for (i = 0; i < q_count; i++) {
+ 		/* Clear all the interrupts which are set */
+ 		mtl_q_isr = XGMAC_MTL_IOREAD(pdata, i, MTL_Q_ISR);
+ 		XGMAC_MTL_IOWRITE(pdata, i, MTL_Q_ISR, mtl_q_isr);
+ 
+ 		/* No MTL interrupts to be enabled */
+ 		XGMAC_MTL_IOWRITE(pdata, i, MTL_Q_IER, 0);
+ 	}
+ }
+ 
+ static void xgbe_enable_mac_interrupts(struct xgbe_prv_data *pdata)
+ {
+ 	unsigned int mac_ier = 0;
+ DBGPR("-->%s\n", __func__);
+ 	/* Enable Timestamp interrupt */
+ 	XGMAC_SET_BITS(mac_ier, MAC_IER, TSIE, 1);
+ 
+ 	XGMAC_IOWRITE(pdata, MAC_IER, mac_ier);
+ }
+ 
+ static int xgbe_set_gmii_speed(struct xgbe_prv_data *pdata)
+ {
+ DBGPR("-->%s\n", __func__);
+ 	XGMAC_IOWRITE_BITS(pdata, MAC_TCR, SS, 0x3);
+ 
+ 	return 0;
+ }
+ 
+ static int xgbe_set_gmii_2500_speed(struct xgbe_prv_data *pdata)
+ {
+ DBGPR("-->%s\n", __func__);
+ 	XGMAC_IOWRITE_BITS(pdata, MAC_TCR, SS, 0x2);
+ 
+ 	return 0;
+ }
+ 
+ static int xgbe_set_xgmii_speed(struct xgbe_prv_data *pdata)
+ {
+ DBGPR("-->%s\n", __func__);
+ 	XGMAC_IOWRITE_BITS(pdata, MAC_TCR, SS, 0);
+ 
+ 	return 0;
+ }
+ 
+ static int xgbe_set_promiscuous_mode(struct xgbe_prv_data *pdata,
+ 				     unsigned int enable)
+ {
+ 	unsigned int val = enable ? 1 : 0;
+ DBGPR("-->%s\n", __func__);
+ 	if (XGMAC_IOREAD_BITS(pdata, MAC_PFR, PR) == val)
+ 		return 0;
+ 
+ 	DBGPR("  %s promiscuous mode\n", enable ? "entering" : "leaving");
+ 	XGMAC_IOWRITE_BITS(pdata, MAC_PFR, PR, val);
+ 
+ 	return 0;
+ }
+ 
+ static int xgbe_set_all_multicast_mode(struct xgbe_prv_data *pdata,
+ 				       unsigned int enable)
+ {
+ 	unsigned int val = enable ? 1 : 0;
+ 
+ 	if (XGMAC_IOREAD_BITS(pdata, MAC_PFR, PM) == val)
+ 		return 0;
+ 
+ 	DBGPR("  %s allmulti mode\n", enable ? "entering" : "leaving");
+ 	XGMAC_IOWRITE_BITS(pdata, MAC_PFR, PM, val);
+ 
+ 	return 0;
+ }
+ 
+ static void xgbe_set_mac_reg(struct xgbe_prv_data *pdata,
+ 			     struct netdev_hw_addr *ha, unsigned int *mac_reg)
+ {
+ 	unsigned int mac_addr_hi, mac_addr_lo;
+ 	u8 *mac_addr;
+ 
+ 	mac_addr_lo = 0;
+ 	mac_addr_hi = 0;
+ DBGPR("-->%s\n", __func__);
+ 	if (ha) {
+ 		mac_addr = (u8 *)&mac_addr_lo;
+ 		mac_addr[0] = ha->addr[0];
+ 		mac_addr[1] = ha->addr[1];
+ 		mac_addr[2] = ha->addr[2];
+ 		mac_addr[3] = ha->addr[3];
+ 		mac_addr = (u8 *)&mac_addr_hi;
+ 		mac_addr[0] = ha->addr[4];
+ 		mac_addr[1] = ha->addr[5];
+ 
+ 		DBGPR("  adding mac address %pM at 0x%04x\n", ha->addr,
+ 		      *mac_reg);
+ 
+ 		XGMAC_SET_BITS(mac_addr_hi, MAC_MACA1HR, AE, 1);
+ 	}
+ 
+ 	XGMAC_IOWRITE(pdata, *mac_reg, mac_addr_hi);
+ 	*mac_reg += MAC_MACA_INC;
+ 	XGMAC_IOWRITE(pdata, *mac_reg, mac_addr_lo);
+ 	*mac_reg += MAC_MACA_INC;
+ }
+ 
+ static void xgbe_set_mac_addn_addrs(struct xgbe_prv_data *pdata)
+ {
+ 	struct net_device *netdev = pdata->netdev;
+ 	struct netdev_hw_addr *ha;
+ 	unsigned int mac_reg;
+ 	unsigned int addn_macs;
+ 
+ 	DBGPR("-->%s\n", __func__);
+ 	mac_reg = MAC_MACA1HR;
+ 	addn_macs = pdata->hw_feat.addn_mac;
+ 
+ 	if (netdev_uc_count(netdev) > addn_macs) {
+ 		xgbe_set_promiscuous_mode(pdata, 1);
+ 	} else {
+ 		netdev_for_each_uc_addr(ha, netdev) {
+ 			xgbe_set_mac_reg(pdata, ha, &mac_reg);
+ 			addn_macs--;
+ 		}
+ 
+ 		if (netdev_mc_count(netdev) > addn_macs) {
+ 			xgbe_set_all_multicast_mode(pdata, 1);
+ 		} else {
+ 			netdev_for_each_mc_addr(ha, netdev) {
+ 				xgbe_set_mac_reg(pdata, ha, &mac_reg);
+ 				addn_macs--;
+ 			}
+ 		}
+ 	}
+ 
+ 	/* Clear remaining additional MAC address entries */
+ 	while (addn_macs--)
+ 		xgbe_set_mac_reg(pdata, NULL, &mac_reg);
+ }
+ 
+ static void xgbe_set_mac_hash_table(struct xgbe_prv_data *pdata)
+ {
+ 	struct net_device *netdev = pdata->netdev;
+ 	struct netdev_hw_addr *ha;
+ 	unsigned int hash_reg;
+ 	unsigned int hash_table_shift, hash_table_count;
+ 	u32 hash_table[XGBE_MAC_HASH_TABLE_SIZE];
+ 	u32 crc;
+ 	unsigned int i;
+ 
+ 	hash_table_shift = 26 - (pdata->hw_feat.hash_table_size >> 7);
+ 	hash_table_count = pdata->hw_feat.hash_table_size / 32;
+ 	memset(hash_table, 0, sizeof(hash_table));
+ 
+ 	/* Build the MAC Hash Table register values */
+ 	netdev_for_each_uc_addr(ha, netdev) {
+ 		crc = bitrev32(~crc32_le(~0, ha->addr, ETH_ALEN));
+ 		crc >>= hash_table_shift;
+ 		hash_table[crc >> 5] |= (1 << (crc & 0x1f));
+ 	}
+ 
+ 	netdev_for_each_mc_addr(ha, netdev) {
+ 		crc = bitrev32(~crc32_le(~0, ha->addr, ETH_ALEN));
+ 		crc >>= hash_table_shift;
+ 		hash_table[crc >> 5] |= (1 << (crc & 0x1f));
+ 	}
+ 
+ 	/* Set the MAC Hash Table registers */
+ 	hash_reg = MAC_HTR0;
+ 	for (i = 0; i < hash_table_count; i++) {
+ 		XGMAC_IOWRITE(pdata, hash_reg, hash_table[i]);
+ 		hash_reg += MAC_HTR_INC;
+ 	}
+ }
+ 
+ static int xgbe_add_mac_addresses(struct xgbe_prv_data *pdata)
+ {
+ DBGPR("-->%s\n", __func__);
+ 	if (pdata->hw_feat.hash_table_size)
+ 		xgbe_set_mac_hash_table(pdata);
+ 	else
+ 		xgbe_set_mac_addn_addrs(pdata);
+ 
+ 	return 0;
+ }
+ 
+ static int xgbe_set_mac_address(struct xgbe_prv_data *pdata, u8 *addr)
+ {
+ 	unsigned int mac_addr_hi, mac_addr_lo;
+ DBGPR("-->%s\n", __func__);
+ 	mac_addr_hi = (addr[5] <<  8) | (addr[4] <<  0);
+ 	mac_addr_lo = (addr[3] << 24) | (addr[2] << 16) |
+ 		      (addr[1] <<  8) | (addr[0] <<  0);
+ 
+ 	XGMAC_IOWRITE(pdata, MAC_MACA0HR, mac_addr_hi);
+ 	XGMAC_IOWRITE(pdata, MAC_MACA0LR, mac_addr_lo);
+ 
+ 	return 0;
+ }
+ 
+ static int xgbe_read_mmd_regs(struct xgbe_prv_data *pdata, int prtad,
+ 			      int mmd_reg)
+ {
+ 	unsigned int mmd_address;
+ 	int mmd_data;
+ 
+ 	if (mmd_reg & MII_ADDR_C45)
+ 		mmd_address = mmd_reg & ~MII_ADDR_C45;
+ 	else
+ 		mmd_address = (pdata->mdio_mmd << 16) | (mmd_reg & 0xffff);
+ 
+ 	/* The PCS registers are accessed using mmio. The underlying APB3
+ 	 * management interface uses indirect addressing to access the MMD
+ 	 * register sets. This requires accessing of the PCS register in two
+ 	 * phases, an address phase and a data phase.
+ 	 *
+ 	 * The mmio interface is based on 32-bit offsets and values. All
+ 	 * register offsets must therefore be adjusted by left shifting the
+ 	 * offset 2 bits and reading 32 bits of data.
+ 	 */
+ 	mutex_lock(&pdata->xpcs_mutex);
+ 	XPCS_IOWRITE(pdata, PCS_MMD_SELECT << 2, mmd_address >> 8);
+ 	mmd_data = XPCS_IOREAD(pdata, (mmd_address & 0xff) << 2);
+ 	mutex_unlock(&pdata->xpcs_mutex);
+ 
+ 
+ 	return mmd_data;
+ }
+ 
+ static void xgbe_write_mmd_regs(struct xgbe_prv_data *pdata, int prtad,
+ 				int mmd_reg, int mmd_data)
+ {
+ 	unsigned int mmd_address;
+ 
+ 	if (mmd_reg & MII_ADDR_C45)
+ 		mmd_address = mmd_reg & ~MII_ADDR_C45;
+ 	else
+ 		mmd_address = (pdata->mdio_mmd << 16) | (mmd_reg & 0xffff);
+ 
+ 	/* The PCS registers are accessed using mmio. The underlying APB3
+ 	 * management interface uses indirect addressing to access the MMD
+ 	 * register sets. This requires accessing of the PCS register in two
+ 	 * phases, an address phase and a data phase.
+ 	 *
+ 	 * The mmio interface is based on 32-bit offsets and values. All
+ 	 * register offsets must therefore be adjusted by left shifting the
+ 	 * offset 2 bits and reading 32 bits of data.
+ 	 */
+          DBGPR("<---write_mmd_register bus 0x%x addr 0x%x data 0x%x\n",PCS_MMD_SELECT << 2, mmd_address, mmd_data);
+ 
+ 	mutex_lock(&pdata->xpcs_mutex);
+ 	XPCS_IOWRITE(pdata, PCS_MMD_SELECT << 2, mmd_address >> 8);
+ 	XPCS_IOWRITE(pdata, (mmd_address & 0xff) << 2, mmd_data);
+ 	mutex_unlock(&pdata->xpcs_mutex);
+ 
+         DBGPR("--->write_mmd_register bus 0x%x addr 0x%x data 0x%x\n",PCS_MMD_SELECT << 2, mmd_address, mmd_data);
+ }
+ 
+ static int xgbe_tx_complete(struct xgbe_ring_desc *rdesc)
+ {
+ DBGPR("-->%s\n", __func__);
+ 	return !XGMAC_GET_BITS_LE(rdesc->desc3, TX_NORMAL_DESC3, OWN);
+ }
+ 
+ static int xgbe_disable_rx_csum(struct xgbe_prv_data *pdata)
+ {
+ DBGPR("-->%s\n", __func__);
+ 	XGMAC_IOWRITE_BITS(pdata, MAC_RCR, IPC, 0);
+ 
+ 	return 0;
+ }
+ 
+ static int xgbe_enable_rx_csum(struct xgbe_prv_data *pdata)
+ {
+ DBGPR("-->%s\n", __func__);
+ 	XGMAC_IOWRITE_BITS(pdata, MAC_RCR, IPC, 1);
+ 
+ 	return 0;
+ }
+ 
+ static int xgbe_disable_loopback(struct xgbe_prv_data *pdata)
+ {
+ DBGPR("-->%s\n", __func__);
+        XGMAC_IOWRITE_BITS(pdata, MAC_RCR, LM, 0);
+ 
+        return 0;
+ }
+ 
+ static int xgbe_enable_loopback(struct xgbe_prv_data *pdata)
+ {
+ DBGPR("-->%s\n", __func__);
+        XGMAC_IOWRITE_BITS(pdata, MAC_RCR, LM, 1);
+ 
+        return 0;
+ }
+ 
+ 
+ static int xgbe_enable_rx_vlan_stripping(struct xgbe_prv_data *pdata)
+ {
+ DBGPR("-->%s\n", __func__);
+ 	/* Put the VLAN tag in the Rx descriptor */
+ 	XGMAC_IOWRITE_BITS(pdata, MAC_VLANTR, EVLRXS, 1);
+ 
+ 	/* Don't check the VLAN type */
+ 	XGMAC_IOWRITE_BITS(pdata, MAC_VLANTR, DOVLTC, 1);
+ 
+ 	/* Check only C-TAG (0x8100) packets */
+ 	XGMAC_IOWRITE_BITS(pdata, MAC_VLANTR, ERSVLM, 0);
+ 
+ 	/* Don't consider an S-TAG (0x88A8) packet as a VLAN packet */
+ 	XGMAC_IOWRITE_BITS(pdata, MAC_VLANTR, ESVL, 0);
+ 
+ 	/* Enable VLAN tag stripping */
+ 	XGMAC_IOWRITE_BITS(pdata, MAC_VLANTR, EVLS, 0x3);
+ 
+ 	return 0;
+ }
+ 
+ static int xgbe_disable_rx_vlan_stripping(struct xgbe_prv_data *pdata)
+ {
+ 	XGMAC_IOWRITE_BITS(pdata, MAC_VLANTR, EVLS, 0);
+ 
+ 	return 0;
+ }
+ 
+ static int xgbe_enable_rx_vlan_filtering(struct xgbe_prv_data *pdata)
+ {
+ DBGPR("-->%s\n", __func__);
+ 	/* Enable VLAN filtering */
+ 	XGMAC_IOWRITE_BITS(pdata, MAC_PFR, VTFE, 1);
+ 
+ 	/* Enable VLAN Hash Table filtering */
+ 	XGMAC_IOWRITE_BITS(pdata, MAC_VLANTR, VTHM, 1);
+ 
+ 	/* Disable VLAN tag inverse matching */
+ 	XGMAC_IOWRITE_BITS(pdata, MAC_VLANTR, VTIM, 0);
+ 
+ 	/* Only filter on the lower 12-bits of the VLAN tag */
+ 	XGMAC_IOWRITE_BITS(pdata, MAC_VLANTR, ETV, 1);
+ 
+ 	/* In order for the VLAN Hash Table filtering to be effective,
+ 	 * the VLAN tag identifier in the VLAN Tag Register must not
+ 	 * be zero.  Set the VLAN tag identifier to "1" to enable the
+ 	 * VLAN Hash Table filtering.  This implies that a VLAN tag of
+ 	 * 1 will always pass filtering.
+ 	 */
+ 	XGMAC_IOWRITE_BITS(pdata, MAC_VLANTR, VL, 1);
+ 
+ 	return 0;
+ }
+ 
+ static int xgbe_disable_rx_vlan_filtering(struct xgbe_prv_data *pdata)
+ {
+ 	/* Disable VLAN filtering */
+ 	XGMAC_IOWRITE_BITS(pdata, MAC_PFR, VTFE, 0);
+ 
+ 	return 0;
+ }
+ 
+ #ifndef CRCPOLY_LE
+ #define CRCPOLY_LE 0xedb88320
+ #endif
+ static u32 xgbe_vid_crc32_le(__le16 vid_le)
+ {
+ 	u32 poly = CRCPOLY_LE;
+ 	u32 crc = ~0;
+ 	u32 temp = 0;
+ 	unsigned char *data = (unsigned char *)&vid_le;
+ 	unsigned char data_byte = 0;
+ 	int i, bits;
+ DBGPR("-->%s\n", __func__);
+ 	bits = get_bitmask_order(VLAN_VID_MASK);
+ 	for (i = 0; i < bits; i++) {
+ 		if ((i % 8) == 0)
+ 			data_byte = data[i / 8];
+ 
+ 		temp = ((crc & 1) ^ data_byte) & 1;
+ 		crc >>= 1;
+ 		data_byte >>= 1;
+ 
+ 		if (temp)
+ 			crc ^= poly;
+ 	}
+ 
+ 	return crc;
+ }
+ 
+ static int xgbe_update_vlan_hash_table(struct xgbe_prv_data *pdata)
+ {
+ 	u32 crc;
+ 	u16 vid;
+ 	__le16 vid_le;
+ 	u16 vlan_hash_table = 0;
+ DBGPR("-->%s\n", __func__);
+ 	/* Generate the VLAN Hash Table value */
+ 	for_each_set_bit(vid, pdata->active_vlans, VLAN_N_VID) {
+ 		/* Get the CRC32 value of the VLAN ID */
+ 		vid_le = cpu_to_le16(vid);
+ 		crc = bitrev32(~xgbe_vid_crc32_le(vid_le)) >> 28;
+ 
+ 		vlan_hash_table |= (1 << crc);
+ 	}
+ 
+ 	/* Set the VLAN Hash Table filtering register */
+ 	XGMAC_IOWRITE_BITS(pdata, MAC_VLANHTR, VLHT, vlan_hash_table);
+ 
+ 	return 0;
+ }
+ 
+ static void xgbe_tx_desc_reset(struct xgbe_ring_data *rdata)
+ {
+ 	struct xgbe_ring_desc *rdesc = rdata->rdesc;
+ 
+ 	/* Reset the Tx descriptor
+ 	 *   Set buffer 1 (lo) address to zero
+ 	 *   Set buffer 1 (hi) address to zero
+ 	 *   Reset all other control bits (IC, TTSE, B2L & B1L)
+ 	 *   Reset all other control bits (OWN, CTXT, FD, LD, CPC, CIC, etc)
+ 	 */
+ 	rdesc->desc0 = 0;
+ 	rdesc->desc1 = 0;
+ 	rdesc->desc2 = 0;
+ 	rdesc->desc3 = 0;
+ //	DBGPR("-->%s\n", __func__);
+ 	/* Make sure ownership is written to the descriptor */
+ 	wmb();
+ }
+ 
+ static void xgbe_tx_desc_init(struct xgbe_channel *channel)
+ {
+ 	struct xgbe_ring *ring = channel->tx_ring;
+ 	struct xgbe_ring_data *rdata;
+ 	int i;
+ 	int start_index = ring->cur;
+ 
+ 	DBGPR("-->tx_desc_init\n");
+ 
+ 	/* Initialze all descriptors */
+ 	for (i = 0; i < ring->rdesc_count; i++) {
+ 		rdata = XGBE_GET_DESC_DATA(ring, i);
+ 
+ 		/* Initialize Tx descriptor */
+ 		xgbe_tx_desc_reset(rdata);
+ 	}
+ 
+ 	/* Update the total number of Tx descriptors */
+ 	XGMAC_DMA_IOWRITE(channel, DMA_CH_TDRLR, ring->rdesc_count - 1);
+ 
+ 	/* Update the starting address of descriptor ring */
+ 	rdata = XGBE_GET_DESC_DATA(ring, start_index);
+ 	XGMAC_DMA_IOWRITE(channel, DMA_CH_TDLR_HI,
+ 			  upper_32_bits(rdata->rdesc_dma));
+ 	DBGPR("-->tx_desc_init channel->dma_regs = 0x%x  data = 0x%x count = %d\n",\
+ 		channel->dma_regs, upper_32_bits(rdata->rdesc_dma), ring->rdesc_count);
+ 	XGMAC_DMA_IOWRITE(channel, DMA_CH_TDLR_LO,
+ 			  lower_32_bits(rdata->rdesc_dma));
+ 	DBGPR("-->tx_desc_init channel->dma_regs = 0x%x  data = 0x%x\n",\
+ 		channel->dma_regs, lower_32_bits(rdata->rdesc_dma));
+ 
+ 	DBGPR("<--tx_desc_init\n");
+ }
+ 
+ static void xgbe_rx_desc_reset(struct xgbe_ring_data *rdata)
+ {
+ 	struct xgbe_ring_desc *rdesc = rdata->rdesc;
+ //DBGPR("-->%s\n", __func__);
+ 	/* Reset the Rx descriptor
+ 	 *   Set buffer 1 (lo) address to header dma address (lo)
+ 	 *   Set buffer 1 (hi) address to header dma address (hi)
+ 	 *   Set buffer 2 (lo) address to buffer dma address (lo)
+ 	 *   Set buffer 2 (hi) address to buffer dma address (hi) and
+ 	 *     set control bits OWN and INTE
+ 	 */
+ 	rdesc->desc0 = cpu_to_le32(lower_32_bits(rdata->rx.hdr.dma));
+ 	rdesc->desc1 = cpu_to_le32(upper_32_bits(rdata->rx.hdr.dma));
+ 	rdesc->desc2 = cpu_to_le32(lower_32_bits(rdata->rx.buf.dma));
+ 	rdesc->desc3 = cpu_to_le32(upper_32_bits(rdata->rx.buf.dma));
+ 
+ 	XGMAC_SET_BITS_LE(rdesc->desc3, RX_NORMAL_DESC3, INTE,
+ 			  rdata->interrupt ? 1 : 0);
+ 
+ 	/* Since the Rx DMA engine is likely running, make sure everything
+ 	 * is written to the descriptor(s) before setting the OWN bit
+ 	 * for the descriptor
+ 	 */
+ 	wmb();
+ 
+ 	XGMAC_SET_BITS_LE(rdesc->desc3, RX_NORMAL_DESC3, OWN, 1);
+ 
+ 	/* Make sure ownership is written to the descriptor */
+ 	wmb();
+ }
+ 
+ static void xgbe_rx_desc_init(struct xgbe_channel *channel)
+ {
+ 	struct xgbe_prv_data *pdata = channel->pdata;
+ 	struct xgbe_ring *ring = channel->rx_ring;
+ 	struct xgbe_ring_data *rdata;
+ 	unsigned int start_index = ring->cur;
+ 	unsigned int rx_coalesce, rx_frames;
+ 	unsigned int i;
+ 
+ 	DBGPR("-->rx_desc_init\n");
+ 
+ 	rx_coalesce = (pdata->rx_riwt || pdata->rx_frames) ? 1 : 0;
+ 	rx_frames = pdata->rx_frames;
+ 
+ 	/* Initialize all descriptors */
+ 	for (i = 0; i < ring->rdesc_count; i++) {
+ 		rdata = XGBE_GET_DESC_DATA(ring, i);
+ 
+ 		/* Set interrupt on completion bit as appropriate */
+ 		if (rx_coalesce && (!rx_frames || ((i + 1) % rx_frames)))
+ 			rdata->interrupt = 0;
+ 		else
+ 			rdata->interrupt = 1;
+ 
+ 		/* Initialize Rx descriptor */
+ 		xgbe_rx_desc_reset(rdata);
+ 	}
+ 
+ 	/* Update the total number of Rx descriptors */
+ 	XGMAC_DMA_IOWRITE(channel, DMA_CH_RDRLR, ring->rdesc_count - 1);
+ 
+ 	/* Update the starting address of descriptor ring */
+ 	rdata = XGBE_GET_DESC_DATA(ring, start_index);
+ 	XGMAC_DMA_IOWRITE(channel, DMA_CH_RDLR_HI,
+ 			  upper_32_bits(rdata->rdesc_dma));
+ 	XGMAC_DMA_IOWRITE(channel, DMA_CH_RDLR_LO,
+ 			  lower_32_bits(rdata->rdesc_dma));
+ 
+ 	DBGPR("-->rx_desc_init channel->dma_regs = 0x%x  data = 0x%x count = %d\n",\
+ 		channel->dma_regs, upper_32_bits(rdata->rdesc_dma), ring->rdesc_count);
+ 	DBGPR("-->rx_desc_init channel->dma_regs = 0x%x  data = 0x%x count = %d\n",\
+ 		channel->dma_regs, lower_32_bits(rdata->rdesc_dma), ring->rdesc_count);
+ 
+ 	/* Update the Rx Descriptor Tail Pointer */
+ 	rdata = XGBE_GET_DESC_DATA(ring, start_index + ring->rdesc_count - 1);
+ 	XGMAC_DMA_IOWRITE(channel, DMA_CH_RDTR_LO,
+ 			  lower_32_bits(rdata->rdesc_dma));
+ 	DBGPR("-->rx_desc_init channel->dma_regs = 0x%x  data = 0x%x count = %d\n",\
+ 		channel->dma_regs, lower_32_bits(rdata->rdesc_dma), ring->rdesc_count);
+ 
+ 	DBGPR("<--rx_desc_init\n");
+ }
+ 
+ static void xgbe_update_tstamp_addend(struct xgbe_prv_data *pdata,
+ 				      unsigned int addend)
+ {
+ 	DBGPR("-->%s\n", __func__);
+ 	/* Set the addend register value and tell the device */
+ 	XGMAC_IOWRITE(pdata, MAC_TSAR, addend);
+ 	XGMAC_IOWRITE_BITS(pdata, MAC_TSCR, TSADDREG, 1);
+ 
+ 	/* Wait for addend update to complete */
+ 	while (XGMAC_IOREAD_BITS(pdata, MAC_TSCR, TSADDREG))
+ 		udelay(5);
+ }
+ 
+ static void xgbe_set_tstamp_time(struct xgbe_prv_data *pdata, unsigned int sec,
+ 				 unsigned int nsec)
+ {
+ DBGPR("-->%s\n", __func__);
+ 	/* Set the time values and tell the device */
+ 	XGMAC_IOWRITE(pdata, MAC_STSUR, sec);
+ 	XGMAC_IOWRITE(pdata, MAC_STNUR, nsec);
+ 	XGMAC_IOWRITE_BITS(pdata, MAC_TSCR, TSINIT, 1);
+ 
+ 	/* Wait for time update to complete */
+ 	while (XGMAC_IOREAD_BITS(pdata, MAC_TSCR, TSINIT))
+ 		udelay(5);
+ }
+ 
+ static u64 xgbe_get_tstamp_time(struct xgbe_prv_data *pdata)
+ {
+ 	u64 nsec;
+ DBGPR("-->%s\n", __func__);
+ 	nsec = XGMAC_IOREAD(pdata, MAC_STSR);
+ 	nsec *= NSEC_PER_SEC;
+ 	nsec += XGMAC_IOREAD(pdata, MAC_STNR);
+ 
+ 	return nsec;
+ }
+ 
+ static u64 xgbe_get_tx_tstamp(struct xgbe_prv_data *pdata)
+ {
+ 	unsigned int tx_snr;
+ 	u64 nsec;
+ DBGPR("-->%s\n", __func__);
+ 	tx_snr = XGMAC_IOREAD(pdata, MAC_TXSNR);
+ 	if (XGMAC_GET_BITS(tx_snr, MAC_TXSNR, TXTSSTSMIS))
+ 		return 0;
+ 
+ 	nsec = XGMAC_IOREAD(pdata, MAC_TXSSR);
+ 	nsec *= NSEC_PER_SEC;
+ 	nsec += tx_snr;
+ 
+ 	return nsec;
+ }
+ 
+ static void xgbe_get_rx_tstamp(struct xgbe_packet_data *packet,
+ 			       struct xgbe_ring_desc *rdesc)
+ {
+ 	u64 nsec;
+ DBGPR("-->%s\n", __func__);
+ 	if (XGMAC_GET_BITS_LE(rdesc->desc3, RX_CONTEXT_DESC3, TSA) &&
+ 	    !XGMAC_GET_BITS_LE(rdesc->desc3, RX_CONTEXT_DESC3, TSD)) {
+ 		nsec = le32_to_cpu(rdesc->desc1);
+ 		nsec <<= 32;
+ 		nsec |= le32_to_cpu(rdesc->desc0);
+ 		if (nsec != 0xffffffffffffffffULL) {
+ 			packet->rx_tstamp = nsec;
+ 			XGMAC_SET_BITS(packet->attributes, RX_PACKET_ATTRIBUTES,
+ 				       RX_TSTAMP, 1);
+ 		}
+ 	}
+ }
+ 
+ static int xgbe_config_tstamp(struct xgbe_prv_data *pdata,
+ 			      unsigned int mac_tscr)
+ {
+ 	/* Set one nano-second accuracy */
+ 	XGMAC_SET_BITS(mac_tscr, MAC_TSCR, TSCTRLSSR, 1);
+ DBGPR("-->%s\n", __func__);
+ 	/* Set fine timestamp update */
+ 	XGMAC_SET_BITS(mac_tscr, MAC_TSCR, TSCFUPDT, 1);
+ 
+ 	/* Overwrite earlier timestamps */
+ 	XGMAC_SET_BITS(mac_tscr, MAC_TSCR, TXTSSTSM, 1);
+ 
+ 	XGMAC_IOWRITE(pdata, MAC_TSCR, mac_tscr);
+ 
+ 	/* Exit if timestamping is not enabled */
+ 	if (!XGMAC_GET_BITS(mac_tscr, MAC_TSCR, TSENA))
+ 		return 0;
+ 
+ 	/* Initialize time registers */
+ 	XGMAC_IOWRITE_BITS(pdata, MAC_SSIR, SSINC, XGBE_TSTAMP_SSINC);
+ 	XGMAC_IOWRITE_BITS(pdata, MAC_SSIR, SNSINC, XGBE_TSTAMP_SNSINC);
+ 	xgbe_update_tstamp_addend(pdata, pdata->tstamp_addend);
+ 	xgbe_set_tstamp_time(pdata, 0, 0);
+ 
+ 	/* Initialize the timecounter */
+ 	timecounter_init(&pdata->tstamp_tc, &pdata->tstamp_cc,
+ 			 ktime_to_ns(ktime_get_real()));
+ 
+ 	return 0;
+ }
+ 
+ static void xgbe_config_dcb_tc(struct xgbe_prv_data *pdata)
+ {
+ 	struct ieee_ets *ets = pdata->ets;
+ 	unsigned int total_weight, min_weight, weight;
+ 	unsigned int i;
+ DBGPR("-->%s\n", __func__);
+ 	if (!ets)
+ 		return;
+ 
+ 	/* Set Tx to deficit weighted round robin scheduling algorithm (when
+ 	 * traffic class is using ETS algorithm)
+ 	 */
+ 	XGMAC_IOWRITE_BITS(pdata, MTL_OMR, ETSALG, MTL_ETSALG_DWRR);
+ 
+ 	/* Set Traffic Class algorithms */
+ 	total_weight = pdata->netdev->mtu * pdata->hw_feat.tc_cnt;
+ 	min_weight = total_weight / 100;
+ 	if (!min_weight)
+ 		min_weight = 1;
+ 
+ 	for (i = 0; i < pdata->hw_feat.tc_cnt; i++) {
+ 		switch (ets->tc_tsa[i]) {
+ 		case IEEE_8021QAZ_TSA_STRICT:
+ 			DBGPR("  TC%u using SP\n", i);
+ 			XGMAC_MTL_IOWRITE_BITS(pdata, i, MTL_TC_ETSCR, TSA,
+ 					       MTL_TSA_SP);
+ 			break;
+ 		case IEEE_8021QAZ_TSA_ETS:
+ 			weight = total_weight * ets->tc_tx_bw[i] / 100;
+ 			weight = clamp(weight, min_weight, total_weight);
+ 
+ 			DBGPR("  TC%u using DWRR (weight %u)\n", i, weight);
+ 			XGMAC_MTL_IOWRITE_BITS(pdata, i, MTL_TC_ETSCR, TSA,
+ 					       MTL_TSA_ETS);
+ 			XGMAC_MTL_IOWRITE_BITS(pdata, i, MTL_TC_QWR, QW,
+ 					       weight);
+ 			break;
+ 		}
+ 	}
+ }
+ 
+ static void xgbe_config_dcb_pfc(struct xgbe_prv_data *pdata)
+ {
+ 	struct ieee_pfc *pfc = pdata->pfc;
+ 	struct ieee_ets *ets = pdata->ets;
+ 	unsigned int mask, reg, reg_val;
+ 	unsigned int tc, prio;
+ DBGPR("-->%s\n", __func__);
+ 	if (!pfc || !ets)
+ 		return;
+ 
+ 	for (tc = 0; tc < pdata->hw_feat.tc_cnt; tc++) {
+ 		mask = 0;
+ 		for (prio = 0; prio < IEEE_8021QAZ_MAX_TCS; prio++) {
+ 			if ((pfc->pfc_en & (1 << prio)) &&
+ 			    (ets->prio_tc[prio] == tc))
+ 				mask |= (1 << prio);
+ 		}
+ 		mask &= 0xff;
+ 
+ 		DBGPR("  TC%u PFC mask=%#x\n", tc, mask);
+ 		reg = MTL_TCPM0R + (MTL_TCPM_INC * (tc / MTL_TCPM_TC_PER_REG));
+ 		reg_val = XGMAC_IOREAD(pdata, reg);
+ 
+ 		reg_val &= ~(0xff << ((tc % MTL_TCPM_TC_PER_REG) << 3));
+ 		reg_val |= (mask << ((tc % MTL_TCPM_TC_PER_REG) << 3));
+ 
+ 		XGMAC_IOWRITE(pdata, reg, reg_val);
+ 	}
+ 
+ 	xgbe_config_flow_control(pdata);
+ }
+ 
+ void read_xpcs_regs_dev(void)
+ {
+ 	DBGPR("\nXPSC PCS reg 0 0x%x\n",READ_XPCS_REG(DEVICE_PCS, 0));
+ 	DBGPR("XPSC PCS reg 1 0x%x\n",READ_XPCS_REG(DEVICE_PCS, 1));
+ 	DBGPR("XPSC PCS reg 2 0x%x\n",READ_XPCS_REG(DEVICE_PCS, 2));
+ 	DBGPR("XPSC PCS reg 3 0x%x\n",READ_XPCS_REG(DEVICE_PCS, 3));
+ 	DBGPR("XPSC PCS reg 4 0x%x\n",READ_XPCS_REG(DEVICE_PCS, 4));
+ 	DBGPR("XPSC PCS reg 5 0x%x\n",READ_XPCS_REG(DEVICE_PCS, 5));
+ 	DBGPR("XPSC PCS reg 6 0x%x\n",READ_XPCS_REG(DEVICE_PCS, 6));
+ 	DBGPR("XPSC PCS reg 7 0x%x\n",READ_XPCS_REG(DEVICE_PCS, 7));
+ 	DBGPR("XPSC PCS reg 0x8000 0x%x \n",READ_XPCS_REG(DEVICE_PCS, 0x8000));
+ 	DBGPR("XPSC PMA reg 2 0x%x\n", READ_XPCS_REG(DEVICE_PMA, 2));
+ 	DBGPR("XPSC PMA reg 3 0x%x\n", READ_XPCS_REG(DEVICE_PMA, 3));
+ 	DBGPR("XPSC PMA reg 5 0x%x\n", READ_XPCS_REG(DEVICE_PMA, 5));
+ 	DBGPR("XPSC PMA reg 6 0x%x\n", READ_XPCS_REG(DEVICE_PMA, 6));
+ 	DBGPR("XPSC PMA reg 0 0x%x\n", READ_XPCS_REG(DEVICE_PMA, 0));
+ 	DBGPR("XPSC PMA reg 809c 0x%x\n",READ_XPCS_REG(DEVICE_PMA, 0x809C));
+ 	DBGPR("XPSC AN reg 0    0x%x\n",READ_XPCS_REG(DEVICE_AN, 0));
+ 	DBGPR("XPSC AN reg 1    0x%x\n",READ_XPCS_REG(DEVICE_AN, 1));
+ 	DBGPR("XPSC AN reg 2    0x%x\n",READ_XPCS_REG(DEVICE_AN, 2));
+ 	DBGPR("XPSC AN reg 3    0x%x\n",READ_XPCS_REG(DEVICE_AN, 3));
+ 	DBGPR("XPSC AN reg 0x10 0x%x\n",READ_XPCS_REG(DEVICE_AN, 0x10));
+ 	DBGPR("XPSC AN reg 0x11 0x%x\n",READ_XPCS_REG(DEVICE_AN, 0x11));
+ 	DBGPR("XPSC AN reg 0x12 0x%x\n",READ_XPCS_REG(DEVICE_AN, 0x12));
+ 	DBGPR("XPSC AN reg 0x30 0x%x\n",READ_XPCS_REG(DEVICE_AN, 0x30));
+ 	DBGPR("XPSC AN reg 0x8001 0x%x\n",READ_XPCS_REG(DEVICE_AN, 0x8001));
+ 	DBGPR("XPSC AN reg 0x8002 0x%x\n\n",READ_XPCS_REG(DEVICE_AN, 0x8002));
+ }
+ 
+ void dump_all_regs(void)
+ {
+ 	int i;
+ 
+ 	DBGPR("DMA_Mode 		0x%x\n",READ_XGMAC_REG(DMA_Mode));
+ 	DBGPR("DMA_SysBus_Mode		0x%x\n",READ_XGMAC_REG(DMA_SysBus_Mode));
+ 	DBGPR("DMA_Interrupt_Status 	0x%x\n",READ_XGMAC_REG(DMA_Interrupt_Status));
+ 	DBGPR("AXI_ARCache_Control 	0x%x\n",READ_XGMAC_REG(AXI_ARCache_Control));
+ 	DBGPR("AXI_AWCache_Control 	0x%x\n",READ_XGMAC_REG(AXI_AWCache_Control));
+ 	DBGPR("DMA_Debug_Status0 	0x%x\n",READ_XGMAC_REG(DMA_Debug_Status0));
+ 	DBGPR("DMA_Debug_Status1 	0x%x\n",READ_XGMAC_REG(DMA_Debug_Status1));
+ 	DBGPR("DMA_Debug_Status2 	0x%x\n",READ_XGMAC_REG(DMA_Debug_Status2));
+ 	DBGPR("DMA_Debug_Status3 	0x%x\n",READ_XGMAC_REG(DMA_Debug_Status3));
+ 	DBGPR("DMA_Debug_Status4 	0x%x\n",READ_XGMAC_REG(DMA_Debug_Status4));
+ 
+ 	for (i = 0; i < 2; i++) {
+ 		DBGPR("DMA_CH_Control(%d)			 0x%x\n", i, READ_XGMAC_REG(DMA_CH_Control(i)));
+ 		DBGPR("DMA_CH_Tx_Control(%d)			 0x%x\n", i, READ_XGMAC_REG(DMA_CH_Tx_Control(i)));
+ 		DBGPR("DMA_CH_Rx_Control(%d)			 0x%x\n", i, READ_XGMAC_REG(DMA_CH_Rx_Control(i)));
+ 		DBGPR("DMA_CH_TxDesc_List_HAddress(%d)		 0x%x\n", i, READ_XGMAC_REG(DMA_CH_TxDesc_List_HAddress(i)));
+ 		DBGPR("DMA_CH_TxDesc_List_LAddress(%d)		 0x%x\n", i, READ_XGMAC_REG(DMA_CH_TxDesc_List_LAddress(i)));
+ 		DBGPR("DMA_CH_RxDesc_List_HAddress(%d)		 0x%x\n", i, READ_XGMAC_REG(DMA_CH_RxDesc_List_HAddress(i)));
+ 		DBGPR("DMA_CH_RxDesc_List_LAddress(%d)		 0x%x\n", i, READ_XGMAC_REG(DMA_CH_RxDesc_List_LAddress(i)));
+ 		DBGPR("DMA_CH_TxDesc_Tail_LPointer(%d)		 0x%x\n", i, READ_XGMAC_REG(DMA_CH_TxDesc_Tail_LPointer(i)));
+ 		DBGPR("DMA_CH_RxDesc_Tail_LPointer(%d)		 0x%x\n", i, READ_XGMAC_REG(DMA_CH_RxDesc_Tail_LPointer(i)));
+ 		DBGPR("DMA_CH_TxDesc_Ring_Length(%d)		 0x%x\n", i, READ_XGMAC_REG(DMA_CH_TxDesc_Ring_Length(i)));
+ 		DBGPR("DMA_CH_RxDesc_Ring_Length(%d)		 0x%x\n", i, READ_XGMAC_REG(DMA_CH_RxDesc_Ring_Length(i)));
+ 		DBGPR("DMA_CH_Interrupt_Enable(%d)		 0x%x\n", i, READ_XGMAC_REG(DMA_CH_Interrupt_Enable(i)));
+ 		DBGPR("DMA_CH_Rx_Interrupt_Watchdog_Timer(%d)	 0x%x\n", i, READ_XGMAC_REG(DMA_CH_Rx_Interrupt_Watchdog_Timer(i)));
+ 		DBGPR("DMA_CH_Current_App_TxDesc_L(%d)		 0x%x\n", i, READ_XGMAC_REG(DMA_CH_Current_App_TxDesc_L(i)));
+ 		DBGPR("DMA_CH_Current_App_RxDesc_L(%d)		 0x%x\n", i, READ_XGMAC_REG(DMA_CH_Current_App_RxDesc_L(i)));
+ 		DBGPR("DMA_CH_Current_App_TxBuffer_H(%d)	 0x%x\n", i, READ_XGMAC_REG(DMA_CH_Current_App_TxBuffer_H(i)));
+ 		DBGPR("DMA_CH_Current_App_TxBuffer_L(%d)	 0x%x\n", i, READ_XGMAC_REG(DMA_CH_Current_App_TxBuffer_L(i)));
+ 		DBGPR("DMA_CH_Current_App_RxBuffer_H(%d)	 0x%x\n", i, READ_XGMAC_REG(DMA_CH_Current_App_RxBuffer_H(i)));
+ 		DBGPR("DMA_CH_Current_App_RxBuffer_L(%d)	 0x%x\n", i, READ_XGMAC_REG(DMA_CH_Current_App_RxBuffer_L(i)));
+ 		DBGPR("DMA_CH_Status(%d)			 0x%x\n", i, READ_XGMAC_REG(DMA_CH_Status(i)));
+ 	}
+ 	DBGPR("MTL_Operation_Mode 	0x%x\n", READ_XGMAC_REG(MTL_Operation_Mode));
+ 	DBGPR("MTL_Debug_Control 	0x%x\n", READ_XGMAC_REG(MTL_Debug_Control));
+ 	DBGPR("MTL_Debug_Status 	0x%x\n", READ_XGMAC_REG(MTL_Debug_Status));
+ 	DBGPR("MTL_FIFO_Debug_Data 	0x%x\n", READ_XGMAC_REG(MTL_FIFO_Debug_Data));
+ 	DBGPR("MTL_Interrupt_Status 	0x%x\n", READ_XGMAC_REG(MTL_Interrupt_Status));
+ 	DBGPR("MTL_RxQ_DMA_Map0 	0x%x\n", READ_XGMAC_REG(MTL_RxQ_DMA_Map0));
+ 	DBGPR("MTL_RxQ_DMA_Map1 	0x%x\n", READ_XGMAC_REG(MTL_RxQ_DMA_Map1));
+ 	DBGPR("MTL_RxQ_DMA_Map2 	0x%x\n", READ_XGMAC_REG(MTL_RxQ_DMA_Map2));
+ 	DBGPR("MTL_TC_Prty_Map0 	0x%x\n", READ_XGMAC_REG(MTL_TC_Prty_Map0));
+ 	DBGPR("MTL_TC_Prty_Map1 	0x%x\n", READ_XGMAC_REG(MTL_TC_Prty_Map1));
+ 	for (i = 0; i < 4; i++) {
+ 		DBGPR("MTL_TxQ_Operation_Mode(%d)		0x%x\n", i, READ_XGMAC_REG(MTL_TxQ_Operation_Mode(i)));
+ 		DBGPR("MTL_TxQ_Underflow(%d)			0x%x\n", i, READ_XGMAC_REG(MTL_TxQ_Underflow(i)));
+ 		DBGPR("MTL_TxQ_Debug(%d)			0x%x\n", i, READ_XGMAC_REG(MTL_TxQ_Debug(i)));
+ 		DBGPR("MTL_TC_ETS_Control(%d)			0x%x\n", i, READ_XGMAC_REG(MTL_TC_ETS_Control(i)));
+ 		DBGPR("MTL_TC_ETS_Status(%d)			0x%x\n", i, READ_XGMAC_REG(MTL_TC_ETS_Status(i)));
+ 		DBGPR("MTL_TC_Quantum_Weight(%d)		0x%x\n", i, READ_XGMAC_REG(MTL_TC_Quantum_Weight(i)));
+ 		DBGPR("MTL_RxQ_Operation_Mode(%d)		0x%x\n", i, READ_XGMAC_REG(MTL_RxQ_Operation_Mode(i)));
+ 		DBGPR("MTL_RxQ_Missed_Pkt_Overflow_Cnt(%d)	0x%x\n", i, READ_XGMAC_REG(MTL_RxQ_Missed_Pkt_Overflow_Cnt(i)));
+ 		DBGPR("MTL_RxQ_Debug(%d)			0x%x\n", i, READ_XGMAC_REG(MTL_RxQ_Debug(i)));
+ 		DBGPR("MTL_RxQ_Control(%d)			0x%x\n", i, READ_XGMAC_REG(MTL_RxQ_Control(i)));
+ 		DBGPR("MTL_RxQ_Flow_Control(%d)			0x%x\n", i, READ_XGMAC_REG(MTL_RxQ_Flow_Control(i)));
+ 		DBGPR("MTL_Q_Interrupt_Enable(%d)		0x%x\n", i, READ_XGMAC_REG(MTL_Q_Interrupt_Enable(i)));
+ 		DBGPR("MTL_Q_Interrupt_Status(%d)		0x%x\n", i, READ_XGMAC_REG(MTL_Q_Interrupt_Status(i)));
+ 	}
+ 
+ 	DBGPR("MAC_Tx_Configuration	0x%x\n", READ_XGMAC_REG(MAC_Tx_Configuration));
+ 	DBGPR("MAC_Rx_Configuration	0x%x\n", READ_XGMAC_REG(MAC_Rx_Configuration));
+ 	DBGPR("MAC_Packet_Filter	0x%x\n", READ_XGMAC_REG(MAC_Packet_Filter));
+ 	DBGPR("MAC_Watchdog_Timeout	0x%x\n", READ_XGMAC_REG(MAC_Watchdog_Timeout));
+ 	DBGPR("MAC_Hash_Table_Reg0	0x%x\n", READ_XGMAC_REG(MAC_Hash_Table_Reg0));
+ 	DBGPR("MAC_Hash_Table_Reg1	0x%x\n", READ_XGMAC_REG(MAC_Hash_Table_Reg1));
+ 	DBGPR("MAC_Hash_Table_Reg2	0x%x\n", READ_XGMAC_REG(MAC_Hash_Table_Reg2));
+ 	DBGPR("MAC_Hash_Table_Reg3	0x%x\n", READ_XGMAC_REG(MAC_Hash_Table_Reg3));
+ 	DBGPR("MAC_Hash_Table_Reg4	0x%x\n", READ_XGMAC_REG(MAC_Hash_Table_Reg4));
+ 	DBGPR("MAC_Hash_Table_Reg5	0x%x\n", READ_XGMAC_REG(MAC_Hash_Table_Reg5));
+ 	DBGPR("MAC_Hash_Table_Reg6	0x%x\n", READ_XGMAC_REG(MAC_Hash_Table_Reg6));
+ 	DBGPR("MAC_Hash_Table_Reg7	0x%x\n", READ_XGMAC_REG(MAC_Hash_Table_Reg7));
+ 	DBGPR("MAC_VLAN_Tag		0x%x\n", READ_XGMAC_REG(MAC_VLAN_Tag));
+ 	DBGPR("MAC_VLAN_Hash_Table	0x%x\n", READ_XGMAC_REG(MAC_VLAN_Hash_Table));
+ 	DBGPR("MAC_VLAN_Incl		0x%x\n", READ_XGMAC_REG(MAC_VLAN_Incl));
+ 	DBGPR("MAC_Inner_VLAN_Incl	0x%x\n", READ_XGMAC_REG(MAC_Inner_VLAN_Incl));
+ 	DBGPR("MAC_Rx_Eth_Type_Match	0x%x\n", READ_XGMAC_REG(MAC_Rx_Eth_Type_Match));
+ 	DBGPR("MAC_Q0_Tx_Flow_Ctrl	0x%x\n", READ_XGMAC_REG(MAC_Q0_Tx_Flow_Ctrl));
+ 	DBGPR("MAC_Q1_Tx_Flow_Ctrl	0x%x\n", READ_XGMAC_REG(MAC_Q1_Tx_Flow_Ctrl));
+ 	DBGPR("MAC_Q2_Tx_Flow_Ctrl	0x%x\n", READ_XGMAC_REG(MAC_Q2_Tx_Flow_Ctrl));
+ 	DBGPR("MAC_Q3_Tx_Flow_Ctrl	0x%x\n", READ_XGMAC_REG(MAC_Q3_Tx_Flow_Ctrl));
+ 	DBGPR("MAC_Q4_Tx_Flow_Ctrl	0x%x\n", READ_XGMAC_REG(MAC_Q4_Tx_Flow_Ctrl));
+ 	DBGPR("MAC_Q5_Tx_Flow_Ctrl	0x%x\n", READ_XGMAC_REG(MAC_Q5_Tx_Flow_Ctrl));
+ 	DBGPR("MAC_Q6_Tx_Flow_Ctrl	0x%x\n", READ_XGMAC_REG(MAC_Q6_Tx_Flow_Ctrl));
+ 	DBGPR("MAC_Q7_Tx_Flow_Ctrl	0x%x\n", READ_XGMAC_REG(MAC_Q7_Tx_Flow_Ctrl));
+ 	DBGPR("MAC_Rx_Flow_Ctrl		0x%x\n", READ_XGMAC_REG(MAC_Rx_Flow_Ctrl));
+ 	DBGPR("MAC_RxQ_Ctrl0		0x%x\n", READ_XGMAC_REG(MAC_RxQ_Ctrl0));
+ 	DBGPR("MAC_RxQ_Ctrl1		0x%x\n", READ_XGMAC_REG(MAC_RxQ_Ctrl1));
+ 	DBGPR("MAC_RxQ_Ctrl2		0x%x\n", READ_XGMAC_REG(MAC_RxQ_Ctrl2));
+ 	DBGPR("MAC_RxQ_Ctrl3		0x%x\n", READ_XGMAC_REG(MAC_RxQ_Ctrl3));
+ 	DBGPR("MAC_Interrupt_Status	0x%x\n", READ_XGMAC_REG(MAC_Interrupt_Status));
+ 	DBGPR("MAC_Interrupt_Enable	0x%x\n", READ_XGMAC_REG(MAC_Interrupt_Enable));
+ 	DBGPR("MAC_RX_TX_Status		0x%x\n", READ_XGMAC_REG(MAC_RX_TX_Status));
+ 	DBGPR("MAC_PMT_Control_Status	0x%x\n", READ_XGMAC_REG(MAC_PMT_Control_Status));
+ 	DBGPR("MAC_RWK_Packet_Filter	0x%x\n", READ_XGMAC_REG(MAC_RWK_Packet_Filter));
+ 	DBGPR("MAC_LPI_Control_Status	0x%x\n", READ_XGMAC_REG(MAC_LPI_Control_Status));
+ 	DBGPR("MAC_LPI_Timers_Control	0x%x\n", READ_XGMAC_REG(MAC_LPI_Timers_Control));
+ 	DBGPR("MAC_Version		0x%x\n", READ_XGMAC_REG(MAC_Version));
+ 	DBGPR("MAC_Debug		0x%x\n", READ_XGMAC_REG(MAC_Debug));
+ 	DBGPR("MAC_HW_Feature0		0x%x\n", READ_XGMAC_REG(MAC_HW_Feature0));
+ 	DBGPR("MAC_HW_Feature1		0x%x\n", READ_XGMAC_REG(MAC_HW_Feature1));
+ 	DBGPR("MAC_HW_Feature2		0x%x\n", READ_XGMAC_REG(MAC_HW_Feature2));
+ 	DBGPR("MAC_GPIO_Control		0x%x\n", READ_XGMAC_REG(MAC_GPIO_Control));
+ 	DBGPR("MAC_GPIO_Status		0x%x\n", READ_XGMAC_REG(MAC_GPIO_Status));
+ 
+ 	for (i = 0; i < 2; i++) {
+ 		DBGPR("MAC_Address_High(%d)	0x%x\n", i, READ_XGMAC_REG(MAC_Address_High(i)));
+ 		DBGPR("MAC_Address_Low(%d)	0x%x\n", i, READ_XGMAC_REG(MAC_Address_Low(i)));
+ 	}
+ 	DBGPR("MAC_L3_L4_Address_Control		0x%x\n", READ_XGMAC_REG(MAC_L3_L4_Address_Control));
+ 	DBGPR("MAC_L3_L4_Data				0x%x\n", READ_XGMAC_REG(MAC_L3_L4_Data));
+ 	DBGPR("MAC_ARP_Address				0x%x\n", READ_XGMAC_REG(MAC_ARP_Address));
+ 	DBGPR("MAC_RSS_Control				0x%x\n", READ_XGMAC_REG(MAC_RSS_Control));
+ 	DBGPR("MAC_RSS_Address				0x%x\n", READ_XGMAC_REG(MAC_RSS_Address));
+ 	DBGPR("MAC_RSS_Data				0x%x\n", READ_XGMAC_REG(MAC_RSS_Data));
+ 	DBGPR("MAC_Timestamp_Control			0x%x\n", READ_XGMAC_REG(MAC_Timestamp_Control));
+ 	DBGPR("MAC_Sub_Second_Increment			0x%x\n", READ_XGMAC_REG(MAC_Sub_Second_Increment));
+ 	DBGPR("MAC_System_Time_Seconds			0x%x\n", READ_XGMAC_REG(MAC_System_Time_Seconds));
+ 	DBGPR("MAC_System_Time_Nanoseconds		0x%x\n", READ_XGMAC_REG(MAC_System_Time_Nanoseconds));
+ 	DBGPR("MAC_System_Time_Seconds_Update		0x%x\n", READ_XGMAC_REG(MAC_System_Time_Seconds_Update));
+ 	DBGPR("MAC_System_Time_Nanoseconds_Update	0x%x\n", READ_XGMAC_REG(MAC_System_Time_Nanoseconds_Update));
+ 	DBGPR("MAC_Timestamp_Addend			0x%x\n", READ_XGMAC_REG(MAC_Timestamp_Addend));
+ 	DBGPR("MAC_System_Time_Higher_Word_Seconds	0x%x\n", READ_XGMAC_REG(MAC_System_Time_Higher_Word_Seconds));
+ 	DBGPR("MAC_Timestamp_Status			0x%x\n", READ_XGMAC_REG(MAC_Timestamp_Status));
+ 	DBGPR("MAC_TxTimestamp_Status_Nanoseconds	0x%x\n", READ_XGMAC_REG(MAC_TxTimestamp_Status_Nanoseconds));
+ 	DBGPR("MAC_TxTimestamp_Status_Seconds		0x%x\n", READ_XGMAC_REG(MAC_TxTimestamp_Status_Seconds));
+ 	DBGPR("MAC_Auxiliary_Control			0x%x\n", READ_XGMAC_REG(MAC_Auxiliary_Control));
+ 	DBGPR("MAC_Auxiliary_Timestamp_Nanoseconds	0x%x\n", READ_XGMAC_REG(MAC_Auxiliary_Timestamp_Nanoseconds));
+ 	DBGPR("MAC_Auxiliary_Timestamp_Seconds		0x%x\n", READ_XGMAC_REG(MAC_Auxiliary_Timestamp_Seconds));
+ 	DBGPR("MAC_Timestamp_Ingress_Asym_Corr		0x%x\n", READ_XGMAC_REG(MAC_Timestamp_Ingress_Asym_Corr));
+ 	DBGPR("MAC_Timestamp_Egress_Asym_Corr		0x%x\n", READ_XGMAC_REG(MAC_Timestamp_Egress_Asym_Corr));
+ 	DBGPR("MAC_Timestamp_Ingress_Corr_Nanosecond	0x%x\n", READ_XGMAC_REG(MAC_Timestamp_Ingress_Corr_Nanosecond));
+ 	DBGPR("MAC_Timestamp_Ingress_Corr_Subnanosecond	0x%x\n", READ_XGMAC_REG(MAC_Timestamp_Ingress_Corr_Subnanosecond));
+ 	DBGPR("MAC_Timestamp_Egress_Corr_Nanosecond	0x%x\n", READ_XGMAC_REG(MAC_Timestamp_Egress_Corr_Nanosecond));
+ 	DBGPR("MAC_Timestamp_Egress_Corr_Subnanosecond	0x%x\n", READ_XGMAC_REG(MAC_Timestamp_Egress_Corr_Subnanosecond));
+ 	DBGPR("MAC_PPS0_Target_Time_Seconds		0x%x\n", READ_XGMAC_REG(MAC_PPS0_Target_Time_Seconds));
+ 	DBGPR("MAC_PPS0_Target_Time_Nanoseconds		0x%x\n", READ_XGMAC_REG(MAC_PPS0_Target_Time_Nanoseconds));
+ 	DBGPR("MAC_PPS0_Interval			0x%x\n", READ_XGMAC_REG(MAC_PPS0_Interval));
+ 	DBGPR("MAC_PPS0_Width				0x%x\n", READ_XGMAC_REG(MAC_PPS0_Width));
+ 	DBGPR("MAC_PPS1_Target_Time_Seconds		0x%x\n", READ_XGMAC_REG(MAC_PPS1_Target_Time_Seconds));
+ 	DBGPR("MAC_PPS1_Target_Time_Nanoseconds		0x%x\n", READ_XGMAC_REG(MAC_PPS1_Target_Time_Nanoseconds));
+ 	DBGPR("MAC_PPS_Control				0x%x\n", READ_XGMAC_REG(MAC_PPS_Control));
+ 	DBGPR("MAC_PPS1_Interval			0x%x\n", READ_XGMAC_REG(MAC_PPS1_Interval));
+ 	DBGPR("MAC_PPS1_Width				0x%x\n", READ_XGMAC_REG(MAC_PPS1_Width));
+ 	DBGPR("MAC_PPS2_Target_Time_Seconds		0x%x\n", READ_XGMAC_REG(MAC_PPS2_Target_Time_Seconds));
+ 	DBGPR("MAC_PPS2_Target_Time_Nanoseconds		0x%x\n", READ_XGMAC_REG(MAC_PPS2_Target_Time_Nanoseconds));
+ 	DBGPR("MAC_PPS2_Interval			0x%x\n", READ_XGMAC_REG(MAC_PPS2_Interval));
+ 	DBGPR("MAC_PPS2_Width				0x%x\n", READ_XGMAC_REG(MAC_PPS2_Width));
+ 	DBGPR("MAC_PPS3_Target_Time_Seconds		0x%x\n", READ_XGMAC_REG(MAC_PPS3_Target_Time_Seconds));
+ 	DBGPR("MAC_PPS3_Target_Time_Nanoseconds		0x%x\n", READ_XGMAC_REG(MAC_PPS3_Target_Time_Nanoseconds));
+ 	DBGPR("MAC_PPS3_Interval			0x%x\n", READ_XGMAC_REG(MAC_PPS3_Interval));
+ 	DBGPR("MAC_PPS3_Width				0x%x\n", READ_XGMAC_REG(MAC_PPS3_Width));
+ 	DBGPR("MAC_PTO_Control				0x%x\n", READ_XGMAC_REG(MAC_PTO_Control));
+ 	DBGPR("MAC_Source_Port_Identity0		0x%x\n", READ_XGMAC_REG(MAC_Source_Port_Identity0));
+ 	DBGPR("MAC_Source_Port_Identity1		0x%x\n", READ_XGMAC_REG(MAC_Source_Port_Identity1));
+ 	DBGPR("MAC_Source_Port_Identity2		0x%x\n", READ_XGMAC_REG(MAC_Source_Port_Identity2));
+ 	DBGPR("MAC_Log_Message_Interval			0x%x\n", READ_XGMAC_REG(MAC_Log_Message_Interval));
+ }
+ 
+ static void xgbe_tx_start_xmit(struct xgbe_channel *channel,
+ 			       struct xgbe_ring *ring)
+ {
+ 	struct xgbe_prv_data *pdata = channel->pdata;
+ 	struct xgbe_ring_data *rdata;
+ 	/* Issue a poll command to Tx DMA by writing address
+ 	 * of next immediate free descriptor */
+ 	rdata = XGBE_GET_DESC_DATA(ring, ring->cur);
+ 
+ 	XGMAC_DMA_IOWRITE(channel, DMA_CH_TDTR_LO, lower_32_bits(rdata->rdesc_dma));
+ 
+ 	/* Start the Tx coalescing timer */
+ 	if (pdata->tx_usecs && !channel->tx_timer_active) {
+ 		channel->tx_timer_active = 1;
+ 		hrtimer_start(&channel->tx_timer,
+ 			      ktime_set(0, pdata->tx_usecs * NSEC_PER_USEC),
+ 			      HRTIMER_MODE_REL);
+ 	}
+ 
+ 	ring->tx.xmit_more = 0;
+ }
+ 
+ static void xgbe_dev_xmit(struct xgbe_channel *channel)
+ {
+ 	struct xgbe_prv_data *pdata = channel->pdata;
+ 	struct xgbe_ring *ring = channel->tx_ring;
+ 	struct xgbe_ring_data *rdata;
+ 	struct xgbe_ring_desc *rdesc;
+ 	struct xgbe_packet_data *packet = &ring->packet_data;
+ 	unsigned int csum, tso, vlan;
+ 	unsigned int tso_context, vlan_context;
+ 	unsigned int tx_set_ic;
+ 	int start_index = ring->cur;
+ 	int i;
+ 	int dbg1, dbg2;
+ 
+ 	DBGPR("-->xgbe_dev_xmit\n");
+ 
+ 	csum = XGMAC_GET_BITS(packet->attributes, TX_PACKET_ATTRIBUTES,
+ 			      CSUM_ENABLE);
+ 	tso = XGMAC_GET_BITS(packet->attributes, TX_PACKET_ATTRIBUTES,
+ 			     TSO_ENABLE);
+ 	vlan = XGMAC_GET_BITS(packet->attributes, TX_PACKET_ATTRIBUTES,
+ 			      VLAN_CTAG);
+ 
+ 	DBGPR("-->csum = 0x%x tso = 0x%x vlan = 0x%x\n", csum, tso, vlan);
+ 
+ 
+ 	if (tso && (packet->mss != ring->tx.cur_mss))
+ 		tso_context = 1;
+ 	else
+ 		tso_context = 0;
+ 
+ 	if (vlan && (packet->vlan_ctag != ring->tx.cur_vlan_ctag))
+ 		vlan_context = 1;
+ 	else
+ 		vlan_context = 0;
+ 
+ 	/* Determine if an interrupt should be generated for this Tx:
+ 	 *   Interrupt:
+ 	 *     - Tx frame count exceeds the frame count setting
+ 	 *     - Addition of Tx frame count to the frame count since the
+ 	 *       last interrupt was set exceeds the frame count setting
+ 	 *   No interrupt:
+ 	 *     - No frame count setting specified (ethtool -C ethX tx-frames 0)
+ 	 *     - Addition of Tx frame count to the frame count since the
+ 	 *       last interrupt was set does not exceed the frame count setting
+ 	 */
+ 	ring->coalesce_count += packet->tx_packets;
+ 	if (!pdata->tx_frames)
+ 		tx_set_ic = 0;
+ 	else if (packet->tx_packets > pdata->tx_frames)
+ 		tx_set_ic = 1;
+ 	else if ((ring->coalesce_count % pdata->tx_frames) <
+ 		 packet->tx_packets)
+ 		tx_set_ic = 1;
+ 	else
+ 		tx_set_ic = 0;
+ 
+ 	rdata = XGBE_GET_DESC_DATA(ring, ring->cur);
+ 	rdesc = rdata->rdesc;
+ 
+ 	DBGPR("-->tso_context = 0x%x vlan_context = 0x%x tx_set_ic = 0x%x\n", tso_context, vlan_context, tx_set_ic);
+ 
+ 	/* Create a context descriptor if this is a TSO packet */
+ 	if (tso_context || vlan_context) {
+ 		if (tso_context) {
+ 			DBGPR("  TSO context descriptor, mss=%u\n",
+ 			      packet->mss);
+ 
+ 			/* Set the MSS size */
+ 			XGMAC_SET_BITS_LE(rdesc->desc2, TX_CONTEXT_DESC2,
+ 					  MSS, packet->mss);
+ 
+ 			/* Mark it as a CONTEXT descriptor */
+ 			XGMAC_SET_BITS_LE(rdesc->desc3, TX_CONTEXT_DESC3,
+ 					  CTXT, 1);
+ 
+ 			/* Indicate this descriptor contains the MSS */
+ 			XGMAC_SET_BITS_LE(rdesc->desc3, TX_CONTEXT_DESC3,
+ 					  TCMSSV, 1);
+ 
+ 			ring->tx.cur_mss = packet->mss;
+ 		}
+ 
+ 		if (vlan_context) {
+ 			DBGPR("  VLAN context descriptor, ctag=%u\n",
+ 			      packet->vlan_ctag);
+ 
+ 			/* Mark it as a CONTEXT descriptor */
+ 			XGMAC_SET_BITS_LE(rdesc->desc3, TX_CONTEXT_DESC3,
+ 					  CTXT, 1);
+ 
+ 			/* Set the VLAN tag */
+ 			XGMAC_SET_BITS_LE(rdesc->desc3, TX_CONTEXT_DESC3,
+ 					  VT, packet->vlan_ctag);
+ 
+ 			/* Indicate this descriptor contains the VLAN tag */
+ 			XGMAC_SET_BITS_LE(rdesc->desc3, TX_CONTEXT_DESC3,
+ 					  VLTV, 1);
+ 
+ 			ring->tx.cur_vlan_ctag = packet->vlan_ctag;
+ 		}
+ 
+ 		ring->cur++;
+ 		rdata = XGBE_GET_DESC_DATA(ring, ring->cur);
+ 		rdesc = rdata->rdesc;
+ 	}
+ 
+ 	/* Update buffer address (for TSO this is the header) */
+ 	rdesc->desc0 =  cpu_to_le32(lower_32_bits(rdata->skb_dma));
+ 	rdesc->desc1 =  cpu_to_le32(upper_32_bits(rdata->skb_dma));
+ 
+ 	/* Update the buffer length */
+ 	XGMAC_SET_BITS_LE(rdesc->desc2, TX_NORMAL_DESC2, HL_B1L,
+ 			  rdata->skb_dma_len);
+ 
+ 	/* VLAN tag insertion check */
+ 	if (vlan)
+ 		XGMAC_SET_BITS_LE(rdesc->desc2, TX_NORMAL_DESC2, VTIR,
+ 				  TX_NORMAL_DESC2_VLAN_INSERT);
+ 
+ 	/* Timestamp enablement check */
+ 	if (XGMAC_GET_BITS(packet->attributes, TX_PACKET_ATTRIBUTES, PTP)){
+ 		DBGPR("Timestamp\n");
+ 		XGMAC_SET_BITS_LE(rdesc->desc2, TX_NORMAL_DESC2, TTSE, 1);
+ 	}
+ 
+ 	/* Mark it as First Descriptor */
+ 	XGMAC_SET_BITS_LE(rdesc->desc3, TX_NORMAL_DESC3, FD, 1);
+ 
+ 	/* Mark it as a NORMAL descriptor */
+ 	XGMAC_SET_BITS_LE(rdesc->desc3, TX_NORMAL_DESC3, CTXT, 0);
+ 
+ 	/* Set OWN bit if not the first descriptor */
+ 	if (ring->cur != start_index)
+ 		XGMAC_SET_BITS_LE(rdesc->desc3, TX_NORMAL_DESC3, OWN, 1);
+ 
+ 	if (tso) {
+ 		/* Enable TSO */
+ 		XGMAC_SET_BITS_LE(rdesc->desc3, TX_NORMAL_DESC3, TSE, 1);
+ 		XGMAC_SET_BITS_LE(rdesc->desc3, TX_NORMAL_DESC3, TCPPL,
+ 				  packet->tcp_payload_len);
+ 		XGMAC_SET_BITS_LE(rdesc->desc3, TX_NORMAL_DESC3, TCPHDRLEN,
+ 				  packet->tcp_header_len / 4);
+ 	} else {
+ 		/* Enable CRC and Pad Insertion */
+ 		XGMAC_SET_BITS_LE(rdesc->desc3, TX_NORMAL_DESC3, CPC, 0);
+ 
+ 		/* Enable HW CSUM */
+ 		if (csum)
+ 			XGMAC_SET_BITS_LE(rdesc->desc3, TX_NORMAL_DESC3,
+ 					  CIC, 0x3);
+ 
+ 		/* Set the total length to be transmitted */
+ 		XGMAC_SET_BITS_LE(rdesc->desc3, TX_NORMAL_DESC3, FL,
+ 				  packet->length);
+ 	}
+ 
+ 	for (i = ring->cur - start_index + 1; i < packet->rdesc_count; i++) {
+ 		ring->cur++;
+ 		rdata = XGBE_GET_DESC_DATA(ring, ring->cur);
+ 		rdesc = rdata->rdesc;
+ 
+ 		/* Update buffer address */
+ 		rdesc->desc0 = cpu_to_le32(lower_32_bits(rdata->skb_dma));
+ 		rdesc->desc1 = cpu_to_le32(upper_32_bits(rdata->skb_dma));
+ 
+ 		/* Update the buffer length */
+ 		XGMAC_SET_BITS_LE(rdesc->desc2, TX_NORMAL_DESC2, HL_B1L,
+ 				  rdata->skb_dma_len);
+ 
+ 		/* Set OWN bit */
+ 		XGMAC_SET_BITS_LE(rdesc->desc3, TX_NORMAL_DESC3, OWN, 1);
+ 
+ 		/* Mark it as NORMAL descriptor */
+ 		XGMAC_SET_BITS_LE(rdesc->desc3, TX_NORMAL_DESC3, CTXT, 0);
+ 
+ 		/* Enable HW CSUM */
+ 		if (csum)
+ 			XGMAC_SET_BITS_LE(rdesc->desc3, TX_NORMAL_DESC3,
+ 					  CIC, 0x3);
+ 	}
+ 
+ 	/* Set LAST bit for the last descriptor */
+ 	XGMAC_SET_BITS_LE(rdesc->desc3, TX_NORMAL_DESC3, LD, 1);
+ 
+ 	/* Set IC bit based on Tx coalescing settings */
+ 	//if (tx_set_ic)
+ 		XGMAC_SET_BITS_LE(rdesc->desc2, TX_NORMAL_DESC2, IC, 1);
+ 
+ 	/* Save the Tx info to report back during cleanup */
+ 	rdata->tx.packets = packet->tx_packets;
+ 	rdata->tx.bytes = packet->tx_bytes;
+ 
+ 	/* In case the Tx DMA engine is running, make sure everything
+ 	 * is written to the descriptor(s) before setting the OWN bit
+ 	 * for the first descriptor
+ 	 */
+ 	wmb();
+ 
+ 	/* Set OWN bit for the first descriptor */
+ 	rdata = XGBE_GET_DESC_DATA(ring, start_index);
+ 	rdesc = rdata->rdesc;
+ 	XGMAC_SET_BITS_LE(rdesc->desc3, TX_NORMAL_DESC3, OWN, 1);
+ 
+ #ifdef XGMAC_ENABLE_TX_DESC_DUMP
+ 	xgbe_dump_tx_desc(ring, start_index, packet->rdesc_count, 1);
+ #endif
+ 
+ 	/* Make sure ownership is written to the descriptor */
+ 	wmb();
+ 
+ 	ring->cur++;
+ 	if (!packet->skb->xmit_more ||
+ 	    netif_xmit_stopped(netdev_get_tx_queue(pdata->netdev,
+ 						   channel->queue_index)))
+ 		xgbe_tx_start_xmit(channel, ring);
+ 	else
+ 		ring->tx.xmit_more = 1;
+ 
+ 	dbg1 = XGMAC_IOREAD(pdata, DMA_DSR0);
+ 	dbg2 = XGMAC_IOREAD(pdata, DMA_DSR1);
+ 	DBGPR("DEBUG1 = 0x%x DEBUG2 = 0x%x\n", dbg1, dbg2);
+ 
+ 	DBGPR("  %s: descriptors %u to %u written\n",
+ 	      channel->name, start_index & (ring->rdesc_count - 1),
+ 	      (ring->cur - 1) & (ring->rdesc_count - 1));
+ 
+ 	DBGPR("<--xgbe_dev_xmit\n");
+ }
+ 
+ static int xgbe_dev_read(struct xgbe_channel *channel)
+ {
+ 	struct xgbe_ring *ring = channel->rx_ring;
+ 	struct xgbe_ring_data *rdata;
+ 	struct xgbe_ring_desc *rdesc;
+ 	struct xgbe_packet_data *packet = &ring->packet_data;
+ 	struct net_device *netdev = channel->pdata->netdev;
+ 	unsigned int err, etlt, l34t;
+ 
+ 	DBGPR("-->xgbe_dev_read: cur = %d\n", ring->cur);
+ 
+ 	rdata = XGBE_GET_DESC_DATA(ring, ring->cur);
+ 	rdesc = rdata->rdesc;
+ 
+ 	/* Check for data availability */
+ 	if (XGMAC_GET_BITS_LE(rdesc->desc3, RX_NORMAL_DESC3, OWN))
+ 		return 1;
+ 
+ 	/* Make sure descriptor fields are read after reading the OWN bit */
+ 	rmb();
+ 
+ #ifdef XGMAC_ENABLE_RX_DESC_DUMP
+ 	xgbe_dump_rx_desc(ring, rdesc, ring->cur);
+ #endif
+ 
+ 	if (XGMAC_GET_BITS_LE(rdesc->desc3, RX_NORMAL_DESC3, CTXT)) {
+ 		/* Timestamp Context Descriptor */
+ 		xgbe_get_rx_tstamp(packet, rdesc);
+ 
+ 		XGMAC_SET_BITS(packet->attributes, RX_PACKET_ATTRIBUTES,
+ 			       CONTEXT, 1);
+ 		XGMAC_SET_BITS(packet->attributes, RX_PACKET_ATTRIBUTES,
+ 			       CONTEXT_NEXT, 0);
+ 		return 0;
+ 	}
+ 
+ 	/* Normal Descriptor, be sure Context Descriptor bit is off */
+ 	XGMAC_SET_BITS(packet->attributes, RX_PACKET_ATTRIBUTES, CONTEXT, 0);
+ 
+ 	/* Indicate if a Context Descriptor is next */
+ 	if (XGMAC_GET_BITS_LE(rdesc->desc3, RX_NORMAL_DESC3, CDA))
+ 		XGMAC_SET_BITS(packet->attributes, RX_PACKET_ATTRIBUTES,
+ 			       CONTEXT_NEXT, 1);
+ 
+ 	/* Get the header length */
+ 	if (XGMAC_GET_BITS_LE(rdesc->desc3, RX_NORMAL_DESC3, FD))
+ 		rdata->rx.hdr_len = XGMAC_GET_BITS_LE(rdesc->desc2,
+ 						      RX_NORMAL_DESC2, HL);
+ 
+ 	/* Get the RSS hash */
+ 	if (XGMAC_GET_BITS_LE(rdesc->desc3, RX_NORMAL_DESC3, RSV)) {
+ 		XGMAC_SET_BITS(packet->attributes, RX_PACKET_ATTRIBUTES,
+ 			       RSS_HASH, 1);
+ 
+ 		packet->rss_hash = le32_to_cpu(rdesc->desc1);
+ 
+ 		l34t = XGMAC_GET_BITS_LE(rdesc->desc3, RX_NORMAL_DESC3, L34T);
+ 		switch (l34t) {
+ 		case RX_DESC3_L34T_IPV4_TCP:
+ 		case RX_DESC3_L34T_IPV4_UDP:
+ 		case RX_DESC3_L34T_IPV6_TCP:
+ 		case RX_DESC3_L34T_IPV6_UDP:
+ 			packet->rss_hash_type = PKT_HASH_TYPE_L4;
+ 			break;
+ 		default:
+ 			packet->rss_hash_type = PKT_HASH_TYPE_L3;
+ 		}
+ 	}
+ 
+ 	/* Get the packet length */
+ 	rdata->rx.len = XGMAC_GET_BITS_LE(rdesc->desc3, RX_NORMAL_DESC3, PL);
+ 
+ 	if (!XGMAC_GET_BITS_LE(rdesc->desc3, RX_NORMAL_DESC3, LD)) {
+ 		/* Not all the data has been transferred for this packet */
+ 		XGMAC_SET_BITS(packet->attributes, RX_PACKET_ATTRIBUTES,
+ 			       INCOMPLETE, 1);
+ 		return 0;
+ 	}
+ 
+ 	/* This is the last of the data for this packet */
+ 	XGMAC_SET_BITS(packet->attributes, RX_PACKET_ATTRIBUTES,
+ 		       INCOMPLETE, 0);
+ 
+ 	/* Set checksum done indicator as appropriate */
+ 	if (channel->pdata->netdev->features & NETIF_F_RXCSUM)
+ 		XGMAC_SET_BITS(packet->attributes, RX_PACKET_ATTRIBUTES,
+ 			       CSUM_DONE, 1);
+ 
+ 	/* Check for errors (only valid in last descriptor) */
+ 	err = XGMAC_GET_BITS_LE(rdesc->desc3, RX_NORMAL_DESC3, ES);
+ 	etlt = XGMAC_GET_BITS_LE(rdesc->desc3, RX_NORMAL_DESC3, ETLT);
+ 	DBGPR("  err=%u, etlt=%#x\n", err, etlt);
+ 
+ 	if (!err || !etlt) {
+ 		/* No error if err is 0 or etlt is 0 */
+ 		if ((etlt == 0x09) &&
+ 		    (netdev->features & NETIF_F_HW_VLAN_CTAG_RX)) {
+ 			XGMAC_SET_BITS(packet->attributes, RX_PACKET_ATTRIBUTES,
+ 				       VLAN_CTAG, 1);
+ 			packet->vlan_ctag = XGMAC_GET_BITS_LE(rdesc->desc0,
+ 							      RX_NORMAL_DESC0,
+ 							      OVT);
+ 			DBGPR("  vlan-ctag=0x%04x\n", packet->vlan_ctag);
+ 		}
+ 	} else {
+ 		if ((etlt == 0x05) || (etlt == 0x06))
+ 			XGMAC_SET_BITS(packet->attributes, RX_PACKET_ATTRIBUTES,
+ 				       CSUM_DONE, 0);
+ 		else
+ 			XGMAC_SET_BITS(packet->errors, RX_PACKET_ERRORS,
+ 				       FRAME, 1);
+ 	}
+ 
+ 	DBGPR("<--xgbe_dev_read: %s - descriptor=%u (cur=%d)\n", channel->name,
+ 	      ring->cur & (ring->rdesc_count - 1), ring->cur);
+ 
+ 	return 0;
+ }
+ 
+ static int xgbe_is_context_desc(struct xgbe_ring_desc *rdesc)
+ {
+ 	/* Rx and Tx share CTXT bit, so check TDES3.CTXT bit */
+ 	return XGMAC_GET_BITS_LE(rdesc->desc3, TX_NORMAL_DESC3, CTXT);
+ }
+ 
+ static int xgbe_is_last_desc(struct xgbe_ring_desc *rdesc)
+ {
+ 	/* Rx and Tx share LD bit, so check TDES3.LD bit */
+ 	return XGMAC_GET_BITS_LE(rdesc->desc3, TX_NORMAL_DESC3, LD);
+ }
+ 
+ static int xgbe_enable_int(struct xgbe_channel *channel,
+ 			   enum xgbe_int int_id)
+ {
+ 	unsigned int dma_ch_ier;
+ DBGPR("-->%s\n", __func__);
+ 	dma_ch_ier = XGMAC_DMA_IOREAD(channel, DMA_CH_IER);
+ 
+ 	switch (int_id) {
+ 	case XGMAC_INT_DMA_CH_SR_TI:
+ 		XGMAC_SET_BITS(dma_ch_ier, DMA_CH_IER, TIE, 1);
+ 		break;
+ 	case XGMAC_INT_DMA_CH_SR_TPS:
+ 		XGMAC_SET_BITS(dma_ch_ier, DMA_CH_IER, TXSE, 1);
+ 		break;
+ 	case XGMAC_INT_DMA_CH_SR_TBU:
+ 		XGMAC_SET_BITS(dma_ch_ier, DMA_CH_IER, TBUE, 1);
+ 		break;
+ 	case XGMAC_INT_DMA_CH_SR_RI:
+ 		XGMAC_SET_BITS(dma_ch_ier, DMA_CH_IER, RIE, 1);
+ 		break;
+ 	case XGMAC_INT_DMA_CH_SR_RBU:
+ 		XGMAC_SET_BITS(dma_ch_ier, DMA_CH_IER, RBUE, 1);
+ 		break;
+ 	case XGMAC_INT_DMA_CH_SR_RPS:
+ 		XGMAC_SET_BITS(dma_ch_ier, DMA_CH_IER, RSE, 1);
+ 		break;
+ 	case XGMAC_INT_DMA_CH_SR_TI_RI:
+ 		XGMAC_SET_BITS(dma_ch_ier, DMA_CH_IER, TIE, 1);
+ 		XGMAC_SET_BITS(dma_ch_ier, DMA_CH_IER, RIE, 1);
+ 		break;
+ 	case XGMAC_INT_DMA_CH_SR_FBE:
+ 		XGMAC_SET_BITS(dma_ch_ier, DMA_CH_IER, FBEE, 1);
+ 		break;
+ 	case XGMAC_INT_DMA_ALL:
+ 		dma_ch_ier |= channel->saved_ier;
+ 		break;
+ 	default:
+ 		return -1;
+ 	}
+ 
+ 	XGMAC_DMA_IOWRITE(channel, DMA_CH_IER, dma_ch_ier);
+ 
+ 	return 0;
+ }
+ 
+ static int xgbe_disable_int(struct xgbe_channel *channel,
+ 			    enum xgbe_int int_id)
+ {
+ 	unsigned int dma_ch_ier;
+ DBGPR("-->%s\n", __func__);
+ 	dma_ch_ier = XGMAC_DMA_IOREAD(channel, DMA_CH_IER);
+ 
+ 	switch (int_id) {
+ 	case XGMAC_INT_DMA_CH_SR_TI:
+ 		XGMAC_SET_BITS(dma_ch_ier, DMA_CH_IER, TIE, 0);
+ 		break;
+ 	case XGMAC_INT_DMA_CH_SR_TPS:
+ 		XGMAC_SET_BITS(dma_ch_ier, DMA_CH_IER, TXSE, 0);
+ 		break;
+ 	case XGMAC_INT_DMA_CH_SR_TBU:
+ 		XGMAC_SET_BITS(dma_ch_ier, DMA_CH_IER, TBUE, 0);
+ 		break;
+ 	case XGMAC_INT_DMA_CH_SR_RI:
+ 		XGMAC_SET_BITS(dma_ch_ier, DMA_CH_IER, RIE, 0);
+ 		break;
+ 	case XGMAC_INT_DMA_CH_SR_RBU:
+ 		XGMAC_SET_BITS(dma_ch_ier, DMA_CH_IER, RBUE, 0);
+ 		break;
+ 	case XGMAC_INT_DMA_CH_SR_RPS:
+ 		XGMAC_SET_BITS(dma_ch_ier, DMA_CH_IER, RSE, 0);
+ 		break;
+ 	case XGMAC_INT_DMA_CH_SR_TI_RI:
+ 		XGMAC_SET_BITS(dma_ch_ier, DMA_CH_IER, TIE, 0);
+ 		XGMAC_SET_BITS(dma_ch_ier, DMA_CH_IER, RIE, 0);
+ 		break;
+ 	case XGMAC_INT_DMA_CH_SR_FBE:
+ 		XGMAC_SET_BITS(dma_ch_ier, DMA_CH_IER, FBEE, 0);
+ 		break;
+ 	case XGMAC_INT_DMA_ALL:
+ 		channel->saved_ier = dma_ch_ier & XGBE_DMA_INTERRUPT_MASK;
+ 		dma_ch_ier &= ~XGBE_DMA_INTERRUPT_MASK;
+ 		break;
+ 	default:
+ 		return -1;
+ 	}
+ 
+ 	XGMAC_DMA_IOWRITE(channel, DMA_CH_IER, dma_ch_ier);
+ 
+ 	return 0;
+ }
+ 
+ static int xgbe_exit(struct xgbe_prv_data *pdata)
+ {
+ 	unsigned int count = 2000;
+ 
+ 	DBGPR("-->xgbe_exit\n");
+ 
+ 	/* Issue a software reset */
+ 	XGMAC_IOWRITE_BITS(pdata, DMA_MR, SWR, 1);
+ 	usleep_range(10, 15);
+ 
+ 	/* Poll Until Poll Condition */
+ 	while (count-- && XGMAC_IOREAD_BITS(pdata, DMA_MR, SWR))
+ 		usleep_range(500, 600);
+ 
+ 	if (!count)
+ 		return -EBUSY;
+ 
+ 	DBGPR("<--xgbe_exit\n");
+ 
+ 	return 0;
+ }
+ 
+ static int xgbe_flush_tx_queues(struct xgbe_prv_data *pdata)
+ {
+ 	unsigned int i, count;
+ DBGPR("-->%s\n", __func__);
+ 	if (XGMAC_GET_BITS(pdata->hw_feat.version, MAC_VR, SNPSVER) < 0x21)
+ 		return 0;
+ 
+ 	for (i = 0; i < pdata->tx_q_count; i++)
+ 		XGMAC_MTL_IOWRITE_BITS(pdata, i, MTL_Q_TQOMR, FTQ, 1);
+ 
+ 	/* Poll Until Poll Condition */
+ 	for (i = 0; i < pdata->tx_q_count; i++) {
+ 		count = 2000;
+ 		while (count-- && XGMAC_MTL_IOREAD_BITS(pdata, i,
+ 							MTL_Q_TQOMR, FTQ))
+ 			usleep_range(500, 600);
+ 
+ 		if (!count)
+ 			return -EBUSY;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static void xgbe_config_dma_bus(struct xgbe_prv_data *pdata)
+ {
+ 	/* Set enhanced addressing mode */
+ 	XGMAC_IOWRITE_BITS(pdata, DMA_SBMR, EAME, 1);
+ DBGPR("-->%s\n", __func__);
+ 	/* Set the System Bus mode */
+ 	XGMAC_IOWRITE_BITS(pdata, DMA_SBMR, UNDEF, 1);
+ 	XGMAC_IOWRITE_BITS(pdata, DMA_SBMR, BLEN_16, 1);
+ }
+ 
+ static void xgbe_config_dma_cache(struct xgbe_prv_data *pdata)
+ {
+ 	unsigned int arcache, awcache;
+ 
+ 	arcache = 0;
+ 	XGMAC_SET_BITS(arcache, DMA_AXIARCR, DRC, pdata->arcache);
+ 	XGMAC_SET_BITS(arcache, DMA_AXIARCR, DRD, pdata->axdomain);
+ 	XGMAC_SET_BITS(arcache, DMA_AXIARCR, TEC, pdata->arcache);
+ 	XGMAC_SET_BITS(arcache, DMA_AXIARCR, TED, pdata->axdomain);
+ 	XGMAC_SET_BITS(arcache, DMA_AXIARCR, THC, pdata->arcache);
+ 	XGMAC_SET_BITS(arcache, DMA_AXIARCR, THD, pdata->axdomain);
+ 	XGMAC_IOWRITE(pdata, DMA_AXIARCR, arcache);
+ 
+ 	awcache = 0;
+ 	XGMAC_SET_BITS(awcache, DMA_AXIAWCR, DWC, pdata->awcache);
+ 	XGMAC_SET_BITS(awcache, DMA_AXIAWCR, DWD, pdata->axdomain);
+ 	XGMAC_SET_BITS(awcache, DMA_AXIAWCR, RPC, pdata->awcache);
+ 	XGMAC_SET_BITS(awcache, DMA_AXIAWCR, RPD, pdata->axdomain);
+ 	XGMAC_SET_BITS(awcache, DMA_AXIAWCR, RHC, pdata->awcache);
+ 	XGMAC_SET_BITS(awcache, DMA_AXIAWCR, RHD, pdata->axdomain);
+ 	XGMAC_SET_BITS(awcache, DMA_AXIAWCR, TDC, pdata->awcache);
+ 	XGMAC_SET_BITS(awcache, DMA_AXIAWCR, TDD, pdata->axdomain);
+ 	XGMAC_IOWRITE(pdata, DMA_AXIAWCR, awcache);
+ }
+ 
+ static void xgbe_config_mtl_mode(struct xgbe_prv_data *pdata)
+ {
+ 	unsigned int i;
+ DBGPR("-->%s\n", __func__);
+ 	/* Set Tx to weighted round robin scheduling algorithm */
+ 	XGMAC_IOWRITE_BITS(pdata, MTL_OMR, ETSALG, MTL_ETSALG_WRR);
+ 
+ 	/* Set Tx traffic classes to use WRR algorithm with equal weights */
+ 	for (i = 0; i < pdata->hw_feat.tc_cnt; i++) {
+ 		XGMAC_MTL_IOWRITE_BITS(pdata, i, MTL_TC_ETSCR, TSA,
+ 				       MTL_TSA_ETS);
+ 		XGMAC_MTL_IOWRITE_BITS(pdata, i, MTL_TC_QWR, QW, 1);
+ 	}
+ 
+ 	/* Set Rx to strict priority algorithm */
+ 	XGMAC_IOWRITE_BITS(pdata, MTL_OMR, RAA, MTL_RAA_SP);
+ }
+ 
+ static unsigned int xgbe_calculate_per_queue_fifo(unsigned int fifo_size,
+ 						  unsigned int queue_count)
+ {
+ 	unsigned int q_fifo_size = 0;
+ 	enum xgbe_mtl_fifo_size p_fifo = XGMAC_MTL_FIFO_SIZE_256;
+ DBGPR("-->%s\n", __func__);
+ 	/* Calculate Tx/Rx fifo share per queue */
+ 	switch (fifo_size) {
+ 	case 0:
+ 		q_fifo_size = XGBE_FIFO_SIZE_B(128);
+ 		break;
+ 	case 1:
+ 		q_fifo_size = XGBE_FIFO_SIZE_B(256);
+ 		break;
+ 	case 2:
+ 		q_fifo_size = XGBE_FIFO_SIZE_B(512);
+ 		break;
+ 	case 3:
+ 		q_fifo_size = XGBE_FIFO_SIZE_KB(1);
+ 		break;
+ 	case 4:
+ 		q_fifo_size = XGBE_FIFO_SIZE_KB(2);
+ 		break;
+ 	case 5:
+ 		q_fifo_size = XGBE_FIFO_SIZE_KB(4);
+ 		break;
+ 	case 6:
+ 		q_fifo_size = XGBE_FIFO_SIZE_KB(8);
+ 		break;
+ 	case 7:
+ 		q_fifo_size = XGBE_FIFO_SIZE_KB(16);
+ 		break;
+ 	case 8:
+ 		q_fifo_size = XGBE_FIFO_SIZE_KB(32);
+ 		break;
+ 	case 9:
+ 		q_fifo_size = XGBE_FIFO_SIZE_KB(64);
+ 		break;
+ 	case 10:
+ 		q_fifo_size = XGBE_FIFO_SIZE_KB(128);
+ 		break;
+ 	case 11:
+ 		q_fifo_size = XGBE_FIFO_SIZE_KB(256);
+ 		break;
+ 	}
+ 
+ 	/* The configured value is not the actual amount of fifo RAM */
+ 	q_fifo_size = min_t(unsigned int, XGBE_FIFO_MAX, q_fifo_size);
+ 
+ 	q_fifo_size = q_fifo_size / queue_count;
+ 
+ 	/* Set the queue fifo size programmable value */
+ 	if (q_fifo_size >= XGBE_FIFO_SIZE_KB(256))
+ 		p_fifo = XGMAC_MTL_FIFO_SIZE_256K;
+ 	else if (q_fifo_size >= XGBE_FIFO_SIZE_KB(128))
+ 		p_fifo = XGMAC_MTL_FIFO_SIZE_128K;
+ 	else if (q_fifo_size >= XGBE_FIFO_SIZE_KB(64))
+ 		p_fifo = XGMAC_MTL_FIFO_SIZE_64K;
+ 	else if (q_fifo_size >= XGBE_FIFO_SIZE_KB(32))
+ 		p_fifo = XGMAC_MTL_FIFO_SIZE_32K;
+ 	else if (q_fifo_size >= XGBE_FIFO_SIZE_KB(16))
+ 		p_fifo = XGMAC_MTL_FIFO_SIZE_16K;
+ 	else if (q_fifo_size >= XGBE_FIFO_SIZE_KB(8))
+ 		p_fifo = XGMAC_MTL_FIFO_SIZE_8K;
+ 	else if (q_fifo_size >= XGBE_FIFO_SIZE_KB(4))
+ 		p_fifo = XGMAC_MTL_FIFO_SIZE_4K;
+ 	else if (q_fifo_size >= XGBE_FIFO_SIZE_KB(2))
+ 		p_fifo = XGMAC_MTL_FIFO_SIZE_2K;
+ 	else if (q_fifo_size >= XGBE_FIFO_SIZE_KB(1))
+ 		p_fifo = XGMAC_MTL_FIFO_SIZE_1K;
+ 	else if (q_fifo_size >= XGBE_FIFO_SIZE_B(512))
+ 		p_fifo = XGMAC_MTL_FIFO_SIZE_512;
+ 	else if (q_fifo_size >= XGBE_FIFO_SIZE_B(256))
+ 		p_fifo = XGMAC_MTL_FIFO_SIZE_256;
+ 
+ 	return p_fifo;
+ }
+ 
+ static void xgbe_config_tx_fifo_size(struct xgbe_prv_data *pdata)
+ {
+ 	enum xgbe_mtl_fifo_size fifo_size;
+ 	unsigned int i;
+ DBGPR("-->%s\n", __func__);
+ 	fifo_size = xgbe_calculate_per_queue_fifo(pdata->hw_feat.tx_fifo_size,
+ 						  pdata->tx_q_count);
+ 
+ 	for (i = 0; i < pdata->tx_q_count; i++)
+ 		XGMAC_MTL_IOWRITE_BITS(pdata, i, MTL_Q_TQOMR, TQS, fifo_size);
+ 
+ 	netdev_notice(pdata->netdev, "%d Tx queues, %d byte fifo per queue\n",
+ 		      pdata->tx_q_count, ((fifo_size + 1) * 256));
+ }
+ 
+ static void xgbe_config_rx_fifo_size(struct xgbe_prv_data *pdata)
+ {
+ 	enum xgbe_mtl_fifo_size fifo_size;
+ 	unsigned int i;
+ DBGPR("-->%s\n", __func__);
+ 	fifo_size = xgbe_calculate_per_queue_fifo(pdata->hw_feat.rx_fifo_size,
+ 						  pdata->rx_q_count);
+ 
+ 	for (i = 0; i < pdata->rx_q_count; i++)
+ 		XGMAC_MTL_IOWRITE_BITS(pdata, i, MTL_Q_RQOMR, RQS, fifo_size);
+ 
+ 	netdev_notice(pdata->netdev, "%d Rx queues, %d byte fifo per queue\n",
+ 		      pdata->rx_q_count, ((fifo_size + 1) * 256));
+ }
+ 
+ static void xgbe_config_queue_mapping(struct xgbe_prv_data *pdata)
+ {
+ 	unsigned int qptc, qptc_extra, queue;
+ 	unsigned int prio_queues;
+ 	unsigned int ppq, ppq_extra, prio;
+ 	unsigned int mask;
+ 	unsigned int i, j, reg, reg_val;
+ DBGPR("-->%s\n", __func__);
+ 	/* Map the MTL Tx Queues to Traffic Classes
+ 	 *   Note: Tx Queues >= Traffic Classes
+ 	 */
+ 	qptc = pdata->tx_q_count / pdata->hw_feat.tc_cnt;
+ 	qptc_extra = pdata->tx_q_count % pdata->hw_feat.tc_cnt;
+ 
+ 	for (i = 0, queue = 0; i < pdata->hw_feat.tc_cnt; i++) {
+ 		for (j = 0; j < qptc; j++) {
+ 			DBGPR("  TXq%u mapped to TC%u\n", queue, i);
+ 			XGMAC_MTL_IOWRITE_BITS(pdata, queue, MTL_Q_TQOMR,
+ 					       Q2TCMAP, i);
+ 			pdata->q2tc_map[queue++] = i;
+ 		}
+ 
+ 		if (i < qptc_extra) {
+ 			DBGPR("  TXq%u mapped to TC%u\n", queue, i);
+ 			XGMAC_MTL_IOWRITE_BITS(pdata, queue, MTL_Q_TQOMR,
+ 					       Q2TCMAP, i);
+ 			pdata->q2tc_map[queue++] = i;
+ 		}
+ 	}
+ 
+ 	/* Map the 8 VLAN priority values to available MTL Rx queues */
+ 	prio_queues = min_t(unsigned int, IEEE_8021QAZ_MAX_TCS,
+ 			    pdata->rx_q_count);
+ 	ppq = IEEE_8021QAZ_MAX_TCS / prio_queues;
+ 	ppq_extra = IEEE_8021QAZ_MAX_TCS % prio_queues;
+ 
+ 	reg = MAC_RQC2R;
+ 	reg_val = 0;
+ 	for (i = 0, prio = 0; i < prio_queues;) {
+ 		mask = 0;
+ 		for (j = 0; j < ppq; j++) {
+ 			DBGPR("  PRIO%u mapped to RXq%u\n", prio, i);
+ 			mask |= (1 << prio);
+ 			pdata->prio2q_map[prio++] = i;
+ 		}
+ 
+ 		if (i < ppq_extra) {
+ 			DBGPR("  PRIO%u mapped to RXq%u\n", prio, i);
+ 			mask |= (1 << prio);
+ 			pdata->prio2q_map[prio++] = i;
+ 		}
+ 
+ 		reg_val |= (mask << ((i++ % MAC_RQC2_Q_PER_REG) << 3));
+ 
+ 		if ((i % MAC_RQC2_Q_PER_REG) && (i != prio_queues))
+ 			continue;
+ 
+ 		XGMAC_IOWRITE(pdata, reg, reg_val);
+ 		reg += MAC_RQC2_INC;
+ 		reg_val = 0;
+ 	}
+ 
+ 	/* Select dynamic mapping of MTL Rx queue to DMA Rx channel */
+ 	reg = MTL_RQDCM0R;
+ 	reg_val = 0;
+ 	for (i = 0; i < pdata->rx_q_count;) {
+ 		reg_val |= (0x80 << ((i++ % MTL_RQDCM_Q_PER_REG) << 3));
+ 
+ 		if ((i % MTL_RQDCM_Q_PER_REG) && (i != pdata->rx_q_count))
+ 			continue;
+ 
+ 		XGMAC_IOWRITE(pdata, reg, reg_val);
+ 
+ 		reg += MTL_RQDCM_INC;
+ 		reg_val = 0;
+ 	}
+ }
+ 
+ static void xgbe_config_flow_control_threshold(struct xgbe_prv_data *pdata)
+ {
+ 	unsigned int i;
+ DBGPR("-->%s\n", __func__);
+ 	for (i = 0; i < pdata->rx_q_count; i++) {
+ 		/* Activate flow control when less than 4k left in fifo */
+ 		XGMAC_MTL_IOWRITE_BITS(pdata, i, MTL_Q_RQFCR, RFA, 2);
+ 
+ 		/* De-activate flow control when more than 6k left in fifo */
+ 		XGMAC_MTL_IOWRITE_BITS(pdata, i, MTL_Q_RQFCR, RFD, 4);
+ 	}
+ }
+ 
+ static void xgbe_config_mac_address(struct xgbe_prv_data *pdata)
+ {
+ DBGPR("-->%s\n", __func__);
+ 	xgbe_set_mac_address(pdata, pdata->netdev->dev_addr);
+ 
+ 	/* Filtering is done using perfect filtering and hash filtering */
+ 	if (pdata->hw_feat.hash_table_size) {
+ 		XGMAC_IOWRITE_BITS(pdata, MAC_PFR, HPF, 1);
+ 		XGMAC_IOWRITE_BITS(pdata, MAC_PFR, HUC, 1);
+ 		XGMAC_IOWRITE_BITS(pdata, MAC_PFR, HMC, 1);
+ 	}
+ }
+ 
+ static void xgbe_config_jumbo_enable(struct xgbe_prv_data *pdata)
+ {
+ 	unsigned int val;
+ DBGPR("-->%s\n", __func__);
+ 	val = (pdata->netdev->mtu > XGMAC_STD_PACKET_MTU) ? 1 : 0;
+ 
+ 	XGMAC_IOWRITE_BITS(pdata, MAC_RCR, JE, val);
+ }
+ 
+ static void xgbe_config_checksum_offload(struct xgbe_prv_data *pdata)
+ {
+ DBGPR("-->%s\n", __func__);
+ 	if (pdata->netdev->features & NETIF_F_RXCSUM)
+ 		xgbe_enable_rx_csum(pdata);
+ 	else
+ 		xgbe_disable_rx_csum(pdata);
+ }
+ 
+ static void xgbe_config_vlan_support(struct xgbe_prv_data *pdata)
+ {
+ 	/* Indicate that VLAN Tx CTAGs come from context descriptors */
+ 	XGMAC_IOWRITE_BITS(pdata, MAC_VLANIR, CSVL, 0);
+ 	XGMAC_IOWRITE_BITS(pdata, MAC_VLANIR, VLTI, 1);
+ DBGPR("-->%s\n", __func__);
+ 	/* Set the current VLAN Hash Table register value */
+ 	xgbe_update_vlan_hash_table(pdata);
+ 
+ 	if (pdata->netdev->features & NETIF_F_HW_VLAN_CTAG_FILTER)
+ 		xgbe_enable_rx_vlan_filtering(pdata);
+ 	else
+ 		xgbe_disable_rx_vlan_filtering(pdata);
+ 
+ 	if (pdata->netdev->features & NETIF_F_HW_VLAN_CTAG_RX)
+ 		xgbe_enable_rx_vlan_stripping(pdata);
+ 	else
+ 		xgbe_disable_rx_vlan_stripping(pdata);
+ }
+ 
+ static void xgbe_prepare_tx_stop(struct xgbe_prv_data *pdata,
+ 				 struct xgbe_channel *channel)
+ {
+ 	unsigned int tx_dsr, tx_pos, tx_qidx;
+ 	unsigned int tx_status;
+ 	unsigned long tx_timeout;
+ DBGPR("-->%s\n", __func__);
+ 	/* Calculate the status register to read and the position within */
+ 	if (channel->queue_index < DMA_DSRX_FIRST_QUEUE) {
+ 		tx_dsr = DMA_DSR0;
+ 		tx_pos = (channel->queue_index * DMA_DSR_Q_WIDTH) +
+ 			 DMA_DSR0_TPS_START;
+ 	} else {
+ 		tx_qidx = channel->queue_index - DMA_DSRX_FIRST_QUEUE;
+ 
+ 		tx_dsr = DMA_DSR1 + ((tx_qidx / DMA_DSRX_QPR) * DMA_DSRX_INC);
+ 		tx_pos = ((tx_qidx % DMA_DSRX_QPR) * DMA_DSR_Q_WIDTH) +
+ 			 DMA_DSRX_TPS_START;
+ 	}
+ 
+ 	/* The Tx engine cannot be stopped if it is actively processing
+ 	 * descriptors. Wait for the Tx engine to enter the stopped or
+ 	 * suspended state.  Don't wait forever though...
+ 	 */
+ 	tx_timeout = jiffies + (XGBE_DMA_STOP_TIMEOUT * HZ);
+ 	while (time_before(jiffies, tx_timeout)) {
+ 		tx_status = XGMAC_IOREAD(pdata, tx_dsr);
+ 		tx_status = GET_BITS(tx_status, tx_pos, DMA_DSR_TPS_WIDTH);
+ 		if ((tx_status == DMA_TPS_STOPPED) ||
+ 		    (tx_status == DMA_TPS_SUSPENDED))
+ 			break;
+ 
+ 		usleep_range(500, 1000);
+ 	}
+ 
+ 	if (!time_before(jiffies, tx_timeout))
+ 		netdev_info(pdata->netdev,
+ 			    "timed out waiting for Tx DMA channel %u to stop\n",
+ 			    channel->queue_index);
+ }
+ 
+ static void xgbe_enable_tx(struct xgbe_prv_data *pdata)
+ {
+ 	struct xgbe_channel *channel;
+ 	unsigned int i;
+ DBGPR("-->%s\n", __func__);
+ 	/* Enable each Tx DMA channel */
+ 	channel = pdata->channel;
+ 	for (i = 0; i < pdata->channel_count; i++, channel++) {
+ 		if (!channel->tx_ring)
+ 			break;
+ 
+ 		XGMAC_DMA_IOWRITE_BITS(channel, DMA_CH_TCR, ST, 1);
+ 	}
+ 
+ 	/* Enable each Tx queue */
+ 	for (i = 0; i < pdata->tx_q_count; i++)
+ 		XGMAC_MTL_IOWRITE_BITS(pdata, i, MTL_Q_TQOMR, TXQEN,
+ 				       MTL_Q_ENABLED);
+ 
+ 	/* Enable MAC Tx */
+ 	XGMAC_IOWRITE_BITS(pdata, MAC_TCR, TE, 1);
+ }
+ 
+ static void xgbe_disable_tx(struct xgbe_prv_data *pdata)
+ {
+ 	struct xgbe_channel *channel;
+ 	unsigned int i;
+ DBGPR("-->%s\n", __func__);
+ 	/* Prepare for Tx DMA channel stop */
+ 	channel = pdata->channel;
+ 	for (i = 0; i < pdata->channel_count; i++, channel++) {
+ 		if (!channel->tx_ring)
+ 			break;
+ 
+ 		xgbe_prepare_tx_stop(pdata, channel);
+ 	}
+ 
+ 	/* Disable MAC Tx */
+ 	XGMAC_IOWRITE_BITS(pdata, MAC_TCR, TE, 0);
+ 
+ 	/* Disable each Tx queue */
+ 	for (i = 0; i < pdata->tx_q_count; i++)
+ 		XGMAC_MTL_IOWRITE_BITS(pdata, i, MTL_Q_TQOMR, TXQEN, 0);
+ 
+ 	/* Disable each Tx DMA channel */
+ 	channel = pdata->channel;
+ 	for (i = 0; i < pdata->channel_count; i++, channel++) {
+ 		if (!channel->tx_ring)
+ 			break;
+ 
+ 		XGMAC_DMA_IOWRITE_BITS(channel, DMA_CH_TCR, ST, 0);
+ 	}
+ }
+ 
+ static void xgbe_enable_rx(struct xgbe_prv_data *pdata)
+ {
+ 	struct xgbe_channel *channel;
+ 	unsigned int reg_val, i;
+ DBGPR("-->%s\n", __func__);
+ 	/* Enable each Rx DMA channel */
+ 	channel = pdata->channel;
+ 	for (i = 0; i < pdata->channel_count; i++, channel++) {
+ 		if (!channel->rx_ring)
+ 			break;
+ 
+ 		XGMAC_DMA_IOWRITE_BITS(channel, DMA_CH_RCR, SR, 1);
+ 	}
+ 
+ 	/* Enable each Rx queue */
+ 	reg_val = 0;
+ 	for (i = 0; i < pdata->rx_q_count; i++)
+ 		reg_val |= (0x02 << (i << 1));
+ 	XGMAC_IOWRITE(pdata, MAC_RQC0R, reg_val);
+ 
+ 	/* Enable MAC Rx */
+ 	XGMAC_IOWRITE_BITS(pdata, MAC_RCR, DCRCC, 1);
+ 	XGMAC_IOWRITE_BITS(pdata, MAC_RCR, CST, 1);
+ 	XGMAC_IOWRITE_BITS(pdata, MAC_RCR, ACS, 1);
+ 	XGMAC_IOWRITE_BITS(pdata, MAC_RCR, RE, 1);
+ }
+ 
+ static void xgbe_disable_rx(struct xgbe_prv_data *pdata)
+ {
+ 	struct xgbe_channel *channel;
+ 	unsigned int i;
+ DBGPR("-->%s\n", __func__);
+ 	/* Disable MAC Rx */
+ 	XGMAC_IOWRITE_BITS(pdata, MAC_RCR, DCRCC, 0);
+ 	XGMAC_IOWRITE_BITS(pdata, MAC_RCR, CST, 0);
+ 	XGMAC_IOWRITE_BITS(pdata, MAC_RCR, ACS, 0);
+ 	XGMAC_IOWRITE_BITS(pdata, MAC_RCR, RE, 0);
+ 
+ 	/* Disable each Rx queue */
+ 	XGMAC_IOWRITE(pdata, MAC_RQC0R, 0);
+ 
+ 	/* Disable each Rx DMA channel */
+ 	channel = pdata->channel;
+ 	for (i = 0; i < pdata->channel_count; i++, channel++) {
+ 		if (!channel->rx_ring)
+ 			break;
+ 
+ 		XGMAC_DMA_IOWRITE_BITS(channel, DMA_CH_RCR, SR, 0);
+ 	}
+ }
+ 
+ static void xgbe_powerup_tx(struct xgbe_prv_data *pdata)
+ {
+ 	struct xgbe_channel *channel;
+ 	unsigned int i;
+ DBGPR("-->%s\n", __func__);
+ 	/* Enable each Tx DMA channel */
+ 	channel = pdata->channel;
+ 	for (i = 0; i < pdata->channel_count; i++, channel++) {
+ 		if (!channel->tx_ring)
+ 			break;
+ 
+ 		XGMAC_DMA_IOWRITE_BITS(channel, DMA_CH_TCR, ST, 1);
+ 	}
+ 
+ 	/* Enable MAC Tx */
+ 	XGMAC_IOWRITE_BITS(pdata, MAC_TCR, TE, 1);
+ }
+ 
+ static void xgbe_powerdown_tx(struct xgbe_prv_data *pdata)
+ {
+ 	struct xgbe_channel *channel;
+ 	unsigned int i;
+ DBGPR("-->%s\n", __func__);
+ 	/* Prepare for Tx DMA channel stop */
+ 	channel = pdata->channel;
+ 	for (i = 0; i < pdata->channel_count; i++, channel++) {
+ 		if (!channel->tx_ring)
+ 			break;
+ 
+ 		xgbe_prepare_tx_stop(pdata, channel);
+ 	}
+ 
+ 	/* Disable MAC Tx */
+ 	XGMAC_IOWRITE_BITS(pdata, MAC_TCR, TE, 0);
+ 
+ 	/* Disable each Tx DMA channel */
+ 	channel = pdata->channel;
+ 	for (i = 0; i < pdata->channel_count; i++, channel++) {
+ 		if (!channel->tx_ring)
+ 			break;
+ 
+ 		XGMAC_DMA_IOWRITE_BITS(channel, DMA_CH_TCR, ST, 0);
+ 	}
+ }
+ 
+ static void xgbe_powerup_rx(struct xgbe_prv_data *pdata)
+ {
+ 	struct xgbe_channel *channel;
+ 	unsigned int i;
+ DBGPR("-->%s\n", __func__);
+ 	/* Enable each Rx DMA channel */
+ 	channel = pdata->channel;
+ 	for (i = 0; i < pdata->channel_count; i++, channel++) {
+ 		if (!channel->rx_ring)
+ 			break;
+ 
+ 		XGMAC_DMA_IOWRITE_BITS(channel, DMA_CH_RCR, SR, 1);
+ 	}
+ }
+ 
+ static void xgbe_powerdown_rx(struct xgbe_prv_data *pdata)
+ {
+ 	struct xgbe_channel *channel;
+ 	unsigned int i;
+ DBGPR("-->%s\n", __func__);
+ 	/* Disable each Rx DMA channel */
+ 	channel = pdata->channel;
+ 	for (i = 0; i < pdata->channel_count; i++, channel++) {
+ 		if (!channel->rx_ring)
+ 			break;
+ 
+ 		XGMAC_DMA_IOWRITE_BITS(channel, DMA_CH_RCR, SR, 0);
+ 	}
+ }
+ 
+ static int xgbe_init(struct xgbe_prv_data *pdata)
+ {
+ 	struct xgbe_desc_if *desc_if = &pdata->desc_if;
+ 	int ret;
+ 
+ 	DBGPR("-->xgbe_init\n");
+ 
+ 	/* Flush Tx queues */
+ 	ret = xgbe_flush_tx_queues(pdata);
+ 	if (ret)
+ 		return ret;
+ 
+ 	/*
+ 	 * Initialize DMA related features
+ 	 */
+ 	xgbe_config_dma_bus(pdata);
+ 	xgbe_config_dma_cache(pdata);
+ 	xgbe_config_osp_mode(pdata);
+ 	xgbe_config_pblx8(pdata);
+ 	xgbe_config_tx_pbl_val(pdata);
+ 	xgbe_config_rx_pbl_val(pdata);
+ 	xgbe_config_rx_coalesce(pdata);
+ 	xgbe_config_tx_coalesce(pdata);
+ 	xgbe_config_rx_buffer_size(pdata);
+ 	xgbe_config_tso_mode(pdata);
+ 	xgbe_config_sph_mode(pdata);
+ 	xgbe_config_rss(pdata);
+ 	desc_if->wrapper_tx_desc_init(pdata);
+ 	desc_if->wrapper_rx_desc_init(pdata);
+ 	xgbe_enable_dma_interrupts(pdata);
+ 
+ 	/*
+ 	 * Initialize MTL related features
+ 	 */
+ 	xgbe_config_mtl_mode(pdata);
+ 	xgbe_config_queue_mapping(pdata);
+ 	xgbe_config_tsf_mode(pdata, pdata->tx_sf_mode);
+ 	xgbe_config_rsf_mode(pdata, pdata->rx_sf_mode);
+ 	xgbe_config_tx_threshold(pdata, pdata->tx_threshold);
+ 	xgbe_config_rx_threshold(pdata, pdata->rx_threshold);
+ 	xgbe_config_tx_fifo_size(pdata);
+ 	xgbe_config_rx_fifo_size(pdata);
+ 	xgbe_config_flow_control_threshold(pdata);
+ 	/*TODO: Error Packet and undersized good Packet forwarding enable
+ 		(FEP and FUP)
+ 	 */
+ 	xgbe_config_dcb_tc(pdata);
+ 	xgbe_config_dcb_pfc(pdata);
+ 	xgbe_enable_mtl_interrupts(pdata);
+ 
+ 	/*
+ 	 * Initialize MAC related features
+ 	 */
+ 	xgbe_config_mac_address(pdata);
+ 	xgbe_config_jumbo_enable(pdata);
+ 	xgbe_config_flow_control(pdata);
+ 	xgbe_config_checksum_offload(pdata);
+ 	xgbe_config_vlan_support(pdata);
+ 	xgbe_enable_mac_interrupts(pdata);
+ 
+ 	DBGPR("<--xgbe_init\n");
+ 
+ 	return 0;
+ }
+ 
+ void xgbe_init_function_ptrs_dev(struct xgbe_hw_if *hw_if)
+ {
+ 	DBGPR("-->xgbe_init_function_ptrs\n");
+ 
+ 	hw_if->tx_complete = xgbe_tx_complete;
+ 
+ 	hw_if->set_promiscuous_mode = xgbe_set_promiscuous_mode;
+ 	hw_if->set_all_multicast_mode = xgbe_set_all_multicast_mode;
+ 	hw_if->add_mac_addresses = xgbe_add_mac_addresses;
+ 	hw_if->set_mac_address = xgbe_set_mac_address;
+ 
+ 	hw_if->enable_rx_csum = xgbe_enable_rx_csum;
+ 	hw_if->disable_rx_csum = xgbe_disable_rx_csum;
+ 
+         hw_if->enable_mac_loopback = xgbe_enable_loopback;
+         hw_if->disable_mac_loopback = xgbe_disable_loopback;
+ 
+ 	hw_if->enable_rx_vlan_stripping = xgbe_enable_rx_vlan_stripping;
+ 	hw_if->disable_rx_vlan_stripping = xgbe_disable_rx_vlan_stripping;
+ 	hw_if->enable_rx_vlan_filtering = xgbe_enable_rx_vlan_filtering;
+ 	hw_if->disable_rx_vlan_filtering = xgbe_disable_rx_vlan_filtering;
+ 	hw_if->update_vlan_hash_table = xgbe_update_vlan_hash_table;
+ 
+ 	hw_if->read_mmd_regs = xgbe_read_mmd_regs;
+ 	hw_if->write_mmd_regs = xgbe_write_mmd_regs;
+ 
+ 	hw_if->set_gmii_speed = xgbe_set_gmii_speed;
+ 	hw_if->set_gmii_2500_speed = xgbe_set_gmii_2500_speed;
+ 	hw_if->set_xgmii_speed = xgbe_set_xgmii_speed;
+ 
+ 	hw_if->enable_tx = xgbe_enable_tx;
+ 	hw_if->disable_tx = xgbe_disable_tx;
+ 	hw_if->enable_rx = xgbe_enable_rx;
+ 	hw_if->disable_rx = xgbe_disable_rx;
+ 
+ 	hw_if->powerup_tx = xgbe_powerup_tx;
+ 	hw_if->powerdown_tx = xgbe_powerdown_tx;
+ 	hw_if->powerup_rx = xgbe_powerup_rx;
+ 	hw_if->powerdown_rx = xgbe_powerdown_rx;
+ 
+ 	hw_if->dev_xmit = xgbe_dev_xmit;
+ 	hw_if->dev_read = xgbe_dev_read;
+ 	hw_if->enable_int = xgbe_enable_int;
+ 	hw_if->disable_int = xgbe_disable_int;
+ 	hw_if->init = xgbe_init;
+ 	hw_if->exit = xgbe_exit;
+ 
+ 	/* Descriptor related Sequences have to be initialized here */
+ 	hw_if->tx_desc_init = xgbe_tx_desc_init;
+ 	hw_if->rx_desc_init = xgbe_rx_desc_init;
+ 	hw_if->tx_desc_reset = xgbe_tx_desc_reset;
+ 	hw_if->rx_desc_reset = xgbe_rx_desc_reset;
+ 	hw_if->is_last_desc = xgbe_is_last_desc;
+ 	hw_if->is_context_desc = xgbe_is_context_desc;
+ 	hw_if->tx_start_xmit = xgbe_tx_start_xmit;
+ 
+ 	/* For FLOW ctrl */
+ 	hw_if->config_tx_flow_control = xgbe_config_tx_flow_control;
+ 	hw_if->config_rx_flow_control = xgbe_config_rx_flow_control;
+ 
+ 	/* For RX coalescing */
+ 	hw_if->config_rx_coalesce = xgbe_config_rx_coalesce;
+ 	hw_if->config_tx_coalesce = xgbe_config_tx_coalesce;
+ 	hw_if->usec_to_riwt = xgbe_usec_to_riwt;
+ 	hw_if->riwt_to_usec = xgbe_riwt_to_usec;
+ 
+ 	/* For RX and TX threshold config */
+ 	hw_if->config_rx_threshold = xgbe_config_rx_threshold;
+ 	hw_if->config_tx_threshold = xgbe_config_tx_threshold;
+ 
+ 	/* For RX and TX Store and Forward Mode config */
+ 	hw_if->config_rsf_mode = xgbe_config_rsf_mode;
+ 	hw_if->config_tsf_mode = xgbe_config_tsf_mode;
+ 
+ 	/* For TX DMA Operating on Second Frame config */
+ 	hw_if->config_osp_mode = xgbe_config_osp_mode;
+ 
+ 	/* For RX and TX PBL config */
+ 	hw_if->config_rx_pbl_val = xgbe_config_rx_pbl_val;
+ 	hw_if->get_rx_pbl_val = xgbe_get_rx_pbl_val;
+ 	hw_if->config_tx_pbl_val = xgbe_config_tx_pbl_val;
+ 	hw_if->get_tx_pbl_val = xgbe_get_tx_pbl_val;
+ 	hw_if->config_pblx8 = xgbe_config_pblx8;
+ 
+ 	/* For PTP config */
+ 	hw_if->config_tstamp = xgbe_config_tstamp;
+ 	hw_if->update_tstamp_addend = xgbe_update_tstamp_addend;
+ 	hw_if->set_tstamp_time = xgbe_set_tstamp_time;
+ 	hw_if->get_tstamp_time = xgbe_get_tstamp_time;
+ 	hw_if->get_tx_tstamp = xgbe_get_tx_tstamp;
+ 
+ 	/* For Data Center Bridging config */
+ 	hw_if->config_dcb_tc = xgbe_config_dcb_tc;
+ 	hw_if->config_dcb_pfc = xgbe_config_dcb_pfc;
+ 
+ 	/* For Receive Side Scaling */
+ 	hw_if->enable_rss = xgbe_enable_rss;
+ 	hw_if->disable_rss = xgbe_disable_rss;
+ 	hw_if->set_rss_hash_key = xgbe_set_rss_hash_key;
+ 	hw_if->set_rss_lookup_table = xgbe_set_rss_lookup_table;
+ 
+ 	DBGPR("<--xgbe_init_function_ptrs\n");
+ }
diff -rcNP linux-4.4.24/drivers/net/ethernet/baikal/xgbe/xgbe-drv.c linux-4.4.24-baikal/drivers/net/ethernet/baikal/xgbe/xgbe-drv.c
*** linux-4.4.24/drivers/net/ethernet/baikal/xgbe/xgbe-drv.c	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/drivers/net/ethernet/baikal/xgbe/xgbe-drv.c	2016-11-11 14:49:52.000000000 +0300
***************
*** 0 ****
--- 1,2367 ----
+ /*
+  * Baikal Electronics 10Gb Ethernet driver
+  *
+  * Based on AMD 10Gb Ethernet driver
+  * drivers/net/ethernet/amd/xgbe
+  *
+  * This file is available to you under your choice of the following two
+  * licenses:
+  *
+  * License 1: GPLv2
+  *
+  * Copyright (c) 2015 Baikal Electronics JSC.
+  * Copyright (c) 2014 Advanced Micro Devices, Inc.
+  *
+  * Adopted by:
+  *   Dmitry Dunaev <dmitry.dunaev@baikalelectronics.ru>
+  *
+  * This file is free software; you may copy, redistribute and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation, either version 2 of the License, or (at
+  * your option) any later version.
+  *
+  * This file is distributed in the hope that it will be useful, but
+  * WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+  * General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+  *
+  * This file incorporates work covered by the following copyright and
+  * permission notice:
+  *     The Synopsys DWC ETHER XGMAC Software Driver and documentation
+  *     (hereinafter "Software") is an unsupported proprietary work of Synopsys,
+  *     Inc. unless otherwise expressly agreed to in writing between Synopsys
+  *     and you.
+  *
+  *     The Software IS NOT an item of Licensed Software or Licensed Product
+  *     under any End User Software License Agreement or Agreement for Licensed
+  *     Product with Synopsys or any supplement thereto.  Permission is hereby
+  *     granted, free of charge, to any person obtaining a copy of this software
+  *     annotated with this license and the Software, to deal in the Software
+  *     without restriction, including without limitation the rights to use,
+  *     copy, modify, merge, publish, distribute, sublicense, and/or sell copies
+  *     of the Software, and to permit persons to whom the Software is furnished
+  *     to do so, subject to the following conditions:
+  *
+  *     The above copyright notice and this permission notice shall be included
+  *     in all copies or substantial portions of the Software.
+  *
+  *     THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS"
+  *     BASIS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  *     TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  *     PARTICULAR PURPOSE ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS
+  *     BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  *     CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  *     SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  *     INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  *     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  *     ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  *     THE POSSIBILITY OF SUCH DAMAGE.
+  *
+  *
+  * License 2: Modified BSD
+  *
+  * Copyright (c) 2015 Baikal Electronics JSC.
+  * Copyright (c) 2014 Advanced Micro Devices, Inc.
+  * All rights reserved.
+  *
+  * Redistribution and use in source and binary forms, with or without
+  * modification, are permitted provided that the following conditions are met:
+  *     * Redistributions of source code must retain the above copyright
+  *       notice, this list of conditions and the following disclaimer.
+  *     * Redistributions in binary form must reproduce the above copyright
+  *       notice, this list of conditions and the following disclaimer in the
+  *       documentation and/or other materials provided with the distribution.
+  *     * Neither the name of Advanced Micro Devices, Inc. nor the
+  *       names of its contributors may be used to endorse or promote products
+  *       derived from this software without specific prior written permission.
+  *
+  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+  * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
+  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+  *
+  * This file incorporates work covered by the following copyright and
+  * permission notice:
+  *     The Synopsys DWC ETHER XGMAC Software Driver and documentation
+  *     (hereinafter "Software") is an unsupported proprietary work of Synopsys,
+  *     Inc. unless otherwise expressly agreed to in writing between Synopsys
+  *     and you.
+  *
+  *     The Software IS NOT an item of Licensed Software or Licensed Product
+  *     under any End User Software License Agreement or Agreement for Licensed
+  *     Product with Synopsys or any supplement thereto.  Permission is hereby
+  *     granted, free of charge, to any person obtaining a copy of this software
+  *     annotated with this license and the Software, to deal in the Software
+  *     without restriction, including without limitation the rights to use,
+  *     copy, modify, merge, publish, distribute, sublicense, and/or sell copies
+  *     of the Software, and to permit persons to whom the Software is furnished
+  *     to do so, subject to the following conditions:
+  *
+  *     The above copyright notice and this permission notice shall be included
+  *     in all copies or substantial portions of the Software.
+  *
+  *     THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS"
+  *     BASIS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  *     TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  *     PARTICULAR PURPOSE ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS
+  *     BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  *     CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  *     SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  *     INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  *     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  *     ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ 	 *     THE POSSIBILITY OF SUCH DAMAGE.
+  */
+ 
+ #include <linux/platform_device.h>
+ #include <linux/spinlock.h>
+ #include <linux/tcp.h>
+ #include <linux/if_vlan.h>
+ #include <net/busy_poll.h>
+ #include <linux/clk.h>
+ #include <linux/if_ether.h>
+ #include <linux/net_tstamp.h>
+ #include <linux/phy.h>
+ 
+ #include "xgbe.h"
+ #include "xgbe-common.h"
+ 
+ static int xgbe_one_poll(struct napi_struct *, int);
+ static int xgbe_all_poll(struct napi_struct *, int);
+ static void xgbe_set_rx_mode(struct net_device *);
+ 
+ static int xgbe_alloc_channels(struct xgbe_prv_data *pdata)
+ {
+ 	struct xgbe_channel *channel_mem, *channel;
+ 	struct xgbe_ring *tx_ring, *rx_ring;
+ 	unsigned int count, i;
+ 	int ret = -ENOMEM;
+ 
+ 	count = max_t(unsigned int, pdata->tx_ring_count, pdata->rx_ring_count);
+ 
+ 	channel_mem = kcalloc(count, sizeof(struct xgbe_channel), GFP_KERNEL);
+ 	
+ 	if (!channel_mem)
+ 		goto err_channel;
+ 
+ 	tx_ring = kcalloc(pdata->tx_ring_count, sizeof(struct xgbe_ring),
+ 			  GFP_KERNEL);
+ 	if (!tx_ring)
+ 		goto err_tx_ring;
+ 
+ 	rx_ring = kcalloc(pdata->rx_ring_count, sizeof(struct xgbe_ring),
+ 			  GFP_KERNEL);
+ 	if (!rx_ring)
+ 		goto err_rx_ring;
+ 
+ 	for (i = 0, channel = channel_mem; i < count; i++, channel++) {
+ 		snprintf(channel->name, sizeof(channel->name), "channel-%d", i);
+ 		channel->pdata = pdata;
+ 		channel->queue_index = i;
+ 		channel->dma_regs = pdata->xgmac_regs + DMA_CH_BASE +
+ 				    (DMA_CH_INC * i);
+ 
+ 		if (pdata->per_channel_irq) {
+ 			/* Get the DMA interrupt (offset 1) */
+ 			ret = platform_get_irq(pdata->pdev, i + 1);
+ 			if (ret < 0) {
+ 				netdev_err(pdata->netdev,
+ 					   "platform_get_irq %u failed\n",
+ 					   i + 1);
+ 				goto err_irq;
+ 			}
+ 
+ 			channel->dma_irq = ret;
+ 		}
+ 
+ 		if (i < pdata->tx_ring_count) {
+ 			spin_lock_init(&tx_ring->lock);
+ 			channel->tx_ring = tx_ring++;
+ 		}
+ 
+ 		if (i < pdata->rx_ring_count) {
+ 			spin_lock_init(&rx_ring->lock);
+ 			channel->rx_ring = rx_ring++;
+ 		}
+ 
+ 		netif_dbg(pdata, drv, pdata->netdev,
+ 			  "%s: dma_regs=%p, dma_irq=%d, tx=%p, rx=%p\n",
+ 			  channel->name, channel->dma_regs, channel->dma_irq,
+ 			  channel->tx_ring, channel->rx_ring);
+ 	}
+ 
+ 	pdata->channel = channel_mem;
+ 	pdata->channel_count = count;
+ 
+ 	return 0;
+ 
+ err_irq:
+ 	kfree(rx_ring);
+ 
+ err_rx_ring:
+ 	kfree(tx_ring);
+ 
+ err_tx_ring:
+ 	kfree(channel_mem);
+ 
+ err_channel:
+ 	return ret;
+ }
+ 
+ static void xgbe_free_channels(struct xgbe_prv_data *pdata)
+ {
+ 	if (!pdata->channel)
+ 		return;
+ 
+ 	kfree(pdata->channel->rx_ring);
+ 	kfree(pdata->channel->tx_ring);
+ 	kfree(pdata->channel);
+ 
+ 	pdata->channel = NULL;
+ 	pdata->channel_count = 0;
+ }
+ 
+ static inline unsigned int xgbe_tx_avail_desc(struct xgbe_ring *ring)
+ {
+ 	return (ring->rdesc_count - (ring->cur - ring->dirty));
+ }
+ 
+ static int xgbe_maybe_stop_tx_queue(struct xgbe_channel *channel,
+ 				    struct xgbe_ring *ring, unsigned int count)
+ {
+ 	struct xgbe_prv_data *pdata = channel->pdata;
+ 
+ 	if (count > xgbe_tx_avail_desc(ring)) {
+ 		netif_info(pdata, drv, pdata->netdev,
+ 			   "Tx queue stopped, not enough descriptors available\n");
+ 		netif_stop_subqueue(pdata->netdev, channel->queue_index);
+ 		ring->tx.queue_stopped = 1;
+ 
+ 		/* If we haven't notified the hardware because of xmit_more
+ 		 * support, tell it now
+ 		 */
+ 		if (ring->tx.xmit_more)
+ 			pdata->hw_if.tx_start_xmit(channel, ring);
+ 
+ 		return NETDEV_TX_BUSY;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int xgbe_calc_rx_buf_size(struct net_device *netdev, unsigned int mtu)
+ {
+ 	unsigned int rx_buf_size;
+ 
+ 	if (mtu > XGMAC_JUMBO_PACKET_MTU) {
+ 		netdev_alert(netdev, "MTU exceeds maximum supported value\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	rx_buf_size = mtu + ETH_HLEN + ETH_FCS_LEN + VLAN_HLEN;
+ 	rx_buf_size = clamp_val(rx_buf_size, XGBE_RX_MIN_BUF_SIZE, PAGE_SIZE);
+ 
+ 	rx_buf_size = (rx_buf_size + XGBE_RX_BUF_ALIGN - 1) &
+ 		      ~(XGBE_RX_BUF_ALIGN - 1);
+ 
+ 	return rx_buf_size;
+ }
+ 
+ static void xgbe_enable_rx_tx_ints(struct xgbe_prv_data *pdata)
+ {
+ 	struct xgbe_hw_if *hw_if = &pdata->hw_if;
+ 	struct xgbe_channel *channel;
+ 	enum xgbe_int int_id;
+ 	unsigned int i;
+ 
+ 	channel = pdata->channel;
+ 	for (i = 0; i < pdata->channel_count; i++, channel++) {
+ 		if (channel->tx_ring && channel->rx_ring)
+ 			int_id = XGMAC_INT_DMA_CH_SR_TI_RI;
+ 		else if (channel->tx_ring)
+ 			int_id = XGMAC_INT_DMA_CH_SR_TI;
+ 		else if (channel->rx_ring)
+ 			int_id = XGMAC_INT_DMA_CH_SR_RI;
+ 		else
+ 			continue;
+ 
+ 		hw_if->enable_int(channel, int_id);
+ 	}
+ }
+ 
+ static void xgbe_disable_rx_tx_ints(struct xgbe_prv_data *pdata)
+ {
+ 	struct xgbe_hw_if *hw_if = &pdata->hw_if;
+ 	struct xgbe_channel *channel;
+ 	enum xgbe_int int_id;
+ 	unsigned int i;
+ 
+ 	channel = pdata->channel;
+ 	for (i = 0; i < pdata->channel_count; i++, channel++) {
+ 		if (channel->tx_ring && channel->rx_ring)
+ 			int_id = XGMAC_INT_DMA_CH_SR_TI_RI;
+ 		else if (channel->tx_ring)
+ 			int_id = XGMAC_INT_DMA_CH_SR_TI;
+ 		else if (channel->rx_ring)
+ 			int_id = XGMAC_INT_DMA_CH_SR_RI;
+ 		else
+ 			continue;
+ 
+ 		hw_if->disable_int(channel, int_id);
+ 	}
+ }
+ 
+ static irqreturn_t xgbe_isr(int irq, void *data)
+ {
+ 	struct xgbe_prv_data *pdata = data;
+ 	struct xgbe_hw_if *hw_if = &pdata->hw_if;
+ 	struct xgbe_channel *channel;
+ 	unsigned int dma_isr, dma_ch_isr;
+ 	unsigned int mac_isr, mac_tssr;
+ 	unsigned int i;
+ 
+ 	/* The DMA interrupt status register also reports MAC and MTL
+ 	 * interrupts. So for polling mode, we just need to check for
+ 	 * this register to be non-zero
+ 	 */
+ 	dma_isr = XGMAC_IOREAD(pdata, DMA_ISR);
+ 	if (!dma_isr)
+ 		goto isr_done;
+ 
+ 	netif_dbg(pdata, intr, pdata->netdev, "DMA_ISR=%#010x\n", dma_isr);
+ 
+ 	for (i = 0; i < pdata->channel_count; i++) {
+ 		if (!(dma_isr & (1 << i)))
+ 			continue;
+ 
+ 		channel = pdata->channel + i;
+ 	
+ 		dma_ch_isr = XGMAC_DMA_IOREAD(channel, DMA_CH_SR);
+ 		netif_dbg(pdata, intr, pdata->netdev, "DMA_CH%u_ISR=%#010x\n",
+ 			  i, dma_ch_isr);
+ 
+ 		/* If we get a TI or RI interrupt that means per channel DMA
+ 		 * interrupts are not enabled, so we use the private data napi
+ 		 * structure, not the per channel napi structure
+ 		 */
+ 		if (XGMAC_GET_BITS(dma_ch_isr, DMA_CH_SR, TI) ||
+ 		    XGMAC_GET_BITS(dma_ch_isr, DMA_CH_SR, RI)) {
+ 			if (napi_schedule_prep(&pdata->napi)) {
+ 				/* Disable Tx and Rx interrupts */
+ 				xgbe_disable_rx_tx_ints(pdata);
+ 
+ 				/* Turn on polling */
+ 				__napi_schedule(&pdata->napi);
+ 			}
+ 		}
+ 
+ 		/* Restart the device on a Fatal Bus Error */
+ 		if (XGMAC_GET_BITS(dma_ch_isr, DMA_CH_SR, FBE))
+ 			schedule_work(&pdata->restart_work);
+ 
+ 
+ 		/* Clear all interrupt signals */
+ 		XGMAC_DMA_IOWRITE(channel, DMA_CH_SR, dma_ch_isr);
+ 	}
+ 
+ 	if (XGMAC_GET_BITS(dma_isr, DMA_ISR, MACIS)) {
+ 		mac_isr = XGMAC_IOREAD(pdata, MAC_ISR);
+ 
+ 		if (XGMAC_GET_BITS(mac_isr, MAC_ISR, TSIS)) {
+ 			mac_tssr = XGMAC_IOREAD(pdata, MAC_TSSR);
+ 
+ 			if (XGMAC_GET_BITS(mac_tssr, MAC_TSSR, TXTSC)) {
+ 				/* Read Tx Timestamp to clear interrupt */
+ 				pdata->tx_tstamp =
+ 					hw_if->get_tx_tstamp(pdata);
+ 				schedule_work(&pdata->tx_tstamp_work);
+ 			}
+ 		}
+ 	}
+ 
+ isr_done:
+ 	return IRQ_HANDLED;
+ }
+ 
+ static irqreturn_t xgbe_dma_isr(int irq, void *data)
+ {
+ 	struct xgbe_channel *channel = data;
+ 
+ 	/* Per channel DMA interrupts are enabled, so we use the per
+ 	 * channel napi structure and not the private data napi structure
+ 	 */
+ 	if (napi_schedule_prep(&channel->napi)) {
+ 		/* Disable Tx and Rx interrupts */
+ 		disable_irq_nosync(channel->dma_irq);
+ 
+ 		/* Turn on polling */
+ 		__napi_schedule(&channel->napi);
+ 	}
+ 
+ 	return IRQ_HANDLED;
+ }
+ 
+ static enum hrtimer_restart xgbe_tx_timer(struct hrtimer *timer)
+ {
+ 	struct xgbe_channel *channel = container_of(timer,
+ 						    struct xgbe_channel,
+ 						    tx_timer);
+ 	struct xgbe_ring *ring = channel->tx_ring;
+ 	struct xgbe_prv_data *pdata = channel->pdata;
+ 	struct napi_struct *napi;
+ 	unsigned long flags;
+ 
+ 	DBGPR("-->xgbe_tx_timer\n");
+ 
+ 	napi = (pdata->per_channel_irq) ? &channel->napi : &pdata->napi;
+ 
+ 	spin_lock_irqsave(&ring->lock, flags);
+ 
+ 	if (napi_schedule_prep(napi)) {
+ 		/* Disable Tx and Rx interrupts */
+ 		if (pdata->per_channel_irq)
+ 			disable_irq_nosync(channel->dma_irq);
+ 		else
+ 			xgbe_disable_rx_tx_ints(pdata);
+ 
+ 		/* Turn on polling */
+ 		__napi_schedule(napi);
+ 	}
+ 
+ 	channel->tx_timer_active = 0;
+ 
+ 	spin_unlock_irqrestore(&ring->lock, flags);
+ 
+ 	DBGPR("<--xgbe_tx_timer\n");
+ 
+ 	return HRTIMER_NORESTART;
+ }
+ 
+ static void xgbe_init_tx_timers(struct xgbe_prv_data *pdata)
+ {
+ 	struct xgbe_channel *channel;
+ 	unsigned int i;
+ 
+ 	DBGPR("-->xgbe_init_tx_timers\n");
+ 
+ 	channel = pdata->channel;
+ 	for (i = 0; i < pdata->channel_count; i++, channel++) {
+ 		if (!channel->tx_ring)
+ 			break;
+ 
+ 		DBGPR("  %s adding tx timer\n", channel->name);
+ 		hrtimer_init(&channel->tx_timer, CLOCK_MONOTONIC,
+ 			     HRTIMER_MODE_REL);
+ 		channel->tx_timer.function = xgbe_tx_timer;
+ 	}
+ 
+ 	DBGPR("<--xgbe_init_tx_timers\n");
+ }
+ 
+ static void xgbe_stop_tx_timers(struct xgbe_prv_data *pdata)
+ {
+ 	struct xgbe_channel *channel;
+ 	unsigned int i;
+ 
+ 	DBGPR("-->xgbe_stop_tx_timers\n");
+ 
+ 	channel = pdata->channel;
+ 	for (i = 0; i < pdata->channel_count; i++, channel++) {
+ 		if (!channel->tx_ring)
+ 			break;
+ 
+ 		DBGPR("  %s deleting tx timer\n", channel->name);
+ 		channel->tx_timer_active = 0;
+ 		hrtimer_cancel(&channel->tx_timer);
+ 	}
+ 
+ 	DBGPR("<--xgbe_stop_tx_timers\n");
+ }
+ 
+ void xgbe_get_all_hw_features(struct xgbe_prv_data *pdata)
+ {
+ 	unsigned int mac_hfr0, mac_hfr1, mac_hfr2;
+ 	struct xgbe_hw_features *hw_feat = &pdata->hw_feat;
+ 
+ 	DBGPR("-->xgbe_get_all_hw_features\n");
+ 
+ 	mac_hfr0 = XGMAC_IOREAD(pdata, MAC_HWF0R);
+ 	mac_hfr1 = XGMAC_IOREAD(pdata, MAC_HWF1R);
+ 	mac_hfr2 = XGMAC_IOREAD(pdata, MAC_HWF2R);
+ 
+ 	memset(hw_feat, 0, sizeof(*hw_feat));
+ 
+ 	hw_feat->version = XGMAC_IOREAD(pdata, MAC_VR);
+ 
+ 	/* Hardware feature register 0 */
+ 	hw_feat->gmii        = XGMAC_GET_BITS(mac_hfr0, MAC_HWF0R, GMIISEL);
+ 	hw_feat->vlhash      = XGMAC_GET_BITS(mac_hfr0, MAC_HWF0R, VLHASH);
+ 	hw_feat->sma         = XGMAC_GET_BITS(mac_hfr0, MAC_HWF0R, SMASEL);
+ 	hw_feat->rwk         = XGMAC_GET_BITS(mac_hfr0, MAC_HWF0R, RWKSEL);
+ 	hw_feat->mgk         = XGMAC_GET_BITS(mac_hfr0, MAC_HWF0R, MGKSEL);
+ 	hw_feat->mmc         = XGMAC_GET_BITS(mac_hfr0, MAC_HWF0R, MMCSEL);
+ 	hw_feat->aoe         = XGMAC_GET_BITS(mac_hfr0, MAC_HWF0R, ARPOFFSEL);
+ 	hw_feat->ts          = XGMAC_GET_BITS(mac_hfr0, MAC_HWF0R, TSSEL);
+ 	hw_feat->eee         = XGMAC_GET_BITS(mac_hfr0, MAC_HWF0R, EEESEL);
+ 	hw_feat->tx_coe      = XGMAC_GET_BITS(mac_hfr0, MAC_HWF0R, TXCOESEL);
+ 	hw_feat->rx_coe      = XGMAC_GET_BITS(mac_hfr0, MAC_HWF0R, RXCOESEL);
+ 	hw_feat->addn_mac    = XGMAC_GET_BITS(mac_hfr0, MAC_HWF0R,
+ 					      ADDMACADRSEL);
+ 	hw_feat->ts_src      = XGMAC_GET_BITS(mac_hfr0, MAC_HWF0R, TSSTSSEL);
+ 	hw_feat->sa_vlan_ins = XGMAC_GET_BITS(mac_hfr0, MAC_HWF0R, SAVLANINS);
+ 
+ 	/* Hardware feature register 1 */
+ 	hw_feat->rx_fifo_size  = XGMAC_GET_BITS(mac_hfr1, MAC_HWF1R,
+ 						RXFIFOSIZE);
+ 	hw_feat->tx_fifo_size  = XGMAC_GET_BITS(mac_hfr1, MAC_HWF1R,
+ 						TXFIFOSIZE);
+ 	hw_feat->adv_ts_hi     = XGMAC_GET_BITS(mac_hfr1, MAC_HWF1R, ADVTHWORD);
+ 	hw_feat->dma_width     = XGMAC_GET_BITS(mac_hfr1, MAC_HWF1R, ADDR64);
+ 	hw_feat->dcb           = XGMAC_GET_BITS(mac_hfr1, MAC_HWF1R, DCBEN);
+ 	hw_feat->sph           = XGMAC_GET_BITS(mac_hfr1, MAC_HWF1R, SPHEN);
+ 	hw_feat->tso           = XGMAC_GET_BITS(mac_hfr1, MAC_HWF1R, TSOEN);
+ 	hw_feat->dma_debug     = XGMAC_GET_BITS(mac_hfr1, MAC_HWF1R, DBGMEMA);
+ 	hw_feat->rss           = XGMAC_GET_BITS(mac_hfr1, MAC_HWF1R, RSSEN);
+ 	hw_feat->tc_cnt	       = XGMAC_GET_BITS(mac_hfr1, MAC_HWF1R, NUMTC);
+ 	hw_feat->hash_table_size = XGMAC_GET_BITS(mac_hfr1, MAC_HWF1R,
+ 						  HASHTBLSZ);
+ 	hw_feat->l3l4_filter_num = XGMAC_GET_BITS(mac_hfr1, MAC_HWF1R,
+ 						  L3L4FNUM);
+ 
+ 	/* Hardware feature register 2 */
+ 	hw_feat->rx_q_cnt     = XGMAC_GET_BITS(mac_hfr2, MAC_HWF2R, RXQCNT);
+ 	hw_feat->tx_q_cnt     = XGMAC_GET_BITS(mac_hfr2, MAC_HWF2R, TXQCNT);
+ 	hw_feat->rx_ch_cnt    = XGMAC_GET_BITS(mac_hfr2, MAC_HWF2R, RXCHCNT);
+ 	hw_feat->tx_ch_cnt    = XGMAC_GET_BITS(mac_hfr2, MAC_HWF2R, TXCHCNT);
+ 	hw_feat->pps_out_num  = XGMAC_GET_BITS(mac_hfr2, MAC_HWF2R, PPSOUTNUM);
+ 	hw_feat->aux_snap_num = XGMAC_GET_BITS(mac_hfr2, MAC_HWF2R, AUXSNAPNUM);
+ 
+ 	/* Translate the Hash Table size into actual number */
+ 	switch (hw_feat->hash_table_size) {
+ 	case 0:
+ 		break;
+ 	case 1:
+ 		hw_feat->hash_table_size = 64;
+ 		break;
+ 	case 2:
+ 		hw_feat->hash_table_size = 128;
+ 		break;
+ 	case 3:
+ 		hw_feat->hash_table_size = 256;
+ 		break;
+ 	}
+ 
+ 	/* Translate the address width setting into actual number */
+ 	switch (hw_feat->dma_width) {
+ 	case 0:
+ 		hw_feat->dma_width = 32;
+ 		break;
+ 	case 1:
+ 		hw_feat->dma_width = 40;
+ 		break;
+ 	case 2:
+ 		hw_feat->dma_width = 48;
+ 		break;
+ 	default:
+ 		hw_feat->dma_width = 32;
+ 	}
+ 
+ 	/* The Queue, Channel and TC counts are zero based so increment them
+ 	 * to get the actual number
+ 	 */
+ 	hw_feat->rx_q_cnt++;
+ 	hw_feat->tx_q_cnt++;
+ 	hw_feat->rx_ch_cnt++;
+ 	hw_feat->tx_ch_cnt++;
+ 	hw_feat->tc_cnt++;
+ 
+ 	DBGPR("<--xgbe_get_all_hw_features\n");
+ }
+ 
+ static void xgbe_napi_enable(struct xgbe_prv_data *pdata, unsigned int add)
+ {
+ 	struct xgbe_channel *channel;
+ 	unsigned int i;
+ 
+ 	if (pdata->per_channel_irq) {
+ 		channel = pdata->channel;
+ 		for (i = 0; i < pdata->channel_count; i++, channel++) {
+ 			if (add)
+ 				netif_napi_add(pdata->netdev, &channel->napi,
+ 					       xgbe_one_poll, NAPI_POLL_WEIGHT);
+ 
+ 			napi_enable(&channel->napi);
+ 		}
+ 	} else {
+ 		if (add)
+ 			netif_napi_add(pdata->netdev, &pdata->napi,
+ 				       xgbe_all_poll, NAPI_POLL_WEIGHT);
+ 
+ 		napi_enable(&pdata->napi);
+ 	}
+ }
+ 
+ static void xgbe_napi_disable(struct xgbe_prv_data *pdata, unsigned int del)
+ {
+ 	struct xgbe_channel *channel;
+ 	unsigned int i;
+ 
+ 	if (pdata->per_channel_irq) {
+ 		channel = pdata->channel;
+ 		for (i = 0; i < pdata->channel_count; i++, channel++) {
+ 			napi_disable(&channel->napi);
+ 
+ 			if (del)
+ 				netif_napi_del(&channel->napi);
+ 		}
+ 	} else {
+ 		napi_disable(&pdata->napi);
+ 
+ 		if (del)
+ 			netif_napi_del(&pdata->napi);
+ 	}
+ }
+ 
+ void xgbe_init_tx_coalesce(struct xgbe_prv_data *pdata)
+ {
+ 	struct xgbe_hw_if *hw_if = &pdata->hw_if;
+ 
+ 	DBGPR("-->xgbe_init_tx_coalesce\n");
+ 
+ 	pdata->tx_usecs = XGMAC_INIT_DMA_TX_USECS;
+ 	pdata->tx_frames = XGMAC_INIT_DMA_TX_FRAMES;
+ 
+ 	hw_if->config_tx_coalesce(pdata);
+ 
+ 	DBGPR("<--xgbe_init_tx_coalesce\n");
+ }
+ 
+ void xgbe_init_rx_coalesce(struct xgbe_prv_data *pdata)
+ {
+ 	struct xgbe_hw_if *hw_if = &pdata->hw_if;
+ 
+ 	DBGPR("-->xgbe_init_rx_coalesce\n");
+ 
+ 	pdata->rx_riwt = hw_if->usec_to_riwt(pdata, XGMAC_INIT_DMA_RX_USECS);
+ 	pdata->rx_frames = XGMAC_INIT_DMA_RX_FRAMES;
+ 
+ 	hw_if->config_rx_coalesce(pdata);
+ 
+ 	DBGPR("<--xgbe_init_rx_coalesce\n");
+ }
+ 
+ static void xgbe_free_tx_data(struct xgbe_prv_data *pdata)
+ {
+ 	struct xgbe_desc_if *desc_if = &pdata->desc_if;
+ 	struct xgbe_channel *channel;
+ 	struct xgbe_ring *ring;
+ 	struct xgbe_ring_data *rdata;
+ 	unsigned int i, j;
+ 
+ 	DBGPR("-->xgbe_free_tx_data\n");
+ 
+ 	channel = pdata->channel;
+ 	for (i = 0; i < pdata->channel_count; i++, channel++) {
+ 		ring = channel->tx_ring;
+ 		if (!ring)
+ 			break;
+ 
+ 		for (j = 0; j < ring->rdesc_count; j++) {
+ 			rdata = XGBE_GET_DESC_DATA(ring, j);
+ 			desc_if->unmap_rdata(pdata, rdata);
+ 		}
+ 	}
+ 
+ 	DBGPR("<--xgbe_free_tx_data\n");
+ }
+ 
+ static void xgbe_free_rx_data(struct xgbe_prv_data *pdata)
+ {
+ 	struct xgbe_desc_if *desc_if = &pdata->desc_if;
+ 	struct xgbe_channel *channel;
+ 	struct xgbe_ring *ring;
+ 	struct xgbe_ring_data *rdata;
+ 	unsigned int i, j;
+ 
+ 	DBGPR("-->xgbe_free_rx_data\n");
+ 
+ 	channel = pdata->channel;
+ 	for (i = 0; i < pdata->channel_count; i++, channel++) {
+ 		ring = channel->rx_ring;
+ 		if (!ring)
+ 			break;
+ 
+ 		for (j = 0; j < ring->rdesc_count; j++) {
+ 			rdata = XGBE_GET_DESC_DATA(ring, j);
+ 			desc_if->unmap_rdata(pdata, rdata);
+ 		}
+ 	}
+ 
+ 	DBGPR("<--xgbe_free_rx_data\n");
+ }
+ 
+ static void xgbe_adjust_link(struct net_device *netdev)
+ {
+ 	struct xgbe_prv_data *pdata = netdev_priv(netdev);
+ 	struct xgbe_hw_if *hw_if = &pdata->hw_if;
+ 	struct phy_device *phydev = pdata->phydev;
+ 	int new_state = 0;
+ 
+ 	if (phydev == NULL)
+ 		return;
+ 
+ 	if (phydev->link) {
+ 		/* Flow control support */
+ 		if (pdata->pause_autoneg) {
+ 			if (phydev->pause || phydev->asym_pause) {
+ 				pdata->tx_pause = 1;
+ 				pdata->rx_pause = 1;
+ 			} else {
+ 				pdata->tx_pause = 0;
+ 				pdata->rx_pause = 0;
+ 			}
+ 		}
+ 
+ 		if (pdata->tx_pause != pdata->phy_tx_pause) {
+ 			hw_if->config_tx_flow_control(pdata);
+ 			pdata->phy_tx_pause = pdata->tx_pause;
+ 		}
+ 
+ 		if (pdata->rx_pause != pdata->phy_rx_pause) {
+ 			hw_if->config_rx_flow_control(pdata);
+ 			pdata->phy_rx_pause = pdata->rx_pause;
+ 		}
+ 
+ 		/* Speed support */
+ 		if (phydev->speed != pdata->phy_speed) {
+ 			new_state = 1;
+ 
+ 			switch (phydev->speed) {
+ 			case SPEED_10000:
+ 				hw_if->set_xgmii_speed(pdata);
+ 				break;
+ 
+ 			case SPEED_2500:
+ 				hw_if->set_gmii_2500_speed(pdata);
+ 				break;
+ 
+ 			case SPEED_1000:
+ 				hw_if->set_gmii_speed(pdata);
+ 				break;
+ 			}
+ 			pdata->phy_speed = phydev->speed;
+ 		}
+ 
+ 		if (phydev->link != pdata->phy_link) {
+ 			new_state = 1;
+ 			pdata->phy_link = 1;
+ 		}
+ 	} else if (pdata->phy_link) {
+ 		new_state = 1;
+ 		pdata->phy_link = 0;
+ 		pdata->phy_speed = SPEED_UNKNOWN;
+ 	}
+ 
+ 	if (new_state)
+ 		phy_print_status(phydev);
+ }
+ 
+ static int xgbe_phy_init(struct xgbe_prv_data *pdata)
+ {
+ 	struct net_device *netdev = pdata->netdev;
+ 	struct phy_device *phydev = pdata->phydev;
+ 	int ret;
+ 
+ 	pdata->phy_link = -1;
+ 	pdata->phy_speed = SPEED_UNKNOWN;
+ 	pdata->phy_tx_pause = pdata->tx_pause;
+ 	pdata->phy_rx_pause = pdata->rx_pause;
+ 
+ 	ret = phy_connect_direct(netdev, phydev, &xgbe_adjust_link,
+ 				 pdata->phy_mode);
+ 	if (ret) {
+ 		netdev_err(netdev, "phy_connect_direct failed\n");
+ 		return ret;
+ 	}
+ 
+ 	if (!phydev->drv || (phydev->drv->phy_id == 0)) {
+ 		netdev_err(netdev, "phy_id not valid\n");
+ 		ret = -ENODEV;
+ 		goto err_phy_connect;
+ 	}
+ 	DBGPR("  phy_connect_direct succeeded for PHY %s, link=%d\n",
+ 	      dev_name(&phydev->dev), phydev->link);
+ 
+ 	return 0;
+ 
+ err_phy_connect:
+ 	phy_disconnect(phydev);
+ 
+ 	return ret;
+ }
+ 
+ static void xgbe_phy_exit(struct xgbe_prv_data *pdata)
+ {
+ 	if (!pdata->phydev)
+ 		return;
+ 
+ 	phy_disconnect(pdata->phydev);
+ }
+ 
+ int xgbe_powerdown(struct net_device *netdev, unsigned int caller)
+ {
+ 	struct xgbe_prv_data *pdata = netdev_priv(netdev);
+ 	struct xgbe_hw_if *hw_if = &pdata->hw_if;
+ 	unsigned long flags;
+ 
+ 	DBGPR("-->xgbe_powerdown\n");
+ 
+ 	if (!netif_running(netdev) ||
+ 	    (caller == XGMAC_IOCTL_CONTEXT && pdata->power_down)) {
+ 		netdev_alert(netdev, "Device is already powered down\n");
+ 		DBGPR("<--xgbe_powerdown\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	phy_stop(pdata->phydev);
+ 
+ 	spin_lock_irqsave(&pdata->lock, flags);
+ 
+ 	if (caller == XGMAC_DRIVER_CONTEXT)
+ 		netif_device_detach(netdev);
+ 
+ 	netif_tx_stop_all_queues(netdev);
+ 	xgbe_napi_disable(pdata, 0);
+ 
+ 	/* Powerdown Tx/Rx */
+ 	hw_if->powerdown_tx(pdata);
+ 	hw_if->powerdown_rx(pdata);
+ 
+ 	pdata->power_down = 1;
+ 
+ 	spin_unlock_irqrestore(&pdata->lock, flags);
+ 
+ 	DBGPR("<--xgbe_powerdown\n");
+ 
+ 	return 0;
+ }
+ 
+ int xgbe_powerup(struct net_device *netdev, unsigned int caller)
+ {
+ 	struct xgbe_prv_data *pdata = netdev_priv(netdev);
+ 	struct xgbe_hw_if *hw_if = &pdata->hw_if;
+ 	unsigned long flags;
+ 
+ 	DBGPR("-->xgbe_powerup\n");
+ 
+ 	if (!netif_running(netdev) ||
+ 	    (caller == XGMAC_IOCTL_CONTEXT && !pdata->power_down)) {
+ 		netdev_alert(netdev, "Device is already powered up\n");
+ 		DBGPR("<--xgbe_powerup\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	spin_lock_irqsave(&pdata->lock, flags);
+ 
+ 	pdata->power_down = 0;
+ 
+ 	phy_start(pdata->phydev);
+ 
+ 	/* Enable Tx/Rx */
+ 	hw_if->powerup_tx(pdata);
+ 	hw_if->powerup_rx(pdata);
+ 
+ 	if (caller == XGMAC_DRIVER_CONTEXT)
+ 		netif_device_attach(netdev);
+ 
+ 	xgbe_napi_enable(pdata, 0);
+ 	netif_tx_start_all_queues(netdev);
+ 
+ 	spin_unlock_irqrestore(&pdata->lock, flags);
+ 
+ 	DBGPR("<--xgbe_powerup\n");
+ 
+ 	return 0;
+ }
+ 
+ static int xgbe_start(struct xgbe_prv_data *pdata)
+ {
+ 	struct xgbe_hw_if *hw_if = &pdata->hw_if;
+ 	struct net_device *netdev = pdata->netdev;
+ 
+ 	DBGPR("-->xgbe_start\n");
+ 
+ 	xgbe_set_rx_mode(netdev);
+ 
+ 	hw_if->init(pdata);
+ 
+ 	phy_start(pdata->phydev);
+ 
+ 	hw_if->enable_tx(pdata);
+ 	hw_if->enable_rx(pdata);
+ 
+ 	xgbe_init_tx_timers(pdata);
+ 
+ 	xgbe_napi_enable(pdata, 1);
+ 	netif_tx_start_all_queues(netdev);
+ 
+ 	DBGPR("<--xgbe_start\n");
+ 
+ 	return 0;
+ }
+ 
+ static void xgbe_stop(struct xgbe_prv_data *pdata)
+ {
+ 	struct xgbe_hw_if *hw_if = &pdata->hw_if;
+ 	struct xgbe_channel *channel;
+ 	struct net_device *netdev = pdata->netdev;
+ 	struct netdev_queue *txq;
+ 	unsigned int i;
+ 
+ 	DBGPR("-->xgbe_stop\n");
+ 
+ 	phy_stop(pdata->phydev);
+ 
+ 	netif_tx_stop_all_queues(netdev);
+ 	xgbe_napi_disable(pdata, 1);
+ 
+ 	xgbe_stop_tx_timers(pdata);
+ 
+ 	hw_if->disable_tx(pdata);
+ 	hw_if->disable_rx(pdata);
+ 
+ 	channel = pdata->channel;
+ 	for (i = 0; i < pdata->channel_count; i++, channel++) {
+ 		if (!channel->tx_ring)
+ 			continue;
+ 
+ 		txq = netdev_get_tx_queue(netdev, channel->queue_index);
+ 		netdev_tx_reset_queue(txq);
+ 	}
+ 
+ 	DBGPR("<--xgbe_stop\n");
+ }
+ 
+ static void xgbe_restart_dev(struct xgbe_prv_data *pdata, unsigned int reset)
+ {
+ 	struct xgbe_channel *channel;
+ 	struct xgbe_hw_if *hw_if = &pdata->hw_if;
+ 	unsigned int i;
+ 
+ 	DBGPR("-->xgbe_restart_dev\n");
+ 
+ 	/* If not running, "restart" will happen on open */
+ 	if (!netif_running(pdata->netdev))
+ 		return;
+ 
+ 	xgbe_stop(pdata);
+ 	synchronize_irq(pdata->dev_irq);
+ 	if (pdata->per_channel_irq) {
+ 		channel = pdata->channel;
+ 		for (i = 0; i < pdata->channel_count; i++, channel++)
+ 			synchronize_irq(channel->dma_irq);
+ 	}
+ 
+ 	xgbe_free_tx_data(pdata);
+ 	xgbe_free_rx_data(pdata);
+ 
+ 	/* Issue software reset to device if requested */
+ 	if (reset)
+ 		hw_if->exit(pdata);
+ 
+ 	xgbe_start(pdata);
+ 
+ 	DBGPR("<--xgbe_restart_dev\n");
+ }
+ 
+ static void xgbe_restart(struct work_struct *work)
+ {
+ 	struct xgbe_prv_data *pdata = container_of(work,
+ 						   struct xgbe_prv_data,
+ 						   restart_work);
+ 
+ 	rtnl_lock();
+ 
+ 	xgbe_restart_dev(pdata, 1);
+ 
+ 	rtnl_unlock();
+ }
+ 
+ static void xgbe_tx_tstamp(struct work_struct *work)
+ {
+ 	struct xgbe_prv_data *pdata = container_of(work,
+ 						   struct xgbe_prv_data,
+ 						   tx_tstamp_work);
+ 	struct skb_shared_hwtstamps hwtstamps;
+ 	u64 nsec;
+ 	unsigned long flags;
+ 
+ 	if (pdata->tx_tstamp) {
+ 		nsec = timecounter_cyc2time(&pdata->tstamp_tc,
+ 					    pdata->tx_tstamp);
+ 
+ 		memset(&hwtstamps, 0, sizeof(hwtstamps));
+ 		hwtstamps.hwtstamp = ns_to_ktime(nsec);
+ 		skb_tstamp_tx(pdata->tx_tstamp_skb, &hwtstamps);
+ 	}
+ 
+ 	dev_kfree_skb_any(pdata->tx_tstamp_skb);
+ 
+ 	spin_lock_irqsave(&pdata->tstamp_lock, flags);
+ 	pdata->tx_tstamp_skb = NULL;
+ 	spin_unlock_irqrestore(&pdata->tstamp_lock, flags);
+ }
+ 
+ static int xgbe_get_hwtstamp_settings(struct xgbe_prv_data *pdata,
+ 				      struct ifreq *ifreq)
+ {
+ 	if (copy_to_user(ifreq->ifr_data, &pdata->tstamp_config,
+ 			 sizeof(pdata->tstamp_config)))
+ 		return -EFAULT;
+ 
+ 	return 0;
+ }
+ 
+ static int xgbe_set_hwtstamp_settings(struct xgbe_prv_data *pdata,
+ 				      struct ifreq *ifreq)
+ {
+ 	struct hwtstamp_config config;
+ 	unsigned int mac_tscr;
+ 
+ 	if (copy_from_user(&config, ifreq->ifr_data, sizeof(config)))
+ 		return -EFAULT;
+ 
+ 	if (config.flags)
+ 		return -EINVAL;
+ 
+ 	mac_tscr = 0;
+ 
+ 	switch (config.tx_type) {
+ 	case HWTSTAMP_TX_OFF:
+ 		break;
+ 
+ 	case HWTSTAMP_TX_ON:
+ 		XGMAC_SET_BITS(mac_tscr, MAC_TSCR, TSENA, 1);
+ 		break;
+ 
+ 	default:
+ 		return -ERANGE;
+ 	}
+ 
+ 	switch (config.rx_filter) {
+ 	case HWTSTAMP_FILTER_NONE:
+ 		break;
+ 
+ 	case HWTSTAMP_FILTER_ALL:
+ 		XGMAC_SET_BITS(mac_tscr, MAC_TSCR, TSENALL, 1);
+ 		XGMAC_SET_BITS(mac_tscr, MAC_TSCR, TSENA, 1);
+ 		break;
+ 
+ 	/* PTP v2, UDP, any kind of event packet */
+ 	case HWTSTAMP_FILTER_PTP_V2_L4_EVENT:
+ 		XGMAC_SET_BITS(mac_tscr, MAC_TSCR, TSVER2ENA, 1);
+ 	/* PTP v1, UDP, any kind of event packet */
+ 	case HWTSTAMP_FILTER_PTP_V1_L4_EVENT:
+ 		XGMAC_SET_BITS(mac_tscr, MAC_TSCR, TSIPV4ENA, 1);
+ 		XGMAC_SET_BITS(mac_tscr, MAC_TSCR, TSIPV6ENA, 1);
+ 		XGMAC_SET_BITS(mac_tscr, MAC_TSCR, SNAPTYPSEL, 1);
+ 		XGMAC_SET_BITS(mac_tscr, MAC_TSCR, TSENA, 1);
+ 		break;
+ 
+ 	/* PTP v2, UDP, Sync packet */
+ 	case HWTSTAMP_FILTER_PTP_V2_L4_SYNC:
+ 		XGMAC_SET_BITS(mac_tscr, MAC_TSCR, TSVER2ENA, 1);
+ 	/* PTP v1, UDP, Sync packet */
+ 	case HWTSTAMP_FILTER_PTP_V1_L4_SYNC:
+ 		XGMAC_SET_BITS(mac_tscr, MAC_TSCR, TSIPV4ENA, 1);
+ 		XGMAC_SET_BITS(mac_tscr, MAC_TSCR, TSIPV6ENA, 1);
+ 		XGMAC_SET_BITS(mac_tscr, MAC_TSCR, TSEVNTENA, 1);
+ 		XGMAC_SET_BITS(mac_tscr, MAC_TSCR, TSENA, 1);
+ 		break;
+ 
+ 	/* PTP v2, UDP, Delay_req packet */
+ 	case HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:
+ 		XGMAC_SET_BITS(mac_tscr, MAC_TSCR, TSVER2ENA, 1);
+ 	/* PTP v1, UDP, Delay_req packet */
+ 	case HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:
+ 		XGMAC_SET_BITS(mac_tscr, MAC_TSCR, TSIPV4ENA, 1);
+ 		XGMAC_SET_BITS(mac_tscr, MAC_TSCR, TSIPV6ENA, 1);
+ 		XGMAC_SET_BITS(mac_tscr, MAC_TSCR, TSEVNTENA, 1);
+ 		XGMAC_SET_BITS(mac_tscr, MAC_TSCR, TSMSTRENA, 1);
+ 		XGMAC_SET_BITS(mac_tscr, MAC_TSCR, TSENA, 1);
+ 		break;
+ 
+ 	/* 802.AS1, Ethernet, any kind of event packet */
+ 	case HWTSTAMP_FILTER_PTP_V2_L2_EVENT:
+ 		XGMAC_SET_BITS(mac_tscr, MAC_TSCR, AV8021ASMEN, 1);
+ 		XGMAC_SET_BITS(mac_tscr, MAC_TSCR, SNAPTYPSEL, 1);
+ 		XGMAC_SET_BITS(mac_tscr, MAC_TSCR, TSENA, 1);
+ 		break;
+ 
+ 	/* 802.AS1, Ethernet, Sync packet */
+ 	case HWTSTAMP_FILTER_PTP_V2_L2_SYNC:
+ 		XGMAC_SET_BITS(mac_tscr, MAC_TSCR, AV8021ASMEN, 1);
+ 		XGMAC_SET_BITS(mac_tscr, MAC_TSCR, TSEVNTENA, 1);
+ 		XGMAC_SET_BITS(mac_tscr, MAC_TSCR, TSENA, 1);
+ 		break;
+ 
+ 	/* 802.AS1, Ethernet, Delay_req packet */
+ 	case HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:
+ 		XGMAC_SET_BITS(mac_tscr, MAC_TSCR, AV8021ASMEN, 1);
+ 		XGMAC_SET_BITS(mac_tscr, MAC_TSCR, TSMSTRENA, 1);
+ 		XGMAC_SET_BITS(mac_tscr, MAC_TSCR, TSEVNTENA, 1);
+ 		XGMAC_SET_BITS(mac_tscr, MAC_TSCR, TSENA, 1);
+ 		break;
+ 
+ 	/* PTP v2/802.AS1, any layer, any kind of event packet */
+ 	case HWTSTAMP_FILTER_PTP_V2_EVENT:
+ 		XGMAC_SET_BITS(mac_tscr, MAC_TSCR, TSVER2ENA, 1);
+ 		XGMAC_SET_BITS(mac_tscr, MAC_TSCR, TSIPENA, 1);
+ 		XGMAC_SET_BITS(mac_tscr, MAC_TSCR, TSIPV4ENA, 1);
+ 		XGMAC_SET_BITS(mac_tscr, MAC_TSCR, TSIPV6ENA, 1);
+ 		XGMAC_SET_BITS(mac_tscr, MAC_TSCR, SNAPTYPSEL, 1);
+ 		XGMAC_SET_BITS(mac_tscr, MAC_TSCR, TSENA, 1);
+ 		break;
+ 
+ 	/* PTP v2/802.AS1, any layer, Sync packet */
+ 	case HWTSTAMP_FILTER_PTP_V2_SYNC:
+ 		XGMAC_SET_BITS(mac_tscr, MAC_TSCR, TSVER2ENA, 1);
+ 		XGMAC_SET_BITS(mac_tscr, MAC_TSCR, TSIPENA, 1);
+ 		XGMAC_SET_BITS(mac_tscr, MAC_TSCR, TSIPV4ENA, 1);
+ 		XGMAC_SET_BITS(mac_tscr, MAC_TSCR, TSIPV6ENA, 1);
+ 		XGMAC_SET_BITS(mac_tscr, MAC_TSCR, TSEVNTENA, 1);
+ 		XGMAC_SET_BITS(mac_tscr, MAC_TSCR, TSENA, 1);
+ 		break;
+ 
+ 	/* PTP v2/802.AS1, any layer, Delay_req packet */
+ 	case HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:
+ 		XGMAC_SET_BITS(mac_tscr, MAC_TSCR, TSVER2ENA, 1);
+ 		XGMAC_SET_BITS(mac_tscr, MAC_TSCR, TSIPENA, 1);
+ 		XGMAC_SET_BITS(mac_tscr, MAC_TSCR, TSIPV4ENA, 1);
+ 		XGMAC_SET_BITS(mac_tscr, MAC_TSCR, TSIPV6ENA, 1);
+ 		XGMAC_SET_BITS(mac_tscr, MAC_TSCR, TSMSTRENA, 1);
+ 		XGMAC_SET_BITS(mac_tscr, MAC_TSCR, TSEVNTENA, 1);
+ 		XGMAC_SET_BITS(mac_tscr, MAC_TSCR, TSENA, 1);
+ 		break;
+ 
+ 	default:
+ 		return -ERANGE;
+ 	}
+ 
+ 	pdata->hw_if.config_tstamp(pdata, mac_tscr);
+ 
+ 	memcpy(&pdata->tstamp_config, &config, sizeof(config));
+ 
+ 	return 0;
+ }
+ 
+ static void xgbe_prep_tx_tstamp(struct xgbe_prv_data *pdata,
+ 				struct sk_buff *skb,
+ 				struct xgbe_packet_data *packet)
+ {
+ 	unsigned long flags;
+ 
+ 	if (XGMAC_GET_BITS(packet->attributes, TX_PACKET_ATTRIBUTES, PTP)) {
+ 		spin_lock_irqsave(&pdata->tstamp_lock, flags);
+ 		if (pdata->tx_tstamp_skb) {
+ 			/* Another timestamp in progress, ignore this one */
+ 			XGMAC_SET_BITS(packet->attributes,
+ 				       TX_PACKET_ATTRIBUTES, PTP, 0);
+ 		} else {
+ 			pdata->tx_tstamp_skb = skb_get(skb);
+ 			skb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;
+ 		}
+ 		spin_unlock_irqrestore(&pdata->tstamp_lock, flags);
+ 	}
+ 
+ 	if (!XGMAC_GET_BITS(packet->attributes, TX_PACKET_ATTRIBUTES, PTP))
+ 		skb_tx_timestamp(skb);
+ }
+ 
+ static void xgbe_prep_vlan(struct sk_buff *skb, struct xgbe_packet_data *packet)
+ {
+ 	if (skb_vlan_tag_present(skb))
+ 		packet->vlan_ctag = skb_vlan_tag_get(skb);
+ }
+ 
+ static int xgbe_prep_tso(struct sk_buff *skb, struct xgbe_packet_data *packet)
+ {
+ 	int ret;
+ 
+ 	if (!XGMAC_GET_BITS(packet->attributes, TX_PACKET_ATTRIBUTES,
+ 			    TSO_ENABLE))
+ 		return 0;
+ 
+ 	ret = skb_cow_head(skb, 0);
+ 	if (ret)
+ 		return ret;
+ 
+ 	packet->header_len = skb_transport_offset(skb) + tcp_hdrlen(skb);
+ 	packet->tcp_header_len = tcp_hdrlen(skb);
+ 	packet->tcp_payload_len = skb->len - packet->header_len;
+ 	packet->mss = skb_shinfo(skb)->gso_size;
+ 	DBGPR("  packet->header_len=%u\n", packet->header_len);
+ 	DBGPR("  packet->tcp_header_len=%u, packet->tcp_payload_len=%u\n",
+ 	      packet->tcp_header_len, packet->tcp_payload_len);
+ 	DBGPR("  packet->mss=%u\n", packet->mss);
+ 
+ 	/* Update the number of packets that will ultimately be transmitted
+ 	 * along with the extra bytes for each extra packet
+ 	 */
+ 	packet->tx_packets = skb_shinfo(skb)->gso_segs;
+ 	packet->tx_bytes += (packet->tx_packets - 1) * packet->header_len;
+ 
+ 	return 0;
+ }
+ 
+ static int xgbe_is_tso(struct sk_buff *skb)
+ {
+ 	if (skb->ip_summed != CHECKSUM_PARTIAL)
+ 		return 0;
+ 
+ 	if (!skb_is_gso(skb))
+ 		return 0;
+ 
+ 	DBGPR("  TSO packet to be processed\n");
+ 
+ 	return 1;
+ }
+ 
+ static void xgbe_packet_info(struct xgbe_prv_data *pdata,
+ 			     struct xgbe_ring *ring, struct sk_buff *skb,
+ 			     struct xgbe_packet_data *packet)
+ {
+ 	struct skb_frag_struct *frag;
+ 	unsigned int context_desc;
+ 	unsigned int len;
+ 	unsigned int i;
+ 
+ 	packet->skb = skb;
+ 
+ 	context_desc = 0;
+ 	packet->rdesc_count = 0;
+ 
+ 	packet->tx_packets = 1;
+ 	packet->tx_bytes = skb->len;
+ 
+ 	if (xgbe_is_tso(skb)) {
+ 		/* TSO requires an extra descriptor if mss is different */
+ 		if (skb_shinfo(skb)->gso_size != ring->tx.cur_mss) {
+ 			context_desc = 1;
+ 			packet->rdesc_count++;
+ 		}
+ 
+ 		/* TSO requires an extra descriptor for TSO header */
+ 		packet->rdesc_count++;
+ 
+ 		XGMAC_SET_BITS(packet->attributes, TX_PACKET_ATTRIBUTES,
+ 			       TSO_ENABLE, 1);
+ 		XGMAC_SET_BITS(packet->attributes, TX_PACKET_ATTRIBUTES,
+ 			       CSUM_ENABLE, 1);
+ 	} else if (skb->ip_summed == CHECKSUM_PARTIAL)
+ 		XGMAC_SET_BITS(packet->attributes, TX_PACKET_ATTRIBUTES,
+ 			       CSUM_ENABLE, 1);
+ 
+ 	if (skb_vlan_tag_present(skb)) {
+ 		/* VLAN requires an extra descriptor if tag is different */
+ 		if (skb_vlan_tag_get(skb) != ring->tx.cur_vlan_ctag)
+ 			/* We can share with the TSO context descriptor */
+ 			if (!context_desc) {
+ 				context_desc = 1;
+ 				packet->rdesc_count++;
+ 			}
+ 
+ 		XGMAC_SET_BITS(packet->attributes, TX_PACKET_ATTRIBUTES,
+ 			       VLAN_CTAG, 1);
+ 	}
+ 
+ 	if ((skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP) &&
+ 	    (pdata->tstamp_config.tx_type == HWTSTAMP_TX_ON))
+ 		XGMAC_SET_BITS(packet->attributes, TX_PACKET_ATTRIBUTES,
+ 			       PTP, 1);
+ 
+ 	for (len = skb_headlen(skb); len;) {
+ 		packet->rdesc_count++;
+ 		len -= min_t(unsigned int, len, XGBE_TX_MAX_BUF_SIZE);
+ 	}
+ 
+ 	for (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {
+ 		frag = &skb_shinfo(skb)->frags[i];
+ 		for (len = skb_frag_size(frag); len; ) {
+ 			packet->rdesc_count++;
+ 			len -= min_t(unsigned int, len, XGBE_TX_MAX_BUF_SIZE);
+ 		}
+ 	}
+ }
+ 
+ static int xgbe_open(struct net_device *netdev)
+ {
+ 	struct xgbe_prv_data *pdata = netdev_priv(netdev);
+ 	struct xgbe_hw_if *hw_if = &pdata->hw_if;
+ 	struct xgbe_desc_if *desc_if = &pdata->desc_if;
+ 	struct xgbe_channel *channel = NULL;
+ 	unsigned int i = 0;
+ 	int ret;
+ 	uint32_t reg;
+ 	int poll;
+ 	int st = 0;
+ 
+ DBGPR("-->%s\n", __func__);
+ 
+ 
+ 
+ 
+ 
+ 	/* Enable the clocks */
+ 	ret = clk_prepare_enable(pdata->sysclk);
+ 	if (ret) {
+ 		netdev_alert(netdev, "dma clk_prepare_enable failed\n");
+ 		goto err_phy_init;
+ 	}
+ 
+ 	ret = clk_prepare_enable(pdata->ptpclk);
+ 	if (ret) {
+ 		netdev_alert(netdev, "ptp clk_prepare_enable failed\n");
+ 		goto err_sysclk;
+ 	}
+ 
+ 	/* Initialize the phy */
+ 	ret = xgbe_phy_init(pdata);
+ 	if (ret)
+ 		return ret;
+ 
+ 
+ 	DBGPR("XPCS Initializing... \n\r");
+ 
+ 	/* 4) Read the SR XS or PCS MMD Control1 Register and wait till the 15 th
+ 	bit of this register (RST – Soft Reset) is read as 0. */
+ 	i = 0;
+ 
+ 	do {
+ 		poll = READ_XPCS_REG(DEVICE_PCS, SR_XS_or_PCS_MMD_Control1) & SR_XS_or_PCS_MMD_Control1_RST;
+ 		DBGPR("RST wait poll = %d\n\r", poll);
+ 		if (i++ > MAX_POLLING_TIMES)
+ 			break;
+ 	} while (poll);
+ 
+ 	DBGPR("Clear Soft Reset[15] = %d.\n\r", poll);
+ 
+ 	/*5) Set 12 th bit (AN_EN) to 0 in SR AN MMD Control Register to disable
+ 	Clause 73 auto-negotiation. */
+ //	reg = READ_XPCS_REG(DEVICE_AN, SR_AN_MMD_Control);
+ //	reg &= ~SR_AN_MMD_Control_AN_EN;
+ //	WRITE_XPCS_REG(DEVICE_AN, SR_AN_MMD_Control, reg);
+ 
+ 	/* 6) Program bits [1:0] (PCS_TYPE_SEL) in SR PCS Control2 Register to
+ 	2’b01 to select KX4 mode or to 2’b00 to select KR mode of operation. */
+ 	reg = READ_XPCS_REG(DEVICE_PCS, SR_PCS_Control2);
+ 	reg &= ~SR_PCS_Control2_PCS_TYPE_SEL_MASK;
+ 	reg |= SR_PCS_Control2_PCS_TYPE_SEL_KR;
+ 	WRITE_XPCS_REG(DEVICE_PCS, SR_PCS_Control2, reg);
+ 
+ 	/* If KX4 mode of operation is in use, the following steps have to be done:
+ 	1) Program field LANE_MODE (bits [3:0]) to 4 and field LINK_WIDTH (bits [10:8])
+ 	 to 2 in VR XS,PMA or MII Synopsys Enterprise Gen5 10G PHY General Control Register. */
+ 	reg = READ_XPCS_REG(DEVICE_PMA, VR_XS_PMA_MII_Ent_Gen5_Gen_Ctl);
+ 	reg &= ~VR_XS_PMA_MII_Ent_Gen5_Gen_Ctl_LANE_MODE_MASK & \
+ 	~(VR_XS_PMA_MII_Ent_Gen5_Gen_Ctl_LINK_WIDTH_MASK << VR_XS_PMA_MII_Ent_Gen5_Gen_Ctl_LINK_WIDTH_SHIFT);
+ 	reg |= VR_XS_PMA_MII_Ent_Gen5_Gen_Ctl_LANE_MODE_KX4 | \
+ 	(VR_XS_PMA_MII_Ent_Gen5_Gen_Ctl_LINK_WIDTH_4 << VR_XS_PMA_MII_Ent_Gen5_Gen_Ctl_LINK_WIDTH_SHIFT);
+ //	WRITE_XPCS_REG(DEVICE_PMA, VR_XS_PMA_MII_Ent_Gen5_Gen_Ctl, reg);
+ 
+ 	/* Enable loopback mode. */
+ 	reg = READ_XPCS_REG(DEVICE_PMA, SR_PMA_MMD_Control1);
+ 	reg |= SR_PMA_MMD_Control1_LB;
+ 	DBGPR("SR_PMA_MMD_Control1 = 0x%x.\n\r", reg);
+ //	WRITE_XPCS_REG(DEVICE_PMA, SR_PMA_MMD_Control1, reg);
+ 
+ 	/* 2) Initiate the Vendor specific Software Reset by setting VR_RST bit[15]
+ 	 of VR XS or PCS MMD Digital Control1 Register to 0x1.*/
+ 	reg = READ_XPCS_REG(DEVICE_PCS, VR_XS_or_PCS_MMD_Digital_Ctl1);
+ 	reg |= VR_XS_or_PCS_MMD_Digital_Ctl1_VR_RST;
+ 	WRITE_XPCS_REG(DEVICE_PCS, VR_XS_or_PCS_MMD_Digital_Ctl1, reg);
+ 
+ 	/* 3) Wait for the bit[15] (VR_RST) of the VR XS or PCS MMD Digital Control1
+ 	Register to get cleared.*/
+ 
+ //	read_xpcs_regs_drv();
+ 	i = 0;
+ 	do {
+ 		poll = READ_XPCS_REG(DEVICE_PCS, VR_XS_or_PCS_MMD_Digital_Ctl1) & VR_XS_or_PCS_MMD_Digital_Ctl1_VR_RST;
+ 		if (i++ > MAX_POLLING_TIMES)
+ 			break;
+ 	} while (poll);
+ 
+ 	DBGPR("Clear Bit VR_RST=%d.\n\r", poll);
+ 
+ 	/* In the initialization process host should program all OUI, MMN and RN
+ 	 fields in Control MMD Standard Registers. Appropriate values of this fields
+ 	  are in BE-T-B_T-AS-008-ID document. */
+ 
+ 	reg = SR_Ctl_MMD_REG_1_VAL;
+ 	WRITE_XPCS_REG(DEVICE_Vendor_Specific, SR_Ctl_MMD_PMA_Dev_Id_1, reg);
+ 	WRITE_XPCS_REG(DEVICE_Vendor_Specific, SR_Ctl_MMD_Dev_Id_1, reg);
+ 	WRITE_XPCS_REG(DEVICE_Vendor_Specific, SR_Ctl_MMD_PCS_Dev_Id_1, reg);
+ 	WRITE_XPCS_REG(DEVICE_Vendor_Specific, SR_Ctl_MMD_AN_Dev_Id_1, reg);
+ 	WRITE_XPCS_REG(DEVICE_Vendor_Specific, SR_Ctl_MMD_Package_Id_1, reg);
+ 
+ 	st += (READ_XPCS_REG(DEVICE_Vendor_Specific, SR_Ctl_MMD_PMA_Dev_Id_1) != reg);
+ 	st += (READ_XPCS_REG(DEVICE_Vendor_Specific, SR_Ctl_MMD_Dev_Id_1) != reg);
+ 	st += (READ_XPCS_REG(DEVICE_Vendor_Specific, SR_Ctl_MMD_PCS_Dev_Id_1) != reg);
+ 	st += (READ_XPCS_REG(DEVICE_Vendor_Specific, SR_Ctl_MMD_AN_Dev_Id_1) != reg);
+ 	st += (READ_XPCS_REG(DEVICE_Vendor_Specific, SR_Ctl_MMD_Package_Id_1) != reg);
+ 
+ 	WRITE_XPCS_REG(DEVICE_Vendor_Specific, SR_Ctl_MMD_PMA_Dev_Id_2, SR_Ctl_MMD_PMA_Dev_Id_2_VAL);
+ 	WRITE_XPCS_REG(DEVICE_Vendor_Specific, SR_Ctl_MMD_Dev_Id_2, SR_Ctl_MMD_Dev_Id_2_VAL );
+ 	WRITE_XPCS_REG(DEVICE_Vendor_Specific, SR_Ctl_MMD_PCS_Dev_Id_2,SR_Ctl_MMD_PCS_Dev_Id_2_VAL );
+ 	WRITE_XPCS_REG(DEVICE_Vendor_Specific, SR_Ctl_MMD_AN_Dev_Id_2, SR_Ctl_MMD_AN_Dev_Id_2_VAL );
+ 	WRITE_XPCS_REG(DEVICE_Vendor_Specific, SR_Ctl_MMD_Package_Id_2, SR_Ctl_MMD_Package_Id_2_VAL);
+ 
+ 	st += (READ_XPCS_REG(DEVICE_Vendor_Specific, SR_Ctl_MMD_PMA_Dev_Id_2) != SR_Ctl_MMD_PMA_Dev_Id_2_VAL);
+ 	st += (READ_XPCS_REG(DEVICE_Vendor_Specific, SR_Ctl_MMD_Dev_Id_2) != SR_Ctl_MMD_Dev_Id_2_VAL );
+ 	st += (READ_XPCS_REG(DEVICE_Vendor_Specific, SR_Ctl_MMD_PCS_Dev_Id_2) != SR_Ctl_MMD_PCS_Dev_Id_2_VAL);
+ 	st += (READ_XPCS_REG(DEVICE_Vendor_Specific, SR_Ctl_MMD_AN_Dev_Id_2) != SR_Ctl_MMD_AN_Dev_Id_2_VAL);
+ 	st += (READ_XPCS_REG(DEVICE_Vendor_Specific, SR_Ctl_MMD_Package_Id_2) != SR_Ctl_MMD_Package_Id_2_VAL);
+ 
+ 	/* 4) Wait for RLU bit[2] of SR XS or PCS MMD Status1 Register to be set to 1. */
+ 	i = 0;
+ 	do {
+ 		poll = READ_XPCS_REG(DEVICE_PCS, SR_XS_or_PCS_MMD_Status1) & SR_XS_or_PCS_MMD_Status1_RLU;
+ 		if (i++ > MAX_POLLING_TIMES)
+ 			break;
+ 	} while (!poll);
+ 
+ 	DBGPR("Set Bit RLU = %d.\n\r", poll);
+ 	/* Calculate the Rx buffer size before allocating rings */
+ 	ret = xgbe_calc_rx_buf_size(netdev, netdev->mtu);
+ 	if (ret < 0)
+ 		goto err_ptpclk;
+ 	pdata->rx_buf_size = ret;
+ 
+ 	/* Allocate the channel and ring structures */
+ 	ret = xgbe_alloc_channels(pdata);
+ 	if (ret)
+ 		goto err_ptpclk;
+ 
+ 	/* Allocate the ring descriptors and buffers */
+ 	ret = desc_if->alloc_ring_resources(pdata);
+ 	if (ret)
+ 		goto err_channels;
+ 
+ 	/* Initialize the device restart and Tx timestamp work struct */
+ 	INIT_WORK(&pdata->restart_work, xgbe_restart);
+ 	INIT_WORK(&pdata->tx_tstamp_work, xgbe_tx_tstamp);
+ 
+ 	/* Request interrupts */
+ 	ret = devm_request_irq(pdata->dev, pdata->dev_irq, xgbe_isr, 0,
+ 			       netdev->name, pdata);
+ 	if (ret) {
+ 		netdev_alert(netdev, "error requesting irq %d\n",
+ 			     pdata->dev_irq);
+ 		goto err_rings;
+ 	}
+ 
+ 	if (pdata->per_channel_irq) {
+ 		channel = pdata->channel;
+ 		for (i = 0; i < pdata->channel_count; i++, channel++) {
+ 			snprintf(channel->dma_irq_name,
+ 				 sizeof(channel->dma_irq_name) - 1,
+ 				 "%s-TxRx-%u", netdev_name(netdev),
+ 				 channel->queue_index);
+ 
+ 			ret = devm_request_irq(pdata->dev, channel->dma_irq,
+ 					       xgbe_dma_isr, 0,
+ 					       channel->dma_irq_name, channel);
+ 			if (ret) {
+ 				netdev_alert(netdev,
+ 					     "error requesting irq %d\n",
+ 					     channel->dma_irq);
+ 				goto err_irq;
+ 			}
+ 		}
+ 	}
+ 
+ 	ret = xgbe_start(pdata);
+ 	if (ret)
+ 		goto err_start;
+ 
+ 	DBGPR("<--xgbe_open\n");
+ 
+ 	return 0;
+ 
+ err_start:
+ 	hw_if->exit(pdata);
+ 
+ err_irq:
+ 	if (pdata->per_channel_irq) {
+ 		/* Using an unsigned int, 'i' will go to UINT_MAX and exit */
+ 		for (i--, channel--; i < pdata->channel_count; i--, channel--)
+ 			devm_free_irq(pdata->dev, channel->dma_irq, channel);
+ 	}
+ 
+ 	devm_free_irq(pdata->dev, pdata->dev_irq, pdata);
+ 
+ err_rings:
+ 	desc_if->free_ring_resources(pdata);
+ 
+ err_channels:
+ 	xgbe_free_channels(pdata);
+ 
+ err_ptpclk:
+ 	clk_disable_unprepare(pdata->ptpclk);
+ 
+ err_sysclk:
+ 	clk_disable_unprepare(pdata->sysclk);
+ 
+ err_phy_init:
+ 	xgbe_phy_exit(pdata);
+ 
+ 	return ret;
+ }
+ 
+ static int xgbe_close(struct net_device *netdev)
+ {
+ 	struct xgbe_prv_data *pdata = netdev_priv(netdev);
+ 	struct xgbe_hw_if *hw_if = &pdata->hw_if;
+ 	struct xgbe_desc_if *desc_if = &pdata->desc_if;
+ 	struct xgbe_channel *channel;
+ 	unsigned int i;
+ 
+ 	DBGPR("-->xgbe_close\n");
+ 
+ 	/* Stop the device */
+ 	xgbe_stop(pdata);
+ 
+ 	/* Issue software reset to device */
+ 	hw_if->exit(pdata);
+ 
+ 	/* Free the ring descriptors and buffers */
+ 	desc_if->free_ring_resources(pdata);
+ 
+ 	/* Release the interrupts */
+ 	devm_free_irq(pdata->dev, pdata->dev_irq, pdata);
+ 	if (pdata->per_channel_irq) {
+ 		channel = pdata->channel;
+ 		for (i = 0; i < pdata->channel_count; i++, channel++)
+ 			devm_free_irq(pdata->dev, channel->dma_irq, channel);
+ 	}
+ 
+ 	/* Free the channel and ring structures */
+ 	xgbe_free_channels(pdata);
+ 
+ 	/* Disable the clocks */
+ 	clk_disable_unprepare(pdata->ptpclk);
+ 	clk_disable_unprepare(pdata->sysclk);
+ 
+ 	/* Release the phy */
+ 	xgbe_phy_exit(pdata);
+ 
+ 	DBGPR("<--xgbe_close\n");
+ 
+ 	return 0;
+ }
+ 
+ static int xgbe_xmit(struct sk_buff *skb, struct net_device *netdev)
+ {
+ 	struct xgbe_prv_data *pdata = netdev_priv(netdev);
+ 	struct xgbe_stats *pstats = &pdata->stats;
+ 	struct xgbe_hw_if *hw_if = &pdata->hw_if;
+ 	struct xgbe_desc_if *desc_if = &pdata->desc_if;
+ 	struct xgbe_channel *channel;
+ 	struct xgbe_ring *ring;
+ 	struct xgbe_packet_data *packet;
+ 	struct netdev_queue *txq;
+ 	unsigned long flags;
+ 	int ret;
+ 
+ 	DBGPR("-->xgbe_xmit: skb->len = %d\n", skb->len);
+ 
+ 	channel = pdata->channel + skb->queue_mapping;
+ 	txq = netdev_get_tx_queue(netdev, channel->queue_index);
+ 	ring = channel->tx_ring;
+ 	packet = &ring->packet_data;
+ 
+ 	ret = NETDEV_TX_OK;
+ 
+ 	spin_lock_irqsave(&ring->lock, flags);
+ 
+ 	if (skb->len == 0) {
+ 		netif_err(pdata, tx_err, netdev,
+ 			  "empty skb received from stack\n");
+ 		dev_kfree_skb_any(skb);
+ 		pstats->txdropped += 1;
+ 		goto tx_netdev_return;
+ 	}
+ 
+ 	pstats->txoctetcount += skb->len;
+ 	pstats->txframecount += 1;
+ 
+ 	/* Calculate preliminary packet info */
+ 	memset(packet, 0, sizeof(*packet));
+ 	xgbe_packet_info(pdata, ring, skb, packet);
+ 
+ 	/* Check that there are enough descriptors available */
+ 	ret = xgbe_maybe_stop_tx_queue(channel, ring, packet->rdesc_count);
+ 	if (ret)
+ 		goto tx_netdev_return;
+ 
+ 	ret = xgbe_prep_tso(skb, packet);
+ 	if (ret) {
+ 		netif_err(pdata, tx_err, netdev,
+ 			  "error processing TSO packet\n");
+ 		dev_kfree_skb_any(skb);
+ 		pstats->txerrorcount += 1;
+ 		goto tx_netdev_return;
+ 	}
+ 	xgbe_prep_vlan(skb, packet);
+ 
+ 	if (!desc_if->map_tx_skb(channel, skb)) {
+ 		dev_kfree_skb_any(skb);
+ 		pstats->txerrorcount += 1;
+ 		goto tx_netdev_return;
+ 	}
+ 
+ 	xgbe_prep_tx_tstamp(pdata, skb, packet);
+ 
+ 	/* Report on the actual number of bytes (to be) sent */
+ 	netdev_tx_sent_queue(txq, packet->tx_bytes);
+ 
+ 	/* Configure required descriptor fields for transmission */
+ 	hw_if->dev_xmit(channel);
+ 
+ #ifdef XGMAC_ENABLE_TX_PKT_DUMP
+ 	xgbe_print_pkt(netdev, skb, true);
+ #endif
+ 
+ 	/* Stop the queue in advance if there may not be enough descriptors */
+ 	xgbe_maybe_stop_tx_queue(channel, ring, XGBE_TX_MAX_DESCS);
+ 
+ 	ret = NETDEV_TX_OK;
+ 
+ tx_netdev_return:
+ 	spin_unlock_irqrestore(&ring->lock, flags);
+ 
+ 	DBGPR("<--xgbe_xmit ret=%x  OK=%x\n", ret, NETDEV_TX_OK);
+ 
+ 	return ret;
+ }
+ 
+ static void xgbe_set_rx_mode(struct net_device *netdev)
+ {
+ 	struct xgbe_prv_data *pdata = netdev_priv(netdev);
+ 	struct xgbe_hw_if *hw_if = &pdata->hw_if;
+ 	unsigned int pr_mode, am_mode;
+ 
+ 	DBGPR("-->xgbe_set_rx_mode\n");
+ 
+ 	pr_mode = ((netdev->flags & IFF_PROMISC) != 0);
+ 	am_mode = ((netdev->flags & IFF_ALLMULTI) != 0);
+ 
+ 	hw_if->set_promiscuous_mode(pdata, pr_mode);
+ 	hw_if->set_all_multicast_mode(pdata, am_mode);
+ 
+ 	hw_if->add_mac_addresses(pdata);
+ 
+ 	DBGPR("<--xgbe_set_rx_mode\n");
+ }
+ 
+ static int xgbe_set_mac_address(struct net_device *netdev, void *addr)
+ {
+ 	struct xgbe_prv_data *pdata = netdev_priv(netdev);
+ 	struct xgbe_hw_if *hw_if = &pdata->hw_if;
+ 	struct sockaddr *saddr = addr;
+ 
+ 	DBGPR("-->xgbe_set_mac_address\n");
+ 
+ 	if (!is_valid_ether_addr(saddr->sa_data))
+ 		return -EADDRNOTAVAIL;
+ 
+ 	memcpy(netdev->dev_addr, saddr->sa_data, netdev->addr_len);
+ 
+ 	hw_if->set_mac_address(pdata, netdev->dev_addr);
+ 
+ 	DBGPR("<--xgbe_set_mac_address\n");
+ 
+ 	return 0;
+ }
+ 
+ static int xgbe_ioctl(struct net_device *netdev, struct ifreq *ifreq, int cmd)
+ {
+ 	struct xgbe_prv_data *pdata = netdev_priv(netdev);
+ 	int ret;
+ 
+ 	switch (cmd) {
+ 	case SIOCGHWTSTAMP:
+ 		ret = xgbe_get_hwtstamp_settings(pdata, ifreq);
+ 		break;
+ 
+ 	case SIOCSHWTSTAMP:
+ 		ret = xgbe_set_hwtstamp_settings(pdata, ifreq);
+ 		break;
+ 
+ 	default:
+ 		ret = -EOPNOTSUPP;
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ static int xgbe_change_mtu(struct net_device *netdev, int mtu)
+ {
+ 	struct xgbe_prv_data *pdata = netdev_priv(netdev);
+ 	int ret;
+ 
+ 	DBGPR("-->xgbe_change_mtu\n");
+ 
+ 	ret = xgbe_calc_rx_buf_size(netdev, mtu);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	pdata->rx_buf_size = ret;
+ 	netdev->mtu = mtu;
+ 
+ 	xgbe_restart_dev(pdata, 0);
+ 
+ 	DBGPR("<--xgbe_change_mtu\n");
+ 
+ 	return 0;
+ }
+ 
+ static void xgbe_tx_timeout(struct net_device *netdev)
+ {
+ 	struct xgbe_prv_data *pdata = netdev_priv(netdev);
+ 
+ 	netdev_warn(netdev, "tx timeout, device restarting\n");
+ 	schedule_work(&pdata->restart_work);
+ }
+ 
+ static struct rtnl_link_stats64 *xgbe_get_stats64(struct net_device *netdev,
+ 						  struct rtnl_link_stats64 *s)
+ {
+ 	struct xgbe_prv_data *pdata = netdev_priv(netdev);
+ 	struct xgbe_stats *pstats = &pdata->stats;
+ 
+ 	DBGPR("-->%s\n", __func__);
+ 
+ 	s->rx_packets = pstats->rxframecount;
+ 	s->rx_bytes = pstats->rxoctetcount;
+ 	s->rx_errors = pstats->rxrunerror;
+ 
+ 	s->multicast = pstats->rxmulticastframes;
+ 	s->rx_length_errors = pstats->rxlengtherror;
+ 	s->rx_crc_errors = pstats->rxcrcerror;
+ 	s->rx_fifo_errors = pstats->rxfifooverflow;
+ 
+ 	s->tx_packets = pstats->txframecount;
+ 	s->tx_bytes = pstats->txoctetcount;
+ 	s->tx_errors = pstats->txerrorcount;
+ 
+ 	DBGPR("<--%s\n", __func__);
+ 
+ 	return s;
+ }
+ 
+ static int xgbe_vlan_rx_add_vid(struct net_device *netdev, __be16 proto,
+ 				u16 vid)
+ {
+ 	struct xgbe_prv_data *pdata = netdev_priv(netdev);
+ 	struct xgbe_hw_if *hw_if = &pdata->hw_if;
+ 
+ 	DBGPR("-->%s\n", __func__);
+ 
+ 	set_bit(vid, pdata->active_vlans);
+ 	hw_if->update_vlan_hash_table(pdata);
+ 
+ 	DBGPR("<--%s\n", __func__);
+ 
+ 	return 0;
+ }
+ 
+ static int xgbe_vlan_rx_kill_vid(struct net_device *netdev, __be16 proto,
+ 				 u16 vid)
+ {
+ 	struct xgbe_prv_data *pdata = netdev_priv(netdev);
+ 	struct xgbe_hw_if *hw_if = &pdata->hw_if;
+ 
+ 	DBGPR("-->%s\n", __func__);
+ 
+ 	clear_bit(vid, pdata->active_vlans);
+ 	hw_if->update_vlan_hash_table(pdata);
+ 
+ 	DBGPR("<--%s\n", __func__);
+ 
+ 	return 0;
+ }
+ 
+ #ifdef CONFIG_NET_POLL_CONTROLLER
+ static void xgbe_poll_controller(struct net_device *netdev)
+ {
+ 	struct xgbe_prv_data *pdata = netdev_priv(netdev);
+ 	struct xgbe_channel *channel;
+ 	unsigned int i;
+ 
+ 	DBGPR("-->xgbe_poll_controller\n");
+ 
+ 	if (pdata->per_channel_irq) {
+ 		channel = pdata->channel;
+ 		for (i = 0; i < pdata->channel_count; i++, channel++)
+ 			xgbe_dma_isr(channel->dma_irq, channel);
+ 	} else {
+ 		disable_irq(pdata->dev_irq);
+ 		xgbe_isr(pdata->dev_irq, pdata);
+ 		enable_irq(pdata->dev_irq);
+ 	}
+ 
+ 	DBGPR("<--xgbe_poll_controller\n");
+ }
+ #endif /* End CONFIG_NET_POLL_CONTROLLER */
+ 
+ static int xgbe_setup_tc(struct net_device *netdev, u8 tc)
+ {
+ 	struct xgbe_prv_data *pdata = netdev_priv(netdev);
+ 	unsigned int offset, queue;
+ 	u8 i;
+ 
+ 	if (tc && (tc != pdata->hw_feat.tc_cnt))
+ 		return -EINVAL;
+ 
+ 	if (tc) {
+ 		netdev_set_num_tc(netdev, tc);
+ 		for (i = 0, queue = 0, offset = 0; i < tc; i++) {
+ 			while ((queue < pdata->tx_q_count) &&
+ 			       (pdata->q2tc_map[queue] == i))
+ 				queue++;
+ 
+ 			netif_dbg(pdata, drv, netdev, "TC%u using TXq%u-%u\n",
+ 				  i, offset, queue - 1);
+ 			netdev_set_tc_queue(netdev, i, queue - offset, offset);
+ 			offset = queue;
+ 		}
+ 	} else {
+ 		netdev_reset_tc(netdev);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int xgbe_set_features(struct net_device *netdev,
+ 			     netdev_features_t features)
+ {
+ 	struct xgbe_prv_data *pdata = netdev_priv(netdev);
+ 	struct xgbe_hw_if *hw_if = &pdata->hw_if;
+ 	netdev_features_t rxhash, rxcsum, rxvlan, rxvlan_filter;
+ 	int ret = 0;
+ 
+ 	rxhash = pdata->netdev_features & NETIF_F_RXHASH;
+ 	rxcsum = pdata->netdev_features & NETIF_F_RXCSUM;
+ 	rxvlan = pdata->netdev_features & NETIF_F_HW_VLAN_CTAG_RX;
+ 	rxvlan_filter = pdata->netdev_features & NETIF_F_HW_VLAN_CTAG_FILTER;
+ 
+ 	if ((features & NETIF_F_RXHASH) && !rxhash)
+ 		ret = hw_if->enable_rss(pdata);
+ 	else if (!(features & NETIF_F_RXHASH) && rxhash)
+ 		ret = hw_if->disable_rss(pdata);
+ 	if (ret)
+ 		return ret;
+ 
+ 	if ((features & NETIF_F_RXCSUM) && !rxcsum)
+ 		hw_if->enable_rx_csum(pdata);
+ 	else if (!(features & NETIF_F_RXCSUM) && rxcsum)
+ 		hw_if->disable_rx_csum(pdata);
+ 
+ 	if ((features & NETIF_F_HW_VLAN_CTAG_RX) && !rxvlan)
+ 		hw_if->enable_rx_vlan_stripping(pdata);
+ 	else if (!(features & NETIF_F_HW_VLAN_CTAG_RX) && rxvlan)
+ 		hw_if->disable_rx_vlan_stripping(pdata);
+ 
+ 	if ((features & NETIF_F_HW_VLAN_CTAG_FILTER) && !rxvlan_filter)
+ 		hw_if->enable_rx_vlan_filtering(pdata);
+ 	else if (!(features & NETIF_F_HW_VLAN_CTAG_FILTER) && rxvlan_filter)
+ 		hw_if->disable_rx_vlan_filtering(pdata);
+ 
+ 	pdata->netdev_features = features;
+ 
+ 	DBGPR("<--xgbe_set_features\n");
+ 
+ 	return 0;
+ }
+ 
+ static const struct net_device_ops xgbe_netdev_ops = {
+ 	.ndo_open		= xgbe_open,
+ 	.ndo_stop		= xgbe_close,
+ 	.ndo_start_xmit		= xgbe_xmit,
+ 	.ndo_set_rx_mode	= xgbe_set_rx_mode,
+ 	.ndo_set_mac_address	= xgbe_set_mac_address,
+ 	.ndo_validate_addr	= eth_validate_addr,
+ 	.ndo_do_ioctl		= xgbe_ioctl,
+ 	.ndo_change_mtu		= xgbe_change_mtu,
+ 	.ndo_tx_timeout		= xgbe_tx_timeout,
+ 	.ndo_get_stats64	= xgbe_get_stats64,
+ 	.ndo_vlan_rx_add_vid	= xgbe_vlan_rx_add_vid,
+ 	.ndo_vlan_rx_kill_vid	= xgbe_vlan_rx_kill_vid,
+ #ifdef CONFIG_NET_POLL_CONTROLLER
+ 	.ndo_poll_controller	= xgbe_poll_controller,
+ #endif
+ 	.ndo_setup_tc		= xgbe_setup_tc,
+ 	.ndo_set_features	= xgbe_set_features,
+ };
+ 
+ struct net_device_ops *xgbe_get_netdev_ops(void)
+ {
+ 	return (struct net_device_ops *)&xgbe_netdev_ops;
+ }
+ 
+ static void xgbe_rx_refresh(struct xgbe_channel *channel)
+ {
+ 	struct xgbe_prv_data *pdata = channel->pdata;
+ 	struct xgbe_desc_if *desc_if = &pdata->desc_if;
+ 	struct xgbe_ring *ring = channel->rx_ring;
+ 	struct xgbe_ring_data *rdata;
+ 
+ 	desc_if->realloc_rx_buffer(channel);
+ 
+ 	/* Update the Rx Tail Pointer Register with address of
+ 	 * the last cleaned entry */
+ 	rdata = XGBE_GET_DESC_DATA(ring, ring->rx.realloc_index - 1);
+ 	XGMAC_DMA_IOWRITE(channel, DMA_CH_RDTR_LO,
+ 			  lower_32_bits(rdata->rdesc_dma));
+ }
+ 
+ static struct sk_buff *xgbe_create_skb(struct xgbe_prv_data *pdata,
+ 				       struct xgbe_ring_data *rdata,
+ 				       unsigned int *len)
+ {
+ 	struct net_device *netdev = pdata->netdev;
+ 	struct sk_buff *skb;
+ 	u8 *packet;
+ 	unsigned int copy_len;
+ 
+ 	skb = netdev_alloc_skb_ip_align(netdev, rdata->rx.hdr.dma_len);
+ 	if (!skb)
+ 		return NULL;
+ 
+ 	packet = page_address(rdata->rx.hdr.pa.pages) +
+ 		 rdata->rx.hdr.pa.pages_offset;
+ 	copy_len = (rdata->rx.hdr_len) ? rdata->rx.hdr_len : *len;
+ 	copy_len = min(rdata->rx.hdr.dma_len, copy_len);
+ 	skb_copy_to_linear_data(skb, packet, copy_len);
+ 	skb_put(skb, copy_len);
+ 
+ 	*len -= copy_len;
+ 
+ 	return skb;
+ }
+ 
+ static int xgbe_tx_poll(struct xgbe_channel *channel)
+ {
+ 	struct xgbe_prv_data *pdata = channel->pdata;
+ 	struct xgbe_hw_if *hw_if = &pdata->hw_if;
+ 	struct xgbe_desc_if *desc_if = &pdata->desc_if;
+ 	struct xgbe_ring *ring = channel->tx_ring;
+ 	struct xgbe_ring_data *rdata;
+ 	struct xgbe_ring_desc *rdesc;
+ 	struct net_device *netdev = pdata->netdev;
+ 	struct netdev_queue *txq;
+ 	unsigned long flags;
+ 	int processed = 0;
+ 	unsigned int tx_packets = 0, tx_bytes = 0;
+ 	unsigned int cur;
+ 
+ 	DBGPR("-->xgbe_tx_poll\n");
+ 
+ 	/* Nothing to do if there isn't a Tx ring for this channel */
+ 	if (!ring)
+ 		return 0;
+ 
+ 	cur = ring->cur;
+ 
+ 	/* Be sure we get ring->cur before accessing descriptor data */
+ 	smp_rmb();
+ 
+ 	txq = netdev_get_tx_queue(netdev, channel->queue_index);
+ 
+ 	spin_lock_irqsave(&ring->lock, flags);
+ 
+ 	while ((processed < XGBE_TX_DESC_MAX_PROC) &&
+ 	       (ring->dirty != cur)) {
+ 		rdata = XGBE_GET_DESC_DATA(ring, ring->dirty);
+ 		rdesc = rdata->rdesc;
+ 
+ 		if (!hw_if->tx_complete(rdesc))
+ 			break;
+ 
+ 		/* Make sure descriptor fields are read after reading the OWN
+ 		 * bit */
+ 		dma_rmb();
+ 
+ #ifdef XGMAC_ENABLE_TX_DESC_DUMP
+ 		xgbe_dump_tx_desc(ring, ring->dirty, 1, 0);
+ #endif
+ 
+ 		if (hw_if->is_last_desc(rdesc)) {
+ 			tx_packets += rdata->tx.packets;
+ 			tx_bytes += rdata->tx.bytes;
+ 		}
+ 
+ 		/* Free the SKB and reset the descriptor for re-use */
+ 		desc_if->unmap_rdata(pdata, rdata);
+ 		hw_if->tx_desc_reset(rdata);
+ 
+ 		processed++;
+ 		ring->dirty++;
+ 	}
+ 
+ 	if (!processed)
+ 		goto unlock;
+ 
+ 	netdev_tx_completed_queue(txq, tx_packets, tx_bytes);
+ 
+ 	if ((ring->tx.queue_stopped == 1) &&
+ 	    (xgbe_tx_avail_desc(ring) > XGBE_TX_DESC_MIN_FREE)) {
+ 		ring->tx.queue_stopped = 0;
+ 		netif_tx_wake_queue(txq);
+ 	}
+ 
+ 	DBGPR("<--xgbe_tx_poll: processed=%d\n", processed);
+ 
+ unlock:
+ 	spin_unlock_irqrestore(&ring->lock, flags);
+ 
+ 	return processed;
+ }
+ 
+ static int xgbe_rx_poll(struct xgbe_channel *channel, int budget)
+ {
+ 	struct xgbe_prv_data *pdata = channel->pdata;
+ 	struct xgbe_stats *pstats = &pdata->stats;
+ 	struct xgbe_hw_if *hw_if = &pdata->hw_if;
+ 	struct xgbe_ring *ring = channel->rx_ring;
+ 	struct xgbe_ring_data *rdata;
+ 	struct xgbe_packet_data *packet;
+ 	struct net_device *netdev = pdata->netdev;
+ 	struct napi_struct *napi;
+ 	struct sk_buff *skb;
+ 	struct skb_shared_hwtstamps *hwtstamps;
+ 	unsigned int incomplete, error, context_next, context;
+ 	unsigned int len, put_len, max_len;
+ 	unsigned int received = 0;
+ 	int packet_count = 0;
+ 
+ 	DBGPR("-->xgbe_rx_poll: budget=%d\n", budget);
+ 
+ 	/* Nothing to do if there isn't a Rx ring for this channel */
+ 	if (!ring)
+ 		return 0;
+ 
+ 	napi = (pdata->per_channel_irq) ? &channel->napi : &pdata->napi;
+ 
+ 	rdata = XGBE_GET_DESC_DATA(ring, ring->cur);
+ 	packet = &ring->packet_data;
+ 	while (packet_count < budget) {
+ 		DBGPR("  cur = %d\n", ring->cur);
+ 
+ 		/* First time in loop see if we need to restore state */
+ 		if (!received && rdata->state_saved) {
+ 			incomplete = rdata->state.incomplete;
+ 			context_next = rdata->state.context_next;
+ 			skb = rdata->state.skb;
+ 			error = rdata->state.error;
+ 			len = rdata->state.len;
+ 		} else {
+ 			memset(packet, 0, sizeof(*packet));
+ 			incomplete = 0;
+ 			context_next = 0;
+ 			skb = NULL;
+ 			error = 0;
+ 			len = 0;
+ 		}
+ 
+ read_again:
+ 		rdata = XGBE_GET_DESC_DATA(ring, ring->cur);
+ 
+ 		if (ring->dirty > (XGBE_RX_DESC_CNT >> 3))
+ 			xgbe_rx_refresh(channel);
+ 
+ 		if (hw_if->dev_read(channel))
+ 			break;
+ 
+ 		received++;
+ 		ring->cur++;
+ 		ring->dirty++;
+ 
+ 		incomplete = XGMAC_GET_BITS(packet->attributes,
+ 					    RX_PACKET_ATTRIBUTES,
+ 					    INCOMPLETE);
+ 		context_next = XGMAC_GET_BITS(packet->attributes,
+ 					      RX_PACKET_ATTRIBUTES,
+ 					      CONTEXT_NEXT);
+ 		context = XGMAC_GET_BITS(packet->attributes,
+ 					 RX_PACKET_ATTRIBUTES,
+ 					 CONTEXT);
+ 
+ 		/* Earlier error, just drain the remaining data */
+ 		if ((incomplete || context_next) && error)
+ 			goto read_again;
+ 
+ 		if (error || packet->errors) {
+ 			if (packet->errors)
+ 				netif_err(pdata, rx_err, netdev,
+ 					  "error in received packet\n");
+ 			pstats->rxrunerror++;
+ 			if (skb)
+ 				xgbe_print_pkt(netdev, skb, false);
+ 			else
+ 				pr_err("SKB is null!\n");
+ 			dev_kfree_skb(skb);
+ 			goto next_packet;
+ 		}
+ 
+ 		if (!context) {
+ 			put_len = rdata->rx.len - len;
+ 			len += put_len;
+ 
+ 			if (!skb) {
+ 				dma_sync_single_for_cpu(pdata->dev,
+ 							rdata->rx.hdr.dma,
+ 							rdata->rx.hdr.dma_len,
+ 							DMA_FROM_DEVICE);
+ 
+ 				skb = xgbe_create_skb(pdata, rdata, &put_len);
+ 				if (!skb) {
+ 					error = 1;
+ 					goto skip_data;
+ 				}
+ 			}
+ 
+ 			if (put_len) {
+ 				dma_sync_single_for_cpu(pdata->dev,
+ 							rdata->rx.buf.dma,
+ 							rdata->rx.buf.dma_len,
+ 							DMA_FROM_DEVICE);
+ 
+ 				skb_add_rx_frag(skb, skb_shinfo(skb)->nr_frags,
+ 						rdata->rx.buf.pa.pages,
+ 						rdata->rx.buf.pa.pages_offset,
+ 						put_len, rdata->rx.buf.dma_len);
+ 				rdata->rx.buf.pa.pages = NULL;
+ 
+ 				pstats->rxoctetcount += skb->len;
+ 				pstats->rxframecount++;
+ 			}
+ 		}
+ 
+ skip_data:
+ 		if (incomplete || context_next)
+ 			goto read_again;
+ 
+ 		if (!skb)
+ 			goto next_packet;
+ 
+ 		/* Be sure we don't exceed the configured MTU */
+ 		max_len = netdev->mtu + ETH_HLEN;
+ 		if (!(netdev->features & NETIF_F_HW_VLAN_CTAG_RX) &&
+ 		    (skb->protocol == htons(ETH_P_8021Q)))
+ 			max_len += VLAN_HLEN;
+ 
+ 		if (skb->len > max_len) {
+ 			pr_err("packet length exceeds configured MTU\n");
+ 			dev_kfree_skb(skb);
+ 			pstats->rxrunerror++;
+ 			goto next_packet;
+ 		}
+ 
+ #ifdef XGMAC_ENABLE_RX_PKT_DUMP
+ 		xgbe_print_pkt(netdev, skb, false);
+ #endif
+ 		skb_checksum_none_assert(skb);
+ 		if (XGMAC_GET_BITS(packet->attributes,
+ 				   RX_PACKET_ATTRIBUTES, CSUM_DONE))
+ 			skb->ip_summed = CHECKSUM_UNNECESSARY;
+ 
+ 		if (XGMAC_GET_BITS(packet->attributes,
+ 				   RX_PACKET_ATTRIBUTES, VLAN_CTAG))
+ 			__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q),
+ 					       packet->vlan_ctag);
+ 
+ 		if (XGMAC_GET_BITS(packet->attributes,
+ 				   RX_PACKET_ATTRIBUTES, RX_TSTAMP)) {
+ 			u64 nsec;
+ 
+ 			nsec = timecounter_cyc2time(&pdata->tstamp_tc,
+ 						    packet->rx_tstamp);
+ 			hwtstamps = skb_hwtstamps(skb);
+ 			hwtstamps->hwtstamp = ns_to_ktime(nsec);
+ 		}
+ 
+ 		if (XGMAC_GET_BITS(packet->attributes,
+ 				   RX_PACKET_ATTRIBUTES, RSS_HASH))
+ 			skb_set_hash(skb, packet->rss_hash,
+ 				     packet->rss_hash_type);
+ 
+ 		skb->dev = netdev;
+ 		skb->protocol = eth_type_trans(skb, netdev);
+ 		skb_record_rx_queue(skb, channel->queue_index);
+ 		skb_mark_napi_id(skb, napi);
+ 
+ 		netdev->last_rx = jiffies;
+ 		napi_gro_receive(napi, skb);
+ 
+ next_packet:
+ 		packet_count++;
+ 	}
+ 
+ 	/* Check if we need to save state before leaving */
+ 	if (received && (incomplete || context_next)) {
+ 		rdata = XGBE_GET_DESC_DATA(ring, ring->cur);
+ 		rdata->state_saved = 1;
+ 		rdata->state.incomplete = incomplete;
+ 		rdata->state.context_next = context_next;
+ 		rdata->state.skb = skb;
+ 		rdata->state.len = len;
+ 		rdata->state.error = error;
+ 	}
+ 
+ 	DBGPR("<--xgbe_rx_poll: packet_count = %d\n", packet_count);
+ 
+ 	return packet_count;
+ }
+ 
+ static int xgbe_one_poll(struct napi_struct *napi, int budget)
+ {
+ 	struct xgbe_channel *channel = container_of(napi, struct xgbe_channel,
+ 						    napi);
+ 	int processed = 0;
+ 
+ 	DBGPR("-->xgbe_one_poll: budget=%d\n", budget);
+ 
+ 	/* Cleanup Tx ring first */
+ 	xgbe_tx_poll(channel);
+ 
+ 	/* Process Rx ring next */
+ 	processed = xgbe_rx_poll(channel, budget);
+ 
+ 	/* If we processed everything, we are done */
+ 	if (processed < budget) {
+ 		/* Turn off polling */
+ 		napi_complete(napi);
+ 
+ 		/* Enable Tx and Rx interrupts */
+ 		enable_irq(channel->dma_irq);
+ 	}
+ 
+ 	DBGPR("<--xgbe_one_poll: received = %d\n", processed);
+ 
+ 	return processed;
+ }
+ 
+ static int xgbe_all_poll(struct napi_struct *napi, int budget)
+ {
+ 	struct xgbe_prv_data *pdata = container_of(napi, struct xgbe_prv_data,
+ 						   napi);
+ 	struct xgbe_channel *channel;
+ 	int ring_budget;
+ 	int processed, last_processed;
+ 	unsigned int i;
+ 
+ 	DBGPR("-->xgbe_all_poll: budget=%d\n", budget);
+ 
+ 	processed = 0;
+ 	ring_budget = budget / pdata->rx_ring_count;
+ 	do {
+ 		last_processed = processed;
+ 
+ 		channel = pdata->channel;
+ 		for (i = 0; i < pdata->channel_count; i++, channel++) {
+ 			/* Cleanup Tx ring first */
+ 			xgbe_tx_poll(channel);
+ 
+ 			/* Process Rx ring next */
+ 			if (ring_budget > (budget - processed))
+ 				ring_budget = budget - processed;
+ 			processed += xgbe_rx_poll(channel, ring_budget);
+ 		}
+ 	} while ((processed < budget) && (processed != last_processed));
+ 
+ 	/* If we processed everything, we are done */
+ 	if (processed < budget) {
+ 		/* Turn off polling */
+ 		napi_complete(napi);
+ 
+ 		/* Enable Tx and Rx interrupts */
+ 		xgbe_enable_rx_tx_ints(pdata);
+ 	}
+ 
+ 	DBGPR("<--xgbe_all_poll: received = %d\n", processed);
+ 
+ 	return processed;
+ }
+ 
+ void xgbe_dump_tx_desc(struct xgbe_ring *ring, unsigned int idx,
+ 		       unsigned int count, unsigned int flag)
+ {
+ 	struct xgbe_ring_data *rdata;
+ 	struct xgbe_ring_desc *rdesc;
+ 
+ 	while (count--) {
+ 		rdata = XGBE_GET_DESC_DATA(ring, idx);
+ 		rdesc = rdata->rdesc;
+ 		pr_alert("TX_NORMAL_DESC[%d %s] = %08x:%08x:%08x:%08x\n", idx,
+ 			 (flag == 1) ? "QUEUED FOR TX" : "TX BY DEVICE",
+ 			 le32_to_cpu(rdesc->desc0), le32_to_cpu(rdesc->desc1),
+ 			 le32_to_cpu(rdesc->desc2), le32_to_cpu(rdesc->desc3));
+ 		idx++;
+ 	}
+ }
+ 
+ void xgbe_dump_rx_desc(struct xgbe_ring *ring, struct xgbe_ring_desc *desc,
+ 		       unsigned int idx)
+ {
+ 	pr_alert("RX_NORMAL_DESC[%d RX BY DEVICE] = %08x:%08x:%08x:%08x\n", idx,
+ 		 le32_to_cpu(desc->desc0), le32_to_cpu(desc->desc1),
+ 		 le32_to_cpu(desc->desc2), le32_to_cpu(desc->desc3));
+ }
+ 
+ void xgbe_print_pkt(struct net_device *netdev, struct sk_buff *skb, bool tx_rx)
+ {
+ 	struct ethhdr *eth = (struct ethhdr *)skb->data;
+ 	unsigned char *buf = skb->data;
+ 	unsigned char buffer[128];
+ 	unsigned int i, j;
+ 
+ 	netdev_alert(netdev, "\n************** SKB dump ****************\n");
+ 
+ 	netdev_alert(netdev, "%s packet of %d bytes\n",
+ 		     (tx_rx ? "TX" : "RX"), skb->len);
+ 
+ 	netdev_alert(netdev, "Dst MAC addr: %pM\n", eth->h_dest);
+ 	netdev_alert(netdev, "Src MAC addr: %pM\n", eth->h_source);
+ 	netdev_alert(netdev, "Protocol: 0x%04hx\n", ntohs(eth->h_proto));
+ 
+ 	for (i = 0, j = 0; i < skb->len;) {
+ 		j += snprintf(buffer + j, sizeof(buffer) - j, "%02hhx",
+ 			      buf[i++]);
+ 
+ 		if ((i % 32) == 0) {
+ 			netdev_alert(netdev, "  0x%04x: %s\n", i - 32, buffer);
+ 			j = 0;
+ 		} else if ((i % 16) == 0) {
+ 			buffer[j++] = ' ';
+ 			buffer[j++] = ' ';
+ 		} else if ((i % 4) == 0) {
+ 			buffer[j++] = ' ';
+ 		}
+ 	}
+ 	if (i % 32)
+ 		netdev_alert(netdev, "  0x%04x: %s\n", i - (i % 32), buffer);
+ 
+ 	netdev_alert(netdev, "\n************** SKB dump ****************\n");
+ }
diff -rcNP linux-4.4.24/drivers/net/ethernet/baikal/xgbe/xgbe-ethtool.c linux-4.4.24-baikal/drivers/net/ethernet/baikal/xgbe/xgbe-ethtool.c
*** linux-4.4.24/drivers/net/ethernet/baikal/xgbe/xgbe-ethtool.c	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/drivers/net/ethernet/baikal/xgbe/xgbe-ethtool.c	2016-11-11 14:49:52.000000000 +0300
***************
*** 0 ****
--- 1,611 ----
+ /*
+  * Baikal Electronics 10Gb Ethernet driver
+  *
+  * Based on AMD 10Gb Ethernet driver
+  * drivers/net/ethernet/amd/xgbe
+  *
+  * This file is available to you under your choice of the following two
+  * licenses:
+  *
+  * License 1: GPLv2
+  *
+  * Copyright (c) 2015,2016 Baikal Electronics JSC.
+  * Copyright (c) 2014 Advanced Micro Devices, Inc.
+  *
+  * Adopted by:
+  *   Dmitry Dunaev <dmitry.dunaev@baikalelectronics.ru>
+  *
+  * This file is free software; you may copy, redistribute and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation, either version 2 of the License, or (at
+  * your option) any later version.
+  *
+  * This file is distributed in the hope that it will be useful, but
+  * WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+  * General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+  *
+  * This file incorporates work covered by the following copyright and
+  * permission notice:
+  *     The Synopsys DWC ETHER XGMAC Software Driver and documentation
+  *     (hereinafter "Software") is an unsupported proprietary work of Synopsys,
+  *     Inc. unless otherwise expressly agreed to in writing between Synopsys
+  *     and you.
+  *
+  *     The Software IS NOT an item of Licensed Software or Licensed Product
+  *     under any End User Software License Agreement or Agreement for Licensed
+  *     Product with Synopsys or any supplement thereto.  Permission is hereby
+  *     granted, free of charge, to any person obtaining a copy of this software
+  *     annotated with this license and the Software, to deal in the Software
+  *     without restriction, including without limitation the rights to use,
+  *     copy, modify, merge, publish, distribute, sublicense, and/or sell copies
+  *     of the Software, and to permit persons to whom the Software is furnished
+  *     to do so, subject to the following conditions:
+  *
+  *     The above copyright notice and this permission notice shall be included
+  *     in all copies or substantial portions of the Software.
+  *
+  *     THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS"
+  *     BASIS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  *     TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  *     PARTICULAR PURPOSE ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS
+  *     BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  *     CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  *     SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  *     INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  *     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  *     ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  *     THE POSSIBILITY OF SUCH DAMAGE.
+  *
+  *
+  * License 2: Modified BSD
+  *
+  * Copyright (c) 2015,2016 Baikal Electronics JSC.
+  * Copyright (c) 2014 Advanced Micro Devices, Inc.
+  * All rights reserved.
+  *
+  * Redistribution and use in source and binary forms, with or without
+  * modification, are permitted provided that the following conditions are met:
+  *     * Redistributions of source code must retain the above copyright
+  *       notice, this list of conditions and the following disclaimer.
+  *     * Redistributions in binary form must reproduce the above copyright
+  *       notice, this list of conditions and the following disclaimer in the
+  *       documentation and/or other materials provided with the distribution.
+  *     * Neither the name of Advanced Micro Devices, Inc. nor the
+  *       names of its contributors may be used to endorse or promote products
+  *       derived from this software without specific prior written permission.
+  *
+  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+  * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
+  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+  *
+  * This file incorporates work covered by the following copyright and
+  * permission notice:
+  *     The Synopsys DWC ETHER XGMAC Software Driver and documentation
+  *     (hereinafter "Software") is an unsupported proprietary work of Synopsys,
+  *     Inc. unless otherwise expressly agreed to in writing between Synopsys
+  *     and you.
+  *
+  *     The Software IS NOT an item of Licensed Software or Licensed Product
+  *     under any End User Software License Agreement or Agreement for Licensed
+  *     Product with Synopsys or any supplement thereto.  Permission is hereby
+  *     granted, free of charge, to any person obtaining a copy of this software
+  *     annotated with this license and the Software, to deal in the Software
+  *     without restriction, including without limitation the rights to use,
+  *     copy, modify, merge, publish, distribute, sublicense, and/or sell copies
+  *     of the Software, and to permit persons to whom the Software is furnished
+  *     to do so, subject to the following conditions:
+  *
+  *     The above copyright notice and this permission notice shall be included
+  *     in all copies or substantial portions of the Software.
+  *
+  *     THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS"
+  *     BASIS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  *     TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  *     PARTICULAR PURPOSE ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS
+  *     BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  *     CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  *     SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  *     INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  *     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  *     ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  *     THE POSSIBILITY OF SUCH DAMAGE.
+  */
+ 
+ #include <linux/spinlock.h>
+ #include <linux/phy.h>
+ #include <linux/net_tstamp.h>
+ 
+ #include "xgbe.h"
+ #include "xgbe-common.h"
+ 
+ struct xgbe_eth_stats {
+ 	char stat_string[ETH_GSTRING_LEN];
+ 	int stat_size;
+ 	int stat_offset;
+ };
+ 
+ #define XGMAC_STAT(_string, _var)				\
+ 	{ _string,						\
+ 	  FIELD_SIZEOF(struct xgbe_stats, _var),		\
+ 	  offsetof(struct xgbe_prv_data, stats._var),	\
+ 	}
+ 
+ static const struct xgbe_eth_stats xgbe_gstring_stats[] = {
+ 	XGMAC_STAT("tx_bytes", txoctetcount),
+ 	XGMAC_STAT("tx_packets", txframecount),
+ 	XGMAC_STAT("tx_unicast_packets", txunicastframes),
+ 	XGMAC_STAT("tx_broadcast_packets", txbroadcastframes),
+ 	XGMAC_STAT("tx_multicast_packets", txmulticastframes),
+ 	XGMAC_STAT("tx_vlan_packets", txvlanframes),
+ 	XGMAC_STAT("tx_underflow_errors", txunderflowerror),
+ 	XGMAC_STAT("tx_pause_frames", txpauseframes),
+ 
+ 	XGMAC_STAT("rx_bytes", rxoctetcount),
+ 	XGMAC_STAT("rx_packets", rxframecount),
+ 	XGMAC_STAT("rx_unicast_packets", rxunicastframes),
+ 	XGMAC_STAT("rx_broadcast_packets", rxbroadcastframes),
+ 	XGMAC_STAT("rx_multicast_packets", rxmulticastframes),
+ 	XGMAC_STAT("rx_vlan_packets", rxvlanframes),
+ 	XGMAC_STAT("rx_undersize_packets", rxundersize),
+ 	XGMAC_STAT("rx_oversize_packets", rxoversize),
+ 	XGMAC_STAT("rx_crc_errors", rxcrcerror),
+ 	XGMAC_STAT("rx_crc_errors_small_packets", rxrunterror),
+ 	XGMAC_STAT("rx_crc_errors_giant_packets", rxjabbererror),
+ 	XGMAC_STAT("rx_length_errors", rxlengtherror),
+ 	XGMAC_STAT("rx_out_of_range_errors", rxoutofrangetype),
+ 	XGMAC_STAT("rx_fifo_overflow_errors", rxfifooverflow),
+ 	XGMAC_STAT("rx_watchdog_errors", rxwatchdogerror),
+ 	XGMAC_STAT("rx_pause_frames", rxpauseframes),
+ };
+ 
+ #define XGBE_STATS_COUNT	ARRAY_SIZE(xgbe_gstring_stats)
+ 
+ static void xgbe_get_strings(struct net_device *netdev, u32 stringset, u8 *data)
+ {
+ 	int i;
+ 
+ 	DBGPR("-->%s\n", __func__);
+ 
+ 	switch (stringset) {
+ 	case ETH_SS_STATS:
+ 		for (i = 0; i < XGBE_STATS_COUNT; i++) {
+ 			memcpy(data, xgbe_gstring_stats[i].stat_string,
+ 			       ETH_GSTRING_LEN);
+ 			data += ETH_GSTRING_LEN;
+ 		}
+ 		break;
+ 	}
+ 
+ 	DBGPR("<--%s\n", __func__);
+ }
+ 
+ static void xgbe_get_ethtool_stats(struct net_device *netdev,
+ 				   struct ethtool_stats *stats, u64 *data)
+ {
+ 	struct xgbe_prv_data *pdata = netdev_priv(netdev);
+ 	u8 *stat;
+ 	int i;
+ 
+ 	DBGPR("-->%s\n", __func__);
+ 
+ 	for (i = 0; i < XGBE_STATS_COUNT; i++) {
+ 		stat = (u8 *)pdata + xgbe_gstring_stats[i].stat_offset;
+ 		*data++ = *(u64 *)stat;
+ 	}
+ 
+ 	DBGPR("<--%s\n", __func__);
+ }
+ 
+ static int xgbe_get_sset_count(struct net_device *netdev, int stringset)
+ {
+ 	int ret;
+ 
+ 	DBGPR("-->%s\n", __func__);
+ 
+ 	switch (stringset) {
+ 	case ETH_SS_STATS:
+ 		ret = XGBE_STATS_COUNT;
+ 		break;
+ 
+ 	default:
+ 		ret = -EOPNOTSUPP;
+ 	}
+ 
+ 	DBGPR("<--%s\n", __func__);
+ 
+ 	return ret;
+ }
+ 
+ static void xgbe_get_pauseparam(struct net_device *netdev,
+ 				struct ethtool_pauseparam *pause)
+ {
+ 	struct xgbe_prv_data *pdata = netdev_priv(netdev);
+ 
+ 	DBGPR("-->xgbe_get_pauseparam\n");
+ 
+ 	pause->autoneg = pdata->pause_autoneg;
+ 	pause->tx_pause = pdata->tx_pause;
+ 	pause->rx_pause = pdata->rx_pause;
+ 
+ 	DBGPR("<--xgbe_get_pauseparam\n");
+ }
+ 
+ static int xgbe_set_pauseparam(struct net_device *netdev,
+ 			       struct ethtool_pauseparam *pause)
+ {
+ 	struct xgbe_prv_data *pdata = netdev_priv(netdev);
+ 	struct phy_device *phydev = pdata->phydev;
+ 	int ret = 0;
+ 
+ 	DBGPR("-->xgbe_set_pauseparam\n");
+ 
+ 	DBGPR("  autoneg = %d, tx_pause = %d, rx_pause = %d\n",
+ 	      pause->autoneg, pause->tx_pause, pause->rx_pause);
+ 
+ 	pdata->pause_autoneg = pause->autoneg;
+ 	if (pause->autoneg) {
+ 		phydev->advertising |= ADVERTISED_Pause;
+ 		phydev->advertising |= ADVERTISED_Asym_Pause;
+ 
+ 	} else {
+ 		phydev->advertising &= ~ADVERTISED_Pause;
+ 		phydev->advertising &= ~ADVERTISED_Asym_Pause;
+ 
+ 		pdata->tx_pause = pause->tx_pause;
+ 		pdata->rx_pause = pause->rx_pause;
+ 	}
+ 
+ 	if (netif_running(netdev))
+ 		ret = phy_start_aneg(phydev);
+ 
+ 	DBGPR("<--xgbe_set_pauseparam\n");
+ 
+ 	return ret;
+ }
+ 
+ static int xgbe_get_settings(struct net_device *netdev,
+ 			     struct ethtool_cmd *cmd)
+ {
+ 	struct xgbe_prv_data *pdata = netdev_priv(netdev);
+ 	int ret;
+ 
+ 	DBGPR("-->xgbe_get_settings\n");
+ 
+ 	if (!pdata->phydev)
+ 		return -ENODEV;
+ 
+ 	ret = phy_ethtool_gset(pdata->phydev, cmd);
+ 	cmd->transceiver = XCVR_EXTERNAL;
+ 
+ 	DBGPR("<--xgbe_get_settings\n");
+ 
+ 	return ret;
+ }
+ 
+ static int xgbe_set_settings(struct net_device *netdev,
+ 			     struct ethtool_cmd *cmd)
+ {
+ 	struct xgbe_prv_data *pdata = netdev_priv(netdev);
+ 	struct phy_device *phydev = pdata->phydev;
+ 	u32 speed;
+ 	int ret;
+ 
+ 	DBGPR("-->xgbe_set_settings\n");
+ 
+ 	if (!pdata->phydev)
+ 		return -ENODEV;
+ 
+ 	speed = ethtool_cmd_speed(cmd);
+ 
+ 	if (cmd->phy_address != phydev->addr)
+ 		return -EINVAL;
+ 
+ 	if ((cmd->autoneg != AUTONEG_ENABLE) &&
+ 	    (cmd->autoneg != AUTONEG_DISABLE))
+ 		return -EINVAL;
+ 
+ 	if (cmd->autoneg == AUTONEG_DISABLE) {
+ 		switch (speed) {
+ 		case SPEED_10000:
+ 		case SPEED_2500:
+ 		case SPEED_1000:
+ 			break;
+ 		default:
+ 			return -EINVAL;
+ 		}
+ 
+ 		if (cmd->duplex != DUPLEX_FULL)
+ 			return -EINVAL;
+ 	}
+ 
+ 	cmd->advertising &= phydev->supported;
+ 	if ((cmd->autoneg == AUTONEG_ENABLE) && !cmd->advertising)
+ 		return -EINVAL;
+ 
+ 	ret = 0;
+ 	phydev->autoneg = cmd->autoneg;
+ 	phydev->speed = speed;
+ 	phydev->duplex = cmd->duplex;
+ 	phydev->advertising = cmd->advertising;
+ 
+ 	if (cmd->autoneg == AUTONEG_ENABLE)
+ 		phydev->advertising |= ADVERTISED_Autoneg;
+ 	else
+ 		phydev->advertising &= ~ADVERTISED_Autoneg;
+ 
+ 	if (netif_running(netdev))
+ 		ret = phy_start_aneg(phydev);
+ 
+ 	DBGPR("<--xgbe_set_settings\n");
+ 
+ 	return ret;
+ }
+ 
+ static void xgbe_get_drvinfo(struct net_device *netdev,
+ 			     struct ethtool_drvinfo *drvinfo)
+ {
+ 	struct xgbe_prv_data *pdata = netdev_priv(netdev);
+ 	struct xgbe_hw_features *hw_feat = &pdata->hw_feat;
+ 
+ 	strlcpy(drvinfo->driver, XGBE_DRV_NAME, sizeof(drvinfo->driver));
+ 	strlcpy(drvinfo->version, XGBE_DRV_VERSION, sizeof(drvinfo->version));
+ 	strlcpy(drvinfo->bus_info, dev_name(pdata->dev),
+ 		sizeof(drvinfo->bus_info));
+ 	snprintf(drvinfo->fw_version, sizeof(drvinfo->fw_version), "%d.%d.%d",
+ 		 XGMAC_GET_BITS(hw_feat->version, MAC_VR, USERVER),
+ 		 XGMAC_GET_BITS(hw_feat->version, MAC_VR, DEVID),
+ 		 XGMAC_GET_BITS(hw_feat->version, MAC_VR, SNPSVER));
+ 	drvinfo->n_stats = XGBE_STATS_COUNT;
+ }
+ 
+ static int xgbe_get_coalesce(struct net_device *netdev,
+ 			     struct ethtool_coalesce *ec)
+ {
+ 	struct xgbe_prv_data *pdata = netdev_priv(netdev);
+ 	struct xgbe_hw_if *hw_if = &pdata->hw_if;
+ 	unsigned int riwt;
+ 
+ 	DBGPR("-->xgbe_get_coalesce\n");
+ 
+ 	memset(ec, 0, sizeof(struct ethtool_coalesce));
+ 
+ 	riwt = pdata->rx_riwt;
+ 	ec->rx_coalesce_usecs = hw_if->riwt_to_usec(pdata, riwt);
+ 	ec->rx_max_coalesced_frames = pdata->rx_frames;
+ 
+ 	ec->tx_coalesce_usecs = pdata->tx_usecs;
+ 	ec->tx_max_coalesced_frames = pdata->tx_frames;
+ 
+ 	DBGPR("<--xgbe_get_coalesce\n");
+ 
+ 	return 0;
+ }
+ 
+ static int xgbe_set_coalesce(struct net_device *netdev,
+ 			     struct ethtool_coalesce *ec)
+ {
+ 	struct xgbe_prv_data *pdata = netdev_priv(netdev);
+ 	struct xgbe_hw_if *hw_if = &pdata->hw_if;
+ 	unsigned int rx_frames, rx_riwt, rx_usecs;
+ 	unsigned int tx_frames, tx_usecs;
+ 
+ 	DBGPR("-->xgbe_set_coalesce\n");
+ 
+ 	/* Check for not supported parameters  */
+ 	if ((ec->rx_coalesce_usecs_irq) ||
+ 	    (ec->rx_max_coalesced_frames_irq) ||
+ 	    (ec->tx_coalesce_usecs_irq) ||
+ 	    (ec->tx_max_coalesced_frames_irq) ||
+ 	    (ec->stats_block_coalesce_usecs) ||
+ 	    (ec->use_adaptive_rx_coalesce) ||
+ 	    (ec->use_adaptive_tx_coalesce) ||
+ 	    (ec->pkt_rate_low) ||
+ 	    (ec->rx_coalesce_usecs_low) ||
+ 	    (ec->rx_max_coalesced_frames_low) ||
+ 	    (ec->tx_coalesce_usecs_low) ||
+ 	    (ec->tx_max_coalesced_frames_low) ||
+ 	    (ec->pkt_rate_high) ||
+ 	    (ec->rx_coalesce_usecs_high) ||
+ 	    (ec->rx_max_coalesced_frames_high) ||
+ 	    (ec->tx_coalesce_usecs_high) ||
+ 	    (ec->tx_max_coalesced_frames_high) ||
+ 	    (ec->rate_sample_interval))
+ 		return -EOPNOTSUPP;
+ 
+ 	/* Can only change rx-frames when interface is down (see
+ 	 * rx_descriptor_init in xgbe-dev.c)
+ 	 */
+ 	rx_frames = pdata->rx_frames;
+ 	if (rx_frames != ec->rx_max_coalesced_frames && netif_running(netdev)) {
+ 		netdev_alert(netdev,
+ 			     "interface must be down to change rx-frames\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	rx_riwt = hw_if->usec_to_riwt(pdata, ec->rx_coalesce_usecs);
+ 	rx_frames = ec->rx_max_coalesced_frames;
+ 
+ 	/* Use smallest possible value if conversion resulted in zero */
+ 	if (ec->rx_coalesce_usecs && !rx_riwt)
+ 		rx_riwt = 1;
+ 
+ 	/* Check the bounds of values for Rx */
+ 	if (rx_riwt > XGMAC_MAX_DMA_RIWT) {
+ 		rx_usecs = hw_if->riwt_to_usec(pdata, XGMAC_MAX_DMA_RIWT);
+ 		netdev_alert(netdev, "rx-usec is limited to %d usecs\n",
+ 			     rx_usecs);
+ 		return -EINVAL;
+ 	}
+ 	if (rx_frames > pdata->rx_desc_count) {
+ 		netdev_alert(netdev, "rx-frames is limited to %d frames\n",
+ 			     pdata->rx_desc_count);
+ 		return -EINVAL;
+ 	}
+ 
+ 	tx_usecs = ec->tx_coalesce_usecs;
+ 	tx_frames = ec->tx_max_coalesced_frames;
+ 
+ 	/* Check the bounds of values for Tx */
+ 	if (tx_frames > pdata->tx_desc_count) {
+ 		netdev_alert(netdev, "tx-frames is limited to %d frames\n",
+ 			     pdata->tx_desc_count);
+ 		return -EINVAL;
+ 	}
+ 
+ 	pdata->rx_riwt = rx_riwt;
+ 	pdata->rx_frames = rx_frames;
+ 	hw_if->config_rx_coalesce(pdata);
+ 
+ 	pdata->tx_usecs = tx_usecs;
+ 	pdata->tx_frames = tx_frames;
+ 	hw_if->config_tx_coalesce(pdata);
+ 
+ 	DBGPR("<--xgbe_set_coalesce\n");
+ 
+ 	return 0;
+ }
+ 
+ static int xgbe_get_rxnfc(struct net_device *netdev,
+ 			  struct ethtool_rxnfc *rxnfc, u32 *rule_locs)
+ {
+ 	struct xgbe_prv_data *pdata = netdev_priv(netdev);
+ 
+ 	switch (rxnfc->cmd) {
+ 	case ETHTOOL_GRXRINGS:
+ 		rxnfc->data = pdata->rx_ring_count;
+ 		break;
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static u32 xgbe_get_rxfh_key_size(struct net_device *netdev)
+ {
+ 	struct xgbe_prv_data *pdata = netdev_priv(netdev);
+ 
+ 	return sizeof(pdata->rss_key);
+ }
+ 
+ static u32 xgbe_get_rxfh_indir_size(struct net_device *netdev)
+ {
+ 	struct xgbe_prv_data *pdata = netdev_priv(netdev);
+ 
+ 	return ARRAY_SIZE(pdata->rss_table);
+ }
+ 
+ static int xgbe_get_rxfh(struct net_device *netdev, u32 *indir, u8 *key,
+ 			 u8 *hfunc)
+ {
+ 	struct xgbe_prv_data *pdata = netdev_priv(netdev);
+ 	unsigned int i;
+ 
+ 	if (indir) {
+ 		for (i = 0; i < ARRAY_SIZE(pdata->rss_table); i++)
+ 			indir[i] = XGMAC_GET_BITS(pdata->rss_table[i],
+ 						  MAC_RSSDR, DMCH);
+ 	}
+ 
+ 	if (key)
+ 		memcpy(key, pdata->rss_key, sizeof(pdata->rss_key));
+ 
+ 	if (hfunc)
+ 		*hfunc = ETH_RSS_HASH_TOP;
+ 
+ 	return 0;
+ }
+ 
+ static int xgbe_set_rxfh(struct net_device *netdev, const u32 *indir,
+ 			 const u8 *key, const u8 hfunc)
+ {
+ 	struct xgbe_prv_data *pdata = netdev_priv(netdev);
+ 	struct xgbe_hw_if *hw_if = &pdata->hw_if;
+ 	unsigned int ret;
+ 
+ 	if (hfunc != ETH_RSS_HASH_NO_CHANGE && hfunc != ETH_RSS_HASH_TOP)
+ 		return -EOPNOTSUPP;
+ 
+ 	if (indir) {
+ 		ret = hw_if->set_rss_lookup_table(pdata, indir);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	if (key) {
+ 		ret = hw_if->set_rss_hash_key(pdata, key);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int xgbe_get_ts_info(struct net_device *netdev,
+ 			    struct ethtool_ts_info *ts_info)
+ {
+ 	struct xgbe_prv_data *pdata = netdev_priv(netdev);
+ 
+ 	ts_info->so_timestamping = SOF_TIMESTAMPING_TX_SOFTWARE |
+ 				   SOF_TIMESTAMPING_RX_SOFTWARE |
+ 				   SOF_TIMESTAMPING_SOFTWARE |
+ 				   SOF_TIMESTAMPING_TX_HARDWARE |
+ 				   SOF_TIMESTAMPING_RX_HARDWARE |
+ 				   SOF_TIMESTAMPING_RAW_HARDWARE;
+ 
+ 	if (pdata->ptp_clock)
+ 		ts_info->phc_index = ptp_clock_index(pdata->ptp_clock);
+ 	else
+ 		ts_info->phc_index = -1;
+ 
+ 	ts_info->tx_types = (1 << HWTSTAMP_TX_OFF) | (1 << HWTSTAMP_TX_ON);
+ 	ts_info->rx_filters = (1 << HWTSTAMP_FILTER_NONE) |
+ 			      (1 << HWTSTAMP_FILTER_PTP_V1_L4_EVENT) |
+ 			      (1 << HWTSTAMP_FILTER_PTP_V1_L4_SYNC) |
+ 			      (1 << HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ) |
+ 			      (1 << HWTSTAMP_FILTER_PTP_V2_L4_EVENT) |
+ 			      (1 << HWTSTAMP_FILTER_PTP_V2_L4_SYNC) |
+ 			      (1 << HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ) |
+ 			      (1 << HWTSTAMP_FILTER_PTP_V2_EVENT) |
+ 			      (1 << HWTSTAMP_FILTER_PTP_V2_SYNC) |
+ 			      (1 << HWTSTAMP_FILTER_PTP_V2_DELAY_REQ) |
+ 			      (1 << HWTSTAMP_FILTER_ALL);
+ 
+ 	return 0;
+ }
+ 
+ static const struct ethtool_ops xgbe_ethtool_ops = {
+ 	.get_settings = xgbe_get_settings,
+ 	.set_settings = xgbe_set_settings,
+ 	.get_drvinfo = xgbe_get_drvinfo,
+ 	.get_link = ethtool_op_get_link,
+ 	.get_coalesce = xgbe_get_coalesce,
+ 	.set_coalesce = xgbe_set_coalesce,
+ 	.get_pauseparam = xgbe_get_pauseparam,
+ 	.set_pauseparam = xgbe_set_pauseparam,
+ 	.get_strings = xgbe_get_strings,
+ 	.get_ethtool_stats = xgbe_get_ethtool_stats,
+ 	.get_sset_count = xgbe_get_sset_count,
+ 	.get_rxnfc = xgbe_get_rxnfc,
+ 	.get_rxfh_key_size = xgbe_get_rxfh_key_size,
+ 	.get_rxfh_indir_size = xgbe_get_rxfh_indir_size,
+ 	.get_rxfh = xgbe_get_rxfh,
+ 	.set_rxfh = xgbe_set_rxfh,
+ 	.get_ts_info = xgbe_get_ts_info,
+ };
+ 
+ struct ethtool_ops *xgbe_get_ethtool_ops(void)
+ {
+ 	return (struct ethtool_ops *)&xgbe_ethtool_ops;
+ }
diff -rcNP linux-4.4.24/drivers/net/ethernet/baikal/xgbe/xgbe.h linux-4.4.24-baikal/drivers/net/ethernet/baikal/xgbe/xgbe.h
*** linux-4.4.24/drivers/net/ethernet/baikal/xgbe/xgbe.h	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/drivers/net/ethernet/baikal/xgbe/xgbe.h	2016-11-11 14:49:52.000000000 +0300
***************
*** 0 ****
--- 1,853 ----
+ /*
+  * Baikal Electronics 10Gb Ethernet driver
+  *
+  * Based on AMD 10Gb Ethernet driver
+  * drivers/net/ethernet/amd/xgbe
+  *
+  * This file is available to you under your choice of the following two
+  * licenses:
+  *
+  * License 1: GPLv2
+  *
+  * Copyright (c) 2015,2016 Baikal Electronics JSC.
+  * Copyright (c) 2014 Advanced Micro Devices, Inc.
+  *
+  * Adopted by:
+  *   Dmitry Dunaev <dmitry.dunaev@baikalelectronics.ru>
+  *
+  * This file is free software; you may copy, redistribute and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation, either version 2 of the License, or (at
+  * your option) any later version.
+  *
+  * This file is distributed in the hope that it will be useful, but
+  * WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+  * General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+  *
+  * This file incorporates work covered by the following copyright and
+  * permission notice:
+  *     The Synopsys DWC ETHER XGMAC Software Driver and documentation
+  *     (hereinafter "Software") is an unsupported proprietary work of Synopsys,
+  *     Inc. unless otherwise expressly agreed to in writing between Synopsys
+  *     and you.
+  *
+  *     The Software IS NOT an item of Licensed Software or Licensed Product
+  *     under any End User Software License Agreement or Agreement for Licensed
+  *     Product with Synopsys or any supplement thereto.  Permission is hereby
+  *     granted, free of charge, to any person obtaining a copy of this software
+  *     annotated with this license and the Software, to deal in the Software
+  *     without restriction, including without limitation the rights to use,
+  *     copy, modify, merge, publish, distribute, sublicense, and/or sell copies
+  *     of the Software, and to permit persons to whom the Software is furnished
+  *     to do so, subject to the following conditions:
+  *
+  *     The above copyright notice and this permission notice shall be included
+  *     in all copies or substantial portions of the Software.
+  *
+  *     THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS"
+  *     BASIS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  *     TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  *     PARTICULAR PURPOSE ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS
+  *     BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  *     CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  *     SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  *     INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  *     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  *     ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  *     THE POSSIBILITY OF SUCH DAMAGE.
+  *
+  *
+  * License 2: Modified BSD
+  *
+  * Copyright (c) 2015,2016 Baikal Electronics JSC.
+  * Copyright (c) 2014 Advanced Micro Devices, Inc.
+  * All rights reserved.
+  *
+  * Redistribution and use in source and binary forms, with or without
+  * modification, are permitted provided that the following conditions are met:
+  *     * Redistributions of source code must retain the above copyright
+  *       notice, this list of conditions and the following disclaimer.
+  *     * Redistributions in binary form must reproduce the above copyright
+  *       notice, this list of conditions and the following disclaimer in the
+  *       documentation and/or other materials provided with the distribution.
+  *     * Neither the name of Advanced Micro Devices, Inc. nor the
+  *       names of its contributors may be used to endorse or promote products
+  *       derived from this software without specific prior written permission.
+  *
+  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+  * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
+  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+  *
+  * This file incorporates work covered by the following copyright and
+  * permission notice:
+  *     The Synopsys DWC ETHER XGMAC Software Driver and documentation
+  *     (hereinafter "Software") is an unsupported proprietary work of Synopsys,
+  *     Inc. unless otherwise expressly agreed to in writing between Synopsys
+  *     and you.
+  *
+  *     The Software IS NOT an item of Licensed Software or Licensed Product
+  *     under any End User Software License Agreement or Agreement for Licensed
+  *     Product with Synopsys or any supplement thereto.  Permission is hereby
+  *     granted, free of charge, to any person obtaining a copy of this software
+  *     annotated with this license and the Software, to deal in the Software
+  *     without restriction, including without limitation the rights to use,
+  *     copy, modify, merge, publish, distribute, sublicense, and/or sell copies
+  *     of the Software, and to permit persons to whom the Software is furnished
+  *     to do so, subject to the following conditions:
+  *
+  *     The above copyright notice and this permission notice shall be included
+  *     in all copies or substantial portions of the Software.
+  *
+  *     THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS"
+  *     BASIS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  *     TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  *     PARTICULAR PURPOSE ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS
+  *     BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  *     CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  *     SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  *     INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  *     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  *     ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  *     THE POSSIBILITY OF SUCH DAMAGE.
+  */
+ 
+ #ifndef __XGBE_H__
+ #define __XGBE_H__
+ 
+ #include <linux/dma-mapping.h>
+ #include <linux/netdevice.h>
+ #include <linux/workqueue.h>
+ #include <linux/phy.h>
+ #include <linux/if_vlan.h>
+ #include <linux/bitops.h>
+ #include <linux/ptp_clock_kernel.h>
+ #include <linux/timecounter.h>
+ #include <linux/net_tstamp.h>
+ #include <net/dcbnl.h>
+ 
+ #define XGBE_DRV_NAME		"be-xgbe"
+ #define XGBE_DRV_VERSION	"1.0.4-a"
+ #define XGBE_DRV_DESC		"Baikal 10 Gigabit Ethernet Driver"
+ 
+ /* Descriptor related defines */
+ #define XGBE_TX_DESC_CNT	512
+ #define XGBE_TX_DESC_MIN_FREE	(XGBE_TX_DESC_CNT >> 3)
+ #define XGBE_TX_DESC_MAX_PROC	(XGBE_TX_DESC_CNT >> 1)
+ #define XGBE_RX_DESC_CNT	512
+ 
+ #define XGBE_TX_MAX_BUF_SIZE	(0x3fff & ~(64 - 1))
+ 
+ /* Descriptors required for maximum contigous TSO/GSO packet */
+ #define XGBE_TX_MAX_SPLIT	((GSO_MAX_SIZE / XGBE_TX_MAX_BUF_SIZE) + 1)
+ 
+ /* Maximum possible descriptors needed for an SKB:
+  * - Maximum number of SKB frags
+  * - Maximum descriptors for contiguous TSO/GSO packet
+  * - Possible context descriptor
+  * - Possible TSO header descriptor
+  */
+ #define XGBE_TX_MAX_DESCS	(MAX_SKB_FRAGS + XGBE_TX_MAX_SPLIT + 2)
+ 
+ #define XGBE_RX_MIN_BUF_SIZE	(ETH_FRAME_LEN + ETH_FCS_LEN + VLAN_HLEN)
+ #define XGBE_RX_BUF_ALIGN	64
+ #define XGBE_SKB_ALLOC_SIZE	256
+ #define XGBE_SPH_HDSMS_SIZE	2	/* Keep in sync with SKB_ALLOC_SIZE */
+ 
+ #define XGBE_MAX_DMA_CHANNELS	16
+ #define XGBE_MAX_QUEUES		16
+ #define XGBE_DMA_STOP_TIMEOUT	5
+ 
+ /* DMA cache settings - Outer sharable, write-back, write-allocate */
+ #define XGBE_DMA_OS_AXDOMAIN	0x2
+ #define XGBE_DMA_OS_ARCACHE	0xb
+ #define XGBE_DMA_OS_AWCACHE	0xf
+ 
+ /* DMA cache settings - System, no caches used */
+ #define XGBE_DMA_SYS_AXDOMAIN	0x3
+ #define XGBE_DMA_SYS_ARCACHE	0x0
+ #define XGBE_DMA_SYS_AWCACHE	0x0
+ 
+ #define XGBE_DMA_INTERRUPT_MASK	0x31c7
+ 
+ #define XGMAC_MIN_PACKET	60
+ #define XGMAC_STD_PACKET_MTU	1500
+ #define XGMAC_MAX_STD_PACKET	1518
+ #define XGMAC_JUMBO_PACKET_MTU	9000
+ #define XGMAC_MAX_JUMBO_PACKET	9018
+ 
+ /* MDIO bus phy name */
+ #define XGBE_PHY_NAME		"be_xgbe_phy"
+ #define XGBE_PRTAD		0
+ 
+ /* Device-tree clock names */
+ #define XGBE_DMA_CLOCK		"dma_clk"
+ #define XGBE_PTP_CLOCK		"ptp_clk"
+ #define XGBE_DMA_IRQS		"be,per-channel-interrupt"
+ 
+ /* Timestamp support - values based on 50MHz PTP clock
+  *   50MHz => 20 nsec
+  */
+ #define XGBE_TSTAMP_SSINC	20
+ #define XGBE_TSTAMP_SNSINC	0
+ 
+ /* Driver PMT macros */
+ #define XGMAC_DRIVER_CONTEXT	1
+ #define XGMAC_IOCTL_CONTEXT	2
+ 
+ #define XGBE_FIFO_MAX		81920
+ #define XGBE_FIFO_SIZE_B(x)	(x)
+ #define XGBE_FIFO_SIZE_KB(x)	(x * 1024)
+ 
+ #define XGBE_TC_MIN_QUANTUM	10
+ 
+ /* Helper macro for descriptor handling
+  *  Always use XGBE_GET_DESC_DATA to access the descriptor data
+  *  since the index is free-running and needs to be and-ed
+  *  with the descriptor count value of the ring to index to
+  *  the proper descriptor data.
+  */
+ #define XGBE_GET_DESC_DATA(_ring, _idx)				\
+ 	((_ring)->rdata +					\
+ 	 ((_idx) & ((_ring)->rdesc_count - 1)))
+ 
+ /* Default coalescing parameters */
+ #define XGMAC_INIT_DMA_TX_USECS		1000
+ #define XGMAC_INIT_DMA_TX_FRAMES	25
+ 
+ #define XGMAC_MAX_DMA_RIWT		0xff
+ #define XGMAC_INIT_DMA_RX_USECS		30
+ #define XGMAC_INIT_DMA_RX_FRAMES	25
+ 
+ /* Flow control queue count */
+ #define XGMAC_MAX_FLOW_CONTROL_QUEUES	8
+ 
+ /* Maximum MAC address hash table size (256 bits = 8 bytes) */
+ #define XGBE_MAC_HASH_TABLE_SIZE	8
+ 
+ /* Receive Side Scaling */
+ #define XGBE_RSS_HASH_KEY_SIZE		40
+ #define XGBE_RSS_MAX_TABLE_SIZE		256
+ #define XGBE_RSS_LOOKUP_TABLE_TYPE	0
+ #define XGBE_RSS_HASH_KEY_TYPE		1
+ 
+ struct xgbe_prv_data;
+ 
+ struct xgbe_packet_data {
+ 	struct sk_buff *skb;
+ 
+ 	unsigned int attributes;
+ 
+ 	unsigned int errors;
+ 
+ 	unsigned int rdesc_count;
+ 	unsigned int length;
+ 
+ 	unsigned int header_len;
+ 	unsigned int tcp_header_len;
+ 	unsigned int tcp_payload_len;
+ 	unsigned short mss;
+ 
+ 	unsigned short vlan_ctag;
+ 
+ 	u64 rx_tstamp;
+ 
+ 	u32 rss_hash;
+ 	enum pkt_hash_types rss_hash_type;
+ 
+ 	unsigned int tx_packets;
+ 	unsigned int tx_bytes;
+ };
+ 
+ /* Common Rx and Tx descriptor mapping */
+ struct xgbe_ring_desc {
+ 	__le32 desc0;
+ 	__le32 desc1;
+ 	__le32 desc2;
+ 	__le32 desc3;
+ };
+ 
+ /* Page allocation related values */
+ struct xgbe_page_alloc {
+ 	struct page *pages;
+ 	unsigned int pages_len;
+ 	unsigned int pages_offset;
+ 
+ 	dma_addr_t pages_dma;
+ };
+ 
+ /* Ring entry buffer data */
+ struct xgbe_buffer_data {
+ 	struct xgbe_page_alloc pa;
+ 	struct xgbe_page_alloc pa_unmap;
+ 
+ 	dma_addr_t dma;
+ 	unsigned int dma_len;
+ };
+ 
+ /* Tx-related ring data */
+ struct xgbe_tx_ring_data {
+ 	unsigned int packets;		/* BQL packet count */
+ 	unsigned int bytes;		/* BQL byte count */
+ };
+ 
+ /* Rx-related ring data */
+ struct xgbe_rx_ring_data {
+ 	struct xgbe_buffer_data hdr;	/* Header locations */
+ 	struct xgbe_buffer_data buf;	/* Payload locations */
+ 
+ 	unsigned short hdr_len;		/* Length of received header */
+ 	unsigned short len;		/* Length of received packet */
+ };
+ 
+ /* Structure used to hold information related to the descriptor
+  * and the packet associated with the descriptor (always use
+  * use the XGBE_GET_DESC_DATA macro to access this data from the ring)
+  */
+ struct xgbe_ring_data {
+ 	struct xgbe_ring_desc *rdesc;	/* Virtual address of descriptor */
+ 	dma_addr_t rdesc_dma;		/* DMA address of descriptor */
+ 
+ 	struct sk_buff *skb;		/* Virtual address of SKB */
+ 	dma_addr_t skb_dma;		/* DMA address of SKB data */
+ 	unsigned int skb_dma_len;	/* Length of SKB DMA area */
+ 
+ 	struct xgbe_tx_ring_data tx;	/* Tx-related data */
+ 	struct xgbe_rx_ring_data rx;	/* Rx-related data */
+ 
+ 	unsigned int interrupt;		/* Interrupt indicator */
+ 
+ 	unsigned int mapped_as_page;
+ 
+ 	/* Incomplete receive save location.  If the budget is exhausted
+ 	 * or the last descriptor (last normal descriptor or a following
+ 	 * context descriptor) has not been DMA'd yet the current state
+ 	 * of the receive processing needs to be saved.
+ 	 */
+ 	unsigned int state_saved;
+ 	struct {
+ 		unsigned int incomplete;
+ 		unsigned int context_next;
+ 		struct sk_buff *skb;
+ 		unsigned int len;
+ 		unsigned int error;
+ 	} state;
+ };
+ 
+ struct xgbe_ring {
+ 	/* Ring lock - used just for TX rings at the moment */
+ 	spinlock_t lock;
+ 
+ 	/* Per packet related information */
+ 	struct xgbe_packet_data packet_data;
+ 
+ 	/* Virtual/DMA addresses and count of allocated descriptor memory */
+ 	struct xgbe_ring_desc *rdesc;
+ 	dma_addr_t rdesc_dma;
+ 	unsigned int rdesc_count;
+ 
+ 	/* Array of descriptor data corresponding the descriptor memory
+ 	 * (always use the XGBE_GET_DESC_DATA macro to access this data)
+ 	 */
+ 	struct xgbe_ring_data *rdata;
+ 
+ 	/* Page allocation for RX buffers */
+ 	struct xgbe_page_alloc rx_hdr_pa;
+ 	struct xgbe_page_alloc rx_buf_pa;
+ 
+ 	/* Ring index values
+ 	 *  cur   - Tx: index of descriptor to be used for current transfer
+ 	 *          Rx: index of descriptor to check for packet availability
+ 	 *  dirty - Tx: index of descriptor to check for transfer complete
+ 	 *          Rx: count of descriptors in which a packet has been received
+ 	 *              (used with skb_realloc_index to refresh the ring)
+ 	 */
+ 	unsigned int cur;
+ 	unsigned int dirty;
+ 
+ 	/* Coalesce frame count used for interrupt bit setting */
+ 	unsigned int coalesce_count;
+ 
+ 	union {
+ 		struct {
+ 			unsigned int queue_stopped;
+ 			unsigned int xmit_more;
+ 			unsigned short cur_mss;
+ 			unsigned short cur_vlan_ctag;
+ 		} tx;
+ 
+ 		struct {
+ 			unsigned int realloc_index;
+ 			unsigned int realloc_threshold;
+ 		} rx;
+ 	};
+ } ____cacheline_aligned;
+ 
+ /* Structure used to describe the descriptor rings associated with
+  * a DMA channel.
+  */
+ struct xgbe_channel {
+ 	char name[16];
+ 
+ 	/* Address of private data area for device */
+ 	struct xgbe_prv_data *pdata;
+ 
+ 	/* Queue index and base address of queue's DMA registers */
+ 	unsigned int queue_index;
+ 	void __iomem *dma_regs;
+ 
+ 	/* Per channel interrupt irq number */
+ 	int dma_irq;
+ 	char dma_irq_name[IFNAMSIZ + 32];
+ 
+ 	/* Netdev related settings */
+ 	struct napi_struct napi;
+ 
+ 	unsigned int saved_ier;
+ 
+ 	unsigned int tx_timer_active;
+ 	struct hrtimer tx_timer;
+ 
+ 	struct xgbe_ring *tx_ring;
+ 	struct xgbe_ring *rx_ring;
+ } ____cacheline_aligned;
+ 
+ enum xgbe_int {
+ 	XGMAC_INT_DMA_CH_SR_TI,
+ 	XGMAC_INT_DMA_CH_SR_TPS,
+ 	XGMAC_INT_DMA_CH_SR_TBU,
+ 	XGMAC_INT_DMA_CH_SR_RI,
+ 	XGMAC_INT_DMA_CH_SR_RBU,
+ 	XGMAC_INT_DMA_CH_SR_RPS,
+ 	XGMAC_INT_DMA_CH_SR_TI_RI,
+ 	XGMAC_INT_DMA_CH_SR_FBE,
+ 	XGMAC_INT_DMA_ALL,
+ };
+ 
+ enum xgbe_int_state {
+ 	XGMAC_INT_STATE_SAVE,
+ 	XGMAC_INT_STATE_RESTORE,
+ };
+ 
+ enum xgbe_mtl_fifo_size {
+ 	XGMAC_MTL_FIFO_SIZE_256  = 0x00,
+ 	XGMAC_MTL_FIFO_SIZE_512  = 0x01,
+ 	XGMAC_MTL_FIFO_SIZE_1K   = 0x03,
+ 	XGMAC_MTL_FIFO_SIZE_2K   = 0x07,
+ 	XGMAC_MTL_FIFO_SIZE_4K   = 0x0f,
+ 	XGMAC_MTL_FIFO_SIZE_8K   = 0x1f,
+ 	XGMAC_MTL_FIFO_SIZE_16K  = 0x3f,
+ 	XGMAC_MTL_FIFO_SIZE_32K  = 0x7f,
+ 	XGMAC_MTL_FIFO_SIZE_64K  = 0xff,
+ 	XGMAC_MTL_FIFO_SIZE_128K = 0x1ff,
+ 	XGMAC_MTL_FIFO_SIZE_256K = 0x3ff,
+ };
+ 
+ struct xgbe_stats {
+ 	/* Tx Stats */
+ 	u64 txdropped;
+ 	u64 txerrorcount;
+ 	u64 txframecount;
+ 	u64 txoctetcount;
+ 	u64 txbroadcastframes;
+ 	u64 txmulticastframes;
+ 	u64 txunicastframes;
+ 	u64 txunderflowerror;
+ 	u64 txpauseframes;
+ 	u64 txvlanframes;
+ 
+ 	/* Rx Stats */
+ 	u64 rxrunerror;
+ 	u64 rxframecount;
+ 	u64 rxoctetcount;
+ 	u64 rxbroadcastframes;
+ 	u64 rxmulticastframes;
+ 	u64 rxunicastframes;
+ 	u64 rxcrcerror;
+ 	u64 rxrunterror;
+ 	u64 rxjabbererror;
+ 	u64 rxundersize;
+ 	u64 rxoversize;
+ 	u64 rxlengtherror;
+ 	u64 rxoutofrangetype;
+ 	u64 rxpauseframes;
+ 	u64 rxfifooverflow;
+ 	u64 rxvlanframes;
+ 	u64 rxwatchdogerror;
+ };
+ 
+ struct xgbe_hw_if {
+ 	int (*tx_complete)(struct xgbe_ring_desc *);
+ 
+ 	int (*set_promiscuous_mode)(struct xgbe_prv_data *, unsigned int);
+ 	int (*set_all_multicast_mode)(struct xgbe_prv_data *, unsigned int);
+ 	int (*add_mac_addresses)(struct xgbe_prv_data *);
+ 	int (*set_mac_address)(struct xgbe_prv_data *, u8 *addr);
+ 
+ 	int (*enable_rx_csum)(struct xgbe_prv_data *);
+ 	int (*disable_rx_csum)(struct xgbe_prv_data *);
+ 
+     int (*enable_mac_loopback)(struct xgbe_prv_data *);
+     int (*disable_mac_loopback)(struct xgbe_prv_data *);
+ 
+ 	int (*enable_rx_vlan_stripping)(struct xgbe_prv_data *);
+ 	int (*disable_rx_vlan_stripping)(struct xgbe_prv_data *);
+ 	int (*enable_rx_vlan_filtering)(struct xgbe_prv_data *);
+ 	int (*disable_rx_vlan_filtering)(struct xgbe_prv_data *);
+ 	int (*update_vlan_hash_table)(struct xgbe_prv_data *);
+ 
+ 	int (*read_mmd_regs)(struct xgbe_prv_data *, int, int);
+ 	void (*write_mmd_regs)(struct xgbe_prv_data *, int, int, int);
+ 	int (*set_gmii_speed)(struct xgbe_prv_data *);
+ 	int (*set_gmii_2500_speed)(struct xgbe_prv_data *);
+ 	int (*set_xgmii_speed)(struct xgbe_prv_data *);
+ 
+ 	void (*enable_tx)(struct xgbe_prv_data *);
+ 	void (*disable_tx)(struct xgbe_prv_data *);
+ 	void (*enable_rx)(struct xgbe_prv_data *);
+ 	void (*disable_rx)(struct xgbe_prv_data *);
+ 
+ 	void (*powerup_tx)(struct xgbe_prv_data *);
+ 	void (*powerdown_tx)(struct xgbe_prv_data *);
+ 	void (*powerup_rx)(struct xgbe_prv_data *);
+ 	void (*powerdown_rx)(struct xgbe_prv_data *);
+ 
+ 	int (*init)(struct xgbe_prv_data *);
+ 	int (*exit)(struct xgbe_prv_data *);
+ 
+ 	int (*enable_int)(struct xgbe_channel *, enum xgbe_int);
+ 	int (*disable_int)(struct xgbe_channel *, enum xgbe_int);
+ 	void (*dev_xmit)(struct xgbe_channel *);
+ 	int (*dev_read)(struct xgbe_channel *);
+ 	void (*tx_desc_init)(struct xgbe_channel *);
+ 	void (*rx_desc_init)(struct xgbe_channel *);
+ 	void (*rx_desc_reset)(struct xgbe_ring_data *);
+ 	void (*tx_desc_reset)(struct xgbe_ring_data *);
+ 	int (*is_last_desc)(struct xgbe_ring_desc *);
+ 	int (*is_context_desc)(struct xgbe_ring_desc *);
+ 	void (*tx_start_xmit)(struct xgbe_channel *, struct xgbe_ring *);
+ 
+ 	/* For FLOW ctrl */
+ 	int (*config_tx_flow_control)(struct xgbe_prv_data *);
+ 	int (*config_rx_flow_control)(struct xgbe_prv_data *);
+ 
+ 	/* For RX coalescing */
+ 	int (*config_rx_coalesce)(struct xgbe_prv_data *);
+ 	int (*config_tx_coalesce)(struct xgbe_prv_data *);
+ 	unsigned int (*usec_to_riwt)(struct xgbe_prv_data *, unsigned int);
+ 	unsigned int (*riwt_to_usec)(struct xgbe_prv_data *, unsigned int);
+ 
+ 	/* For RX and TX threshold config */
+ 	int (*config_rx_threshold)(struct xgbe_prv_data *, unsigned int);
+ 	int (*config_tx_threshold)(struct xgbe_prv_data *, unsigned int);
+ 
+ 	/* For RX and TX Store and Forward Mode config */
+ 	int (*config_rsf_mode)(struct xgbe_prv_data *, unsigned int);
+ 	int (*config_tsf_mode)(struct xgbe_prv_data *, unsigned int);
+ 
+ 	/* For TX DMA Operate on Second Frame config */
+ 	int (*config_osp_mode)(struct xgbe_prv_data *);
+ 
+ 	/* For RX and TX PBL config */
+ 	int (*config_rx_pbl_val)(struct xgbe_prv_data *);
+ 	int (*get_rx_pbl_val)(struct xgbe_prv_data *);
+ 	int (*config_tx_pbl_val)(struct xgbe_prv_data *);
+ 	int (*get_tx_pbl_val)(struct xgbe_prv_data *);
+ 	int (*config_pblx8)(struct xgbe_prv_data *);
+ 
+ 	/* For Timestamp config */
+ 	int (*config_tstamp)(struct xgbe_prv_data *, unsigned int);
+ 	void (*update_tstamp_addend)(struct xgbe_prv_data *, unsigned int);
+ 	void (*set_tstamp_time)(struct xgbe_prv_data *, unsigned int sec,
+ 				unsigned int nsec);
+ 	u64 (*get_tstamp_time)(struct xgbe_prv_data *);
+ 	u64 (*get_tx_tstamp)(struct xgbe_prv_data *);
+ 
+ 	/* For Data Center Bridging config */
+ 	void (*config_dcb_tc)(struct xgbe_prv_data *);
+ 	void (*config_dcb_pfc)(struct xgbe_prv_data *);
+ 
+ 	/* For Receive Side Scaling */
+ 	int (*enable_rss)(struct xgbe_prv_data *);
+ 	int (*disable_rss)(struct xgbe_prv_data *);
+ 	int (*set_rss_hash_key)(struct xgbe_prv_data *, const u8 *);
+ 	int (*set_rss_lookup_table)(struct xgbe_prv_data *, const u32 *);
+ };
+ 
+ struct xgbe_desc_if {
+ 	int (*alloc_ring_resources)(struct xgbe_prv_data *);
+ 	void (*free_ring_resources)(struct xgbe_prv_data *);
+ 	int (*map_tx_skb)(struct xgbe_channel *, struct sk_buff *);
+ 	void (*realloc_rx_buffer)(struct xgbe_channel *);
+ 	void (*unmap_rdata)(struct xgbe_prv_data *, struct xgbe_ring_data *);
+ 	void (*wrapper_tx_desc_init)(struct xgbe_prv_data *);
+ 	void (*wrapper_rx_desc_init)(struct xgbe_prv_data *);
+ };
+ 
+ /* This structure contains flags that indicate what hardware features
+  * or configurations are present in the device.
+  */
+ struct xgbe_hw_features {
+ 	/* HW Version */
+ 	unsigned int version;
+ 
+ 	/* HW Feature Register0 */
+ 	unsigned int gmii;		/* 1000 Mbps support */
+ 	unsigned int vlhash;		/* VLAN Hash Filter */
+ 	unsigned int sma;		/* SMA(MDIO) Interface */
+ 	unsigned int rwk;		/* PMT remote wake-up packet */
+ 	unsigned int mgk;		/* PMT magic packet */
+ 	unsigned int mmc;		/* RMON module */
+ 	unsigned int aoe;		/* ARP Offload */
+ 	unsigned int ts;		/* IEEE 1588-2008 Advanced Timestamp */
+ 	unsigned int eee;		/* Energy Efficient Ethernet */
+ 	unsigned int tx_coe;		/* Tx Checksum Offload */
+ 	unsigned int rx_coe;		/* Rx Checksum Offload */
+ 	unsigned int addn_mac;		/* Additional MAC Addresses */
+ 	unsigned int ts_src;		/* Timestamp Source */
+ 	unsigned int sa_vlan_ins;	/* Source Address or VLAN Insertion */
+ 
+ 	/* HW Feature Register1 */
+ 	unsigned int rx_fifo_size;	/* MTL Receive FIFO Size */
+ 	unsigned int tx_fifo_size;	/* MTL Transmit FIFO Size */
+ 	unsigned int adv_ts_hi;		/* Advance Timestamping High Word */
+ 	unsigned int dma_width;		/* DMA width */
+ 	unsigned int dcb;		/* DCB Feature */
+ 	unsigned int sph;		/* Split Header Feature */
+ 	unsigned int tso;		/* TCP Segmentation Offload */
+ 	unsigned int dma_debug;		/* DMA Debug Registers */
+ 	unsigned int rss;		/* Receive Side Scaling */
+ 	unsigned int tc_cnt;		/* Number of Traffic Classes */
+ 	unsigned int hash_table_size;	/* Hash Table Size */
+ 	unsigned int l3l4_filter_num;	/* Number of L3-L4 Filters */
+ 
+ 	/* HW Feature Register2 */
+ 	unsigned int rx_q_cnt;		/* Number of MTL Receive Queues */
+ 	unsigned int tx_q_cnt;		/* Number of MTL Transmit Queues */
+ 	unsigned int rx_ch_cnt;		/* Number of DMA Receive Channels */
+ 	unsigned int tx_ch_cnt;		/* Number of DMA Transmit Channels */
+ 	unsigned int pps_out_num;	/* Number of PPS outputs */
+ 	unsigned int aux_snap_num;	/* Number of Aux snapshot inputs */
+ };
+ 
+ struct xgbe_prv_data {
+ 	struct net_device *netdev;
+ 	struct platform_device *pdev;
+ 	struct device *dev;
+ 
+ 	/* XGMAC/XPCS related mmio registers */
+ 	void __iomem *xgmac_regs;	/* XGMAC CSRs */
+ 	void __iomem *xpcs_regs;	/* XPCS MMD registers */
+ 
+ 	/* Overall device lock */
+ 	spinlock_t lock;
+ 
+ 	/* XPCS indirect addressing mutex */
+ 	struct mutex xpcs_mutex;
+ 
+ 	/* RSS addressing mutex */
+ 	struct mutex rss_mutex;
+ 
+ 	int dev_irq;
+ 	unsigned int per_channel_irq;
+ 
+ 	struct xgbe_hw_if hw_if;
+ 	struct xgbe_desc_if desc_if;
+ 
+ 	/* AXI DMA settings */
+ 	unsigned int axdomain;
+ 	unsigned int arcache;
+ 	unsigned int awcache;
+ 
+ 	/* Rings for Tx/Rx on a DMA channel */
+ 	struct xgbe_channel *channel;
+ 	unsigned int channel_count;
+ 	unsigned int tx_ring_count;
+ 	unsigned int tx_desc_count;
+ 	unsigned int rx_ring_count;
+ 	unsigned int rx_desc_count;
+ 
+ 	unsigned int tx_q_count;
+ 	unsigned int rx_q_count;
+ 
+ 	/* Tx/Rx common settings */
+ 	unsigned int pblx8;
+ 
+ 	/* Tx settings */
+ 	unsigned int tx_sf_mode;
+ 	unsigned int tx_threshold;
+ 	unsigned int tx_pbl;
+ 	unsigned int tx_osp_mode;
+ 
+ 	/* Rx settings */
+ 	unsigned int rx_sf_mode;
+ 	unsigned int rx_threshold;
+ 	unsigned int rx_pbl;
+ 
+ 	/* Tx coalescing settings */
+ 	unsigned int tx_usecs;
+ 	unsigned int tx_frames;
+ 
+ 	/* Rx coalescing settings */
+ 	unsigned int rx_riwt;
+ 	unsigned int rx_frames;
+ 
+ 	/* Current Rx buffer size */
+ 	unsigned int rx_buf_size;
+ 
+ 	/* Flow control settings */
+ 	unsigned int pause_autoneg;
+ 	unsigned int tx_pause;
+ 	unsigned int rx_pause;
+ 
+ 	/* Receive Side Scaling settings */
+ 	u8 rss_key[XGBE_RSS_HASH_KEY_SIZE];
+ 	u32 rss_table[XGBE_RSS_MAX_TABLE_SIZE];
+ 	u32 rss_options;
+ 
+ 	/* MDIO settings */
+ 	struct module *phy_module;
+ 	char *mii_bus_id;
+ 	struct mii_bus *mii;
+ 	int mdio_mmd;
+ 	struct phy_device *phydev;
+ 	int default_autoneg;
+ 	int default_speed;
+ 
+ 	/* Current PHY settings */
+ 	phy_interface_t phy_mode;
+ 	int phy_link;
+ 	int phy_speed;
+ 	unsigned int phy_tx_pause;
+ 	unsigned int phy_rx_pause;
+ 
+ 	/* Netdev related settings */
+ 	netdev_features_t netdev_features;
+ 	struct napi_struct napi;
+ 	struct xgbe_stats stats;
+ 
+ 	/* Filtering support */
+ 	unsigned long active_vlans[BITS_TO_LONGS(VLAN_N_VID)];
+ 
+ 	/* Device clocks */
+ 	struct clk *sysclk;
+ 	struct clk *ptpclk;
+ 
+ 	/* Timestamp support */
+ 	spinlock_t tstamp_lock;
+ 	struct ptp_clock_info ptp_clock_info;
+ 	struct ptp_clock *ptp_clock;
+ 	struct hwtstamp_config tstamp_config;
+ 	struct cyclecounter tstamp_cc;
+ 	struct timecounter tstamp_tc;
+ 	unsigned int tstamp_addend;
+ 	struct work_struct tx_tstamp_work;
+ 	struct sk_buff *tx_tstamp_skb;
+ 	u64 tx_tstamp;
+ 
+ 	/* DCB support */
+ 	struct ieee_ets *ets;
+ 	struct ieee_pfc *pfc;
+ 	unsigned int q2tc_map[XGBE_MAX_QUEUES];
+ 	unsigned int prio2q_map[IEEE_8021QAZ_MAX_TCS];
+ 
+ 	/* Hardware features of the device */
+ 	struct xgbe_hw_features hw_feat;
+ 
+ 	/* Device restart work structure */
+ 	struct work_struct restart_work;
+ 
+ 	/* Keeps track of power mode */
+ 	unsigned int power_down;
+ 
+ 	/* Network interface message level setting */
+ 	u32 msg_enable;
+ 
+ #ifdef CONFIG_DEBUG_FS
+ 	struct dentry *xgbe_debugfs;
+ 
+ 	unsigned int debugfs_xgmac_reg;
+ 
+ 	unsigned int debugfs_xpcs_mmd;
+ 	unsigned int debugfs_xpcs_reg;
+ #endif
+ };
+ 
+ /* Function prototypes*/
+ 
+ void xgbe_init_function_ptrs_dev(struct xgbe_hw_if *);
+ void xgbe_init_function_ptrs_desc(struct xgbe_desc_if *);
+ struct net_device_ops *xgbe_get_netdev_ops(void);
+ struct ethtool_ops *xgbe_get_ethtool_ops(void);
+ #ifdef CONFIG_AMD_XGBE_DCB
+ const struct dcbnl_rtnl_ops *xgbe_get_dcbnl_ops(void);
+ #endif
+ 
+ int xgbe_mdio_register(struct xgbe_prv_data *);
+ void xgbe_mdio_unregister(struct xgbe_prv_data *);
+ void xgbe_dump_phy_registers(struct xgbe_prv_data *);
+ void xgbe_ptp_register(struct xgbe_prv_data *);
+ void xgbe_ptp_unregister(struct xgbe_prv_data *);
+ void xgbe_dump_tx_desc(struct xgbe_ring *, unsigned int, unsigned int,
+ 		       unsigned int);
+ void xgbe_dump_rx_desc(struct xgbe_ring *, struct xgbe_ring_desc *,
+ 		       unsigned int);
+ void xgbe_print_pkt(struct net_device *, struct sk_buff *, bool);
+ void xgbe_get_all_hw_features(struct xgbe_prv_data *);
+ int xgbe_powerup(struct net_device *, unsigned int);
+ int xgbe_powerdown(struct net_device *, unsigned int);
+ void xgbe_init_rx_coalesce(struct xgbe_prv_data *);
+ void xgbe_init_tx_coalesce(struct xgbe_prv_data *);
+ 
+ #ifdef CONFIG_DEBUG_FS
+ void xgbe_debugfs_init(struct xgbe_prv_data *);
+ void xgbe_debugfs_exit(struct xgbe_prv_data *);
+ #else
+ static inline void xgbe_debugfs_init(struct xgbe_prv_data *pdata) {}
+ static inline void xgbe_debugfs_exit(struct xgbe_prv_data *pdata) {}
+ #endif /* CONFIG_DEBUG_FS */
+ 
+ /* NOTE: Uncomment for TX and RX DESCRIPTOR DUMP in KERNEL LOG */
+ #if 0
+ #define XGMAC_ENABLE_TX_DESC_DUMP
+ #define XGMAC_ENABLE_RX_DESC_DUMP
+ #endif
+ 
+ /* NOTE: Uncomment for TX and RX PACKET DUMP in KERNEL LOG */
+ #if 0
+ #define XGMAC_ENABLE_TX_PKT_DUMP
+ #define XGMAC_ENABLE_RX_PKT_DUMP
+ #endif
+ 
+ /* NOTE: Uncomment for function trace log messages in KERNEL LOG */
+ #if 0
+ #define YDEBUG
+ #define YDEBUG_MDIO
+ #endif
+ 
+ /* For debug prints */
+ #ifdef YDEBUG
+ #define DBGPR(x...) pr_info(x)
+ #define DBGPHY_REGS(x...) xgbe_dump_phy_registers(x)
+ #else
+ #define DBGPR(x...) do { } while (0)
+ #define DBGPHY_REGS(x...) do { } while (0)
+ #endif
+ 
+ #ifdef YDEBUG_MDIO
+ #define DBGPR_MDIO(x...) pr_alert(x)
+ #else
+ #define DBGPR_MDIO(x...) do { } while (0)
+ #endif
+ 
+ #endif
diff -rcNP linux-4.4.24/drivers/net/ethernet/baikal/xgbe/xgbe-main.c linux-4.4.24-baikal/drivers/net/ethernet/baikal/xgbe/xgbe-main.c
*** linux-4.4.24/drivers/net/ethernet/baikal/xgbe/xgbe-main.c	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/drivers/net/ethernet/baikal/xgbe/xgbe-main.c	2016-11-11 14:49:52.000000000 +0300
***************
*** 0 ****
--- 1,520 ----
+ /*
+  * Baikal Electronics 10Gb Ethernet driver
+  *
+  * Based on AMD 10Gb Ethernet driver
+  * drivers/net/ethernet/amd/xgbe
+  *
+  * This file is available to you under your choice of the following two
+  * licenses:
+  *
+  * License 1: GPLv2
+  *
+  * Copyright (c) 2015,2016 Baikal Electronics JSC.
+  * Copyright (c) 2014 Advanced Micro Devices, Inc.
+  *
+  * Adopted by:
+  *   Dmitry Dunaev <dmitry.dunaev@baikalelectronics.ru>
+  *
+  * This file is free software; you may copy, redistribute and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation, either version 2 of the License, or (at
+  * your option) any later version.
+  *
+  * This file is distributed in the hope that it will be useful, but
+  * WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+  * General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+  *
+  * This file incorporates work covered by the following copyright and
+  * permission notice:
+  *     The Synopsys DWC ETHER XGMAC Software Driver and documentation
+  *     (hereinafter "Software") is an unsupported proprietary work of Synopsys,
+  *     Inc. unless otherwise expressly agreed to in writing between Synopsys
+  *     and you.
+  *
+  *     The Software IS NOT an item of Licensed Software or Licensed Product
+  *     under any End User Software License Agreement or Agreement for Licensed
+  *     Product with Synopsys or any supplement thereto.  Permission is hereby
+  *     granted, free of charge, to any person obtaining a copy of this software
+  *     annotated with this license and the Software, to deal in the Software
+  *     without restriction, including without limitation the rights to use,
+  *     copy, modify, merge, publish, distribute, sublicense, and/or sell copies
+  *     of the Software, and to permit persons to whom the Software is furnished
+  *     to do so, subject to the following conditions:
+  *
+  *     The above copyright notice and this permission notice shall be included
+  *     in all copies or substantial portions of the Software.
+  *
+  *     THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS"
+  *     BASIS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  *     TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  *     PARTICULAR PURPOSE ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS
+  *     BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  *     CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  *     SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  *     INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  *     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  *     ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  *     THE POSSIBILITY OF SUCH DAMAGE.
+  *
+  *
+  * License 2: Modified BSD
+  *
+  * Copyright (c) 2015,2016 Baikal Electronics JSC.
+  * Copyright (c) 2014 Advanced Micro Devices, Inc.
+  * All rights reserved.
+  *
+  * Redistribution and use in source and binary forms, with or without
+  * modification, are permitted provided that the following conditions are met:
+  *     * Redistributions of source code must retain the above copyright
+  *       notice, this list of conditions and the following disclaimer.
+  *     * Redistributions in binary form must reproduce the above copyright
+  *       notice, this list of conditions and the following disclaimer in the
+  *       documentation and/or other materials provided with the distribution.
+  *     * Neither the name of Advanced Micro Devices, Inc. nor the
+  *       names of its contributors may be used to endorse or promote products
+  *       derived from this software without specific prior written permission.
+  *
+  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+  * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
+  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+  *
+  * This file incorporates work covered by the following copyright and
+  * permission notice:
+  *     The Synopsys DWC ETHER XGMAC Software Driver and documentation
+  *     (hereinafter "Software") is an unsupported proprietary work of Synopsys,
+  *     Inc. unless otherwise expressly agreed to in writing between Synopsys
+  *     and you.
+  *
+  *     The Software IS NOT an item of Licensed Software or Licensed Product
+  *     under any End User Software License Agreement or Agreement for Licensed
+  *     Product with Synopsys or any supplement thereto.  Permission is hereby
+  *     granted, free of charge, to any person obtaining a copy of this software
+  *     annotated with this license and the Software, to deal in the Software
+  *     without restriction, including without limitation the rights to use,
+  *     copy, modify, merge, publish, distribute, sublicense, and/or sell copies
+  *     of the Software, and to permit persons to whom the Software is furnished
+  *     to do so, subject to the following conditions:
+  *
+  *     The above copyright notice and this permission notice shall be included
+  *     in all copies or substantial portions of the Software.
+  *
+  *     THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS"
+  *     BASIS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  *     TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  *     PARTICULAR PURPOSE ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS
+  *     BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  *     CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  *     SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  *     INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  *     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  *     ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  *     THE POSSIBILITY OF SUCH DAMAGE.
+  */
+ 
+ #include <linux/module.h>
+ #include <linux/device.h>
+ #include <linux/platform_device.h>
+ #include <linux/spinlock.h>
+ #include <linux/netdevice.h>
+ #include <linux/etherdevice.h>
+ #include <linux/io.h>
+ #include <linux/of.h>
+ #include <linux/of_net.h>
+ #include <linux/clk.h>
+ 
+ #include "xgbe.h"
+ #include "xgbe-common.h"
+ 
+ MODULE_AUTHOR("Tom Lendacky <thomas.lendacky@amd.com>");
+ MODULE_LICENSE("Dual BSD/GPL");
+ MODULE_VERSION(XGBE_DRV_VERSION);
+ MODULE_DESCRIPTION(XGBE_DRV_DESC);
+ 
+ static void xgbe_default_config(struct xgbe_prv_data *pdata)
+ {
+ 	DBGPR("-->xgbe_default_config\n");
+ 
+ 	pdata->pblx8 = DMA_PBL_X8_ENABLE;
+ 	pdata->tx_sf_mode = MTL_TSF_ENABLE;
+ 	pdata->tx_threshold = MTL_TX_THRESHOLD_64;
+ 	pdata->tx_pbl = DMA_PBL_16;
+ 	pdata->tx_osp_mode = DMA_OSP_DISABLE;
+ 	pdata->rx_sf_mode = MTL_RSF_DISABLE;
+ 	pdata->rx_threshold = MTL_RX_THRESHOLD_64;
+ 	pdata->rx_pbl = DMA_PBL_16;
+ 	pdata->pause_autoneg = 1;
+ 	pdata->tx_pause = 1;
+ 	pdata->rx_pause = 1;
+ 	pdata->power_down = 0;
+ 	pdata->default_autoneg = AUTONEG_DISABLE;
+ 	pdata->default_speed = SPEED_10000;
+ 
+ 	DBGPR("<--xgbe_default_config\n");
+ }
+ 
+ static void xgbe_init_all_fptrs(struct xgbe_prv_data *pdata)
+ {
+ 	xgbe_init_function_ptrs_dev(&pdata->hw_if);
+ 	xgbe_init_function_ptrs_desc(&pdata->desc_if);
+ }
+ 
+ static int xgbe_probe(struct platform_device *pdev)
+ {
+ 	struct xgbe_prv_data *pdata;
+ 	struct xgbe_hw_if *hw_if;
+ 	struct xgbe_desc_if *desc_if;
+ 	struct net_device *netdev;
+ 	struct device *dev = &pdev->dev;
+ 	struct resource *res;
+ 	const u8 *mac_addr;
+ 	unsigned int i;
+ 	int ret;
+ 
+ 	DBGPR("--> xgbe_probe\n");
+ 
+ 	netdev = alloc_etherdev_mq(sizeof(struct xgbe_prv_data),
+ 				   XGBE_MAX_DMA_CHANNELS);
+ 	if (!netdev) {
+ 		dev_err(dev, "alloc_etherdev failed\n");
+ 		ret = -ENOMEM;
+ 		goto err_alloc;
+ 	}
+ 	SET_NETDEV_DEV(netdev, dev);
+ 	pdata = netdev_priv(netdev);
+ 	pdata->netdev = netdev;
+ 	pdata->pdev = pdev;
+ 	pdata->dev = dev;
+ 	platform_set_drvdata(pdev, netdev);
+ 
+ 	spin_lock_init(&pdata->lock);
+ 	mutex_init(&pdata->xpcs_mutex);
+ 	mutex_init(&pdata->rss_mutex);
+ 	spin_lock_init(&pdata->tstamp_lock);
+ 
+ 	/* Set and validate the number of descriptors for a ring */
+ 	BUILD_BUG_ON_NOT_POWER_OF_2(XGBE_TX_DESC_CNT);
+ 	pdata->tx_desc_count = XGBE_TX_DESC_CNT;
+ 	if (pdata->tx_desc_count & (pdata->tx_desc_count - 1)) {
+ 		dev_err(dev, "tx descriptor count (%d) is not valid\n",
+ 			pdata->tx_desc_count);
+ 		ret = -EINVAL;
+ 		goto err_io;
+ 	}
+ 	BUILD_BUG_ON_NOT_POWER_OF_2(XGBE_RX_DESC_CNT);
+ 	pdata->rx_desc_count = XGBE_RX_DESC_CNT;
+ 	if (pdata->rx_desc_count & (pdata->rx_desc_count - 1)) {
+ 		dev_err(dev, "rx descriptor count (%d) is not valid\n",
+ 			pdata->rx_desc_count);
+ 		ret = -EINVAL;
+ 		goto err_io;
+ 	}
+ 
+ 	/* Obtain the system clock setting */
+ 	pdata->sysclk = devm_clk_get(dev, XGBE_DMA_CLOCK);
+ 	if (IS_ERR(pdata->sysclk)) {
+ 		dev_err(dev, "dma devm_clk_get failed\n");
+ 		ret = PTR_ERR(pdata->sysclk);
+ 		goto err_io;
+ 	}
+ 
+ 	/* Obtain the PTP clock setting */
+ 	pdata->ptpclk = devm_clk_get(dev, XGBE_PTP_CLOCK);
+ 	if (IS_ERR(pdata->ptpclk)) {
+ 		dev_err(dev, "ptp devm_clk_get failed\n");
+ 		ret = PTR_ERR(pdata->ptpclk);
+ 		goto err_io;
+ 	}
+ 
+ 	/* Obtain the mmio areas for the device */
+ 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+ 	pdata->xgmac_regs = devm_ioremap_resource(dev, res);
+ 	if (IS_ERR(pdata->xgmac_regs)) {
+ 		dev_err(dev, "xgmac ioremap failed\n");
+ 		ret = PTR_ERR(pdata->xgmac_regs);
+ 		goto err_io;
+ 	}
+ 	DBGPR("  xgmac_regs = %p\n", pdata->xgmac_regs);
+ 
+ 	res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+ 	pdata->xpcs_regs = devm_ioremap_resource(dev, res);
+ 	if (IS_ERR(pdata->xpcs_regs)) {
+ 		dev_err(dev, "xpcs ioremap failed\n");
+ 		ret = PTR_ERR(pdata->xpcs_regs);
+ 		goto err_io;
+ 	}
+ 	DBGPR("  xpcs_regs  = %p\n", pdata->xpcs_regs);
+ 
+ 	/* Set the DMA mask */
+ 	if (!dev->dma_mask)
+ 		dev->dma_mask = &dev->coherent_dma_mask;
+ 	ret = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(32));
+ 	if (ret) {
+ 		dev_err(dev, "dma_set_mask_and_coherent failed\n");
+ 		goto err_io;
+ 	}
+ 
+ 	if (of_property_read_bool(dev->of_node, "dma-coherent")) {
+ 		pdata->axdomain = XGBE_DMA_OS_AXDOMAIN;
+ 		pdata->arcache = XGBE_DMA_OS_ARCACHE;
+ 		pdata->awcache = XGBE_DMA_OS_AWCACHE;
+ 	} else {
+ 		pdata->axdomain = XGBE_DMA_SYS_AXDOMAIN;
+ 		pdata->arcache = XGBE_DMA_SYS_ARCACHE;
+ 		pdata->awcache = XGBE_DMA_SYS_AWCACHE;
+ 	}
+ 
+ 	/* Check for per channel interrupt support */
+ 	if (of_property_read_bool(dev->of_node, XGBE_DMA_IRQS))
+ 		pdata->per_channel_irq = 1;
+ 
+ 	ret = platform_get_irq(pdev, 0);
+ 	if (ret < 0) {
+ 		dev_err(dev, "platform_get_irq 0 failed\n");
+ 		goto err_io;
+ 	}
+ 	pdata->dev_irq = ret;
+ 
+ 	netdev->irq = pdata->dev_irq;
+ 	netdev->base_addr = (unsigned long)pdata->xgmac_regs;
+ 
+ 	/* Set all the function pointers */
+ 	xgbe_init_all_fptrs(pdata);
+ 	hw_if = &pdata->hw_if;
+ 	desc_if = &pdata->desc_if;
+ 
+ 	/* Issue software reset to device */
+ 	hw_if->exit(pdata);
+ 
+ 	/* Populate the hardware features */
+ 	xgbe_get_all_hw_features(pdata);
+ 
+ 	/* Retrieve the MAC address */
+ 	mac_addr = of_get_mac_address(dev->of_node);
+ 	if (!mac_addr) {
+ 		dev_err(dev, "invalid mac address for this device\n");
+ 		ret = -EINVAL;
+ 		goto err_io;
+ 	}
+ 	memcpy(netdev->dev_addr, mac_addr, netdev->addr_len);
+ 
+ 	/* Retrieve the PHY mode - it must be "xgmii" */
+ 	pdata->phy_mode = of_get_phy_mode(dev->of_node);
+ 	if (pdata->phy_mode != PHY_INTERFACE_MODE_XGMII) {
+ 		dev_err(dev, "invalid phy-mode specified for this device\n");
+ 		ret = -EINVAL;
+ 		goto err_io;
+ 	}
+ 
+ 	/* Set default configuration data */
+ 	xgbe_default_config(pdata);
+ 
+ 	/* Calculate the number of Tx and Rx rings to be created
+ 	 *  -Tx (DMA) Channels map 1-to-1 to Tx Queues so set
+ 	 *   the number of Tx queues to the number of Tx channels
+ 	 *   enabled
+ 	 *  -Rx (DMA) Channels do not map 1-to-1 so use the actual
+ 	 *   number of Rx queues
+ 	 */
+ 	pdata->tx_ring_count = min_t(unsigned int, num_online_cpus(),
+ 				     pdata->hw_feat.tx_ch_cnt);
+ 	pdata->tx_q_count = pdata->tx_ring_count;
+ 	ret = netif_set_real_num_tx_queues(netdev, pdata->tx_ring_count);
+ 	if (ret) {
+ 		dev_err(dev, "error setting real tx queue count\n");
+ 		goto err_io;
+ 	}
+ 
+ 	pdata->rx_ring_count = min_t(unsigned int,
+ 				     netif_get_num_default_rss_queues(),
+ 				     pdata->hw_feat.rx_ch_cnt);
+ 	pdata->rx_q_count = pdata->hw_feat.rx_q_cnt;
+ 	ret = netif_set_real_num_rx_queues(netdev, pdata->rx_ring_count);
+ 	if (ret) {
+ 		dev_err(dev, "error setting real rx queue count\n");
+ 		goto err_io;
+ 	}
+ 
+ 	/* Initialize RSS hash key and lookup table */
+ 	netdev_rss_key_fill(pdata->rss_key, sizeof(pdata->rss_key));
+ 
+ 	for (i = 0; i < XGBE_RSS_MAX_TABLE_SIZE; i++)
+ 		XGMAC_SET_BITS(pdata->rss_table[i], MAC_RSSDR, DMCH,
+ 			       i % pdata->rx_ring_count);
+ 
+ 	XGMAC_SET_BITS(pdata->rss_options, MAC_RSSCR, IP2TE, 1);
+ 	XGMAC_SET_BITS(pdata->rss_options, MAC_RSSCR, TCP4TE, 1);
+ 	XGMAC_SET_BITS(pdata->rss_options, MAC_RSSCR, UDP4TE, 1);
+ 
+ 	/* Prepare to regsiter with MDIO */
+ 	pdata->mii_bus_id = kasprintf(GFP_KERNEL, "%s", pdev->name);
+ 	if (!pdata->mii_bus_id) {
+ 		dev_err(dev, "failed to allocate mii bus id\n");
+ 		ret = -ENOMEM;
+ 		goto err_io;
+ 	}
+ 	ret = xgbe_mdio_register(pdata);
+ 	if (ret)
+ 		goto err_bus_id;
+ 
+ 	/* Set device operations */
+ 	netdev->netdev_ops = xgbe_get_netdev_ops();
+ 	netdev->ethtool_ops = xgbe_get_ethtool_ops();
+ #ifdef CONFIG_AMD_XGBE_DCB
+ 	netdev->dcbnl_ops = xgbe_get_dcbnl_ops();
+ #endif
+ 
+ 	/* Set device features */
+ 	netdev->hw_features = NETIF_F_SG |
+ 			      NETIF_F_IP_CSUM |
+ 			      NETIF_F_IPV6_CSUM |
+ 			      NETIF_F_RXCSUM |
+ 			      NETIF_F_TSO |
+ 			      NETIF_F_TSO6 |
+ 			      NETIF_F_GRO |
+ 			      NETIF_F_HW_VLAN_CTAG_RX |
+ 			      NETIF_F_HW_VLAN_CTAG_TX |
+ 			      NETIF_F_HW_VLAN_CTAG_FILTER;
+ 
+ 	if (pdata->hw_feat.rss)
+ 		netdev->hw_features |= NETIF_F_RXHASH;
+ 
+ 	netdev->vlan_features |= NETIF_F_SG |
+ 				 NETIF_F_IP_CSUM |
+ 				 NETIF_F_IPV6_CSUM |
+ 				 NETIF_F_TSO |
+ 				 NETIF_F_TSO6;
+ 
+ 	netdev->features |= netdev->hw_features;
+ 	pdata->netdev_features = netdev->features;
+ 
+ 	netdev->priv_flags |= IFF_UNICAST_FLT;
+ 
+ 	xgbe_init_rx_coalesce(pdata);
+ 	xgbe_init_tx_coalesce(pdata);
+ 
+ 	netif_carrier_off(netdev);
+ 	ret = register_netdev(netdev);
+ 	if (ret) {
+ 		dev_err(dev, "net device registration failed\n");
+ 		goto err_reg_netdev;
+ 	}
+ 
+ 	xgbe_ptp_register(pdata);
+ 
+ 	xgbe_debugfs_init(pdata);
+ 
+ 	netdev_notice(netdev, "net device enabled\n");
+ 
+ 	DBGPR("<-- xgbe_probe\n");
+ 
+ 	return 0;
+ 
+ err_reg_netdev:
+ 	xgbe_mdio_unregister(pdata);
+ 
+ err_bus_id:
+ 	kfree(pdata->mii_bus_id);
+ 
+ err_io:
+ 	free_netdev(netdev);
+ 
+ err_alloc:
+ 	dev_notice(dev, "net device not enabled\n");
+ 
+ 	return ret;
+ }
+ 
+ static int xgbe_remove(struct platform_device *pdev)
+ {
+ 	struct net_device *netdev = platform_get_drvdata(pdev);
+ 	struct xgbe_prv_data *pdata = netdev_priv(netdev);
+ 
+ 	DBGPR("-->xgbe_remove\n");
+ 
+ 	xgbe_debugfs_exit(pdata);
+ 
+ 	xgbe_ptp_unregister(pdata);
+ 
+ 	unregister_netdev(netdev);
+ 
+ 	xgbe_mdio_unregister(pdata);
+ 
+ 	kfree(pdata->mii_bus_id);
+ 
+ 	free_netdev(netdev);
+ 
+ 	DBGPR("<--xgbe_remove\n");
+ 
+ 	return 0;
+ }
+ 
+ #ifdef CONFIG_PM
+ static int xgbe_suspend(struct device *dev)
+ {
+ 	struct net_device *netdev = dev_get_drvdata(dev);
+ 	int ret;
+ 
+ 	DBGPR("-->xgbe_suspend\n");
+ 
+ 	if (!netif_running(netdev)) {
+ 		DBGPR("<--xgbe_dev_suspend\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	ret = xgbe_powerdown(netdev, XGMAC_DRIVER_CONTEXT);
+ 
+ 	DBGPR("<--xgbe_suspend\n");
+ 
+ 	return ret;
+ }
+ 
+ static int xgbe_resume(struct device *dev)
+ {
+ 	struct net_device *netdev = dev_get_drvdata(dev);
+ 	int ret;
+ 
+ 	DBGPR("-->xgbe_resume\n");
+ 
+ 	if (!netif_running(netdev)) {
+ 		DBGPR("<--xgbe_dev_resume\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	ret = xgbe_powerup(netdev, XGMAC_DRIVER_CONTEXT);
+ 
+ 	DBGPR("<--xgbe_resume\n");
+ 
+ 	return ret;
+ }
+ #endif /* CONFIG_PM */
+ 
+ static const struct of_device_id xgbe_of_match[] = {
+ 	{ .compatible = "be,baikal-xgbe", },
+ 	{},
+ };
+ 
+ MODULE_DEVICE_TABLE(of, xgbe_of_match);
+ static SIMPLE_DEV_PM_OPS(xgbe_pm_ops, xgbe_suspend, xgbe_resume);
+ 
+ static struct platform_driver xgbe_driver = {
+ 	.driver = {
+ 		.name = "be-xgbe",
+ 		.of_match_table = xgbe_of_match,
+ 		.pm = &xgbe_pm_ops,
+ 	},
+ 	.probe = xgbe_probe,
+ 	.remove = xgbe_remove,
+ };
+ 
+ module_platform_driver(xgbe_driver);
diff -rcNP linux-4.4.24/drivers/net/ethernet/baikal/xgbe/xgbe-mdio.c linux-4.4.24-baikal/drivers/net/ethernet/baikal/xgbe/xgbe-mdio.c
*** linux-4.4.24/drivers/net/ethernet/baikal/xgbe/xgbe-mdio.c	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/drivers/net/ethernet/baikal/xgbe/xgbe-mdio.c	2016-11-11 14:49:52.000000000 +0300
***************
*** 0 ****
--- 1,340 ----
+ /*
+  * Baikal Electronics 10Gb Ethernet driver
+  *
+  * Based on AMD 10Gb Ethernet driver
+  * drivers/net/ethernet/amd/xgbe
+  *
+  * This file is available to you under your choice of the following two
+  * licenses:
+  *
+  * License 1: GPLv2
+  *
+  * Copyright (c) 2015,2016 Baikal Electronics JSC.
+  * Copyright (c) 2014 Advanced Micro Devices, Inc.
+  *
+  * Adopted by:
+  *   Dmitry Dunaev <dmitry.dunaev@baikalelectronics.ru>
+  *
+  * This file is free software; you may copy, redistribute and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation, either version 2 of the License, or (at
+  * your option) any later version.
+  *
+  * This file is distributed in the hope that it will be useful, but
+  * WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+  * General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+  *
+  * This file incorporates work covered by the following copyright and
+  * permission notice:
+  *     The Synopsys DWC ETHER XGMAC Software Driver and documentation
+  *     (hereinafter "Software") is an unsupported proprietary work of Synopsys,
+  *     Inc. unless otherwise expressly agreed to in writing between Synopsys
+  *     and you.
+  *
+  *     The Software IS NOT an item of Licensed Software or Licensed Product
+  *     under any End User Software License Agreement or Agreement for Licensed
+  *     Product with Synopsys or any supplement thereto.  Permission is hereby
+  *     granted, free of charge, to any person obtaining a copy of this software
+  *     annotated with this license and the Software, to deal in the Software
+  *     without restriction, including without limitation the rights to use,
+  *     copy, modify, merge, publish, distribute, sublicense, and/or sell copies
+  *     of the Software, and to permit persons to whom the Software is furnished
+  *     to do so, subject to the following conditions:
+  *
+  *     The above copyright notice and this permission notice shall be included
+  *     in all copies or substantial portions of the Software.
+  *
+  *     THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS"
+  *     BASIS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  *     TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  *     PARTICULAR PURPOSE ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS
+  *     BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  *     CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  *     SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  *     INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  *     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  *     ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  *     THE POSSIBILITY OF SUCH DAMAGE.
+  *
+  *
+  * License 2: Modified BSD
+  *
+  * Copyright (c) 2015,2016 Baikal Electronics JSC.
+  * Copyright (c) 2014 Advanced Micro Devices, Inc.
+  * All rights reserved.
+  *
+  * Redistribution and use in source and binary forms, with or without
+  * modification, are permitted provided that the following conditions are met:
+  *     * Redistributions of source code must retain the above copyright
+  *       notice, this list of conditions and the following disclaimer.
+  *     * Redistributions in binary form must reproduce the above copyright
+  *       notice, this list of conditions and the following disclaimer in the
+  *       documentation and/or other materials provided with the distribution.
+  *     * Neither the name of Advanced Micro Devices, Inc. nor the
+  *       names of its contributors may be used to endorse or promote products
+  *       derived from this software without specific prior written permission.
+  *
+  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+  * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
+  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+  *
+  * This file incorporates work covered by the following copyright and
+  * permission notice:
+  *     The Synopsys DWC ETHER XGMAC Software Driver and documentation
+  *     (hereinafter "Software") is an unsupported proprietary work of Synopsys,
+  *     Inc. unless otherwise expressly agreed to in writing between Synopsys
+  *     and you.
+  *
+  *     The Software IS NOT an item of Licensed Software or Licensed Product
+  *     under any End User Software License Agreement or Agreement for Licensed
+  *     Product with Synopsys or any supplement thereto.  Permission is hereby
+  *     granted, free of charge, to any person obtaining a copy of this software
+  *     annotated with this license and the Software, to deal in the Software
+  *     without restriction, including without limitation the rights to use,
+  *     copy, modify, merge, publish, distribute, sublicense, and/or sell copies
+  *     of the Software, and to permit persons to whom the Software is furnished
+  *     to do so, subject to the following conditions:
+  *
+  *     The above copyright notice and this permission notice shall be included
+  *     in all copies or substantial portions of the Software.
+  *
+  *     THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS"
+  *     BASIS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  *     TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  *     PARTICULAR PURPOSE ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS
+  *     BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  *     CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  *     SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  *     INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  *     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  *     ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  *     THE POSSIBILITY OF SUCH DAMAGE.
+  */
+ 
+ #include <linux/module.h>
+ #include <linux/kmod.h>
+ #include <linux/mdio.h>
+ #include <linux/phy.h>
+ #include <linux/of.h>
+ 
+ #include "xgbe.h"
+ #include "xgbe-common.h"
+ 
+ static int xgbe_mdio_read(struct mii_bus *mii, int prtad, int mmd_reg)
+ {
+ 	struct xgbe_prv_data *pdata = mii->priv;
+ 	struct xgbe_hw_if *hw_if = &pdata->hw_if;
+ 	int mmd_data;
+ 
+ 	DBGPR_MDIO("-->xgbe_mdio_read: prtad=%#x mmd_reg=%#x\n",
+ 		   prtad, mmd_reg);
+ #ifdef CONFIG_BAIKAL_ERRATA_XGMAC
+ 	mmd_data = mmd_reg & 0xFFFF;
+ 	if (mmd_data == MDIO_DEVS1)
+ 		mmd_reg = (mmd_reg & 0XFFFF0000) | MDIO_DEVS2;
+ 	else if (mmd_data == MDIO_DEVS2)
+ 		mmd_reg = (mmd_reg & 0XFFFF0000) | MDIO_DEVS1;
+ #endif
+ 	mmd_data = hw_if->read_mmd_regs(pdata, prtad, mmd_reg);
+ 
+ 	DBGPR_MDIO("<--xgbe_mdio_read: mmd_data=%#x\n", mmd_data);
+ 
+ 	return mmd_data;
+ }
+ 
+ static int xgbe_mdio_write(struct mii_bus *mii, int prtad, int mmd_reg,
+ 			   u16 mmd_val)
+ {
+ 	struct xgbe_prv_data *pdata = mii->priv;
+ 	struct xgbe_hw_if *hw_if = &pdata->hw_if;
+ 	int mmd_data = mmd_val;
+ 
+ 	DBGPR_MDIO("-->xgbe_mdio_write: prtad=%#x mmd_reg=%#x mmd_data=%#x\n",
+ 		   prtad, mmd_reg, mmd_data);
+ 
+ 	hw_if->write_mmd_regs(pdata, prtad, mmd_reg, mmd_data);
+ 
+ 	DBGPR_MDIO("<--xgbe_mdio_write\n");
+ 
+ 	return 0;
+ }
+ 
+ void xgbe_dump_phy_registers(struct xgbe_prv_data *pdata)
+ {
+ 	struct device *dev = pdata->dev;
+ 	struct phy_device *phydev = pdata->mii->phy_map[XGBE_PRTAD];
+ 	int i;
+ 
+ 	dev_alert(dev, "\n************* PHY Reg dump **********************\n");
+ 
+ 	dev_alert(dev, "PCS Control Reg (%#04x) = %#04x\n", MDIO_CTRL1,
+ 		  XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_CTRL1));
+ 	dev_alert(dev, "PCS Status Reg (%#04x) = %#04x\n", MDIO_STAT1,
+ 		  XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_STAT1));
+ 	dev_alert(dev, "Phy Id (PHYS ID 1 %#04x)= %#04x\n", MDIO_DEVID1,
+ 		  XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_DEVID1));
+ 	dev_alert(dev, "Phy Id (PHYS ID 2 %#04x)= %#04x\n", MDIO_DEVID2,
+ 		  XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_DEVID2));
+ 	dev_alert(dev, "Devices in Package (%#04x)= %#04x\n", MDIO_DEVS1,
+ 		  XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_DEVS1));
+ 	dev_alert(dev, "Devices in Package (%#04x)= %#04x\n", MDIO_DEVS2,
+ 		  XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_DEVS2));
+ 
+ 	dev_alert(dev, "Auto-Neg Control Reg (%#04x) = %#04x\n", MDIO_CTRL1,
+ 		  XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_CTRL1));
+ 	dev_alert(dev, "Auto-Neg Status Reg (%#04x) = %#04x\n", MDIO_STAT1,
+ 		  XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_STAT1));
+ 	dev_alert(dev, "Auto-Neg Ad Reg 1 (%#04x) = %#04x\n",
+ 		  MDIO_AN_ADVERTISE,
+ 		  XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_ADVERTISE));
+ 	dev_alert(dev, "Auto-Neg Ad Reg 2 (%#04x) = %#04x\n",
+ 		  MDIO_AN_ADVERTISE + 1,
+ 		  XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_ADVERTISE + 1));
+ 	dev_alert(dev, "Auto-Neg Ad Reg 3 (%#04x) = %#04x\n",
+ 		  MDIO_AN_ADVERTISE + 2,
+ 		  XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_ADVERTISE + 2));
+ 	dev_alert(dev, "Auto-Neg Completion Reg (%#04x) = %#04x\n",
+ 		  MDIO_AN_COMP_STAT,
+ 		  XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_COMP_STAT));
+ 
+ 	dev_alert(dev, "MMD Device Mask = %#x\n",
+ 		  phydev->c45_ids.devices_in_package);
+ 	for (i = 0; i < ARRAY_SIZE(phydev->c45_ids.device_ids); i++)
+ 		dev_alert(dev, "  MMD %d: ID = %#08x\n", i,
+ 			  phydev->c45_ids.device_ids[i]);
+ 
+ 	dev_alert(dev, "\n*************************************************\n");
+ }
+ 
+ int xgbe_mdio_register(struct xgbe_prv_data *pdata)
+ {
+ 	struct device_node *phy_node;
+ 	struct mii_bus *mii;
+ 	struct phy_device *phydev;
+ 	int ret = 0;
+ 
+ 	DBGPR("-->xgbe_mdio_register\n");
+ 
+ 	/* Retrieve the phy-handle */
+ 	phy_node = of_parse_phandle(pdata->dev->of_node, "phy-handle", 0);
+ 	if (!phy_node) {
+ 		dev_err(pdata->dev, "unable to parse phy-handle\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	mii = mdiobus_alloc();
+ 	if (mii == NULL) {
+ 		dev_err(pdata->dev, "mdiobus_alloc failed\n");
+ 		ret = -ENOMEM;
+ 		goto err_node_get;
+ 	}
+ 
+ 	/* Register on the MDIO bus (don't probe any PHYs) */
+ 	mii->name = XGBE_PHY_NAME;
+ 	mii->read = xgbe_mdio_read;
+ 	mii->write = xgbe_mdio_write;
+ 	snprintf(mii->id, sizeof(mii->id), "%s", pdata->mii_bus_id);
+ 	mii->priv = pdata;
+ 	mii->phy_mask = ~0;
+ 	mii->parent = pdata->dev;
+ 	ret = mdiobus_register(mii);
+ 	if (ret) {
+ 		dev_err(pdata->dev, "mdiobus_register failed\n");
+ 		goto err_mdiobus_alloc;
+ 	}
+ 	DBGPR("  mdiobus_register succeeded for %s\n", pdata->mii_bus_id);
+ 
+ 	/* Probe the PCS using Clause 45 */
+ 	phydev = get_phy_device(mii, XGBE_PRTAD, true);
+ 	if (IS_ERR(phydev) || !phydev ||
+ 	    !phydev->c45_ids.device_ids[MDIO_MMD_PCS]) {
+ 		dev_err(pdata->dev, "get_phy_device failed\n");
+ 		ret = phydev ? PTR_ERR(phydev) : -ENOLINK;
+ 		goto err_mdiobus_register;
+ 	}
+ 	request_module(MDIO_MODULE_PREFIX MDIO_ID_FMT,
+ 		       MDIO_ID_ARGS(phydev->c45_ids.device_ids[MDIO_MMD_PCS]));
+ 
+ 	of_node_get(phy_node);
+ 	phydev->dev.of_node = phy_node;
+ 
+ 	ret = phy_device_register(phydev);
+ 	if (ret) {
+ 		dev_err(pdata->dev, "phy_device_register failed\n");
+ 		of_node_put(phy_node);
+ 		goto err_phy_device;
+ 	}
+ 
+ 	/* Add a reference to the PHY driver so it can't be unloaded */
+ 	pdata->phy_module = phydev->dev.driver ?
+ 			    phydev->dev.driver->owner : NULL;
+ 	if (!try_module_get(pdata->phy_module)) {
+ 		dev_err(pdata->dev, "try_module_get failed\n");
+ 		ret = -EIO;
+ 		goto err_phy_device;
+ 	}
+ 
+ 	pdata->mii = mii;
+ 	pdata->mdio_mmd = MDIO_MMD_PCS;
+ 
+ 	phydev->autoneg = pdata->default_autoneg;
+ 	if (phydev->autoneg == AUTONEG_DISABLE) {
+ 		phydev->speed = pdata->default_speed;
+ 		phydev->duplex = DUPLEX_FULL;
+ 
+ 		phydev->advertising &= ~ADVERTISED_Autoneg;
+ 	}
+ 
+ 	pdata->phydev = phydev;
+ 
+ 	of_node_put(phy_node);
+ 
+ 	DBGPHY_REGS(pdata);
+ 
+ 	DBGPR("<--xgbe_mdio_register\n");
+ 
+ 	return 0;
+ 
+ err_phy_device:
+ 	phy_device_free(phydev);
+ 
+ err_mdiobus_register:
+ 	mdiobus_unregister(mii);
+ 
+ err_mdiobus_alloc:
+ 	mdiobus_free(mii);
+ 
+ err_node_get:
+ 	of_node_put(phy_node);
+ 
+ 	return ret;
+ }
+ 
+ void xgbe_mdio_unregister(struct xgbe_prv_data *pdata)
+ {
+ 	DBGPR("-->xgbe_mdio_unregister\n");
+ 
+ 	pdata->phydev = NULL;
+ 
+ 	module_put(pdata->phy_module);
+ 	pdata->phy_module = NULL;
+ 
+ 	mdiobus_unregister(pdata->mii);
+ 	pdata->mii->priv = NULL;
+ 
+ 	mdiobus_free(pdata->mii);
+ 	pdata->mii = NULL;
+ 
+ 	DBGPR("<--xgbe_mdio_unregister\n");
+ }
diff -rcNP linux-4.4.24/drivers/net/ethernet/baikal/xgbe/xgbe-ptp.c linux-4.4.24-baikal/drivers/net/ethernet/baikal/xgbe/xgbe-ptp.c
*** linux-4.4.24/drivers/net/ethernet/baikal/xgbe/xgbe-ptp.c	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/drivers/net/ethernet/baikal/xgbe/xgbe-ptp.c	2016-11-11 14:49:52.000000000 +0300
***************
*** 0 ****
--- 1,287 ----
+ /*
+  * Baikal Electronics 10Gb Ethernet driver
+  *
+  * Based on AMD 10Gb Ethernet driver
+  * drivers/net/ethernet/amd/xgbe
+  *
+  * This file is available to you under your choice of the following two
+  * licenses:
+  *
+  * License 1: GPLv2
+  *
+  * Copyright (c) 2015,2016 Baikal Electronics JSC.
+  * Copyright (c) 2014 Advanced Micro Devices, Inc.
+  *
+  * Adopted by:
+  *   Dmitry Dunaev <dmitry.dunaev@baikalelectronics.ru>
+  *
+  * This file is free software; you may copy, redistribute and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation, either version 2 of the License, or (at
+  * your option) any later version.
+  *
+  * This file is distributed in the hope that it will be useful, but
+  * WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+  * General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+  *
+  * This file incorporates work covered by the following copyright and
+  * permission notice:
+  *     The Synopsys DWC ETHER XGMAC Software Driver and documentation
+  *     (hereinafter "Software") is an unsupported proprietary work of Synopsys,
+  *     Inc. unless otherwise expressly agreed to in writing between Synopsys
+  *     and you.
+  *
+  *     The Software IS NOT an item of Licensed Software or Licensed Product
+  *     under any End User Software License Agreement or Agreement for Licensed
+  *     Product with Synopsys or any supplement thereto.  Permission is hereby
+  *     granted, free of charge, to any person obtaining a copy of this software
+  *     annotated with this license and the Software, to deal in the Software
+  *     without restriction, including without limitation the rights to use,
+  *     copy, modify, merge, publish, distribute, sublicense, and/or sell copies
+  *     of the Software, and to permit persons to whom the Software is furnished
+  *     to do so, subject to the following conditions:
+  *
+  *     The above copyright notice and this permission notice shall be included
+  *     in all copies or substantial portions of the Software.
+  *
+  *     THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS"
+  *     BASIS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  *     TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  *     PARTICULAR PURPOSE ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS
+  *     BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  *     CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  *     SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  *     INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  *     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  *     ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  *     THE POSSIBILITY OF SUCH DAMAGE.
+  *
+  *
+  * License 2: Modified BSD
+  *
+  * Copyright (c) 2015,2016 Baikal Electronics JSC.
+  * Copyright (c) 2014 Advanced Micro Devices, Inc.
+  * All rights reserved.
+  *
+  * Redistribution and use in source and binary forms, with or without
+  * modification, are permitted provided that the following conditions are met:
+  *     * Redistributions of source code must retain the above copyright
+  *       notice, this list of conditions and the following disclaimer.
+  *     * Redistributions in binary form must reproduce the above copyright
+  *       notice, this list of conditions and the following disclaimer in the
+  *       documentation and/or other materials provided with the distribution.
+  *     * Neither the name of Advanced Micro Devices, Inc. nor the
+  *       names of its contributors may be used to endorse or promote products
+  *       derived from this software without specific prior written permission.
+  *
+  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+  * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
+  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+  *
+  * This file incorporates work covered by the following copyright and
+  * permission notice:
+  *     The Synopsys DWC ETHER XGMAC Software Driver and documentation
+  *     (hereinafter "Software") is an unsupported proprietary work of Synopsys,
+  *     Inc. unless otherwise expressly agreed to in writing between Synopsys
+  *     and you.
+  *
+  *     The Software IS NOT an item of Licensed Software or Licensed Product
+  *     under any End User Software License Agreement or Agreement for Licensed
+  *     Product with Synopsys or any supplement thereto.  Permission is hereby
+  *     granted, free of charge, to any person obtaining a copy of this software
+  *     annotated with this license and the Software, to deal in the Software
+  *     without restriction, including without limitation the rights to use,
+  *     copy, modify, merge, publish, distribute, sublicense, and/or sell copies
+  *     of the Software, and to permit persons to whom the Software is furnished
+  *     to do so, subject to the following conditions:
+  *
+  *     The above copyright notice and this permission notice shall be included
+  *     in all copies or substantial portions of the Software.
+  *
+  *     THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS"
+  *     BASIS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  *     TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  *     PARTICULAR PURPOSE ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS
+  *     BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  *     CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  *     SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  *     INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  *     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  *     ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  *     THE POSSIBILITY OF SUCH DAMAGE.
+  */
+ 
+ #include <linux/clk.h>
+ #include <linux/clocksource.h>
+ #include <linux/ptp_clock_kernel.h>
+ #include <linux/net_tstamp.h>
+ 
+ #include "xgbe.h"
+ #include "xgbe-common.h"
+ 
+ static cycle_t xgbe_cc_read(const struct cyclecounter *cc)
+ {
+ 	struct xgbe_prv_data *pdata = container_of(cc,
+ 						   struct xgbe_prv_data,
+ 						   tstamp_cc);
+ 	u64 nsec;
+ 
+ 	nsec = pdata->hw_if.get_tstamp_time(pdata);
+ 
+ 	return nsec;
+ }
+ 
+ static int xgbe_adjfreq(struct ptp_clock_info *info, s32 delta)
+ {
+ 	struct xgbe_prv_data *pdata = container_of(info,
+ 						   struct xgbe_prv_data,
+ 						   ptp_clock_info);
+ 	unsigned long flags;
+ 	u64 adjust;
+ 	u32 addend, diff;
+ 	unsigned int neg_adjust = 0;
+ 
+ 	if (delta < 0) {
+ 		neg_adjust = 1;
+ 		delta = -delta;
+ 	}
+ 
+ 	adjust = pdata->tstamp_addend;
+ 	adjust *= delta;
+ 	diff = div_u64(adjust, 1000000000UL);
+ 
+ 	addend = (neg_adjust) ? pdata->tstamp_addend - diff :
+ 				pdata->tstamp_addend + diff;
+ 
+ 	spin_lock_irqsave(&pdata->tstamp_lock, flags);
+ 
+ 	pdata->hw_if.update_tstamp_addend(pdata, addend);
+ 
+ 	spin_unlock_irqrestore(&pdata->tstamp_lock, flags);
+ 
+ 	return 0;
+ }
+ 
+ static int xgbe_adjtime(struct ptp_clock_info *info, s64 delta)
+ {
+ 	struct xgbe_prv_data *pdata = container_of(info,
+ 						   struct xgbe_prv_data,
+ 						   ptp_clock_info);
+ 	unsigned long flags;
+ 
+ 	spin_lock_irqsave(&pdata->tstamp_lock, flags);
+ 	timecounter_adjtime(&pdata->tstamp_tc, delta);
+ 	spin_unlock_irqrestore(&pdata->tstamp_lock, flags);
+ 
+ 	return 0;
+ }
+ 
+ static int xgbe_gettime(struct ptp_clock_info *info, struct timespec64 *ts)
+ {
+ 	struct xgbe_prv_data *pdata = container_of(info,
+ 						   struct xgbe_prv_data,
+ 						   ptp_clock_info);
+ 	unsigned long flags;
+ 	u64 nsec;
+ 
+ 	spin_lock_irqsave(&pdata->tstamp_lock, flags);
+ 
+ 	nsec = timecounter_read(&pdata->tstamp_tc);
+ 
+ 	spin_unlock_irqrestore(&pdata->tstamp_lock, flags);
+ 
+ 	*ts = ns_to_timespec64(nsec);
+ 
+ 	return 0;
+ }
+ 
+ static int xgbe_settime(struct ptp_clock_info *info,
+ 			const struct timespec64 *ts)
+ {
+ 	struct xgbe_prv_data *pdata = container_of(info,
+ 						   struct xgbe_prv_data,
+ 						   ptp_clock_info);
+ 	unsigned long flags;
+ 	u64 nsec;
+ 
+ 	nsec = timespec64_to_ns(ts);
+ 
+ 	spin_lock_irqsave(&pdata->tstamp_lock, flags);
+ 
+ 	timecounter_init(&pdata->tstamp_tc, &pdata->tstamp_cc, nsec);
+ 
+ 	spin_unlock_irqrestore(&pdata->tstamp_lock, flags);
+ 
+ 	return 0;
+ }
+ 
+ static int xgbe_enable(struct ptp_clock_info *info,
+ 		       struct ptp_clock_request *request, int on)
+ {
+ 	return -EOPNOTSUPP;
+ }
+ 
+ void xgbe_ptp_register(struct xgbe_prv_data *pdata)
+ {
+ 	struct ptp_clock_info *info = &pdata->ptp_clock_info;
+ 	struct ptp_clock *clock;
+ 	struct cyclecounter *cc = &pdata->tstamp_cc;
+ 	u64 dividend;
+ 
+ 	snprintf(info->name, sizeof(info->name), "%s",
+ 		 netdev_name(pdata->netdev));
+ 	info->owner = THIS_MODULE;
+ 	info->max_adj = clk_get_rate(pdata->ptpclk);
+ 	info->adjfreq = xgbe_adjfreq;
+ 	info->adjtime = xgbe_adjtime;
+ 	info->gettime64 = xgbe_gettime;
+ 	info->settime64 = xgbe_settime;
+ 	info->enable = xgbe_enable;
+ 
+ 	clock = ptp_clock_register(info, pdata->dev);
+ 	if (IS_ERR(clock)) {
+ 		dev_err(pdata->dev, "ptp_clock_register failed\n");
+ 		return;
+ 	}
+ 
+ 	pdata->ptp_clock = clock;
+ 
+ 	/* Calculate the addend:
+ 	 *   addend = 2^32 / (PTP ref clock / 50Mhz)
+ 	 *          = (2^32 * 50Mhz) / PTP ref clock
+ 	 */
+ 	dividend = 50000000;
+ 	dividend <<= 32;
+ 	pdata->tstamp_addend = div_u64(dividend, clk_get_rate(pdata->ptpclk));
+ 
+ 	/* Setup the timecounter */
+ 	cc->read = xgbe_cc_read;
+ 	cc->mask = CLOCKSOURCE_MASK(64);
+ 	cc->mult = 1;
+ 	cc->shift = 0;
+ 
+ 	timecounter_init(&pdata->tstamp_tc, &pdata->tstamp_cc,
+ 			 ktime_to_ns(ktime_get_real()));
+ 
+ 	/* Disable all timestamping to start */
+ 	XGMAC_IOWRITE(pdata, MAC_TCR, 0);
+ 	pdata->tstamp_config.tx_type = HWTSTAMP_TX_OFF;
+ 	pdata->tstamp_config.rx_filter = HWTSTAMP_FILTER_NONE;
+ }
+ 
+ void xgbe_ptp_unregister(struct xgbe_prv_data *pdata)
+ {
+ 	if (pdata->ptp_clock)
+ 		ptp_clock_unregister(pdata->ptp_clock);
+ }
diff -rcNP linux-4.4.24/drivers/net/ethernet/Kconfig linux-4.4.24-baikal/drivers/net/ethernet/Kconfig
*** linux-4.4.24/drivers/net/ethernet/Kconfig	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/net/ethernet/Kconfig	2016-11-11 14:49:52.000000000 +0300
***************
*** 32,37 ****
--- 32,38 ----
  source "drivers/net/ethernet/aurora/Kconfig"
  source "drivers/net/ethernet/cadence/Kconfig"
  source "drivers/net/ethernet/adi/Kconfig"
+ source "drivers/net/ethernet/baikal/Kconfig"
  source "drivers/net/ethernet/broadcom/Kconfig"
  source "drivers/net/ethernet/brocade/Kconfig"
  source "drivers/net/ethernet/calxeda/Kconfig"
diff -rcNP linux-4.4.24/drivers/net/ethernet/Makefile linux-4.4.24-baikal/drivers/net/ethernet/Makefile
*** linux-4.4.24/drivers/net/ethernet/Makefile	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/net/ethernet/Makefile	2016-11-11 14:49:52.000000000 +0300
***************
*** 17,22 ****
--- 17,23 ----
  obj-$(CONFIG_NET_VENDOR_ATHEROS) += atheros/
  obj-$(CONFIG_NET_VENDOR_AURORA) += aurora/
  obj-$(CONFIG_NET_CADENCE) += cadence/
+ obj-$(CONFIG_NET_VENDOR_BAIKAL) += baikal/
  obj-$(CONFIG_NET_BFIN) += adi/
  obj-$(CONFIG_NET_VENDOR_BROADCOM) += broadcom/
  obj-$(CONFIG_NET_VENDOR_BROCADE) += brocade/
diff -rcNP linux-4.4.24/drivers/net/ethernet/stmicro/stmmac/chain_mode.c linux-4.4.24-baikal/drivers/net/ethernet/stmicro/stmmac/chain_mode.c
*** linux-4.4.24/drivers/net/ethernet/stmicro/stmmac/chain_mode.c	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/net/ethernet/stmicro/stmmac/chain_mode.c	2016-11-11 14:49:53.000000000 +0300
***************
*** 31,38 ****
  static int stmmac_jumbo_frm(void *p, struct sk_buff *skb, int csum)
  {
  	struct stmmac_priv *priv = (struct stmmac_priv *)p;
! 	unsigned int txsize = priv->dma_tx_size;
! 	unsigned int entry = priv->cur_tx % txsize;
  	struct dma_desc *desc = priv->dma_tx + entry;
  	unsigned int nopaged_len = skb_headlen(skb);
  	unsigned int bmax;
--- 31,37 ----
  static int stmmac_jumbo_frm(void *p, struct sk_buff *skb, int csum)
  {
  	struct stmmac_priv *priv = (struct stmmac_priv *)p;
! 	unsigned int entry = priv->cur_tx;
  	struct dma_desc *desc = priv->dma_tx + entry;
  	unsigned int nopaged_len = skb_headlen(skb);
  	unsigned int bmax;
***************
*** 50,60 ****
  	if (dma_mapping_error(priv->device, desc->des2))
  		return -1;
  	priv->tx_skbuff_dma[entry].buf = desc->des2;
! 	priv->hw->desc->prepare_tx_desc(desc, 1, bmax, csum, STMMAC_CHAIN_MODE);
  
  	while (len != 0) {
  		priv->tx_skbuff[entry] = NULL;
! 		entry = (++priv->cur_tx) % txsize;
  		desc = priv->dma_tx + entry;
  
  		if (len > bmax) {
--- 49,62 ----
  	if (dma_mapping_error(priv->device, desc->des2))
  		return -1;
  	priv->tx_skbuff_dma[entry].buf = desc->des2;
! 	priv->tx_skbuff_dma[entry].len = bmax;
! 	/* do not close the descriptor and do not set own bit */
! 	priv->hw->desc->prepare_tx_desc(desc, 1, bmax, csum, STMMAC_CHAIN_MODE,
! 					0, false);
  
  	while (len != 0) {
  		priv->tx_skbuff[entry] = NULL;
! 		entry = STMMAC_GET_ENTRY(entry, DMA_TX_SIZE);
  		desc = priv->dma_tx + entry;
  
  		if (len > bmax) {
***************
*** 64,72 ****
  			if (dma_mapping_error(priv->device, desc->des2))
  				return -1;
  			priv->tx_skbuff_dma[entry].buf = desc->des2;
  			priv->hw->desc->prepare_tx_desc(desc, 0, bmax, csum,
! 							STMMAC_CHAIN_MODE);
! 			priv->hw->desc->set_tx_owner(desc);
  			len -= bmax;
  			i++;
  		} else {
--- 66,75 ----
  			if (dma_mapping_error(priv->device, desc->des2))
  				return -1;
  			priv->tx_skbuff_dma[entry].buf = desc->des2;
+ 			priv->tx_skbuff_dma[entry].len = bmax;
  			priv->hw->desc->prepare_tx_desc(desc, 0, bmax, csum,
! 							STMMAC_CHAIN_MODE, 1,
! 							false);
  			len -= bmax;
  			i++;
  		} else {
***************
*** 76,87 ****
  			if (dma_mapping_error(priv->device, desc->des2))
  				return -1;
  			priv->tx_skbuff_dma[entry].buf = desc->des2;
  			priv->hw->desc->prepare_tx_desc(desc, 0, len, csum,
! 							STMMAC_CHAIN_MODE);
! 			priv->hw->desc->set_tx_owner(desc);
  			len = 0;
  		}
  	}
  	return entry;
  }
  
--- 79,95 ----
  			if (dma_mapping_error(priv->device, desc->des2))
  				return -1;
  			priv->tx_skbuff_dma[entry].buf = desc->des2;
+ 			priv->tx_skbuff_dma[entry].len = len;
+ 			/* last descriptor can be set now */
  			priv->hw->desc->prepare_tx_desc(desc, 0, len, csum,
! 							STMMAC_CHAIN_MODE, 1,
! 							true);
  			len = 0;
  		}
  	}
+ 
+ 	priv->cur_tx = entry;
+ 
  	return entry;
  }
  
***************
*** 138,160 ****
  		 */
  		p->des3 = (unsigned int)(priv->dma_rx_phy +
  					 (((priv->dirty_rx) + 1) %
! 					  priv->dma_rx_size) *
  					 sizeof(struct dma_desc));
  }
  
  static void stmmac_clean_desc3(void *priv_ptr, struct dma_desc *p)
  {
  	struct stmmac_priv *priv = (struct stmmac_priv *)priv_ptr;
  
! 	if (priv->hw->desc->get_tx_ls(p) && !priv->extend_desc)
  		/* NOTE: Device will overwrite des3 with timestamp value if
  		 * 1588-2002 time stamping is enabled, hence reinitialize it
  		 * to keep explicit chaining in the descriptor.
  		 */
! 		p->des3 = (unsigned int)(priv->dma_tx_phy +
! 					 (((priv->dirty_tx + 1) %
! 					   priv->dma_tx_size) *
! 					  sizeof(struct dma_desc)));
  }
  
  const struct stmmac_mode_ops chain_mode_ops = {
--- 146,169 ----
  		 */
  		p->des3 = (unsigned int)(priv->dma_rx_phy +
  					 (((priv->dirty_rx) + 1) %
! 					  DMA_RX_SIZE) *
  					 sizeof(struct dma_desc));
  }
  
  static void stmmac_clean_desc3(void *priv_ptr, struct dma_desc *p)
  {
  	struct stmmac_priv *priv = (struct stmmac_priv *)priv_ptr;
+ 	unsigned int entry = priv->dirty_tx;
  
! 	if (priv->tx_skbuff_dma[entry].last_segment && !priv->extend_desc &&
! 	    priv->hwts_tx_en)
  		/* NOTE: Device will overwrite des3 with timestamp value if
  		 * 1588-2002 time stamping is enabled, hence reinitialize it
  		 * to keep explicit chaining in the descriptor.
  		 */
! 		p->des3 = (unsigned int)((priv->dma_tx_phy +
! 					  ((priv->dirty_tx + 1) % DMA_TX_SIZE))
! 					  * sizeof(struct dma_desc));
  }
  
  const struct stmmac_mode_ops chain_mode_ops = {
diff -rcNP linux-4.4.24/drivers/net/ethernet/stmicro/stmmac/common.h linux-4.4.24-baikal/drivers/net/ethernet/stmicro/stmmac/common.h
*** linux-4.4.24/drivers/net/ethernet/stmicro/stmmac/common.h	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/net/ethernet/stmicro/stmmac/common.h	2016-11-11 14:49:53.000000000 +0300
***************
*** 27,32 ****
--- 27,33 ----
  
  #include <linux/etherdevice.h>
  #include <linux/netdevice.h>
+ #include <linux/stmmac.h>
  #include <linux/phy.h>
  #include <linux/module.h>
  #if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
***************
*** 41,46 ****
--- 42,51 ----
  #define	DWMAC_CORE_3_40	0x34
  #define	DWMAC_CORE_3_50	0x35
  
+ #define DMA_TX_SIZE 512
+ #define DMA_RX_SIZE 512
+ #define STMMAC_GET_ENTRY(x, size)	((x + 1) & (size - 1))
+ 
  #undef FRAME_FILTER_DEBUG
  /* #define FRAME_FILTER_DEBUG */
  
***************
*** 95,101 ****
  	unsigned long napi_poll;
  	unsigned long tx_normal_irq_n;
  	unsigned long tx_clean;
! 	unsigned long tx_reset_ic_bit;
  	unsigned long irq_receive_pmt_irq_n;
  	/* MMC info */
  	unsigned long mmc_tx_irq_n;
--- 100,106 ----
  	unsigned long napi_poll;
  	unsigned long tx_normal_irq_n;
  	unsigned long tx_clean;
! 	unsigned long tx_set_ic_bit;
  	unsigned long irq_receive_pmt_irq_n;
  	/* MMC info */
  	unsigned long mmc_tx_irq_n;
***************
*** 137,142 ****
--- 142,172 ----
  	unsigned long pcs_link;
  	unsigned long pcs_duplex;
  	unsigned long pcs_speed;
+ 	/* debug register */
+ 	unsigned long mtl_tx_status_fifo_full;
+ 	unsigned long mtl_tx_fifo_not_empty;
+ 	unsigned long mmtl_fifo_ctrl;
+ 	unsigned long mtl_tx_fifo_read_ctrl_write;
+ 	unsigned long mtl_tx_fifo_read_ctrl_wait;
+ 	unsigned long mtl_tx_fifo_read_ctrl_read;
+ 	unsigned long mtl_tx_fifo_read_ctrl_idle;
+ 	unsigned long mac_tx_in_pause;
+ 	unsigned long mac_tx_frame_ctrl_xfer;
+ 	unsigned long mac_tx_frame_ctrl_idle;
+ 	unsigned long mac_tx_frame_ctrl_wait;
+ 	unsigned long mac_tx_frame_ctrl_pause;
+ 	unsigned long mac_gmii_tx_proto_engine;
+ 	unsigned long mtl_rx_fifo_fill_level_full;
+ 	unsigned long mtl_rx_fifo_fill_above_thresh;
+ 	unsigned long mtl_rx_fifo_fill_below_thresh;
+ 	unsigned long mtl_rx_fifo_fill_level_empty;
+ 	unsigned long mtl_rx_fifo_read_ctrl_flush;
+ 	unsigned long mtl_rx_fifo_read_ctrl_read_data;
+ 	unsigned long mtl_rx_fifo_read_ctrl_status;
+ 	unsigned long mtl_rx_fifo_read_ctrl_idle;
+ 	unsigned long mtl_rx_fifo_ctrl_active;
+ 	unsigned long mac_rx_frame_ctrl_fifo;
+ 	unsigned long mac_gmii_rx_proto_engine;
  };
  
  /* CSR Frequency Access Defines*/
***************
*** 208,217 ****
  
  /* Rx IPC status */
  enum rx_frame_status {
! 	good_frame = 0,
! 	discard_frame = 1,
! 	csum_none = 2,
! 	llc_snap = 4,
  };
  
  enum dma_irq_status {
--- 238,256 ----
  
  /* Rx IPC status */
  enum rx_frame_status {
! 	good_frame = 0x0,
! 	discard_frame = 0x1,
! 	csum_none = 0x2,
! 	llc_snap = 0x4,
! 	dma_own = 0x8,
! };
! 
! /* Tx status */
! enum tx_frame_status {
! 	tx_done = 0x0,
! 	tx_not_ls = 0x1,
! 	tx_err = 0x2,
! 	tx_dma_own = 0x4,
  };
  
  enum dma_irq_status {
***************
*** 307,323 ****
  
  	/* Invoked by the xmit function to prepare the tx descriptor */
  	void (*prepare_tx_desc) (struct dma_desc *p, int is_fs, int len,
! 				 int csum_flag, int mode);
  	/* Set/get the owner of the descriptor */
  	void (*set_tx_owner) (struct dma_desc *p);
  	int (*get_tx_owner) (struct dma_desc *p);
- 	/* Invoked by the xmit function to close the tx descriptor */
- 	void (*close_tx_desc) (struct dma_desc *p);
  	/* Clean the tx descriptor as soon as the tx irq is received */
  	void (*release_tx_desc) (struct dma_desc *p, int mode);
  	/* Clear interrupt on tx frame completion. When this bit is
  	 * set an interrupt happens as soon as the frame is transmitted */
! 	void (*clear_tx_ic) (struct dma_desc *p);
  	/* Last tx segment reports the transmit status */
  	int (*get_tx_ls) (struct dma_desc *p);
  	/* Return the transmit status looking at the TDES1 */
--- 346,361 ----
  
  	/* Invoked by the xmit function to prepare the tx descriptor */
  	void (*prepare_tx_desc) (struct dma_desc *p, int is_fs, int len,
! 				 bool csum_flag, int mode, bool tx_own,
! 				 bool ls);
  	/* Set/get the owner of the descriptor */
  	void (*set_tx_owner) (struct dma_desc *p);
  	int (*get_tx_owner) (struct dma_desc *p);
  	/* Clean the tx descriptor as soon as the tx irq is received */
  	void (*release_tx_desc) (struct dma_desc *p, int mode);
  	/* Clear interrupt on tx frame completion. When this bit is
  	 * set an interrupt happens as soon as the frame is transmitted */
! 	void (*set_tx_ic)(struct dma_desc *p);
  	/* Last tx segment reports the transmit status */
  	int (*get_tx_ls) (struct dma_desc *p);
  	/* Return the transmit status looking at the TDES1 */
***************
*** 326,332 ****
  	/* Get the buffer size from the descriptor */
  	int (*get_tx_len) (struct dma_desc *p);
  	/* Handle extra events on specific interrupts hw dependent */
- 	int (*get_rx_owner) (struct dma_desc *p);
  	void (*set_rx_owner) (struct dma_desc *p);
  	/* Get the receive frame size */
  	int (*get_rx_frame_len) (struct dma_desc *p, int rx_coe_type);
--- 364,369 ----
***************
*** 351,358 ****
  /* Specific DMA helpers */
  struct stmmac_dma_ops {
  	/* DMA core initialization */
! 	int (*init) (void __iomem *ioaddr, int pbl, int fb, int mb,
! 		     int burst_len, u32 dma_tx, u32 dma_rx, int atds);
  	/* Dump DMA registers */
  	void (*dump_regs) (void __iomem *ioaddr);
  	/* Set tx/rx threshold in the csr6 register
--- 388,398 ----
  /* Specific DMA helpers */
  struct stmmac_dma_ops {
  	/* DMA core initialization */
! 	int (*reset)(void __iomem *ioaddr);
! 	void (*init)(void __iomem *ioaddr, int pbl, int fb, int mb,
! 		     int aal, u32 dma_tx, u32 dma_rx, int atds);
! 	/* Configure the AXI Bus Mode Register */
! 	void (*axi)(void __iomem *ioaddr, struct stmmac_axi *axi);
  	/* Dump DMA registers */
  	void (*dump_regs) (void __iomem *ioaddr);
  	/* Set tx/rx threshold in the csr6 register
***************
*** 408,419 ****
  	void (*set_eee_pls)(struct mac_device_info *hw, int link);
  	void (*ctrl_ane)(struct mac_device_info *hw, bool restart);
  	void (*get_adv)(struct mac_device_info *hw, struct rgmii_adv *adv);
  };
  
  /* PTP and HW Timer helpers */
  struct stmmac_hwtimestamp {
  	void (*config_hw_tstamping) (void __iomem *ioaddr, u32 data);
! 	void (*config_sub_second_increment) (void __iomem *ioaddr);
  	int (*init_systime) (void __iomem *ioaddr, u32 sec, u32 nsec);
  	int (*config_addend) (void __iomem *ioaddr, u32 addend);
  	int (*adjust_systime) (void __iomem *ioaddr, u32 sec, u32 nsec,
--- 448,460 ----
  	void (*set_eee_pls)(struct mac_device_info *hw, int link);
  	void (*ctrl_ane)(struct mac_device_info *hw, bool restart);
  	void (*get_adv)(struct mac_device_info *hw, struct rgmii_adv *adv);
+ 	void (*debug)(void __iomem *ioaddr, struct stmmac_extra_stats *x);
  };
  
  /* PTP and HW Timer helpers */
  struct stmmac_hwtimestamp {
  	void (*config_hw_tstamping) (void __iomem *ioaddr, u32 data);
! 	u32 (*config_sub_second_increment) (void __iomem *ioaddr, u32 clk_rate);
  	int (*init_systime) (void __iomem *ioaddr, u32 sec, u32 nsec);
  	int (*config_addend) (void __iomem *ioaddr, u32 addend);
  	int (*adjust_systime) (void __iomem *ioaddr, u32 sec, u32 nsec,
diff -rcNP linux-4.4.24/drivers/net/ethernet/stmicro/stmmac/descs_com.h linux-4.4.24-baikal/drivers/net/ethernet/stmicro/stmmac/descs_com.h
*** linux-4.4.24/drivers/net/ethernet/stmicro/stmmac/descs_com.h	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/net/ethernet/stmicro/stmmac/descs_com.h	2016-11-11 14:49:53.000000000 +0300
***************
*** 35,134 ****
  /* Enhanced descriptors */
  static inline void ehn_desc_rx_set_on_ring(struct dma_desc *p, int end)
  {
! 	p->des01.erx.buffer2_size = BUF_SIZE_8KiB - 1;
! 	if (end)
! 		p->des01.erx.end_ring = 1;
! }
  
- static inline void ehn_desc_tx_set_on_ring(struct dma_desc *p, int end)
- {
  	if (end)
! 		p->des01.etx.end_ring = 1;
  }
  
! static inline void enh_desc_end_tx_desc_on_ring(struct dma_desc *p, int ter)
  {
! 	p->des01.etx.end_ring = ter;
  }
  
  static inline void enh_set_tx_desc_len_on_ring(struct dma_desc *p, int len)
  {
  	if (unlikely(len > BUF_SIZE_4KiB)) {
! 		p->des01.etx.buffer1_size = BUF_SIZE_4KiB;
! 		p->des01.etx.buffer2_size = len - BUF_SIZE_4KiB;
  	} else
! 		p->des01.etx.buffer1_size = len;
  }
  
  /* Normal descriptors */
  static inline void ndesc_rx_set_on_ring(struct dma_desc *p, int end)
  {
! 	p->des01.rx.buffer2_size = BUF_SIZE_2KiB - 1;
! 	if (end)
! 		p->des01.rx.end_ring = 1;
! }
  
- static inline void ndesc_tx_set_on_ring(struct dma_desc *p, int end)
- {
  	if (end)
! 		p->des01.tx.end_ring = 1;
  }
  
! static inline void ndesc_end_tx_desc_on_ring(struct dma_desc *p, int ter)
  {
! 	p->des01.tx.end_ring = ter;
  }
  
  static inline void norm_set_tx_desc_len_on_ring(struct dma_desc *p, int len)
  {
  	if (unlikely(len > BUF_SIZE_2KiB)) {
! 		p->des01.etx.buffer1_size = BUF_SIZE_2KiB - 1;
! 		p->des01.etx.buffer2_size = len - p->des01.etx.buffer1_size;
  	} else
! 		p->des01.tx.buffer1_size = len;
  }
  
  /* Specific functions used for Chain mode */
  
  /* Enhanced descriptors */
! static inline void ehn_desc_rx_set_on_chain(struct dma_desc *p, int end)
! {
! 	p->des01.erx.second_address_chained = 1;
! }
! 
! static inline void ehn_desc_tx_set_on_chain(struct dma_desc *p, int end)
  {
! 	p->des01.etx.second_address_chained = 1;
  }
  
! static inline void enh_desc_end_tx_desc_on_chain(struct dma_desc *p, int ter)
  {
! 	p->des01.etx.second_address_chained = 1;
  }
  
  static inline void enh_set_tx_desc_len_on_chain(struct dma_desc *p, int len)
  {
! 	p->des01.etx.buffer1_size = len;
  }
  
  /* Normal descriptors */
  static inline void ndesc_rx_set_on_chain(struct dma_desc *p, int end)
  {
! 	p->des01.rx.second_address_chained = 1;
! }
! 
! static inline void ndesc_tx_set_on_chain(struct dma_desc *p, int ring_size)
! {
! 	p->des01.tx.second_address_chained = 1;
  }
  
! static inline void ndesc_end_tx_desc_on_chain(struct dma_desc *p, int ter)
  {
! 	p->des01.tx.second_address_chained = 1;
  }
  
  static inline void norm_set_tx_desc_len_on_chain(struct dma_desc *p, int len)
  {
! 	p->des01.tx.buffer1_size = len;
  }
  #endif /* __DESC_COM_H__ */
--- 35,125 ----
  /* Enhanced descriptors */
  static inline void ehn_desc_rx_set_on_ring(struct dma_desc *p, int end)
  {
! 	p->des1 |= ((BUF_SIZE_8KiB - 1) << ERDES1_BUFFER2_SIZE_SHIFT)
! 		   & ERDES1_BUFFER2_SIZE_MASK;
  
  	if (end)
! 		p->des1 |= ERDES1_END_RING;
  }
  
! static inline void enh_desc_end_tx_desc_on_ring(struct dma_desc *p, int end)
  {
! 	if (end)
! 		p->des0 |= ETDES0_END_RING;
! 	else
! 		p->des0 &= ~ETDES0_END_RING;
  }
  
  static inline void enh_set_tx_desc_len_on_ring(struct dma_desc *p, int len)
  {
  	if (unlikely(len > BUF_SIZE_4KiB)) {
! 		p->des1 |= (((len - BUF_SIZE_4KiB) << ETDES1_BUFFER2_SIZE_SHIFT)
! 			    & ETDES1_BUFFER2_SIZE_MASK) | (BUF_SIZE_4KiB
! 			    & ETDES1_BUFFER1_SIZE_MASK);
  	} else
! 		p->des1 |= (len & ETDES1_BUFFER1_SIZE_MASK);
  }
  
  /* Normal descriptors */
  static inline void ndesc_rx_set_on_ring(struct dma_desc *p, int end)
  {
! 	p->des1 |= ((BUF_SIZE_2KiB - 1) << RDES1_BUFFER2_SIZE_SHIFT)
! 		    & RDES1_BUFFER2_SIZE_MASK;
  
  	if (end)
! 		p->des1 |= RDES1_END_RING;
  }
  
! static inline void ndesc_end_tx_desc_on_ring(struct dma_desc *p, int end)
  {
! 	if (end)
! 		p->des1 |= TDES1_END_RING;
! 	else
! 		p->des1 &= ~TDES1_END_RING;
  }
  
  static inline void norm_set_tx_desc_len_on_ring(struct dma_desc *p, int len)
  {
  	if (unlikely(len > BUF_SIZE_2KiB)) {
! 		unsigned int buffer1 = (BUF_SIZE_2KiB - 1)
! 					& TDES1_BUFFER1_SIZE_MASK;
! 		p->des1 |= ((((len - buffer1) << TDES1_BUFFER2_SIZE_SHIFT)
! 			    & TDES1_BUFFER2_SIZE_MASK) | buffer1);
  	} else
! 		p->des1 |= (len & TDES1_BUFFER1_SIZE_MASK);
  }
  
  /* Specific functions used for Chain mode */
  
  /* Enhanced descriptors */
! static inline void ehn_desc_rx_set_on_chain(struct dma_desc *p)
  {
! 	p->des1 |= ERDES1_SECOND_ADDRESS_CHAINED;
  }
  
! static inline void enh_desc_end_tx_desc_on_chain(struct dma_desc *p)
  {
! 	p->des0 |= ETDES0_SECOND_ADDRESS_CHAINED;
  }
  
  static inline void enh_set_tx_desc_len_on_chain(struct dma_desc *p, int len)
  {
! 	p->des1 |= (len & ETDES1_BUFFER1_SIZE_MASK);
  }
  
  /* Normal descriptors */
  static inline void ndesc_rx_set_on_chain(struct dma_desc *p, int end)
  {
! 	p->des1 |= RDES1_SECOND_ADDRESS_CHAINED;
  }
  
! static inline void ndesc_tx_set_on_chain(struct dma_desc *p)
  {
! 	p->des1 |= TDES1_SECOND_ADDRESS_CHAINED;
  }
  
  static inline void norm_set_tx_desc_len_on_chain(struct dma_desc *p, int len)
  {
! 	p->des1 |= len & TDES1_BUFFER1_SIZE_MASK;
  }
  #endif /* __DESC_COM_H__ */
diff -rcNP linux-4.4.24/drivers/net/ethernet/stmicro/stmmac/descs.h linux-4.4.24-baikal/drivers/net/ethernet/stmicro/stmmac/descs.h
*** linux-4.4.24/drivers/net/ethernet/stmicro/stmmac/descs.h	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/net/ethernet/stmicro/stmmac/descs.h	2016-11-11 14:49:53.000000000 +0300
***************
*** 1,6 ****
  /*******************************************************************************
!   Header File to describe the DMA descriptors.
!   Enhanced descriptors have been in case of DWMAC1000 Cores.
  
    This program is free software; you can redistribute it and/or modify it
    under the terms and conditions of the GNU General Public License,
--- 1,6 ----
  /*******************************************************************************
!   Header File to describe the DMA descriptors and related definitions.
!   This is for DWMAC100 and 1000 cores.
  
    This program is free software; you can redistribute it and/or modify it
    under the terms and conditions of the GNU General Public License,
***************
*** 24,221 ****
  #ifndef __DESCS_H__
  #define __DESCS_H__
  
! /* Basic descriptor structure for normal and alternate descriptors */
! struct dma_desc {
! 	/* Receive descriptor */
! 	union {
! 		struct {
! 			/* RDES0 */
! 			u32 payload_csum_error:1;
! 			u32 crc_error:1;
! 			u32 dribbling:1;
! 			u32 mii_error:1;
! 			u32 receive_watchdog:1;
! 			u32 frame_type:1;
! 			u32 collision:1;
! 			u32 ipc_csum_error:1;
! 			u32 last_descriptor:1;
! 			u32 first_descriptor:1;
! 			u32 vlan_tag:1;
! 			u32 overflow_error:1;
! 			u32 length_error:1;
! 			u32 sa_filter_fail:1;
! 			u32 descriptor_error:1;
! 			u32 error_summary:1;
! 			u32 frame_length:14;
! 			u32 da_filter_fail:1;
! 			u32 own:1;
! 			/* RDES1 */
! 			u32 buffer1_size:11;
! 			u32 buffer2_size:11;
! 			u32 reserved1:2;
! 			u32 second_address_chained:1;
! 			u32 end_ring:1;
! 			u32 reserved2:5;
! 			u32 disable_ic:1;
! 
! 		} rx;
! 		struct {
! 			/* RDES0 */
! 			u32 rx_mac_addr:1;
! 			u32 crc_error:1;
! 			u32 dribbling:1;
! 			u32 error_gmii:1;
! 			u32 receive_watchdog:1;
! 			u32 frame_type:1;
! 			u32 late_collision:1;
! 			u32 ipc_csum_error:1;
! 			u32 last_descriptor:1;
! 			u32 first_descriptor:1;
! 			u32 vlan_tag:1;
! 			u32 overflow_error:1;
! 			u32 length_error:1;
! 			u32 sa_filter_fail:1;
! 			u32 descriptor_error:1;
! 			u32 error_summary:1;
! 			u32 frame_length:14;
! 			u32 da_filter_fail:1;
! 			u32 own:1;
  			/* RDES1 */
! 			u32 buffer1_size:13;
! 			u32 reserved1:1;
! 			u32 second_address_chained:1;
! 			u32 end_ring:1;
! 			u32 buffer2_size:13;
! 			u32 reserved2:2;
! 			u32 disable_ic:1;
! 		} erx;		/* -- enhanced -- */
! 
! 		/* Transmit descriptor */
! 		struct {
! 			/* TDES0 */
! 			u32 deferred:1;
! 			u32 underflow_error:1;
! 			u32 excessive_deferral:1;
! 			u32 collision_count:4;
! 			u32 vlan_frame:1;
! 			u32 excessive_collisions:1;
! 			u32 late_collision:1;
! 			u32 no_carrier:1;
! 			u32 loss_carrier:1;
! 			u32 payload_error:1;
! 			u32 frame_flushed:1;
! 			u32 jabber_timeout:1;
! 			u32 error_summary:1;
! 			u32 ip_header_error:1;
! 			u32 time_stamp_status:1;
! 			u32 reserved1:13;
! 			u32 own:1;
! 			/* TDES1 */
! 			u32 buffer1_size:11;
! 			u32 buffer2_size:11;
! 			u32 time_stamp_enable:1;
! 			u32 disable_padding:1;
! 			u32 second_address_chained:1;
! 			u32 end_ring:1;
! 			u32 crc_disable:1;
! 			u32 checksum_insertion:2;
! 			u32 first_segment:1;
! 			u32 last_segment:1;
! 			u32 interrupt:1;
! 		} tx;
! 		struct {
! 			/* TDES0 */
! 			u32 deferred:1;
! 			u32 underflow_error:1;
! 			u32 excessive_deferral:1;
! 			u32 collision_count:4;
! 			u32 vlan_frame:1;
! 			u32 excessive_collisions:1;
! 			u32 late_collision:1;
! 			u32 no_carrier:1;
! 			u32 loss_carrier:1;
! 			u32 payload_error:1;
! 			u32 frame_flushed:1;
! 			u32 jabber_timeout:1;
! 			u32 error_summary:1;
! 			u32 ip_header_error:1;
! 			u32 time_stamp_status:1;
! 			u32 reserved1:2;
! 			u32 second_address_chained:1;
! 			u32 end_ring:1;
! 			u32 checksum_insertion:2;
! 			u32 reserved2:1;
! 			u32 time_stamp_enable:1;
! 			u32 disable_padding:1;
! 			u32 crc_disable:1;
! 			u32 first_segment:1;
! 			u32 last_segment:1;
! 			u32 interrupt:1;
! 			u32 own:1;
! 			/* TDES1 */
! 			u32 buffer1_size:13;
! 			u32 reserved3:3;
! 			u32 buffer2_size:13;
! 			u32 reserved4:3;
! 		} etx;		/* -- enhanced -- */
  
! 		u64 all_flags;
! 	} des01;
  	unsigned int des2;
  	unsigned int des3;
  };
  
! /* Extended descriptor structure (supported by new SYNP GMAC generations) */
  struct dma_extended_desc {
! 	struct dma_desc basic;
! 	union {
! 		struct {
! 			u32 ip_payload_type:3;
! 			u32 ip_hdr_err:1;
! 			u32 ip_payload_err:1;
! 			u32 ip_csum_bypassed:1;
! 			u32 ipv4_pkt_rcvd:1;
! 			u32 ipv6_pkt_rcvd:1;
! 			u32 msg_type:4;
! 			u32 ptp_frame_type:1;
! 			u32 ptp_ver:1;
! 			u32 timestamp_dropped:1;
! 			u32 reserved:1;
! 			u32 av_pkt_rcvd:1;
! 			u32 av_tagged_pkt_rcvd:1;
! 			u32 vlan_tag_priority_val:3;
! 			u32 reserved3:3;
! 			u32 l3_filter_match:1;
! 			u32 l4_filter_match:1;
! 			u32 l3_l4_filter_no_match:2;
! 			u32 reserved4:4;
! 		} erx;
! 		struct {
! 			u32 reserved;
! 		} etx;
! 	} des4;
  	unsigned int des5;	/* Reserved */
  	unsigned int des6;	/* Tx/Rx Timestamp Low */
  	unsigned int des7;	/* Tx/Rx Timestamp High */
  };
  
  /* Transmit checksum insertion control */
! enum tdes_csum_insertion {
! 	cic_disabled = 0,	/* Checksum Insertion Control */
! 	cic_only_ip = 1,	/* Only IP header */
! 	/* IP header but pseudoheader is not calculated */
! 	cic_no_pseudoheader = 2,
! 	cic_full = 3,		/* IP header and pseudoheader */
! };
! 
! /* Extended RDES4 definitions */
! #define RDES_EXT_NO_PTP			0
! #define RDES_EXT_SYNC			0x1
! #define RDES_EXT_FOLLOW_UP		0x2
! #define RDES_EXT_DELAY_REQ		0x3
! #define RDES_EXT_DELAY_RESP		0x4
! #define RDES_EXT_PDELAY_REQ		0x5
! #define RDES_EXT_PDELAY_RESP		0x6
! #define RDES_EXT_PDELAY_FOLLOW_UP	0x7
  
  #endif /* __DESCS_H__ */
--- 24,187 ----
  #ifndef __DESCS_H__
  #define __DESCS_H__
  
! #include <linux/bitops.h>
! 
! /* Normal receive descriptor defines */
! 
! /* RDES0 */
! #define	RDES0_PAYLOAD_CSUM_ERR	BIT(0)
! #define	RDES0_CRC_ERROR		BIT(1)
! #define	RDES0_DRIBBLING		BIT(2)
! #define	RDES0_MII_ERROR		BIT(3)
! #define	RDES0_RECEIVE_WATCHDOG	BIT(4)
! #define	RDES0_FRAME_TYPE	BIT(5)
! #define	RDES0_COLLISION		BIT(6)
! #define	RDES0_IPC_CSUM_ERROR	BIT(7)
! #define	RDES0_LAST_DESCRIPTOR	BIT(8)
! #define	RDES0_FIRST_DESCRIPTOR	BIT(9)
! #define	RDES0_VLAN_TAG		BIT(10)
! #define	RDES0_OVERFLOW_ERROR	BIT(11)
! #define	RDES0_LENGTH_ERROR	BIT(12)
! #define	RDES0_SA_FILTER_FAIL	BIT(13)
! #define	RDES0_DESCRIPTOR_ERROR	BIT(14)
! #define	RDES0_ERROR_SUMMARY	BIT(15)
! #define	RDES0_FRAME_LEN_MASK	GENMASK(29, 16)
! #define RDES0_FRAME_LEN_SHIFT	16
! #define	RDES0_DA_FILTER_FAIL	BIT(30)
! #define	RDES0_OWN		BIT(31)
  			/* RDES1 */
! #define	RDES1_BUFFER1_SIZE_MASK		GENMASK(10, 0)
! #define	RDES1_BUFFER2_SIZE_MASK		GENMASK(21, 11)
! #define	RDES1_BUFFER2_SIZE_SHIFT	11
! #define	RDES1_SECOND_ADDRESS_CHAINED	BIT(24)
! #define	RDES1_END_RING			BIT(25)
! #define	RDES1_DISABLE_IC		BIT(31)
! 
! /* Enhanced receive descriptor defines */
! 
! /* RDES0 (similar to normal RDES) */
! #define	 ERDES0_RX_MAC_ADDR	BIT(0)
! 
! /* RDES1: completely differ from normal desc definitions */
! #define	ERDES1_BUFFER1_SIZE_MASK	GENMASK(12, 0)
! #define	ERDES1_SECOND_ADDRESS_CHAINED	BIT(14)
! #define	ERDES1_END_RING			BIT(15)
! #define	ERDES1_BUFFER2_SIZE_MASK	GENMASK(28, 16)
! #define ERDES1_BUFFER2_SIZE_SHIFT	16
! #define	ERDES1_DISABLE_IC		BIT(31)
! 
! /* Normal transmit descriptor defines */
! /* TDES0 */
! #define	TDES0_DEFERRED			BIT(0)
! #define	TDES0_UNDERFLOW_ERROR		BIT(1)
! #define	TDES0_EXCESSIVE_DEFERRAL	BIT(2)
! #define	TDES0_COLLISION_COUNT_MASK	GENMASK(6, 3)
! #define	TDES0_VLAN_FRAME		BIT(7)
! #define	TDES0_EXCESSIVE_COLLISIONS	BIT(8)
! #define	TDES0_LATE_COLLISION		BIT(9)
! #define	TDES0_NO_CARRIER		BIT(10)
! #define	TDES0_LOSS_CARRIER		BIT(11)
! #define	TDES0_PAYLOAD_ERROR		BIT(12)
! #define	TDES0_FRAME_FLUSHED		BIT(13)
! #define	TDES0_JABBER_TIMEOUT		BIT(14)
! #define	TDES0_ERROR_SUMMARY		BIT(15)
! #define	TDES0_IP_HEADER_ERROR		BIT(16)
! #define	TDES0_TIME_STAMP_STATUS		BIT(17)
! #define	TDES0_OWN			BIT(31)
! /* TDES1 */
! #define	TDES1_BUFFER1_SIZE_MASK		GENMASK(10, 0)
! #define	TDES1_BUFFER2_SIZE_MASK		GENMASK(21, 11)
! #define	TDES1_BUFFER2_SIZE_SHIFT	11
! #define	TDES1_TIME_STAMP_ENABLE		BIT(22)
! #define	TDES1_DISABLE_PADDING		BIT(23)
! #define	TDES1_SECOND_ADDRESS_CHAINED	BIT(24)
! #define	TDES1_END_RING			BIT(25)
! #define	TDES1_CRC_DISABLE		BIT(26)
! #define	TDES1_CHECKSUM_INSERTION_MASK	GENMASK(28, 27)
! #define	TDES1_CHECKSUM_INSERTION_SHIFT	27
! #define	TDES1_FIRST_SEGMENT		BIT(29)
! #define	TDES1_LAST_SEGMENT		BIT(30)
! #define	TDES1_INTERRUPT			BIT(31)
! 
! /* Enhanced transmit descriptor defines */
! /* TDES0 */
! #define	ETDES0_DEFERRED			BIT(0)
! #define	ETDES0_UNDERFLOW_ERROR		BIT(1)
! #define	ETDES0_EXCESSIVE_DEFERRAL	BIT(2)
! #define	ETDES0_COLLISION_COUNT_MASK	GENMASK(6, 3)
! #define	ETDES0_VLAN_FRAME		BIT(7)
! #define	ETDES0_EXCESSIVE_COLLISIONS	BIT(8)
! #define	ETDES0_LATE_COLLISION		BIT(9)
! #define	ETDES0_NO_CARRIER		BIT(10)
! #define	ETDES0_LOSS_CARRIER		BIT(11)
! #define	ETDES0_PAYLOAD_ERROR		BIT(12)
! #define	ETDES0_FRAME_FLUSHED		BIT(13)
! #define	ETDES0_JABBER_TIMEOUT		BIT(14)
! #define	ETDES0_ERROR_SUMMARY		BIT(15)
! #define	ETDES0_IP_HEADER_ERROR		BIT(16)
! #define	ETDES0_TIME_STAMP_STATUS	BIT(17)
! #define	ETDES0_SECOND_ADDRESS_CHAINED	BIT(20)
! #define	ETDES0_END_RING			BIT(21)
! #define	ETDES0_CHECKSUM_INSERTION_MASK	GENMASK(23, 22)
! #define	ETDES0_CHECKSUM_INSERTION_SHIFT	22
! #define	ETDES0_TIME_STAMP_ENABLE	BIT(25)
! #define	ETDES0_DISABLE_PADDING		BIT(26)
! #define	ETDES0_CRC_DISABLE		BIT(27)
! #define	ETDES0_FIRST_SEGMENT		BIT(28)
! #define	ETDES0_LAST_SEGMENT		BIT(29)
! #define	ETDES0_INTERRUPT		BIT(30)
! #define	ETDES0_OWN			BIT(31)
! /* TDES1 */
! #define	ETDES1_BUFFER1_SIZE_MASK	GENMASK(12, 0)
! #define	ETDES1_BUFFER2_SIZE_MASK	GENMASK(28, 16)
! #define	ETDES1_BUFFER2_SIZE_SHIFT	16
! 
! /* Extended Receive descriptor definitions */
! #define	ERDES4_IP_PAYLOAD_TYPE_MASK	GENMASK(2, 6)
! #define	ERDES4_IP_HDR_ERR		BIT(3)
! #define	ERDES4_IP_PAYLOAD_ERR		BIT(4)
! #define	ERDES4_IP_CSUM_BYPASSED		BIT(5)
! #define	ERDES4_IPV4_PKT_RCVD		BIT(6)
! #define	ERDES4_IPV6_PKT_RCVD		BIT(7)
! #define	ERDES4_MSG_TYPE_MASK		GENMASK(11, 8)
! #define	ERDES4_PTP_FRAME_TYPE		BIT(12)
! #define	ERDES4_PTP_VER			BIT(13)
! #define	ERDES4_TIMESTAMP_DROPPED	BIT(14)
! #define	ERDES4_AV_PKT_RCVD		BIT(16)
! #define	ERDES4_AV_TAGGED_PKT_RCVD	BIT(17)
! #define	ERDES4_VLAN_TAG_PRI_VAL_MASK	GENMASK(20, 18)
! #define	ERDES4_L3_FILTER_MATCH		BIT(24)
! #define	ERDES4_L4_FILTER_MATCH		BIT(25)
! #define	ERDES4_L3_L4_FILT_NO_MATCH_MASK	GENMASK(27, 26)
! 
! /* Extended RDES4 message type definitions */
! #define RDES_EXT_NO_PTP			0
! #define RDES_EXT_SYNC			1
! #define RDES_EXT_FOLLOW_UP		2
! #define RDES_EXT_DELAY_REQ		3
! #define RDES_EXT_DELAY_RESP		4
! #define RDES_EXT_PDELAY_REQ		5
! #define RDES_EXT_PDELAY_RESP		6
! #define RDES_EXT_PDELAY_FOLLOW_UP	7
  
! /* Basic descriptor structure for normal and alternate descriptors */
! struct dma_desc {
! 	unsigned int des0;
! 	unsigned int des1;
  	unsigned int des2;
  	unsigned int des3;
  };
  
! /* Extended descriptor structure (e.g. >= databook 3.50a) */
  struct dma_extended_desc {
! 	struct dma_desc basic;	/* Basic descriptors */
! 	unsigned int des4;	/* Extended Status */
  	unsigned int des5;	/* Reserved */
  	unsigned int des6;	/* Tx/Rx Timestamp Low */
  	unsigned int des7;	/* Tx/Rx Timestamp High */
  };
  
  /* Transmit checksum insertion control */
! #define	TX_CIC_FULL	3	/* Include IP header and pseudoheader */
  
  #endif /* __DESCS_H__ */
diff -rcNP linux-4.4.24/drivers/net/ethernet/stmicro/stmmac/dwmac1000_core.c linux-4.4.24-baikal/drivers/net/ethernet/stmicro/stmmac/dwmac1000_core.c
*** linux-4.4.24/drivers/net/ethernet/stmicro/stmmac/dwmac1000_core.c	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/net/ethernet/stmicro/stmmac/dwmac1000_core.c	2016-11-11 14:49:53.000000000 +0300
***************
*** 397,402 ****
--- 397,476 ----
  	adv->lp_pause = (value & GMAC_ANE_PSE) >> GMAC_ANE_PSE_SHIFT;
  }
  
+ static void dwmac1000_debug(void __iomem *ioaddr, struct stmmac_extra_stats *x)
+ {
+ 	u32 value = readl(ioaddr + GMAC_DEBUG);
+ 
+ 	if (value & GMAC_DEBUG_TXSTSFSTS)
+ 		x->mtl_tx_status_fifo_full++;
+ 	if (value & GMAC_DEBUG_TXFSTS)
+ 		x->mtl_tx_fifo_not_empty++;
+ 	if (value & GMAC_DEBUG_TWCSTS)
+ 		x->mmtl_fifo_ctrl++;
+ 	if (value & GMAC_DEBUG_TRCSTS_MASK) {
+ 		u32 trcsts = (value & GMAC_DEBUG_TRCSTS_MASK)
+ 			     >> GMAC_DEBUG_TRCSTS_SHIFT;
+ 		if (trcsts == GMAC_DEBUG_TRCSTS_WRITE)
+ 			x->mtl_tx_fifo_read_ctrl_write++;
+ 		else if (trcsts == GMAC_DEBUG_TRCSTS_TXW)
+ 			x->mtl_tx_fifo_read_ctrl_wait++;
+ 		else if (trcsts == GMAC_DEBUG_TRCSTS_READ)
+ 			x->mtl_tx_fifo_read_ctrl_read++;
+ 		else
+ 			x->mtl_tx_fifo_read_ctrl_idle++;
+ 	}
+ 	if (value & GMAC_DEBUG_TXPAUSED)
+ 		x->mac_tx_in_pause++;
+ 	if (value & GMAC_DEBUG_TFCSTS_MASK) {
+ 		u32 tfcsts = (value & GMAC_DEBUG_TFCSTS_MASK)
+ 			      >> GMAC_DEBUG_TFCSTS_SHIFT;
+ 
+ 		if (tfcsts == GMAC_DEBUG_TFCSTS_XFER)
+ 			x->mac_tx_frame_ctrl_xfer++;
+ 		else if (tfcsts == GMAC_DEBUG_TFCSTS_GEN_PAUSE)
+ 			x->mac_tx_frame_ctrl_pause++;
+ 		else if (tfcsts == GMAC_DEBUG_TFCSTS_WAIT)
+ 			x->mac_tx_frame_ctrl_wait++;
+ 		else
+ 			x->mac_tx_frame_ctrl_idle++;
+ 	}
+ 	if (value & GMAC_DEBUG_TPESTS)
+ 		x->mac_gmii_tx_proto_engine++;
+ 	if (value & GMAC_DEBUG_RXFSTS_MASK) {
+ 		u32 rxfsts = (value & GMAC_DEBUG_RXFSTS_MASK)
+ 			     >> GMAC_DEBUG_RRCSTS_SHIFT;
+ 
+ 		if (rxfsts == GMAC_DEBUG_RXFSTS_FULL)
+ 			x->mtl_rx_fifo_fill_level_full++;
+ 		else if (rxfsts == GMAC_DEBUG_RXFSTS_AT)
+ 			x->mtl_rx_fifo_fill_above_thresh++;
+ 		else if (rxfsts == GMAC_DEBUG_RXFSTS_BT)
+ 			x->mtl_rx_fifo_fill_below_thresh++;
+ 		else
+ 			x->mtl_rx_fifo_fill_level_empty++;
+ 	}
+ 	if (value & GMAC_DEBUG_RRCSTS_MASK) {
+ 		u32 rrcsts = (value & GMAC_DEBUG_RRCSTS_MASK) >>
+ 			     GMAC_DEBUG_RRCSTS_SHIFT;
+ 
+ 		if (rrcsts == GMAC_DEBUG_RRCSTS_FLUSH)
+ 			x->mtl_rx_fifo_read_ctrl_flush++;
+ 		else if (rrcsts == GMAC_DEBUG_RRCSTS_RSTAT)
+ 			x->mtl_rx_fifo_read_ctrl_read_data++;
+ 		else if (rrcsts == GMAC_DEBUG_RRCSTS_RDATA)
+ 			x->mtl_rx_fifo_read_ctrl_status++;
+ 		else
+ 			x->mtl_rx_fifo_read_ctrl_idle++;
+ 	}
+ 	if (value & GMAC_DEBUG_RWCSTS)
+ 		x->mtl_rx_fifo_ctrl_active++;
+ 	if (value & GMAC_DEBUG_RFCFCSTS_MASK)
+ 		x->mac_rx_frame_ctrl_fifo = (value & GMAC_DEBUG_RFCFCSTS_MASK)
+ 					    >> GMAC_DEBUG_RFCFCSTS_SHIFT;
+ 	if (value & GMAC_DEBUG_RPESTS)
+ 		x->mac_gmii_rx_proto_engine++;
+ }
+ 
  static const struct stmmac_ops dwmac1000_ops = {
  	.core_init = dwmac1000_core_init,
  	.rx_ipc = dwmac1000_rx_ipc_enable,
***************
*** 413,418 ****
--- 487,493 ----
  	.set_eee_pls = dwmac1000_set_eee_pls,
  	.ctrl_ane = dwmac1000_ctrl_ane,
  	.get_adv = dwmac1000_get_adv,
+ 	.debug = dwmac1000_debug,
  };
  
  struct mac_device_info *dwmac1000_setup(void __iomem *ioaddr, int mcbins,
diff -rcNP linux-4.4.24/drivers/net/ethernet/stmicro/stmmac/dwmac1000_dma.c linux-4.4.24-baikal/drivers/net/ethernet/stmicro/stmmac/dwmac1000_dma.c
*** linux-4.4.24/drivers/net/ethernet/stmicro/stmmac/dwmac1000_dma.c	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/net/ethernet/stmicro/stmmac/dwmac1000_dma.c	2016-11-11 14:49:53.000000000 +0300
***************
*** 30,66 ****
  #include "dwmac1000.h"
  #include "dwmac_dma.h"
  
! static int dwmac1000_dma_init(void __iomem *ioaddr, int pbl, int fb, int mb,
! 			      int burst_len, u32 dma_tx, u32 dma_rx, int atds)
  {
! 	u32 value = readl(ioaddr + DMA_BUS_MODE);
! 	int limit;
  
! 	/* DMA SW reset */
! 	value |= DMA_BUS_MODE_SFT_RESET;
! 	writel(value, ioaddr + DMA_BUS_MODE);
! 	limit = 10;
! 	while (limit--) {
! 		if (!(readl(ioaddr + DMA_BUS_MODE) & DMA_BUS_MODE_SFT_RESET))
  			break;
! 		mdelay(10);
  	}
! 	if (limit < 0)
! 		return -EBUSY;
  
  	/*
! 	 * Set the DMA PBL (Programmable Burst Length) mode
! 	 * Before stmmac core 3.50 this mode bit was 4xPBL, and
  	 * post 3.5 mode bit acts as 8*PBL.
! 	 * For core rev < 3.5, when the core is set for 4xPBL mode, the
! 	 * DMA transfers the data in 4, 8, 16, 32, 64 & 128 beats
! 	 * depending on pbl value.
! 	 * For core rev > 3.5, when the core is set for 8xPBL mode, the
! 	 * DMA transfers the data in 8, 16, 32, 64, 128 & 256 beats
! 	 * depending on pbl value.
  	 */
! 	value = DMA_BUS_MODE_PBL | ((pbl << DMA_BUS_MODE_PBL_SHIFT) |
! 				    (pbl << DMA_BUS_MODE_RPBL_SHIFT));
  
  	/* Set the Fixed burst mode */
  	if (fb)
--- 30,105 ----
  #include "dwmac1000.h"
  #include "dwmac_dma.h"
  
! static void dwmac1000_dma_axi(void __iomem *ioaddr, struct stmmac_axi *axi)
  {
! 	u32 value = readl(ioaddr + DMA_AXI_BUS_MODE);
! 	int i;
  
! 	pr_info("dwmac1000: Master AXI performs %s burst length\n",
! 		!(value & DMA_AXI_UNDEF) ? "fixed" : "any");
! 
! 	if (axi->axi_lpi_en)
! 		value |= DMA_AXI_EN_LPI;
! 	if (axi->axi_xit_frm)
! 		value |= DMA_AXI_LPI_XIT_FRM;
! 
! 	value |= (axi->axi_wr_osr_lmt & DMA_AXI_WR_OSR_LMT_MASK) <<
! 		 DMA_AXI_WR_OSR_LMT_SHIFT;
! 
! 	value |= (axi->axi_rd_osr_lmt & DMA_AXI_RD_OSR_LMT_MASK) <<
! 		 DMA_AXI_RD_OSR_LMT_SHIFT;
! 
! 	/* Depending on the UNDEF bit the Master AXI will perform any burst
! 	 * length according to the BLEN programmed (by default all BLEN are
! 	 * set).
! 	 */
! 	for (i = 0; i < AXI_BLEN; i++) {
! 		switch (axi->axi_blen[i]) {
! 		case 256:
! 			value |= DMA_AXI_BLEN256;
! 			break;
! 		case 128:
! 			value |= DMA_AXI_BLEN128;
! 			break;
! 		case 64:
! 			value |= DMA_AXI_BLEN64;
  			break;
! 		case 32:
! 			value |= DMA_AXI_BLEN32;
! 			break;
! 		case 16:
! 			value |= DMA_AXI_BLEN16;
! 			break;
! 		case 8:
! 			value |= DMA_AXI_BLEN8;
! 			break;
! 		case 4:
! 			value |= DMA_AXI_BLEN4;
! 			break;
! 		}
  	}
! 
! 	writel(value, ioaddr + DMA_AXI_BUS_MODE);
! }
! 
! static void dwmac1000_dma_init(void __iomem *ioaddr, int pbl, int fb, int mb,
! 			       int aal, u32 dma_tx, u32 dma_rx, int atds)
! {
! 	u32 value = readl(ioaddr + DMA_BUS_MODE);
  
  	/*
! 	 * Set the DMA PBL (Programmable Burst Length) mode.
! 	 *
! 	 * Note: before stmmac core 3.50 this mode bit was 4xPBL, and
  	 * post 3.5 mode bit acts as 8*PBL.
! 	 *
! 	 * This configuration doesn't take care about the Separate PBL
! 	 * so only the bits: 13-8 are programmed with the PBL passed from the
! 	 * platform.
  	 */
! 	value |= DMA_BUS_MODE_MAXPBL;
! 	value &= ~DMA_BUS_MODE_PBL_MASK;
! 	value |= (pbl << DMA_BUS_MODE_PBL_SHIFT);
  
  	/* Set the Fixed burst mode */
  	if (fb)
***************
*** 73,98 ****
  	if (atds)
  		value |= DMA_BUS_MODE_ATDS;
  
! 	writel(value, ioaddr + DMA_BUS_MODE);
  
! 	/* In case of GMAC AXI configuration, program the DMA_AXI_BUS_MODE
! 	 * for supported bursts.
! 	 *
! 	 * Note: This is applicable only for revision GMACv3.61a. For
! 	 * older version this register is reserved and shall have no
! 	 * effect.
! 	 *
! 	 * Note:
! 	 *  For Fixed Burst Mode: if we directly write 0xFF to this
! 	 *  register using the configurations pass from platform code,
! 	 *  this would ensure that all bursts supported by core are set
! 	 *  and those which are not supported would remain ineffective.
! 	 *
! 	 *  For Non Fixed Burst Mode: provide the maximum value of the
! 	 *  burst length. Any burst equal or below the provided burst
! 	 *  length would be allowed to perform.
! 	 */
! 	writel(burst_len, ioaddr + DMA_AXI_BUS_MODE);
  
  	/* Mask interrupts by writing to CSR7 */
  	writel(DMA_INTR_DEFAULT_MASK, ioaddr + DMA_INTR_ENA);
--- 112,121 ----
  	if (atds)
  		value |= DMA_BUS_MODE_ATDS;
  
! 	if (aal)
! 		value |= DMA_BUS_MODE_AAL;
  
! 	writel(value, ioaddr + DMA_BUS_MODE);
  
  	/* Mask interrupts by writing to CSR7 */
  	writel(DMA_INTR_DEFAULT_MASK, ioaddr + DMA_INTR_ENA);
***************
*** 102,109 ****
  	 */
  	writel(dma_tx, ioaddr + DMA_TX_BASE_ADDR);
  	writel(dma_rx, ioaddr + DMA_RCV_BASE_ADDR);
- 
- 	return 0;
  }
  
  static u32 dwmac1000_configure_fc(u32 csr6, int rxfifosz)
--- 125,130 ----
***************
*** 205,211 ****
--- 226,234 ----
  }
  
  const struct stmmac_dma_ops dwmac1000_dma_ops = {
+ 	.reset = dwmac_dma_reset,
  	.init = dwmac1000_dma_init,
+ 	.axi = dwmac1000_dma_axi,
  	.dump_regs = dwmac1000_dump_dma_regs,
  	.dma_mode = dwmac1000_dma_operation_mode,
  	.enable_dma_transmission = dwmac_enable_dma_transmission,
diff -rcNP linux-4.4.24/drivers/net/ethernet/stmicro/stmmac/dwmac1000.h linux-4.4.24-baikal/drivers/net/ethernet/stmicro/stmmac/dwmac1000.h
*** linux-4.4.24/drivers/net/ethernet/stmicro/stmmac/dwmac1000.h	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/net/ethernet/stmicro/stmmac/dwmac1000.h	2016-11-11 14:49:53.000000000 +0300
***************
*** 34,39 ****
--- 34,40 ----
  #define GMAC_FLOW_CTRL		0x00000018	/* Flow Control */
  #define GMAC_VLAN_TAG		0x0000001c	/* VLAN Tag */
  #define GMAC_VERSION		0x00000020	/* GMAC CORE Version */
+ #define GMAC_DEBUG		0x00000024	/* GMAC debug register */
  #define GMAC_WAKEUP_FILTER	0x00000028	/* Wake-up Frame Filter */
  
  #define GMAC_INT_STATUS		0x00000038	/* interrupt status register */
***************
*** 177,185 ****
  #define GMAC_FLOW_CTRL_TFE	0x00000002	/* Tx Flow Control Enable */
  #define GMAC_FLOW_CTRL_FCB_BPA	0x00000001	/* Flow Control Busy ... */
  
  /*--- DMA BLOCK defines ---*/
  /* DMA Bus Mode register defines */
- #define DMA_BUS_MODE_SFT_RESET	0x00000001	/* Software Reset */
  #define DMA_BUS_MODE_DA		0x00000002	/* Arbitration scheme */
  #define DMA_BUS_MODE_DSL_MASK	0x0000007c	/* Descriptor Skip Length */
  #define DMA_BUS_MODE_DSL_SHIFT	2		/*   (in DWORDS)      */
--- 178,226 ----
  #define GMAC_FLOW_CTRL_TFE	0x00000002	/* Tx Flow Control Enable */
  #define GMAC_FLOW_CTRL_FCB_BPA	0x00000001	/* Flow Control Busy ... */
  
+ /* DEBUG Register defines */
+ /* MTL TxStatus FIFO */
+ #define GMAC_DEBUG_TXSTSFSTS	BIT(25)	/* MTL TxStatus FIFO Full Status */
+ #define GMAC_DEBUG_TXFSTS	BIT(24) /* MTL Tx FIFO Not Empty Status */
+ #define GMAC_DEBUG_TWCSTS	BIT(22) /* MTL Tx FIFO Write Controller */
+ /* MTL Tx FIFO Read Controller Status */
+ #define GMAC_DEBUG_TRCSTS_MASK	GENMASK(21, 20)
+ #define GMAC_DEBUG_TRCSTS_SHIFT	20
+ #define GMAC_DEBUG_TRCSTS_IDLE	0
+ #define GMAC_DEBUG_TRCSTS_READ	1
+ #define GMAC_DEBUG_TRCSTS_TXW	2
+ #define GMAC_DEBUG_TRCSTS_WRITE	3
+ #define GMAC_DEBUG_TXPAUSED	BIT(19) /* MAC Transmitter in PAUSE */
+ /* MAC Transmit Frame Controller Status */
+ #define GMAC_DEBUG_TFCSTS_MASK	GENMASK(18, 17)
+ #define GMAC_DEBUG_TFCSTS_SHIFT	17
+ #define GMAC_DEBUG_TFCSTS_IDLE	0
+ #define GMAC_DEBUG_TFCSTS_WAIT	1
+ #define GMAC_DEBUG_TFCSTS_GEN_PAUSE	2
+ #define GMAC_DEBUG_TFCSTS_XFER	3
+ /* MAC GMII or MII Transmit Protocol Engine Status */
+ #define GMAC_DEBUG_TPESTS	BIT(16)
+ #define GMAC_DEBUG_RXFSTS_MASK	GENMASK(9, 8) /* MTL Rx FIFO Fill-level */
+ #define GMAC_DEBUG_RXFSTS_SHIFT	8
+ #define GMAC_DEBUG_RXFSTS_EMPTY	0
+ #define GMAC_DEBUG_RXFSTS_BT	1
+ #define GMAC_DEBUG_RXFSTS_AT	2
+ #define GMAC_DEBUG_RXFSTS_FULL	3
+ #define GMAC_DEBUG_RRCSTS_MASK	GENMASK(6, 5) /* MTL Rx FIFO Read Controller */
+ #define GMAC_DEBUG_RRCSTS_SHIFT	5
+ #define GMAC_DEBUG_RRCSTS_IDLE	0
+ #define GMAC_DEBUG_RRCSTS_RDATA	1
+ #define GMAC_DEBUG_RRCSTS_RSTAT	2
+ #define GMAC_DEBUG_RRCSTS_FLUSH	3
+ #define GMAC_DEBUG_RWCSTS	BIT(4) /* MTL Rx FIFO Write Controller Active */
+ /* MAC Receive Frame Controller FIFO Status */
+ #define GMAC_DEBUG_RFCFCSTS_MASK	GENMASK(2, 1)
+ #define GMAC_DEBUG_RFCFCSTS_SHIFT	1
+ /* MAC GMII or MII Receive Protocol Engine Status */
+ #define GMAC_DEBUG_RPESTS	BIT(0)
+ 
  /*--- DMA BLOCK defines ---*/
  /* DMA Bus Mode register defines */
  #define DMA_BUS_MODE_DA		0x00000002	/* Arbitration scheme */
  #define DMA_BUS_MODE_DSL_MASK	0x0000007c	/* Descriptor Skip Length */
  #define DMA_BUS_MODE_DSL_SHIFT	2		/*   (in DWORDS)      */
***************
*** 199,205 ****
  #define DMA_BUS_MODE_RPBL_MASK	0x003e0000	/* Rx-Programmable Burst Len */
  #define DMA_BUS_MODE_RPBL_SHIFT	17
  #define DMA_BUS_MODE_USP	0x00800000
! #define DMA_BUS_MODE_PBL	0x01000000
  #define DMA_BUS_MODE_AAL	0x02000000
  
  /* DMA CRS Control and Status Register Mapping */
--- 240,246 ----
  #define DMA_BUS_MODE_RPBL_MASK	0x003e0000	/* Rx-Programmable Burst Len */
  #define DMA_BUS_MODE_RPBL_SHIFT	17
  #define DMA_BUS_MODE_USP	0x00800000
! #define DMA_BUS_MODE_MAXPBL	0x01000000
  #define DMA_BUS_MODE_AAL	0x02000000
  
  /* DMA CRS Control and Status Register Mapping */
diff -rcNP linux-4.4.24/drivers/net/ethernet/stmicro/stmmac/dwmac100_dma.c linux-4.4.24-baikal/drivers/net/ethernet/stmicro/stmmac/dwmac100_dma.c
*** linux-4.4.24/drivers/net/ethernet/stmicro/stmmac/dwmac100_dma.c	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/net/ethernet/stmicro/stmmac/dwmac100_dma.c	2016-11-11 14:49:53.000000000 +0300
***************
*** 32,55 ****
  #include "dwmac100.h"
  #include "dwmac_dma.h"
  
! static int dwmac100_dma_init(void __iomem *ioaddr, int pbl, int fb, int mb,
! 			     int burst_len, u32 dma_tx, u32 dma_rx, int atds)
  {
- 	u32 value = readl(ioaddr + DMA_BUS_MODE);
- 	int limit;
- 
- 	/* DMA SW reset */
- 	value |= DMA_BUS_MODE_SFT_RESET;
- 	writel(value, ioaddr + DMA_BUS_MODE);
- 	limit = 10;
- 	while (limit--) {
- 		if (!(readl(ioaddr + DMA_BUS_MODE) & DMA_BUS_MODE_SFT_RESET))
- 			break;
- 		mdelay(10);
- 	}
- 	if (limit < 0)
- 		return -EBUSY;
- 
  	/* Enable Application Access by writing to DMA CSR0 */
  	writel(DMA_BUS_MODE_DEFAULT | (pbl << DMA_BUS_MODE_PBL_SHIFT),
  	       ioaddr + DMA_BUS_MODE);
--- 32,40 ----
  #include "dwmac100.h"
  #include "dwmac_dma.h"
  
! static void dwmac100_dma_init(void __iomem *ioaddr, int pbl, int fb, int mb,
! 			      int aal, u32 dma_tx, u32 dma_rx, int atds)
  {
  	/* Enable Application Access by writing to DMA CSR0 */
  	writel(DMA_BUS_MODE_DEFAULT | (pbl << DMA_BUS_MODE_PBL_SHIFT),
  	       ioaddr + DMA_BUS_MODE);
***************
*** 62,69 ****
  	 */
  	writel(dma_tx, ioaddr + DMA_TX_BASE_ADDR);
  	writel(dma_rx, ioaddr + DMA_RCV_BASE_ADDR);
- 
- 	return 0;
  }
  
  /* Store and Forward capability is not used at all.
--- 47,52 ----
***************
*** 131,136 ****
--- 114,120 ----
  }
  
  const struct stmmac_dma_ops dwmac100_dma_ops = {
+ 	.reset = dwmac_dma_reset,
  	.init = dwmac100_dma_init,
  	.dump_regs = dwmac100_dump_dma_regs,
  	.dma_mode = dwmac100_dma_operation_mode,
diff -rcNP linux-4.4.24/drivers/net/ethernet/stmicro/stmmac/dwmac100.h linux-4.4.24-baikal/drivers/net/ethernet/stmicro/stmmac/dwmac100.h
*** linux-4.4.24/drivers/net/ethernet/stmicro/stmmac/dwmac100.h	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/net/ethernet/stmicro/stmmac/dwmac100.h	2016-11-11 14:49:53.000000000 +0300
***************
*** 95,101 ****
  #define DMA_BUS_MODE_DSL_MASK	0x0000007c	/* Descriptor Skip Length */
  #define DMA_BUS_MODE_DSL_SHIFT	2	/*   (in DWORDS)      */
  #define DMA_BUS_MODE_BAR_BUS	0x00000002	/* Bar-Bus Arbitration */
- #define DMA_BUS_MODE_SFT_RESET	0x00000001	/* Software Reset */
  #define DMA_BUS_MODE_DEFAULT	0x00000000
  
  /* DMA Control register defines */
--- 95,100 ----
diff -rcNP linux-4.4.24/drivers/net/ethernet/stmicro/stmmac/dwmac-baikal.c linux-4.4.24-baikal/drivers/net/ethernet/stmicro/stmmac/dwmac-baikal.c
*** linux-4.4.24/drivers/net/ethernet/stmicro/stmmac/dwmac-baikal.c	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/drivers/net/ethernet/stmicro/stmmac/dwmac-baikal.c	2016-11-11 14:49:53.000000000 +0300
***************
*** 0 ****
--- 1,83 ----
+ /*
+  * Baikal Electronics SoCs DWMAC glue layer
+  *
+  * Copyright (C) 2015,2016 Baikal Electronics JSC
+  * Author:
+  *   Dmitry Dunaev <dmitry.dunaev@baikalelectronics.ru>
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License version 2 as
+  * published by the Free Software Foundation.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program. If not, see <http://www.gnu.org/licenses/>.
+  */
+ 
+ #include <linux/module.h>
+ #include <linux/of.h>
+ #include <linux/platform_device.h>
+ 
+ #include "stmmac.h"
+ #include "stmmac_platform.h"
+ 
+ 
+ static int dwmac_baikal_probe(struct platform_device *pdev)
+ {
+ 	struct plat_stmmacenet_data *plat_dat;
+ 	struct stmmac_resources stmmac_res;
+ 	int ret;
+ 
+ 	ret = stmmac_get_platform_resources(pdev, &stmmac_res);
+ 	if (ret)
+ 		return ret;
+ 
+ 	if (pdev->dev.of_node) {
+ 		plat_dat = stmmac_probe_config_dt(pdev, &stmmac_res.mac);
+ 		if (IS_ERR(plat_dat)) {
+ 			dev_err(&pdev->dev, "dt configuration failed\n");
+ 			return PTR_ERR(plat_dat);
+ 		}
+ 	} else {
+ 		plat_dat = dev_get_platdata(&pdev->dev);
+ 		if (!plat_dat) {
+ 			dev_err(&pdev->dev, "no platform data provided\n");
+ 			return  -EINVAL;
+ 		}
+ 
+ 		/* Set default value for multicast hash bins */
+ 		plat_dat->multicast_filter_bins = HASH_TABLE_SIZE;
+ 
+ 		/* Set default value for unicast filter entries */
+ 		plat_dat->unicast_filter_entries = 1;
+ 	}
+ 
+ 	plat_dat->has_gmac = 1;
+ 	plat_dat->enh_desc = 1;
+ 	plat_dat->tx_coe = 1;
+ 	plat_dat->rx_coe = 1;
+ 
+ 	dev_info(&pdev->dev, "Baikal Electronics DWMAC glue driver\n");
+ 
+ 	return stmmac_dvr_probe(&pdev->dev, plat_dat, &stmmac_res);
+ }
+ 
+ static const struct of_device_id dwmac_baikal_match[] = {
+ 	{ .compatible = "be,dwmac-3.710"},
+ 	{ .compatible = "be,dwmac"},
+ 	{ }
+ };
+ MODULE_DEVICE_TABLE(of, dwmac_baikal_match);
+ 
+ static struct platform_driver dwmac_baikal_driver = {
+ 	.probe  = dwmac_baikal_probe,
+ 	.remove = stmmac_pltfr_remove,
+ 	.driver = {
+ 		.name           = "baikal-dwmac",
+ 		.pm		= &stmmac_pltfr_pm_ops,
+ 		.of_match_table = of_match_ptr(dwmac_baikal_match),
+ 	},
+ };
+ module_platform_driver(dwmac_baikal_driver);
+ 
+ MODULE_DESCRIPTION("Baikal dwmac glue driver");
+ MODULE_LICENSE("GPL v2");
diff -rcNP linux-4.4.24/drivers/net/ethernet/stmicro/stmmac/dwmac_dma.h linux-4.4.24-baikal/drivers/net/ethernet/stmicro/stmmac/dwmac_dma.h
*** linux-4.4.24/drivers/net/ethernet/stmicro/stmmac/dwmac_dma.h	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/net/ethernet/stmicro/stmmac/dwmac_dma.h	2016-11-11 14:49:53.000000000 +0300
***************
*** 35,44 ****
  #define DMA_CONTROL		0x00001018	/* Ctrl (Operational Mode) */
  #define DMA_INTR_ENA		0x0000101c	/* Interrupt Enable */
  #define DMA_MISSED_FRAME_CTR	0x00001020	/* Missed Frame Counter */
  /* Rx watchdog register */
  #define DMA_RX_WATCHDOG		0x00001024
! /* AXI Bus Mode */
  #define DMA_AXI_BUS_MODE	0x00001028
  #define DMA_CUR_TX_BUF_ADDR	0x00001050	/* Current Host Tx Buffer */
  #define DMA_CUR_RX_BUF_ADDR	0x00001054	/* Current Host Rx Buffer */
  #define DMA_HW_FEATURE		0x00001058	/* HW Feature Register */
--- 35,83 ----
  #define DMA_CONTROL		0x00001018	/* Ctrl (Operational Mode) */
  #define DMA_INTR_ENA		0x0000101c	/* Interrupt Enable */
  #define DMA_MISSED_FRAME_CTR	0x00001020	/* Missed Frame Counter */
+ #define GMAC_GPIO		0x000000e0      /* GPIO register */
+ 
+ #define GMAC_GPIO_GPO0		(1 << 8)	/* 0-output port */
+ 
+ /* SW Reset */
+ #define DMA_BUS_MODE_SFT_RESET	0x00000001	/* Software Reset */
+ 
  /* Rx watchdog register */
  #define DMA_RX_WATCHDOG		0x00001024
! 
! /* AXI Master Bus Mode */
  #define DMA_AXI_BUS_MODE	0x00001028
+ 
+ #define DMA_AXI_EN_LPI		BIT(31)
+ #define DMA_AXI_LPI_XIT_FRM	BIT(30)
+ #define DMA_AXI_WR_OSR_LMT	GENMASK(23, 20)
+ #define DMA_AXI_WR_OSR_LMT_SHIFT	20
+ #define DMA_AXI_WR_OSR_LMT_MASK	0xf
+ #define DMA_AXI_RD_OSR_LMT	GENMASK(19, 16)
+ #define DMA_AXI_RD_OSR_LMT_SHIFT	16
+ #define DMA_AXI_RD_OSR_LMT_MASK	0xf
+ 
+ #define DMA_AXI_OSR_MAX		0xf
+ #define DMA_AXI_MAX_OSR_LIMIT ((DMA_AXI_OSR_MAX << DMA_AXI_WR_OSR_LMT_SHIFT) | \
+ 			       (DMA_AXI_OSR_MAX << DMA_AXI_RD_OSR_LMT_SHIFT))
+ #define	DMA_AXI_1KBBE		BIT(13)
+ #define DMA_AXI_AAL		BIT(12)
+ #define DMA_AXI_BLEN256		BIT(7)
+ #define DMA_AXI_BLEN128		BIT(6)
+ #define DMA_AXI_BLEN64		BIT(5)
+ #define DMA_AXI_BLEN32		BIT(4)
+ #define DMA_AXI_BLEN16		BIT(3)
+ #define DMA_AXI_BLEN8		BIT(2)
+ #define DMA_AXI_BLEN4		BIT(1)
+ #define DMA_BURST_LEN_DEFAULT	(DMA_AXI_BLEN256 | DMA_AXI_BLEN128 | \
+ 				 DMA_AXI_BLEN64 | DMA_AXI_BLEN32 | \
+ 				 DMA_AXI_BLEN16 | DMA_AXI_BLEN8 | \
+ 				 DMA_AXI_BLEN4)
+ 
+ #define DMA_AXI_UNDEF		BIT(0)
+ 
+ #define DMA_AXI_BURST_LEN_MASK	0x000000FE
+ 
  #define DMA_CUR_TX_BUF_ADDR	0x00001050	/* Current Host Tx Buffer */
  #define DMA_CUR_RX_BUF_ADDR	0x00001054	/* Current Host Rx Buffer */
  #define DMA_HW_FEATURE		0x00001058	/* HW Feature Register */
***************
*** 112,116 ****
--- 151,156 ----
  void dwmac_dma_start_rx(void __iomem *ioaddr);
  void dwmac_dma_stop_rx(void __iomem *ioaddr);
  int dwmac_dma_interrupt(void __iomem *ioaddr, struct stmmac_extra_stats *x);
+ int dwmac_dma_reset(void __iomem *ioaddr);
  
  #endif /* __DWMAC_DMA_H__ */
diff -rcNP linux-4.4.24/drivers/net/ethernet/stmicro/stmmac/dwmac-ipq806x.c linux-4.4.24-baikal/drivers/net/ethernet/stmicro/stmmac/dwmac-ipq806x.c
*** linux-4.4.24/drivers/net/ethernet/stmicro/stmmac/dwmac-ipq806x.c	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/net/ethernet/stmicro/stmmac/dwmac-ipq806x.c	2016-11-11 14:49:53.000000000 +0300
***************
*** 198,216 ****
  	return 0;
  }
  
! static void *ipq806x_gmac_of_parse(struct ipq806x_gmac *gmac)
  {
  	struct device *dev = &gmac->pdev->dev;
  
  	gmac->phy_mode = of_get_phy_mode(dev->of_node);
  	if (gmac->phy_mode < 0) {
  		dev_err(dev, "missing phy mode property\n");
! 		return ERR_PTR(-EINVAL);
  	}
  
  	if (of_property_read_u32(dev->of_node, "qcom,id", &gmac->id) < 0) {
  		dev_err(dev, "missing qcom id property\n");
! 		return ERR_PTR(-EINVAL);
  	}
  
  	/* The GMACs are called 1 to 4 in the documentation, but to simplify the
--- 198,216 ----
  	return 0;
  }
  
! static int ipq806x_gmac_of_parse(struct ipq806x_gmac *gmac)
  {
  	struct device *dev = &gmac->pdev->dev;
  
  	gmac->phy_mode = of_get_phy_mode(dev->of_node);
  	if (gmac->phy_mode < 0) {
  		dev_err(dev, "missing phy mode property\n");
! 		return -EINVAL;
  	}
  
  	if (of_property_read_u32(dev->of_node, "qcom,id", &gmac->id) < 0) {
  		dev_err(dev, "missing qcom id property\n");
! 		return -EINVAL;
  	}
  
  	/* The GMACs are called 1 to 4 in the documentation, but to simplify the
***************
*** 219,231 ****
  	 */
  	if (gmac->id < 0 || gmac->id > 3) {
  		dev_err(dev, "invalid gmac id\n");
! 		return ERR_PTR(-EINVAL);
  	}
  
  	gmac->core_clk = devm_clk_get(dev, "stmmaceth");
  	if (IS_ERR(gmac->core_clk)) {
  		dev_err(dev, "missing stmmaceth clk property\n");
! 		return gmac->core_clk;
  	}
  	clk_set_rate(gmac->core_clk, 266000000);
  
--- 219,231 ----
  	 */
  	if (gmac->id < 0 || gmac->id > 3) {
  		dev_err(dev, "invalid gmac id\n");
! 		return -EINVAL;
  	}
  
  	gmac->core_clk = devm_clk_get(dev, "stmmaceth");
  	if (IS_ERR(gmac->core_clk)) {
  		dev_err(dev, "missing stmmaceth clk property\n");
! 		return PTR_ERR(gmac->core_clk);
  	}
  	clk_set_rate(gmac->core_clk, 266000000);
  
***************
*** 234,251 ****
  							   "qcom,nss-common");
  	if (IS_ERR(gmac->nss_common)) {
  		dev_err(dev, "missing nss-common node\n");
! 		return gmac->nss_common;
  	}
  
  	/* Setup the register map for the qsgmii csr registers */
  	gmac->qsgmii_csr = syscon_regmap_lookup_by_phandle(dev->of_node,
  							   "qcom,qsgmii-csr");
! 	if (IS_ERR(gmac->qsgmii_csr)) {
  		dev_err(dev, "missing qsgmii-csr node\n");
- 		return gmac->qsgmii_csr;
- 	}
  
! 	return NULL;
  }
  
  static void ipq806x_gmac_fix_mac_speed(void *priv, unsigned int speed)
--- 234,249 ----
  							   "qcom,nss-common");
  	if (IS_ERR(gmac->nss_common)) {
  		dev_err(dev, "missing nss-common node\n");
! 		return PTR_ERR(gmac->nss_common);
  	}
  
  	/* Setup the register map for the qsgmii csr registers */
  	gmac->qsgmii_csr = syscon_regmap_lookup_by_phandle(dev->of_node,
  							   "qcom,qsgmii-csr");
! 	if (IS_ERR(gmac->qsgmii_csr))
  		dev_err(dev, "missing qsgmii-csr node\n");
  
! 	return PTR_ERR_OR_ZERO(gmac->qsgmii_csr);
  }
  
  static void ipq806x_gmac_fix_mac_speed(void *priv, unsigned int speed)
***************
*** 262,268 ****
  	struct device *dev = &pdev->dev;
  	struct ipq806x_gmac *gmac;
  	int val;
! 	void *err;
  
  	val = stmmac_get_platform_resources(pdev, &stmmac_res);
  	if (val)
--- 260,266 ----
  	struct device *dev = &pdev->dev;
  	struct ipq806x_gmac *gmac;
  	int val;
! 	int err;
  
  	val = stmmac_get_platform_resources(pdev, &stmmac_res);
  	if (val)
***************
*** 279,287 ****
  	gmac->pdev = pdev;
  
  	err = ipq806x_gmac_of_parse(gmac);
! 	if (IS_ERR(err)) {
  		dev_err(dev, "device tree parsing error\n");
! 		return PTR_ERR(err);
  	}
  
  	regmap_write(gmac->qsgmii_csr, QSGMII_PCS_CAL_LCKDT_CTL,
--- 277,285 ----
  	gmac->pdev = pdev;
  
  	err = ipq806x_gmac_of_parse(gmac);
! 	if (err) {
  		dev_err(dev, "device tree parsing error\n");
! 		return err;
  	}
  
  	regmap_write(gmac->qsgmii_csr, QSGMII_PCS_CAL_LCKDT_CTL,
diff -rcNP linux-4.4.24/drivers/net/ethernet/stmicro/stmmac/dwmac_lib.c linux-4.4.24-baikal/drivers/net/ethernet/stmicro/stmmac/dwmac_lib.c
*** linux-4.4.24/drivers/net/ethernet/stmicro/stmmac/dwmac_lib.c	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/net/ethernet/stmicro/stmmac/dwmac_lib.c	2016-11-11 14:49:53.000000000 +0300
***************
*** 26,31 ****
--- 26,60 ----
  
  #define GMAC_HI_REG_AE		0x80000000
  
+ int dwmac_dma_reset(void __iomem *ioaddr)
+ {
+ 	u32 value = readl(ioaddr + DMA_BUS_MODE);
+ 	int limit;
+ 
+ 	/* DMA SW reset */
+ 	value |= DMA_BUS_MODE_SFT_RESET;
+ 	writel(value, ioaddr + DMA_BUS_MODE);
+ 
+ #ifdef CONFIG_MACH_BAIKAL_BFK2
+ 	/* Clear PHY reset */
+ 	value = readl(ioaddr + GMAC_GPIO);
+ 	value |= GMAC_GPIO_GPO0;
+ 	writel(value, ioaddr + GMAC_GPIO);
+ #endif /* CONFIG_MACH_BAIKAL_BFK2 */
+ 	
+ 	limit = 10;
+ 	while (limit--) {
+ 		if (!(readl(ioaddr + DMA_BUS_MODE) & DMA_BUS_MODE_SFT_RESET))
+ 			break;
+ 		mdelay(10);
+ 	}
+ 
+ 	if (limit < 0)
+ 		return -EBUSY;
+ 
+ 	return 0;
+ }
+ 
  /* CSR1 enables the transmit DMA to check for new descriptor */
  void dwmac_enable_dma_transmission(void __iomem *ioaddr)
  {
diff -rcNP linux-4.4.24/drivers/net/ethernet/stmicro/stmmac/dwmac-socfpga.c linux-4.4.24-baikal/drivers/net/ethernet/stmicro/stmmac/dwmac-socfpga.c
*** linux-4.4.24/drivers/net/ethernet/stmicro/stmmac/dwmac-socfpga.c	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/net/ethernet/stmicro/stmmac/dwmac-socfpga.c	2016-11-11 14:49:53.000000000 +0300
***************
*** 32,37 ****
--- 32,38 ----
  #define SYSMGR_EMACGRP_CTRL_PHYSEL_ENUM_RMII 0x2
  #define SYSMGR_EMACGRP_CTRL_PHYSEL_WIDTH 2
  #define SYSMGR_EMACGRP_CTRL_PHYSEL_MASK 0x00000003
+ #define SYSMGR_EMACGRP_CTRL_PTP_REF_CLK_MASK 0x00000010
  
  #define EMAC_SPLITTER_CTRL_REG			0x0
  #define EMAC_SPLITTER_CTRL_SPEED_MASK		0x3
***************
*** 47,52 ****
--- 48,54 ----
  	struct regmap *sys_mgr_base_addr;
  	struct reset_control *stmmac_rst;
  	void __iomem *splitter_base;
+ 	bool f2h_ptp_ref_clk;
  };
  
  static void socfpga_dwmac_fix_mac_speed(void *priv, unsigned int speed)
***************
*** 116,121 ****
--- 118,125 ----
  		return -EINVAL;
  	}
  
+ 	dwmac->f2h_ptp_ref_clk = of_property_read_bool(np, "altr,f2h_ptp_ref_clk");
+ 
  	np_splitter = of_parse_phandle(np, "altr,emac-splitter", 0);
  	if (np_splitter) {
  		if (of_address_to_resource(np_splitter, 0, &res_splitter)) {
***************
*** 171,176 ****
--- 175,185 ----
  	ctrl &= ~(SYSMGR_EMACGRP_CTRL_PHYSEL_MASK << reg_shift);
  	ctrl |= val << reg_shift;
  
+ 	if (dwmac->f2h_ptp_ref_clk)
+ 		ctrl |= SYSMGR_EMACGRP_CTRL_PTP_REF_CLK_MASK << (reg_shift / 2);
+ 	else
+ 		ctrl &= ~(SYSMGR_EMACGRP_CTRL_PTP_REF_CLK_MASK << (reg_shift / 2));
+ 
  	regmap_write(sys_mgr_base_addr, reg_offset, ctrl);
  	return 0;
  }
diff -rcNP linux-4.4.24/drivers/net/ethernet/stmicro/stmmac/enh_desc.c linux-4.4.24-baikal/drivers/net/ethernet/stmicro/stmmac/enh_desc.c
*** linux-4.4.24/drivers/net/ethernet/stmicro/stmmac/enh_desc.c	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/net/ethernet/stmicro/stmmac/enh_desc.c	2016-11-11 14:49:53.000000000 +0300
***************
*** 1,7 ****
  /*******************************************************************************
    This contains the functions to handle the enhanced descriptors.
  
!   Copyright (C) 2007-2009  STMicroelectronics Ltd
  
    This program is free software; you can redistribute it and/or modify it
    under the terms and conditions of the GNU General Public License,
--- 1,7 ----
  /*******************************************************************************
    This contains the functions to handle the enhanced descriptors.
  
!   Copyright (C) 2007-2014  STMicroelectronics Ltd
  
    This program is free software; you can redistribute it and/or modify it
    under the terms and conditions of the GNU General Public License,
***************
*** 29,84 ****
  static int enh_desc_get_tx_status(void *data, struct stmmac_extra_stats *x,
  				  struct dma_desc *p, void __iomem *ioaddr)
  {
- 	int ret = 0;
  	struct net_device_stats *stats = (struct net_device_stats *)data;
  
! 	if (unlikely(p->des01.etx.error_summary)) {
! 		if (unlikely(p->des01.etx.jabber_timeout))
  			x->tx_jabber++;
  
! 		if (unlikely(p->des01.etx.frame_flushed)) {
  			x->tx_frame_flushed++;
  			dwmac_dma_flush_tx_fifo(ioaddr);
  		}
  
! 		if (unlikely(p->des01.etx.loss_carrier)) {
  			x->tx_losscarrier++;
  			stats->tx_carrier_errors++;
  		}
! 		if (unlikely(p->des01.etx.no_carrier)) {
  			x->tx_carrier++;
  			stats->tx_carrier_errors++;
  		}
! 		if (unlikely(p->des01.etx.late_collision))
! 			stats->collisions += p->des01.etx.collision_count;
! 
! 		if (unlikely(p->des01.etx.excessive_collisions))
! 			stats->collisions += p->des01.etx.collision_count;
  
! 		if (unlikely(p->des01.etx.excessive_deferral))
  			x->tx_deferred++;
  
! 		if (unlikely(p->des01.etx.underflow_error)) {
  			dwmac_dma_flush_tx_fifo(ioaddr);
  			x->tx_underflow++;
  		}
  
! 		if (unlikely(p->des01.etx.ip_header_error))
  			x->tx_ip_header_error++;
  
! 		if (unlikely(p->des01.etx.payload_error)) {
  			x->tx_payload_error++;
  			dwmac_dma_flush_tx_fifo(ioaddr);
  		}
  
! 		ret = -1;
  	}
  
! 	if (unlikely(p->des01.etx.deferred))
  		x->tx_deferred++;
  
  #ifdef STMMAC_VLAN_TAG_USED
! 	if (p->des01.etx.vlan_frame)
  		x->tx_vlan++;
  #endif
  
--- 29,92 ----
  static int enh_desc_get_tx_status(void *data, struct stmmac_extra_stats *x,
  				  struct dma_desc *p, void __iomem *ioaddr)
  {
  	struct net_device_stats *stats = (struct net_device_stats *)data;
+ 	unsigned int tdes0 = p->des0;
+ 	int ret = tx_done;
  
! 	/* Get tx owner first */
! 	if (unlikely(tdes0 & ETDES0_OWN))
! 		return tx_dma_own;
! 
! 	/* Verify tx error by looking at the last segment. */
! 	if (likely(!(tdes0 & ETDES0_LAST_SEGMENT)))
! 		return tx_not_ls;
! 
! 	if (unlikely(tdes0 & ETDES0_ERROR_SUMMARY)) {
! 		if (unlikely(tdes0 & ETDES0_JABBER_TIMEOUT))
  			x->tx_jabber++;
  
! 		if (unlikely(tdes0 & ETDES0_FRAME_FLUSHED)) {
  			x->tx_frame_flushed++;
  			dwmac_dma_flush_tx_fifo(ioaddr);
  		}
  
! 		if (unlikely(tdes0 & ETDES0_LOSS_CARRIER)) {
  			x->tx_losscarrier++;
  			stats->tx_carrier_errors++;
  		}
! 		if (unlikely(tdes0 & ETDES0_NO_CARRIER)) {
  			x->tx_carrier++;
  			stats->tx_carrier_errors++;
  		}
! 		if (unlikely((tdes0 & ETDES0_LATE_COLLISION) ||
! 			     (tdes0 & ETDES0_EXCESSIVE_COLLISIONS)))
! 			stats->collisions +=
! 				(tdes0 & ETDES0_COLLISION_COUNT_MASK) >> 3;
  
! 		if (unlikely(tdes0 & ETDES0_EXCESSIVE_DEFERRAL))
  			x->tx_deferred++;
  
! 		if (unlikely(tdes0 & ETDES0_UNDERFLOW_ERROR)) {
  			dwmac_dma_flush_tx_fifo(ioaddr);
  			x->tx_underflow++;
  		}
  
! 		if (unlikely(tdes0 & ETDES0_IP_HEADER_ERROR))
  			x->tx_ip_header_error++;
  
! 		if (unlikely(tdes0 & ETDES0_PAYLOAD_ERROR)) {
  			x->tx_payload_error++;
  			dwmac_dma_flush_tx_fifo(ioaddr);
  		}
  
! 		ret = tx_err;
  	}
  
! 	if (unlikely(tdes0 & ETDES0_DEFERRED))
  		x->tx_deferred++;
  
  #ifdef STMMAC_VLAN_TAG_USED
! 	if (tdes0 & ETDES0_VLAN_FRAME)
  		x->tx_vlan++;
  #endif
  
***************
*** 87,93 ****
  
  static int enh_desc_get_tx_len(struct dma_desc *p)
  {
! 	return p->des01.etx.buffer1_size;
  }
  
  static int enh_desc_coe_rdes0(int ipc_err, int type, int payload_err)
--- 95,101 ----
  
  static int enh_desc_get_tx_len(struct dma_desc *p)
  {
! 	return (p->des1 & ETDES1_BUFFER1_SIZE_MASK);
  }
  
  static int enh_desc_coe_rdes0(int ipc_err, int type, int payload_err)
***************
*** 126,175 ****
  static void enh_desc_get_ext_status(void *data, struct stmmac_extra_stats *x,
  				    struct dma_extended_desc *p)
  {
! 	if (unlikely(p->basic.des01.erx.rx_mac_addr)) {
! 		if (p->des4.erx.ip_hdr_err)
  			x->ip_hdr_err++;
! 		if (p->des4.erx.ip_payload_err)
  			x->ip_payload_err++;
! 		if (p->des4.erx.ip_csum_bypassed)
  			x->ip_csum_bypassed++;
! 		if (p->des4.erx.ipv4_pkt_rcvd)
  			x->ipv4_pkt_rcvd++;
! 		if (p->des4.erx.ipv6_pkt_rcvd)
  			x->ipv6_pkt_rcvd++;
! 		if (p->des4.erx.msg_type == RDES_EXT_SYNC)
  			x->rx_msg_type_sync++;
! 		else if (p->des4.erx.msg_type == RDES_EXT_FOLLOW_UP)
  			x->rx_msg_type_follow_up++;
! 		else if (p->des4.erx.msg_type == RDES_EXT_DELAY_REQ)
  			x->rx_msg_type_delay_req++;
! 		else if (p->des4.erx.msg_type == RDES_EXT_DELAY_RESP)
  			x->rx_msg_type_delay_resp++;
! 		else if (p->des4.erx.msg_type == RDES_EXT_PDELAY_REQ)
  			x->rx_msg_type_pdelay_req++;
! 		else if (p->des4.erx.msg_type == RDES_EXT_PDELAY_RESP)
  			x->rx_msg_type_pdelay_resp++;
! 		else if (p->des4.erx.msg_type == RDES_EXT_PDELAY_FOLLOW_UP)
  			x->rx_msg_type_pdelay_follow_up++;
  		else
  			x->rx_msg_type_ext_no_ptp++;
! 		if (p->des4.erx.ptp_frame_type)
  			x->ptp_frame_type++;
! 		if (p->des4.erx.ptp_ver)
  			x->ptp_ver++;
! 		if (p->des4.erx.timestamp_dropped)
  			x->timestamp_dropped++;
! 		if (p->des4.erx.av_pkt_rcvd)
  			x->av_pkt_rcvd++;
! 		if (p->des4.erx.av_tagged_pkt_rcvd)
  			x->av_tagged_pkt_rcvd++;
! 		if (p->des4.erx.vlan_tag_priority_val)
  			x->vlan_tag_priority_val++;
! 		if (p->des4.erx.l3_filter_match)
  			x->l3_filter_match++;
! 		if (p->des4.erx.l4_filter_match)
  			x->l4_filter_match++;
! 		if (p->des4.erx.l3_l4_filter_no_match)
  			x->l3_l4_filter_no_match++;
  	}
  }
--- 134,188 ----
  static void enh_desc_get_ext_status(void *data, struct stmmac_extra_stats *x,
  				    struct dma_extended_desc *p)
  {
! 	unsigned int rdes0 = p->basic.des0;
! 	unsigned int rdes4 = p->des4;
! 
! 	if (unlikely(rdes0 & ERDES0_RX_MAC_ADDR)) {
! 		int message_type = (rdes4 & ERDES4_MSG_TYPE_MASK) >> 8;
! 
! 		if (rdes4 & ERDES4_IP_HDR_ERR)
  			x->ip_hdr_err++;
! 		if (rdes4 & ERDES4_IP_PAYLOAD_ERR)
  			x->ip_payload_err++;
! 		if (rdes4 & ERDES4_IP_CSUM_BYPASSED)
  			x->ip_csum_bypassed++;
! 		if (rdes4 & ERDES4_IPV4_PKT_RCVD)
  			x->ipv4_pkt_rcvd++;
! 		if (rdes4 & ERDES4_IPV6_PKT_RCVD)
  			x->ipv6_pkt_rcvd++;
! 		if (message_type == RDES_EXT_SYNC)
  			x->rx_msg_type_sync++;
! 		else if (message_type == RDES_EXT_FOLLOW_UP)
  			x->rx_msg_type_follow_up++;
! 		else if (message_type == RDES_EXT_DELAY_REQ)
  			x->rx_msg_type_delay_req++;
! 		else if (message_type == RDES_EXT_DELAY_RESP)
  			x->rx_msg_type_delay_resp++;
! 		else if (message_type == RDES_EXT_PDELAY_REQ)
  			x->rx_msg_type_pdelay_req++;
! 		else if (message_type == RDES_EXT_PDELAY_RESP)
  			x->rx_msg_type_pdelay_resp++;
! 		else if (message_type == RDES_EXT_PDELAY_FOLLOW_UP)
  			x->rx_msg_type_pdelay_follow_up++;
  		else
  			x->rx_msg_type_ext_no_ptp++;
! 		if (rdes4 & ERDES4_PTP_FRAME_TYPE)
  			x->ptp_frame_type++;
! 		if (rdes4 & ERDES4_PTP_VER)
  			x->ptp_ver++;
! 		if (rdes4 & ERDES4_TIMESTAMP_DROPPED)
  			x->timestamp_dropped++;
! 		if (rdes4 & ERDES4_AV_PKT_RCVD)
  			x->av_pkt_rcvd++;
! 		if (rdes4 & ERDES4_AV_TAGGED_PKT_RCVD)
  			x->av_tagged_pkt_rcvd++;
! 		if ((rdes4 & ERDES4_VLAN_TAG_PRI_VAL_MASK) >> 18)
  			x->vlan_tag_priority_val++;
! 		if (rdes4 & ERDES4_L3_FILTER_MATCH)
  			x->l3_filter_match++;
! 		if (rdes4 & ERDES4_L4_FILTER_MATCH)
  			x->l4_filter_match++;
! 		if ((rdes4 & ERDES4_L3_L4_FILT_NO_MATCH_MASK) >> 26)
  			x->l3_l4_filter_no_match++;
  	}
  }
***************
*** 177,206 ****
  static int enh_desc_get_rx_status(void *data, struct stmmac_extra_stats *x,
  				  struct dma_desc *p)
  {
- 	int ret = good_frame;
  	struct net_device_stats *stats = (struct net_device_stats *)data;
  
! 	if (unlikely(p->des01.erx.error_summary)) {
! 		if (unlikely(p->des01.erx.descriptor_error)) {
  			x->rx_desc++;
  			stats->rx_length_errors++;
  		}
! 		if (unlikely(p->des01.erx.overflow_error))
  			x->rx_gmac_overflow++;
  
! 		if (unlikely(p->des01.erx.ipc_csum_error))
  			pr_err("\tIPC Csum Error/Giant frame\n");
  
! 		if (unlikely(p->des01.erx.late_collision)) {
  			stats->collisions++;
! 		}
! 		if (unlikely(p->des01.erx.receive_watchdog))
  			x->rx_watchdog++;
  
! 		if (unlikely(p->des01.erx.error_gmii))
  			x->rx_mii++;
  
! 		if (unlikely(p->des01.erx.crc_error)) {
  			x->rx_crc++;
  			stats->rx_crc_errors++;
  		}
--- 190,222 ----
  static int enh_desc_get_rx_status(void *data, struct stmmac_extra_stats *x,
  				  struct dma_desc *p)
  {
  	struct net_device_stats *stats = (struct net_device_stats *)data;
+ 	unsigned int rdes0 = p->des0;
+ 	int ret = good_frame;
  
! 	if (unlikely(rdes0 & RDES0_OWN))
! 		return dma_own;
! 
! 	if (unlikely(rdes0 & RDES0_ERROR_SUMMARY)) {
! 		if (unlikely(rdes0 & RDES0_DESCRIPTOR_ERROR)) {
  			x->rx_desc++;
  			stats->rx_length_errors++;
  		}
! 		if (unlikely(rdes0 & RDES0_OVERFLOW_ERROR))
  			x->rx_gmac_overflow++;
  
! 		if (unlikely(rdes0 & RDES0_IPC_CSUM_ERROR))
  			pr_err("\tIPC Csum Error/Giant frame\n");
  
! 		if (unlikely(rdes0 & RDES0_COLLISION))
  			stats->collisions++;
! 		if (unlikely(rdes0 & RDES0_RECEIVE_WATCHDOG))
  			x->rx_watchdog++;
  
! 		if (unlikely(rdes0 & RDES0_MII_ERROR))	/* GMII */
  			x->rx_mii++;
  
! 		if (unlikely(rdes0 & RDES0_CRC_ERROR)) {
  			x->rx_crc++;
  			stats->rx_crc_errors++;
  		}
***************
*** 211,236 ****
  	 * It doesn't match with the information reported into the databook.
  	 * At any rate, we need to understand if the CSUM hw computation is ok
  	 * and report this info to the upper layers. */
! 	ret = enh_desc_coe_rdes0(p->des01.erx.ipc_csum_error,
! 		p->des01.erx.frame_type, p->des01.erx.rx_mac_addr);
  
! 	if (unlikely(p->des01.erx.dribbling))
  		x->dribbling_bit++;
  
! 	if (unlikely(p->des01.erx.sa_filter_fail)) {
  		x->sa_rx_filter_fail++;
  		ret = discard_frame;
  	}
! 	if (unlikely(p->des01.erx.da_filter_fail)) {
  		x->da_rx_filter_fail++;
  		ret = discard_frame;
  	}
! 	if (unlikely(p->des01.erx.length_error)) {
  		x->rx_length++;
  		ret = discard_frame;
  	}
  #ifdef STMMAC_VLAN_TAG_USED
! 	if (p->des01.erx.vlan_tag)
  		x->rx_vlan++;
  #endif
  
--- 227,253 ----
  	 * It doesn't match with the information reported into the databook.
  	 * At any rate, we need to understand if the CSUM hw computation is ok
  	 * and report this info to the upper layers. */
! 	ret = enh_desc_coe_rdes0(!!(rdes0 & RDES0_IPC_CSUM_ERROR),
! 				 !!(rdes0 & RDES0_FRAME_TYPE),
! 				 !!(rdes0 & ERDES0_RX_MAC_ADDR));
  
! 	if (unlikely(rdes0 & RDES0_DRIBBLING))
  		x->dribbling_bit++;
  
! 	if (unlikely(rdes0 & RDES0_SA_FILTER_FAIL)) {
  		x->sa_rx_filter_fail++;
  		ret = discard_frame;
  	}
! 	if (unlikely(rdes0 & RDES0_DA_FILTER_FAIL)) {
  		x->da_rx_filter_fail++;
  		ret = discard_frame;
  	}
! 	if (unlikely(rdes0 & RDES0_LENGTH_ERROR)) {
  		x->rx_length++;
  		ret = discard_frame;
  	}
  #ifdef STMMAC_VLAN_TAG_USED
! 	if (rdes0 & RDES0_VLAN_TAG)
  		x->rx_vlan++;
  #endif
  
***************
*** 240,349 ****
  static void enh_desc_init_rx_desc(struct dma_desc *p, int disable_rx_ic,
  				  int mode, int end)
  {
! 	p->des01.all_flags = 0;
! 	p->des01.erx.own = 1;
! 	p->des01.erx.buffer1_size = BUF_SIZE_8KiB - 1;
  
  	if (mode == STMMAC_CHAIN_MODE)
! 		ehn_desc_rx_set_on_chain(p, end);
  	else
  		ehn_desc_rx_set_on_ring(p, end);
  
  	if (disable_rx_ic)
! 		p->des01.erx.disable_ic = 1;
  }
  
  static void enh_desc_init_tx_desc(struct dma_desc *p, int mode, int end)
  {
! 	p->des01.all_flags = 0;
  	if (mode == STMMAC_CHAIN_MODE)
! 		ehn_desc_tx_set_on_chain(p, end);
  	else
! 		ehn_desc_tx_set_on_ring(p, end);
  }
  
  static int enh_desc_get_tx_owner(struct dma_desc *p)
  {
! 	return p->des01.etx.own;
! }
! 
! static int enh_desc_get_rx_owner(struct dma_desc *p)
! {
! 	return p->des01.erx.own;
  }
  
  static void enh_desc_set_tx_owner(struct dma_desc *p)
  {
! 	p->des01.etx.own = 1;
  }
  
  static void enh_desc_set_rx_owner(struct dma_desc *p)
  {
! 	p->des01.erx.own = 1;
  }
  
  static int enh_desc_get_tx_ls(struct dma_desc *p)
  {
! 	return p->des01.etx.last_segment;
  }
  
  static void enh_desc_release_tx_desc(struct dma_desc *p, int mode)
  {
! 	int ter = p->des01.etx.end_ring;
  
  	memset(p, 0, offsetof(struct dma_desc, des2));
  	if (mode == STMMAC_CHAIN_MODE)
! 		enh_desc_end_tx_desc_on_chain(p, ter);
  	else
  		enh_desc_end_tx_desc_on_ring(p, ter);
  }
  
  static void enh_desc_prepare_tx_desc(struct dma_desc *p, int is_fs, int len,
! 				     int csum_flag, int mode)
  {
! 	p->des01.etx.first_segment = is_fs;
  
  	if (mode == STMMAC_CHAIN_MODE)
  		enh_set_tx_desc_len_on_chain(p, len);
  	else
  		enh_set_tx_desc_len_on_ring(p, len);
  
  	if (likely(csum_flag))
! 		p->des01.etx.checksum_insertion = cic_full;
! }
  
! static void enh_desc_clear_tx_ic(struct dma_desc *p)
! {
! 	p->des01.etx.interrupt = 0;
  }
  
! static void enh_desc_close_tx_desc(struct dma_desc *p)
  {
! 	p->des01.etx.last_segment = 1;
! 	p->des01.etx.interrupt = 1;
  }
  
  static int enh_desc_get_rx_frame_len(struct dma_desc *p, int rx_coe_type)
  {
  	/* The type-1 checksum offload engines append the checksum at
  	 * the end of frame and the two bytes of checksum are added in
  	 * the length.
  	 * Adjust for that in the framelen for type-1 checksum offload
! 	 * engines. */
  	if (rx_coe_type == STMMAC_RX_COE_TYPE1)
! 		return p->des01.erx.frame_length - 2;
! 	else
! 		return p->des01.erx.frame_length;
  }
  
  static void enh_desc_enable_tx_timestamp(struct dma_desc *p)
  {
! 	p->des01.etx.time_stamp_enable = 1;
  }
  
  static int enh_desc_get_tx_timestamp_status(struct dma_desc *p)
  {
! 	return p->des01.etx.time_stamp_status;
  }
  
  static u64 enh_desc_get_timestamp(void *desc, u32 ats)
--- 257,382 ----
  static void enh_desc_init_rx_desc(struct dma_desc *p, int disable_rx_ic,
  				  int mode, int end)
  {
! 	p->des0 |= RDES0_OWN;
! 	p->des1 |= ((BUF_SIZE_8KiB - 1) & ERDES1_BUFFER1_SIZE_MASK);
  
  	if (mode == STMMAC_CHAIN_MODE)
! 		ehn_desc_rx_set_on_chain(p);
  	else
  		ehn_desc_rx_set_on_ring(p, end);
  
  	if (disable_rx_ic)
! 		p->des1 |= ERDES1_DISABLE_IC;
  }
  
  static void enh_desc_init_tx_desc(struct dma_desc *p, int mode, int end)
  {
! 	p->des0 &= ~ETDES0_OWN;
  	if (mode == STMMAC_CHAIN_MODE)
! 		enh_desc_end_tx_desc_on_chain(p);
  	else
! 		enh_desc_end_tx_desc_on_ring(p, end);
  }
  
  static int enh_desc_get_tx_owner(struct dma_desc *p)
  {
! 	return (p->des0 & ETDES0_OWN) >> 31;
  }
  
  static void enh_desc_set_tx_owner(struct dma_desc *p)
  {
! 	p->des0 |= ETDES0_OWN;
  }
  
  static void enh_desc_set_rx_owner(struct dma_desc *p)
  {
! 	p->des0 |= RDES0_OWN;
  }
  
  static int enh_desc_get_tx_ls(struct dma_desc *p)
  {
! 	return (p->des0 & ETDES0_LAST_SEGMENT) >> 29;
  }
  
  static void enh_desc_release_tx_desc(struct dma_desc *p, int mode)
  {
! 	int ter = (p->des0 & ETDES0_END_RING) >> 21;
  
  	memset(p, 0, offsetof(struct dma_desc, des2));
  	if (mode == STMMAC_CHAIN_MODE)
! 		enh_desc_end_tx_desc_on_chain(p);
  	else
  		enh_desc_end_tx_desc_on_ring(p, ter);
  }
  
  static void enh_desc_prepare_tx_desc(struct dma_desc *p, int is_fs, int len,
! 				     bool csum_flag, int mode, bool tx_own,
! 				     bool ls)
  {
! 	unsigned int tdes0 = p->des0;
  
  	if (mode == STMMAC_CHAIN_MODE)
  		enh_set_tx_desc_len_on_chain(p, len);
  	else
  		enh_set_tx_desc_len_on_ring(p, len);
  
+ 	if (is_fs)
+ 		tdes0 |= ETDES0_FIRST_SEGMENT;
+ 	else
+ 		tdes0 &= ~ETDES0_FIRST_SEGMENT;
+ 
  	if (likely(csum_flag))
! 		tdes0 |= (TX_CIC_FULL << ETDES0_CHECKSUM_INSERTION_SHIFT);
! 	else
! 		tdes0 &= ~(TX_CIC_FULL << ETDES0_CHECKSUM_INSERTION_SHIFT);
  
! 	if (ls)
! 		tdes0 |= ETDES0_LAST_SEGMENT;
! 
! 	/* Finally set the OWN bit. Later the DMA will start! */
! 	if (tx_own) {
! 		tdes0 |= ETDES0_OWN;
! 
! 		if (is_fs)
! 		/* When the own bit, for the first frame, has to be set, all
! 		 * descriptors for the same frame has to be set before, to
! 		 * avoid race condition.
! 		 */
! 			wmb();
! 	}
! 
! 	p->des0 = tdes0;
  }
  
! static void enh_desc_set_tx_ic(struct dma_desc *p)
  {
! 	p->des0 |= ETDES0_INTERRUPT;
  }
  
  static int enh_desc_get_rx_frame_len(struct dma_desc *p, int rx_coe_type)
  {
+ 	unsigned int csum = 0;
  	/* The type-1 checksum offload engines append the checksum at
  	 * the end of frame and the two bytes of checksum are added in
  	 * the length.
  	 * Adjust for that in the framelen for type-1 checksum offload
! 	 * engines.
! 	 */
  	if (rx_coe_type == STMMAC_RX_COE_TYPE1)
! 		csum = 2;
! 
! 	return (((p->des0 & RDES0_FRAME_LEN_MASK) >> RDES0_FRAME_LEN_SHIFT) -
! 		csum);
  }
  
  static void enh_desc_enable_tx_timestamp(struct dma_desc *p)
  {
! 	p->des0 |= ETDES0_TIME_STAMP_ENABLE;
  }
  
  static int enh_desc_get_tx_timestamp_status(struct dma_desc *p)
  {
! 	return (p->des0 & ETDES0_TIME_STAMP_STATUS) >> 17;
  }
  
  static u64 enh_desc_get_timestamp(void *desc, u32 ats)
***************
*** 368,374 ****
  {
  	if (ats) {
  		struct dma_extended_desc *p = (struct dma_extended_desc *)desc;
! 		return p->basic.des01.erx.ipc_csum_error;
  	} else {
  		struct dma_desc *p = (struct dma_desc *)desc;
  		if ((p->des2 == 0xffffffff) && (p->des3 == 0xffffffff))
--- 401,407 ----
  {
  	if (ats) {
  		struct dma_extended_desc *p = (struct dma_extended_desc *)desc;
! 		return (p->basic.des0 & RDES0_IPC_CSUM_ERROR) >> 7;
  	} else {
  		struct dma_desc *p = (struct dma_desc *)desc;
  		if ((p->des2 == 0xffffffff) && (p->des3 == 0xffffffff))
***************
*** 386,396 ****
  	.init_rx_desc = enh_desc_init_rx_desc,
  	.init_tx_desc = enh_desc_init_tx_desc,
  	.get_tx_owner = enh_desc_get_tx_owner,
- 	.get_rx_owner = enh_desc_get_rx_owner,
  	.release_tx_desc = enh_desc_release_tx_desc,
  	.prepare_tx_desc = enh_desc_prepare_tx_desc,
! 	.clear_tx_ic = enh_desc_clear_tx_ic,
! 	.close_tx_desc = enh_desc_close_tx_desc,
  	.get_tx_ls = enh_desc_get_tx_ls,
  	.set_tx_owner = enh_desc_set_tx_owner,
  	.set_rx_owner = enh_desc_set_rx_owner,
--- 419,427 ----
  	.init_rx_desc = enh_desc_init_rx_desc,
  	.init_tx_desc = enh_desc_init_tx_desc,
  	.get_tx_owner = enh_desc_get_tx_owner,
  	.release_tx_desc = enh_desc_release_tx_desc,
  	.prepare_tx_desc = enh_desc_prepare_tx_desc,
! 	.set_tx_ic = enh_desc_set_tx_ic,
  	.get_tx_ls = enh_desc_get_tx_ls,
  	.set_tx_owner = enh_desc_set_tx_owner,
  	.set_rx_owner = enh_desc_set_rx_owner,
diff -rcNP linux-4.4.24/drivers/net/ethernet/stmicro/stmmac/Kconfig linux-4.4.24-baikal/drivers/net/ethernet/stmicro/stmmac/Kconfig
*** linux-4.4.24/drivers/net/ethernet/stmicro/stmmac/Kconfig	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/net/ethernet/stmicro/stmmac/Kconfig	2016-11-11 14:49:53.000000000 +0300
***************
*** 37,42 ****
--- 37,52 ----
  	  platform specific code to function or is using platform
  	  data for setup.
  
+ config DWMAC_BAIKAL
+ 	tristate "Baikal Electronics DWMAC support"
+ 	default ARCH_BAIKAL
+ 	depends on OF
+ 	help
+ 	  Support for Baikal Electronics DWMAC Ethernet.
+ 
+ 	  This selects the Baikal-T SoC glue layer support for the stmmac
+ 	  device driver.
+ 
  config DWMAC_IPQ806X
  	tristate "QCA IPQ806x DWMAC support"
  	default ARCH_QCOM
***************
*** 114,120 ****
  	  This selects Allwinner SoC glue layer support for the
  	  stmmac device driver. This driver is used for A20/A31
  	  GMAC ethernet controller.
! endif
  
  config STMMAC_PCI
  	tristate "STMMAC PCI bus support"
--- 124,140 ----
  	  This selects Allwinner SoC glue layer support for the
  	  stmmac device driver. This driver is used for A20/A31
  	  GMAC ethernet controller.
! 
! config STMMAC_POLL_MODE
!     bool "Enable poll mode on STMMAC"
!     default n
!     depends on STMMAC_PLATFORM
!     ---help---  
!       If set to Y, this option enables stmmac polling mode, it tries to
!       reschedule the poll from the STMMAC's poll method.
! 
!       If unsure, say N.
! endif # STMMAC_PLATFORM
  
  config STMMAC_PCI
  	tristate "STMMAC PCI bus support"
diff -rcNP linux-4.4.24/drivers/net/ethernet/stmicro/stmmac/Makefile linux-4.4.24-baikal/drivers/net/ethernet/stmicro/stmmac/Makefile
*** linux-4.4.24/drivers/net/ethernet/stmicro/stmmac/Makefile	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/net/ethernet/stmicro/stmmac/Makefile	2016-11-11 14:49:53.000000000 +0300
***************
*** 6,11 ****
--- 6,12 ----
  
  # Ordering matters. Generic driver must be last.
  obj-$(CONFIG_STMMAC_PLATFORM)	+= stmmac-platform.o
+ obj-$(CONFIG_DWMAC_BAIKAL)	+= dwmac-baikal.o
  obj-$(CONFIG_DWMAC_IPQ806X)	+= dwmac-ipq806x.o
  obj-$(CONFIG_DWMAC_LPC18XX)	+= dwmac-lpc18xx.o
  obj-$(CONFIG_DWMAC_MESON)	+= dwmac-meson.o
diff -rcNP linux-4.4.24/drivers/net/ethernet/stmicro/stmmac/norm_desc.c linux-4.4.24-baikal/drivers/net/ethernet/stmicro/stmmac/norm_desc.c
*** linux-4.4.24/drivers/net/ethernet/stmicro/stmmac/norm_desc.c	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/net/ethernet/stmicro/stmmac/norm_desc.c	2016-11-11 14:49:53.000000000 +0300
***************
*** 29,61 ****
  static int ndesc_get_tx_status(void *data, struct stmmac_extra_stats *x,
  			       struct dma_desc *p, void __iomem *ioaddr)
  {
- 	int ret = 0;
  	struct net_device_stats *stats = (struct net_device_stats *)data;
  
! 	if (unlikely(p->des01.tx.error_summary)) {
! 		if (unlikely(p->des01.tx.underflow_error)) {
  			x->tx_underflow++;
  			stats->tx_fifo_errors++;
  		}
! 		if (unlikely(p->des01.tx.no_carrier)) {
  			x->tx_carrier++;
  			stats->tx_carrier_errors++;
  		}
! 		if (unlikely(p->des01.tx.loss_carrier)) {
  			x->tx_losscarrier++;
  			stats->tx_carrier_errors++;
  		}
! 		if (unlikely((p->des01.tx.excessive_deferral) ||
! 			     (p->des01.tx.excessive_collisions) ||
! 			     (p->des01.tx.late_collision)))
! 			stats->collisions += p->des01.tx.collision_count;
! 		ret = -1;
  	}
  
! 	if (p->des01.etx.vlan_frame)
  		x->tx_vlan++;
  
! 	if (unlikely(p->des01.tx.deferred))
  		x->tx_deferred++;
  
  	return ret;
--- 29,75 ----
  static int ndesc_get_tx_status(void *data, struct stmmac_extra_stats *x,
  			       struct dma_desc *p, void __iomem *ioaddr)
  {
  	struct net_device_stats *stats = (struct net_device_stats *)data;
+ 	unsigned int tdes0 = p->des0;
+ 	unsigned int tdes1 = p->des1;
+ 	int ret = tx_done;
+ 
+ 	/* Get tx owner first */
+ 	if (unlikely(tdes0 & TDES0_OWN))
+ 		return tx_dma_own;
+ 
+ 	/* Verify tx error by looking at the last segment. */
+ 	if (likely(!(tdes1 & TDES1_LAST_SEGMENT)))
+ 		return tx_not_ls;
  
! 	if (unlikely(tdes0 & TDES0_ERROR_SUMMARY)) {
! 		if (unlikely(tdes0 & TDES0_UNDERFLOW_ERROR)) {
  			x->tx_underflow++;
  			stats->tx_fifo_errors++;
  		}
! 		if (unlikely(tdes0 & TDES0_NO_CARRIER)) {
  			x->tx_carrier++;
  			stats->tx_carrier_errors++;
  		}
! 		if (unlikely(tdes0 & TDES0_LOSS_CARRIER)) {
  			x->tx_losscarrier++;
  			stats->tx_carrier_errors++;
  		}
! 		if (unlikely((tdes0 & TDES0_EXCESSIVE_DEFERRAL) ||
! 			     (tdes0 & TDES0_EXCESSIVE_COLLISIONS) ||
! 			     (tdes0 & TDES0_LATE_COLLISION))) {
! 			unsigned int collisions;
! 
! 			collisions = (tdes0 & TDES0_COLLISION_COUNT_MASK) >> 3;
! 			stats->collisions += collisions;
! 		}
! 		ret = tx_err;
  	}
  
! 	if (tdes0 & TDES0_VLAN_FRAME)
  		x->tx_vlan++;
  
! 	if (unlikely(tdes0 & TDES0_DEFERRED))
  		x->tx_deferred++;
  
  	return ret;
***************
*** 63,69 ****
  
  static int ndesc_get_tx_len(struct dma_desc *p)
  {
! 	return p->des01.tx.buffer1_size;
  }
  
  /* This function verifies if each incoming frame has some errors
--- 77,83 ----
  
  static int ndesc_get_tx_len(struct dma_desc *p)
  {
! 	return (p->des1 & RDES1_BUFFER1_SIZE_MASK);
  }
  
  /* This function verifies if each incoming frame has some errors
***************
*** 74,120 ****
  			       struct dma_desc *p)
  {
  	int ret = good_frame;
  	struct net_device_stats *stats = (struct net_device_stats *)data;
  
! 	if (unlikely(p->des01.rx.last_descriptor == 0)) {
  		pr_warn("%s: Oversized frame spanned multiple buffers\n",
  			__func__);
  		stats->rx_length_errors++;
  		return discard_frame;
  	}
  
! 	if (unlikely(p->des01.rx.error_summary)) {
! 		if (unlikely(p->des01.rx.descriptor_error))
  			x->rx_desc++;
! 		if (unlikely(p->des01.rx.sa_filter_fail))
  			x->sa_filter_fail++;
! 		if (unlikely(p->des01.rx.overflow_error))
  			x->overflow_error++;
! 		if (unlikely(p->des01.rx.ipc_csum_error))
  			x->ipc_csum_error++;
! 		if (unlikely(p->des01.rx.collision)) {
  			x->rx_collision++;
  			stats->collisions++;
  		}
! 		if (unlikely(p->des01.rx.crc_error)) {
  			x->rx_crc++;
  			stats->rx_crc_errors++;
  		}
  		ret = discard_frame;
  	}
! 	if (unlikely(p->des01.rx.dribbling))
  		x->dribbling_bit++;
  
! 	if (unlikely(p->des01.rx.length_error)) {
  		x->rx_length++;
  		ret = discard_frame;
  	}
! 	if (unlikely(p->des01.rx.mii_error)) {
  		x->rx_mii++;
  		ret = discard_frame;
  	}
  #ifdef STMMAC_VLAN_TAG_USED
! 	if (p->des01.rx.vlan_tag)
  		x->vlan_tag++;
  #endif
  	return ret;
--- 88,138 ----
  			       struct dma_desc *p)
  {
  	int ret = good_frame;
+ 	unsigned int rdes0 = p->des0;
  	struct net_device_stats *stats = (struct net_device_stats *)data;
  
! 	if (unlikely(rdes0 & RDES0_OWN))
! 		return dma_own;
! 
! 	if (unlikely(!(rdes0 & RDES0_LAST_DESCRIPTOR))) {
  		pr_warn("%s: Oversized frame spanned multiple buffers\n",
  			__func__);
  		stats->rx_length_errors++;
  		return discard_frame;
  	}
  
! 	if (unlikely(rdes0 & RDES0_ERROR_SUMMARY)) {
! 		if (unlikely(rdes0 & RDES0_DESCRIPTOR_ERROR))
  			x->rx_desc++;
! 		if (unlikely(rdes0 & RDES0_SA_FILTER_FAIL))
  			x->sa_filter_fail++;
! 		if (unlikely(rdes0 & RDES0_OVERFLOW_ERROR))
  			x->overflow_error++;
! 		if (unlikely(rdes0 & RDES0_IPC_CSUM_ERROR))
  			x->ipc_csum_error++;
! 		if (unlikely(rdes0 & RDES0_COLLISION)) {
  			x->rx_collision++;
  			stats->collisions++;
  		}
! 		if (unlikely(rdes0 & RDES0_CRC_ERROR)) {
  			x->rx_crc++;
  			stats->rx_crc_errors++;
  		}
  		ret = discard_frame;
  	}
! 	if (unlikely(rdes0 & RDES0_DRIBBLING))
  		x->dribbling_bit++;
  
! 	if (unlikely(rdes0 & RDES0_LENGTH_ERROR)) {
  		x->rx_length++;
  		ret = discard_frame;
  	}
! 	if (unlikely(rdes0 & RDES0_MII_ERROR)) {
  		x->rx_mii++;
  		ret = discard_frame;
  	}
  #ifdef STMMAC_VLAN_TAG_USED
! 	if (rdes0 & RDES0_VLAN_TAG)
  		x->vlan_tag++;
  #endif
  	return ret;
***************
*** 123,131 ****
  static void ndesc_init_rx_desc(struct dma_desc *p, int disable_rx_ic, int mode,
  			       int end)
  {
! 	p->des01.all_flags = 0;
! 	p->des01.rx.own = 1;
! 	p->des01.rx.buffer1_size = BUF_SIZE_2KiB - 1;
  
  	if (mode == STMMAC_CHAIN_MODE)
  		ndesc_rx_set_on_chain(p, end);
--- 141,148 ----
  static void ndesc_init_rx_desc(struct dma_desc *p, int disable_rx_ic, int mode,
  			       int end)
  {
! 	p->des0 |= RDES0_OWN;
! 	p->des1 |= (BUF_SIZE_2KiB - 1) & RDES1_BUFFER1_SIZE_MASK;
  
  	if (mode == STMMAC_CHAIN_MODE)
  		ndesc_rx_set_on_chain(p, end);
***************
*** 133,231 ****
  		ndesc_rx_set_on_ring(p, end);
  
  	if (disable_rx_ic)
! 		p->des01.rx.disable_ic = 1;
  }
  
  static void ndesc_init_tx_desc(struct dma_desc *p, int mode, int end)
  {
! 	p->des01.all_flags = 0;
  	if (mode == STMMAC_CHAIN_MODE)
! 		ndesc_tx_set_on_chain(p, end);
  	else
! 		ndesc_tx_set_on_ring(p, end);
  }
  
  static int ndesc_get_tx_owner(struct dma_desc *p)
  {
! 	return p->des01.tx.own;
! }
! 
! static int ndesc_get_rx_owner(struct dma_desc *p)
! {
! 	return p->des01.rx.own;
  }
  
  static void ndesc_set_tx_owner(struct dma_desc *p)
  {
! 	p->des01.tx.own = 1;
  }
  
  static void ndesc_set_rx_owner(struct dma_desc *p)
  {
! 	p->des01.rx.own = 1;
  }
  
  static int ndesc_get_tx_ls(struct dma_desc *p)
  {
! 	return p->des01.tx.last_segment;
  }
  
  static void ndesc_release_tx_desc(struct dma_desc *p, int mode)
  {
! 	int ter = p->des01.tx.end_ring;
  
  	memset(p, 0, offsetof(struct dma_desc, des2));
  	if (mode == STMMAC_CHAIN_MODE)
! 		ndesc_end_tx_desc_on_chain(p, ter);
  	else
  		ndesc_end_tx_desc_on_ring(p, ter);
  }
  
  static void ndesc_prepare_tx_desc(struct dma_desc *p, int is_fs, int len,
! 				  int csum_flag, int mode)
  {
! 	p->des01.tx.first_segment = is_fs;
  	if (mode == STMMAC_CHAIN_MODE)
  		norm_set_tx_desc_len_on_chain(p, len);
  	else
  		norm_set_tx_desc_len_on_ring(p, len);
  
! 	if (likely(csum_flag))
! 		p->des01.tx.checksum_insertion = cic_full;
  }
  
! static void ndesc_clear_tx_ic(struct dma_desc *p)
  {
! 	p->des01.tx.interrupt = 0;
! }
! 
! static void ndesc_close_tx_desc(struct dma_desc *p)
! {
! 	p->des01.tx.last_segment = 1;
! 	p->des01.tx.interrupt = 1;
  }
  
  static int ndesc_get_rx_frame_len(struct dma_desc *p, int rx_coe_type)
  {
  	/* The type-1 checksum offload engines append the checksum at
  	 * the end of frame and the two bytes of checksum are added in
  	 * the length.
  	 * Adjust for that in the framelen for type-1 checksum offload
! 	 * engines. */
  	if (rx_coe_type == STMMAC_RX_COE_TYPE1)
! 		return p->des01.rx.frame_length - 2;
! 	else
! 		return p->des01.rx.frame_length;
  }
  
  static void ndesc_enable_tx_timestamp(struct dma_desc *p)
  {
! 	p->des01.tx.time_stamp_enable = 1;
  }
  
  static int ndesc_get_tx_timestamp_status(struct dma_desc *p)
  {
! 	return p->des01.tx.time_stamp_status;
  }
  
  static u64 ndesc_get_timestamp(void *desc, u32 ats)
--- 150,259 ----
  		ndesc_rx_set_on_ring(p, end);
  
  	if (disable_rx_ic)
! 		p->des1 |= RDES1_DISABLE_IC;
  }
  
  static void ndesc_init_tx_desc(struct dma_desc *p, int mode, int end)
  {
! 	p->des0 &= ~TDES0_OWN;
  	if (mode == STMMAC_CHAIN_MODE)
! 		ndesc_tx_set_on_chain(p);
  	else
! 		ndesc_end_tx_desc_on_ring(p, end);
  }
  
  static int ndesc_get_tx_owner(struct dma_desc *p)
  {
! 	return (p->des0 & TDES0_OWN) >> 31;
  }
  
  static void ndesc_set_tx_owner(struct dma_desc *p)
  {
! 	p->des0 |= TDES0_OWN;
  }
  
  static void ndesc_set_rx_owner(struct dma_desc *p)
  {
! 	p->des0 |= RDES0_OWN;
  }
  
  static int ndesc_get_tx_ls(struct dma_desc *p)
  {
! 	return (p->des1 & TDES1_LAST_SEGMENT) >> 30;
  }
  
  static void ndesc_release_tx_desc(struct dma_desc *p, int mode)
  {
! 	int ter = (p->des1 & TDES1_END_RING) >> 25;
  
  	memset(p, 0, offsetof(struct dma_desc, des2));
  	if (mode == STMMAC_CHAIN_MODE)
! 		ndesc_tx_set_on_chain(p);
  	else
  		ndesc_end_tx_desc_on_ring(p, ter);
  }
  
  static void ndesc_prepare_tx_desc(struct dma_desc *p, int is_fs, int len,
! 				  bool csum_flag, int mode, bool tx_own,
! 				  bool ls)
  {
! 	unsigned int tdes1 = p->des1;
! 
! 	if (is_fs)
! 		tdes1 |= TDES1_FIRST_SEGMENT;
! 	else
! 		tdes1 &= ~TDES1_FIRST_SEGMENT;
! 
! 	if (likely(csum_flag))
! 		tdes1 |= (TX_CIC_FULL) << TDES1_CHECKSUM_INSERTION_SHIFT;
! 	else
! 		tdes1 &= ~(TX_CIC_FULL << TDES1_CHECKSUM_INSERTION_SHIFT);
! 
! 	if (ls)
! 		tdes1 |= TDES1_LAST_SEGMENT;
! 
! 	p->des1 = tdes1;
! 
  	if (mode == STMMAC_CHAIN_MODE)
  		norm_set_tx_desc_len_on_chain(p, len);
  	else
  		norm_set_tx_desc_len_on_ring(p, len);
  
! 	if (tx_own)
! 		p->des0 |= TDES0_OWN;
  }
  
! static void ndesc_set_tx_ic(struct dma_desc *p)
  {
! 	p->des1 |= TDES1_INTERRUPT;
  }
  
  static int ndesc_get_rx_frame_len(struct dma_desc *p, int rx_coe_type)
  {
+ 	unsigned int csum = 0;
+ 
  	/* The type-1 checksum offload engines append the checksum at
  	 * the end of frame and the two bytes of checksum are added in
  	 * the length.
  	 * Adjust for that in the framelen for type-1 checksum offload
! 	 * engines
! 	 */
  	if (rx_coe_type == STMMAC_RX_COE_TYPE1)
! 		csum = 2;
! 
! 	return (((p->des0 & RDES0_FRAME_LEN_MASK) >> RDES0_FRAME_LEN_SHIFT) -
! 		csum);
! 
  }
  
  static void ndesc_enable_tx_timestamp(struct dma_desc *p)
  {
! 	p->des1 |= TDES1_TIME_STAMP_ENABLE;
  }
  
  static int ndesc_get_tx_timestamp_status(struct dma_desc *p)
  {
! 	return (p->des0 & TDES0_TIME_STAMP_STATUS) >> 17;
  }
  
  static u64 ndesc_get_timestamp(void *desc, u32 ats)
***************
*** 258,268 ****
  	.init_rx_desc = ndesc_init_rx_desc,
  	.init_tx_desc = ndesc_init_tx_desc,
  	.get_tx_owner = ndesc_get_tx_owner,
- 	.get_rx_owner = ndesc_get_rx_owner,
  	.release_tx_desc = ndesc_release_tx_desc,
  	.prepare_tx_desc = ndesc_prepare_tx_desc,
! 	.clear_tx_ic = ndesc_clear_tx_ic,
! 	.close_tx_desc = ndesc_close_tx_desc,
  	.get_tx_ls = ndesc_get_tx_ls,
  	.set_tx_owner = ndesc_set_tx_owner,
  	.set_rx_owner = ndesc_set_rx_owner,
--- 286,294 ----
  	.init_rx_desc = ndesc_init_rx_desc,
  	.init_tx_desc = ndesc_init_tx_desc,
  	.get_tx_owner = ndesc_get_tx_owner,
  	.release_tx_desc = ndesc_release_tx_desc,
  	.prepare_tx_desc = ndesc_prepare_tx_desc,
! 	.set_tx_ic = ndesc_set_tx_ic,
  	.get_tx_ls = ndesc_get_tx_ls,
  	.set_tx_owner = ndesc_set_tx_owner,
  	.set_rx_owner = ndesc_set_rx_owner,
diff -rcNP linux-4.4.24/drivers/net/ethernet/stmicro/stmmac/ring_mode.c linux-4.4.24-baikal/drivers/net/ethernet/stmicro/stmmac/ring_mode.c
*** linux-4.4.24/drivers/net/ethernet/stmicro/stmmac/ring_mode.c	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/net/ethernet/stmicro/stmmac/ring_mode.c	2016-11-11 14:49:53.000000000 +0300
***************
*** 31,38 ****
  static int stmmac_jumbo_frm(void *p, struct sk_buff *skb, int csum)
  {
  	struct stmmac_priv *priv = (struct stmmac_priv *)p;
! 	unsigned int txsize = priv->dma_tx_size;
! 	unsigned int entry = priv->cur_tx % txsize;
  	struct dma_desc *desc;
  	unsigned int nopaged_len = skb_headlen(skb);
  	unsigned int bmax, len;
--- 31,37 ----
  static int stmmac_jumbo_frm(void *p, struct sk_buff *skb, int csum)
  {
  	struct stmmac_priv *priv = (struct stmmac_priv *)p;
! 	unsigned int entry = priv->cur_tx;
  	struct dma_desc *desc;
  	unsigned int nopaged_len = skb_headlen(skb);
  	unsigned int bmax, len;
***************
*** 57,68 ****
  			return -1;
  
  		priv->tx_skbuff_dma[entry].buf = desc->des2;
  		desc->des3 = desc->des2 + BUF_SIZE_4KiB;
  		priv->hw->desc->prepare_tx_desc(desc, 1, bmax, csum,
! 						STMMAC_RING_MODE);
! 		wmb();
  		priv->tx_skbuff[entry] = NULL;
! 		entry = (++priv->cur_tx) % txsize;
  
  		if (priv->extend_desc)
  			desc = (struct dma_desc *)(priv->dma_etx + entry);
--- 56,69 ----
  			return -1;
  
  		priv->tx_skbuff_dma[entry].buf = desc->des2;
+ 		priv->tx_skbuff_dma[entry].len = bmax;
+ 		priv->tx_skbuff_dma[entry].is_jumbo = true;
+ 
  		desc->des3 = desc->des2 + BUF_SIZE_4KiB;
  		priv->hw->desc->prepare_tx_desc(desc, 1, bmax, csum,
! 						STMMAC_RING_MODE, 0, false);
  		priv->tx_skbuff[entry] = NULL;
! 		entry = STMMAC_GET_ENTRY(entry, DMA_TX_SIZE);
  
  		if (priv->extend_desc)
  			desc = (struct dma_desc *)(priv->dma_etx + entry);
***************
*** 74,95 ****
  		if (dma_mapping_error(priv->device, desc->des2))
  			return -1;
  		priv->tx_skbuff_dma[entry].buf = desc->des2;
  		desc->des3 = desc->des2 + BUF_SIZE_4KiB;
  		priv->hw->desc->prepare_tx_desc(desc, 0, len, csum,
! 						STMMAC_RING_MODE);
! 		wmb();
! 		priv->hw->desc->set_tx_owner(desc);
  	} else {
  		desc->des2 = dma_map_single(priv->device, skb->data,
  					    nopaged_len, DMA_TO_DEVICE);
  		if (dma_mapping_error(priv->device, desc->des2))
  			return -1;
  		priv->tx_skbuff_dma[entry].buf = desc->des2;
  		desc->des3 = desc->des2 + BUF_SIZE_4KiB;
  		priv->hw->desc->prepare_tx_desc(desc, 1, nopaged_len, csum,
! 						STMMAC_RING_MODE);
  	}
  
  	return entry;
  }
  
--- 75,101 ----
  		if (dma_mapping_error(priv->device, desc->des2))
  			return -1;
  		priv->tx_skbuff_dma[entry].buf = desc->des2;
+ 		priv->tx_skbuff_dma[entry].len = len;
+ 		priv->tx_skbuff_dma[entry].is_jumbo = true;
+ 
  		desc->des3 = desc->des2 + BUF_SIZE_4KiB;
  		priv->hw->desc->prepare_tx_desc(desc, 0, len, csum,
! 						STMMAC_RING_MODE, 1, true);
  	} else {
  		desc->des2 = dma_map_single(priv->device, skb->data,
  					    nopaged_len, DMA_TO_DEVICE);
  		if (dma_mapping_error(priv->device, desc->des2))
  			return -1;
  		priv->tx_skbuff_dma[entry].buf = desc->des2;
+ 		priv->tx_skbuff_dma[entry].len = nopaged_len;
+ 		priv->tx_skbuff_dma[entry].is_jumbo = true;
  		desc->des3 = desc->des2 + BUF_SIZE_4KiB;
  		priv->hw->desc->prepare_tx_desc(desc, 1, nopaged_len, csum,
! 						STMMAC_RING_MODE, 0, true);
  	}
  
+ 	priv->cur_tx = entry;
+ 
  	return entry;
  }
  
***************
*** 120,126 ****
  
  static void stmmac_clean_desc3(void *priv_ptr, struct dma_desc *p)
  {
! 	if (unlikely(p->des3))
  		p->des3 = 0;
  }
  
--- 126,138 ----
  
  static void stmmac_clean_desc3(void *priv_ptr, struct dma_desc *p)
  {
! 	struct stmmac_priv *priv = (struct stmmac_priv *)priv_ptr;
! 	unsigned int entry = priv->dirty_tx;
! 
! 	/* des3 is only used for jumbo frames tx or time stamping */
! 	if (unlikely(priv->tx_skbuff_dma[entry].is_jumbo ||
! 		     (priv->tx_skbuff_dma[entry].last_segment &&
! 		      !priv->extend_desc && priv->hwts_tx_en)))
  		p->des3 = 0;
  }
  
diff -rcNP linux-4.4.24/drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c linux-4.4.24-baikal/drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c
*** linux-4.4.24/drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c	2016-11-11 14:49:53.000000000 +0300
***************
*** 97,103 ****
  	STMMAC_STAT(napi_poll),
  	STMMAC_STAT(tx_normal_irq_n),
  	STMMAC_STAT(tx_clean),
! 	STMMAC_STAT(tx_reset_ic_bit),
  	STMMAC_STAT(irq_receive_pmt_irq_n),
  	/* MMC info */
  	STMMAC_STAT(mmc_tx_irq_n),
--- 97,103 ----
  	STMMAC_STAT(napi_poll),
  	STMMAC_STAT(tx_normal_irq_n),
  	STMMAC_STAT(tx_clean),
! 	STMMAC_STAT(tx_set_ic_bit),
  	STMMAC_STAT(irq_receive_pmt_irq_n),
  	/* MMC info */
  	STMMAC_STAT(mmc_tx_irq_n),
***************
*** 136,141 ****
--- 136,166 ----
  	STMMAC_STAT(irq_pcs_ane_n),
  	STMMAC_STAT(irq_pcs_link_n),
  	STMMAC_STAT(irq_rgmii_n),
+ 	/* DEBUG */
+ 	STMMAC_STAT(mtl_tx_status_fifo_full),
+ 	STMMAC_STAT(mtl_tx_fifo_not_empty),
+ 	STMMAC_STAT(mmtl_fifo_ctrl),
+ 	STMMAC_STAT(mtl_tx_fifo_read_ctrl_write),
+ 	STMMAC_STAT(mtl_tx_fifo_read_ctrl_wait),
+ 	STMMAC_STAT(mtl_tx_fifo_read_ctrl_read),
+ 	STMMAC_STAT(mtl_tx_fifo_read_ctrl_idle),
+ 	STMMAC_STAT(mac_tx_in_pause),
+ 	STMMAC_STAT(mac_tx_frame_ctrl_xfer),
+ 	STMMAC_STAT(mac_tx_frame_ctrl_idle),
+ 	STMMAC_STAT(mac_tx_frame_ctrl_wait),
+ 	STMMAC_STAT(mac_tx_frame_ctrl_pause),
+ 	STMMAC_STAT(mac_gmii_tx_proto_engine),
+ 	STMMAC_STAT(mtl_rx_fifo_fill_level_full),
+ 	STMMAC_STAT(mtl_rx_fifo_fill_above_thresh),
+ 	STMMAC_STAT(mtl_rx_fifo_fill_below_thresh),
+ 	STMMAC_STAT(mtl_rx_fifo_fill_level_empty),
+ 	STMMAC_STAT(mtl_rx_fifo_read_ctrl_flush),
+ 	STMMAC_STAT(mtl_rx_fifo_read_ctrl_read_data),
+ 	STMMAC_STAT(mtl_rx_fifo_read_ctrl_status),
+ 	STMMAC_STAT(mtl_rx_fifo_read_ctrl_idle),
+ 	STMMAC_STAT(mtl_rx_fifo_ctrl_active),
+ 	STMMAC_STAT(mac_rx_frame_ctrl_fifo),
+ 	STMMAC_STAT(mac_gmii_rx_proto_engine),
  };
  #define STMMAC_STATS_LEN ARRAY_SIZE(stmmac_gstrings_stats)
  
***************
*** 497,502 ****
--- 522,532 ----
  			if (val)
  				priv->xstats.phy_eee_wakeup_error_n = val;
  		}
+ 
+ 		if ((priv->hw->mac->debug) &&
+ 		    (priv->synopsys_id >= DWMAC_CORE_3_50))
+ 			priv->hw->mac->debug(priv->ioaddr,
+ 					     (void *)&priv->xstats);
  	}
  	for (i = 0; i < STMMAC_STATS_LEN; i++) {
  		char *p = (char *)priv + stmmac_gstrings_stats[i].stat_offset;
***************
*** 751,756 ****
--- 781,823 ----
  		return ethtool_op_get_ts_info(dev, info);
  }
  
+ static int stmmac_get_tunable(struct net_device *dev,
+ 			      const struct ethtool_tunable *tuna, void *data)
+ {
+ 	struct stmmac_priv *priv = netdev_priv(dev);
+ 	int ret = 0;
+ 
+ 	switch (tuna->id) {
+ 	case ETHTOOL_RX_COPYBREAK:
+ 		*(u32 *)data = priv->rx_copybreak;
+ 		break;
+ 	default:
+ 		ret = -EINVAL;
+ 		break;
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ static int stmmac_set_tunable(struct net_device *dev,
+ 			      const struct ethtool_tunable *tuna,
+ 			      const void *data)
+ {
+ 	struct stmmac_priv *priv = netdev_priv(dev);
+ 	int ret = 0;
+ 
+ 	switch (tuna->id) {
+ 	case ETHTOOL_RX_COPYBREAK:
+ 		priv->rx_copybreak = *(u32 *)data;
+ 		break;
+ 	default:
+ 		ret = -EINVAL;
+ 		break;
+ 	}
+ 
+ 	return ret;
+ }
+ 
  static const struct ethtool_ops stmmac_ethtool_ops = {
  	.begin = stmmac_check_if_running,
  	.get_drvinfo = stmmac_ethtool_getdrvinfo,
***************
*** 773,778 ****
--- 840,847 ----
  	.get_ts_info = stmmac_get_ts_info,
  	.get_coalesce = stmmac_get_coalesce,
  	.set_coalesce = stmmac_set_coalesce,
+ 	.get_tunable = stmmac_get_tunable,
+ 	.set_tunable = stmmac_set_tunable,
  };
  
  void stmmac_set_ethtool_ops(struct net_device *netdev)
diff -rcNP linux-4.4.24/drivers/net/ethernet/stmicro/stmmac/stmmac.h linux-4.4.24-baikal/drivers/net/ethernet/stmicro/stmmac/stmmac.h
*** linux-4.4.24/drivers/net/ethernet/stmicro/stmmac/stmmac.h	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/net/ethernet/stmicro/stmmac/stmmac.h	2016-11-11 14:49:53.000000000 +0300
***************
*** 24,30 ****
  #define __STMMAC_H__
  
  #define STMMAC_RESOURCE_NAME   "stmmaceth"
! #define DRV_MODULE_VERSION	"March_2013"
  
  #include <linux/clk.h>
  #include <linux/stmmac.h>
--- 24,30 ----
  #define __STMMAC_H__
  
  #define STMMAC_RESOURCE_NAME   "stmmaceth"
! #define DRV_MODULE_VERSION	"Oct_2015"
  
  #include <linux/clk.h>
  #include <linux/stmmac.h>
***************
*** 45,50 ****
--- 45,53 ----
  struct stmmac_tx_info {
  	dma_addr_t buf;
  	bool map_as_page;
+ 	unsigned len;
+ 	bool last_segment;
+ 	bool is_jumbo;
  };
  
  struct stmmac_priv {
***************
*** 54,60 ****
  	struct sk_buff **tx_skbuff;
  	unsigned int cur_tx;
  	unsigned int dirty_tx;
- 	unsigned int dma_tx_size;
  	u32 tx_count_frames;
  	u32 tx_coal_frames;
  	u32 tx_coal_timer;
--- 57,62 ----
***************
*** 71,78 ****
  	struct sk_buff **rx_skbuff;
  	unsigned int cur_rx;
  	unsigned int dirty_rx;
- 	unsigned int dma_rx_size;
  	unsigned int dma_buf_sz;
  	u32 rx_riwt;
  	int hwts_rx_en;
  	dma_addr_t *rx_skbuff_dma;
--- 73,81 ----
  	struct sk_buff **rx_skbuff;
  	unsigned int cur_rx;
  	unsigned int dirty_rx;
  	unsigned int dma_buf_sz;
+ 	unsigned int rx_copybreak;
+ 	unsigned int rx_zeroc_thresh;
  	u32 rx_riwt;
  	int hwts_rx_en;
  	dma_addr_t *rx_skbuff_dma;
diff -rcNP linux-4.4.24/drivers/net/ethernet/stmicro/stmmac/stmmac_hwtstamp.c linux-4.4.24-baikal/drivers/net/ethernet/stmicro/stmmac/stmmac_hwtstamp.c
*** linux-4.4.24/drivers/net/ethernet/stmicro/stmmac/stmmac_hwtstamp.c	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/net/ethernet/stmicro/stmmac/stmmac_hwtstamp.c	2016-11-11 14:49:53.000000000 +0300
***************
*** 33,54 ****
  	writel(data, ioaddr + PTP_TCR);
  }
  
! static void stmmac_config_sub_second_increment(void __iomem *ioaddr)
  {
  	u32 value = readl(ioaddr + PTP_TCR);
  	unsigned long data;
  
  	/* Convert the ptp_clock to nano second
! 	 * formula = (1/ptp_clock) * 1000000000
  	 * where, ptp_clock = 50MHz.
  	 */
! 	data = (1000000000ULL / 50000000);
  
  	/* 0.465ns accuracy */
  	if (!(value & PTP_TCR_TSCTRLSSR))
  		data = (data * 1000) / 465;
  
  	writel(data, ioaddr + PTP_SSIR);
  }
  
  static int stmmac_init_systime(void __iomem *ioaddr, u32 sec, u32 nsec)
--- 33,57 ----
  	writel(data, ioaddr + PTP_TCR);
  }
  
! static u32 stmmac_config_sub_second_increment(void __iomem *ioaddr,
! 					      u32 ptp_clock)
  {
  	u32 value = readl(ioaddr + PTP_TCR);
  	unsigned long data;
  
  	/* Convert the ptp_clock to nano second
! 	 * formula = (2/ptp_clock) * 1000000000
  	 * where, ptp_clock = 50MHz.
  	 */
! 	data = (2000000000ULL / ptp_clock);
  
  	/* 0.465ns accuracy */
  	if (!(value & PTP_TCR_TSCTRLSSR))
  		data = (data * 1000) / 465;
  
  	writel(data, ioaddr + PTP_SSIR);
+ 
+ 	return data;
  }
  
  static int stmmac_init_systime(void __iomem *ioaddr, u32 sec, u32 nsec)
diff -rcNP linux-4.4.24/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c linux-4.4.24-baikal/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
*** linux-4.4.24/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c	2016-11-11 14:49:53.000000000 +0300
***************
*** 53,58 ****
--- 53,59 ----
  #include "stmmac.h"
  #include <linux/reset.h>
  #include <linux/of_mdio.h>
+ #include "dwmac1000.h"
  
  #define STMMAC_ALIGN(x)	L1_CACHE_ALIGN(x)
  
***************
*** 70,84 ****
  module_param(phyaddr, int, S_IRUGO);
  MODULE_PARM_DESC(phyaddr, "Physical device address");
  
! #define DMA_TX_SIZE 256
! static int dma_txsize = DMA_TX_SIZE;
! module_param(dma_txsize, int, S_IRUGO | S_IWUSR);
! MODULE_PARM_DESC(dma_txsize, "Number of descriptors in the TX list");
! 
! #define DMA_RX_SIZE 256
! static int dma_rxsize = DMA_RX_SIZE;
! module_param(dma_rxsize, int, S_IRUGO | S_IWUSR);
! MODULE_PARM_DESC(dma_rxsize, "Number of descriptors in the RX list");
  
  static int flow_ctrl = FLOW_OFF;
  module_param(flow_ctrl, int, S_IRUGO | S_IWUSR);
--- 71,78 ----
  module_param(phyaddr, int, S_IRUGO);
  MODULE_PARM_DESC(phyaddr, "Physical device address");
  
! #define STMMAC_TX_THRESH	(DMA_TX_SIZE / 4)
! #define STMMAC_RX_THRESH	(DMA_RX_SIZE / 4)
  
  static int flow_ctrl = FLOW_OFF;
  module_param(flow_ctrl, int, S_IRUGO | S_IWUSR);
***************
*** 98,103 ****
--- 92,99 ----
  module_param(buf_sz, int, S_IRUGO | S_IWUSR);
  MODULE_PARM_DESC(buf_sz, "DMA buffer size");
  
+ #define	STMMAC_RX_COPYBREAK	256
+ 
  static const u32 default_msg_level = (NETIF_MSG_DRV | NETIF_MSG_PROBE |
  				      NETIF_MSG_LINK | NETIF_MSG_IFUP |
  				      NETIF_MSG_IFDOWN | NETIF_MSG_TIMER);
***************
*** 133,142 ****
  {
  	if (unlikely(watchdog < 0))
  		watchdog = TX_TIMEO;
- 	if (unlikely(dma_rxsize < 0))
- 		dma_rxsize = DMA_RX_SIZE;
- 	if (unlikely(dma_txsize < 0))
- 		dma_txsize = DMA_TX_SIZE;
  	if (unlikely((buf_sz < DEFAULT_BUFSIZE) || (buf_sz > BUF_SIZE_16KiB)))
  		buf_sz = DEFAULT_BUFSIZE;
  	if (unlikely(flow_ctrl > 1))
--- 129,134 ----
***************
*** 185,191 ****
  			priv->clk_csr = STMMAC_CSR_100_150M;
  		else if ((clk_rate >= CSR_F_150M) && (clk_rate < CSR_F_250M))
  			priv->clk_csr = STMMAC_CSR_150_250M;
! 		else if ((clk_rate >= CSR_F_250M) && (clk_rate <= CSR_F_300M))
  			priv->clk_csr = STMMAC_CSR_250_300M;
  	}
  }
--- 177,183 ----
  			priv->clk_csr = STMMAC_CSR_100_150M;
  		else if ((clk_rate >= CSR_F_150M) && (clk_rate < CSR_F_250M))
  			priv->clk_csr = STMMAC_CSR_150_250M;
! 		else if ((clk_rate >= CSR_F_250M) && (clk_rate < CSR_F_300M))
  			priv->clk_csr = STMMAC_CSR_250_300M;
  	}
  }
***************
*** 196,207 ****
  	print_hex_dump_bytes("", DUMP_PREFIX_OFFSET, buf, len);
  }
  
- /* minimum number of free TX descriptors required to wake up TX process */
- #define STMMAC_TX_THRESH(x)	(x->dma_tx_size/4)
- 
  static inline u32 stmmac_tx_avail(struct stmmac_priv *priv)
  {
! 	return priv->dirty_tx + priv->dma_tx_size - priv->cur_tx - 1;
  }
  
  /**
--- 188,215 ----
  	print_hex_dump_bytes("", DUMP_PREFIX_OFFSET, buf, len);
  }
  
  static inline u32 stmmac_tx_avail(struct stmmac_priv *priv)
  {
! 	unsigned avail;
! 
! 	if (priv->dirty_tx > priv->cur_tx)
! 		avail = priv->dirty_tx - priv->cur_tx - 1;
! 	else
! 		avail = DMA_TX_SIZE - priv->cur_tx + priv->dirty_tx - 1;
! 
! 	return avail;
! }
! 
! static inline u32 stmmac_rx_dirty(struct stmmac_priv *priv)
! {
! 	unsigned dirty;
! 
! 	if (priv->dirty_rx <= priv->cur_rx)
! 		dirty = priv->cur_rx - priv->dirty_rx;
! 	else
! 		dirty = DMA_RX_SIZE - priv->dirty_rx + priv->cur_rx;
! 
! 	return dirty;
  }
  
  /**
***************
*** 270,276 ****
   */
  bool stmmac_eee_init(struct stmmac_priv *priv)
  {
- 	char *phy_bus_name = priv->plat->phy_bus_name;
  	unsigned long flags;
  	bool ret = false;
  
--- 278,283 ----
***************
*** 281,290 ****
  	    (priv->pcs == STMMAC_PCS_RTBI))
  		goto out;
  
- 	/* Never init EEE in case of a switch is attached */
- 	if (phy_bus_name && (!strcmp(phy_bus_name, "fixed")))
- 		goto out;
- 
  	/* MAC core supports the EEE feature. */
  	if (priv->dma_cap.eee) {
  		int tx_lpi_timer = priv->tx_lpi_timer;
--- 288,293 ----
***************
*** 435,440 ****
--- 438,444 ----
  	u32 ts_master_en = 0;
  	u32 ts_event_en = 0;
  	u32 value = 0;
+ 	u32 sec_inc;
  
  	if (!(priv->dma_cap.time_stamp || priv->adv_ts)) {
  		netdev_alert(priv->dev, "No support for HW time stamping\n");
***************
*** 598,621 ****
  			 tstamp_all | ptp_v2 | ptp_over_ethernet |
  			 ptp_over_ipv6_udp | ptp_over_ipv4_udp | ts_event_en |
  			 ts_master_en | snap_type_sel);
- 
  		priv->hw->ptp->config_hw_tstamping(priv->ioaddr, value);
  
  		/* program Sub Second Increment reg */
! 		priv->hw->ptp->config_sub_second_increment(priv->ioaddr);
  
  		/* calculate default added value:
  		 * formula is :
  		 * addend = (2^32)/freq_div_ratio;
! 		 * where, freq_div_ratio = clk_ptp_ref_i/50MHz
! 		 * hence, addend = ((2^32) * 50MHz)/clk_ptp_ref_i;
! 		 * NOTE: clk_ptp_ref_i should be >= 50MHz to
! 		 *       achieve 20ns accuracy.
! 		 *
! 		 * 2^x * y == (y << x), hence
! 		 * 2^32 * 50000000 ==> (50000000 << 32)
  		 */
! 		temp = (u64) (50000000ULL << 32);
  		priv->default_addend = div_u64(temp, priv->clk_ptp_rate);
  		priv->hw->ptp->config_addend(priv->ioaddr,
  					     priv->default_addend);
--- 602,620 ----
  			 tstamp_all | ptp_v2 | ptp_over_ethernet |
  			 ptp_over_ipv6_udp | ptp_over_ipv4_udp | ts_event_en |
  			 ts_master_en | snap_type_sel);
  		priv->hw->ptp->config_hw_tstamping(priv->ioaddr, value);
  
  		/* program Sub Second Increment reg */
! 		sec_inc = priv->hw->ptp->config_sub_second_increment(
! 			priv->ioaddr, priv->clk_ptp_rate);
! 		temp = div_u64(1000000000ULL, sec_inc);
  
  		/* calculate default added value:
  		 * formula is :
  		 * addend = (2^32)/freq_div_ratio;
! 		 * where, freq_div_ratio = 1e9ns/sec_inc
  		 */
! 		temp = (u64)(temp << 32);
  		priv->default_addend = div_u64(temp, priv->clk_ptp_rate);
  		priv->hw->ptp->config_addend(priv->ioaddr,
  					     priv->default_addend);
***************
*** 730,736 ****
--- 729,739 ----
  			case 10:
  				if (priv->plat->has_gmac) {
  					ctrl |= priv->hw->link.port;
+ #ifdef CONFIG_BAIKAL_ERRATA_GMAC
+ 					if (phydev->speed == SPEED_10) {
+ #else
  					if (phydev->speed == SPEED_100) {
+ #endif
  						ctrl |= priv->hw->link.speed;
  					} else {
  						ctrl &= ~(priv->hw->link.speed);
***************
*** 768,777 ****
  
  	spin_unlock_irqrestore(&priv->lock, flags);
  
! 	/* At this stage, it could be needed to setup the EEE or adjust some
! 	 * MAC related HW registers.
! 	 */
! 	priv->eee_enabled = stmmac_eee_init(priv);
  }
  
  /**
--- 771,786 ----
  
  	spin_unlock_irqrestore(&priv->lock, flags);
  
! 	if (phydev->is_pseudo_fixed_link)
! 		/* Stop PHY layer to call the hook to adjust the link in case
! 		 * of a switch is attached to the stmmac driver.
! 		 */
! 		phydev->irq = PHY_IGNORE_INTERRUPT;
! 	else
! 		/* At this stage, init the EEE if supported.
! 		 * Never called in case of fixed_link.
! 		 */
! 		priv->eee_enabled = stmmac_eee_init(priv);
  }
  
  /**
***************
*** 823,834 ****
  		phydev = of_phy_connect(dev, priv->plat->phy_node,
  					&stmmac_adjust_link, 0, interface);
  	} else {
! 		if (priv->plat->phy_bus_name)
! 			snprintf(bus_id, MII_BUS_ID_SIZE, "%s-%x",
! 				 priv->plat->phy_bus_name, priv->plat->bus_id);
! 		else
! 			snprintf(bus_id, MII_BUS_ID_SIZE, "stmmac-%x",
! 				 priv->plat->bus_id);
  
  		snprintf(phy_id_fmt, MII_BUS_ID_SIZE + 3, PHY_ID_FMT, bus_id,
  			 priv->plat->phy_addr);
--- 832,839 ----
  		phydev = of_phy_connect(dev, priv->plat->phy_node,
  					&stmmac_adjust_link, 0, interface);
  	} else {
! 		snprintf(bus_id, MII_BUS_ID_SIZE, "stmmac-%x",
! 			 priv->plat->bus_id);
  
  		snprintf(phy_id_fmt, MII_BUS_ID_SIZE + 3, PHY_ID_FMT, bus_id,
  			 priv->plat->phy_addr);
***************
*** 865,870 ****
--- 870,876 ----
  		phy_disconnect(phydev);
  		return -ENODEV;
  	}
+ 
  	pr_debug("stmmac_init_phy:  %s: attached to PHY (UID 0x%x)"
  		 " Link = %d\n", dev->name, phydev->phy_id, phydev->link);
  
***************
*** 909,927 ****
  
  static void stmmac_display_rings(struct stmmac_priv *priv)
  {
- 	unsigned int txsize = priv->dma_tx_size;
- 	unsigned int rxsize = priv->dma_rx_size;
- 
  	if (priv->extend_desc) {
  		pr_info("Extended RX descriptor ring:\n");
! 		stmmac_display_ring((void *)priv->dma_erx, rxsize, 1);
  		pr_info("Extended TX descriptor ring:\n");
! 		stmmac_display_ring((void *)priv->dma_etx, txsize, 1);
  	} else {
  		pr_info("RX descriptor ring:\n");
! 		stmmac_display_ring((void *)priv->dma_rx, rxsize, 0);
  		pr_info("TX descriptor ring:\n");
! 		stmmac_display_ring((void *)priv->dma_tx, txsize, 0);
  	}
  }
  
--- 915,930 ----
  
  static void stmmac_display_rings(struct stmmac_priv *priv)
  {
  	if (priv->extend_desc) {
  		pr_info("Extended RX descriptor ring:\n");
! 		stmmac_display_ring((void *)priv->dma_erx, DMA_RX_SIZE, 1);
  		pr_info("Extended TX descriptor ring:\n");
! 		stmmac_display_ring((void *)priv->dma_etx, DMA_TX_SIZE, 1);
  	} else {
  		pr_info("RX descriptor ring:\n");
! 		stmmac_display_ring((void *)priv->dma_rx, DMA_RX_SIZE, 0);
  		pr_info("TX descriptor ring:\n");
! 		stmmac_display_ring((void *)priv->dma_tx, DMA_TX_SIZE, 0);
  	}
  }
  
***************
*** 950,977 ****
  static void stmmac_clear_descriptors(struct stmmac_priv *priv)
  {
  	int i;
- 	unsigned int txsize = priv->dma_tx_size;
- 	unsigned int rxsize = priv->dma_rx_size;
  
  	/* Clear the Rx/Tx descriptors */
! 	for (i = 0; i < rxsize; i++)
  		if (priv->extend_desc)
  			priv->hw->desc->init_rx_desc(&priv->dma_erx[i].basic,
  						     priv->use_riwt, priv->mode,
! 						     (i == rxsize - 1));
  		else
  			priv->hw->desc->init_rx_desc(&priv->dma_rx[i],
  						     priv->use_riwt, priv->mode,
! 						     (i == rxsize - 1));
! 	for (i = 0; i < txsize; i++)
  		if (priv->extend_desc)
  			priv->hw->desc->init_tx_desc(&priv->dma_etx[i].basic,
  						     priv->mode,
! 						     (i == txsize - 1));
  		else
  			priv->hw->desc->init_tx_desc(&priv->dma_tx[i],
  						     priv->mode,
! 						     (i == txsize - 1));
  }
  
  /**
--- 953,978 ----
  static void stmmac_clear_descriptors(struct stmmac_priv *priv)
  {
  	int i;
  
  	/* Clear the Rx/Tx descriptors */
! 	for (i = 0; i < DMA_RX_SIZE; i++)
  		if (priv->extend_desc)
  			priv->hw->desc->init_rx_desc(&priv->dma_erx[i].basic,
  						     priv->use_riwt, priv->mode,
! 						     (i == DMA_RX_SIZE - 1));
  		else
  			priv->hw->desc->init_rx_desc(&priv->dma_rx[i],
  						     priv->use_riwt, priv->mode,
! 						     (i == DMA_RX_SIZE - 1));
! 	for (i = 0; i < DMA_TX_SIZE; i++)
  		if (priv->extend_desc)
  			priv->hw->desc->init_tx_desc(&priv->dma_etx[i].basic,
  						     priv->mode,
! 						     (i == DMA_TX_SIZE - 1));
  		else
  			priv->hw->desc->init_tx_desc(&priv->dma_tx[i],
  						     priv->mode,
! 						     (i == DMA_TX_SIZE - 1));
  }
  
  /**
***************
*** 1034,1041 ****
  {
  	int i;
  	struct stmmac_priv *priv = netdev_priv(dev);
- 	unsigned int txsize = priv->dma_tx_size;
- 	unsigned int rxsize = priv->dma_rx_size;
  	unsigned int bfsize = 0;
  	int ret = -ENOMEM;
  
--- 1035,1040 ----
***************
*** 1047,1056 ****
  
  	priv->dma_buf_sz = bfsize;
  
- 	if (netif_msg_probe(priv))
- 		pr_debug("%s: txsize %d, rxsize %d, bfsize %d\n", __func__,
- 			 txsize, rxsize, bfsize);
- 
  	if (netif_msg_probe(priv)) {
  		pr_debug("(%s) dma_rx_phy=0x%08x dma_tx_phy=0x%08x\n", __func__,
  			 (u32) priv->dma_rx_phy, (u32) priv->dma_tx_phy);
--- 1046,1051 ----
***************
*** 1058,1064 ****
  		/* RX INITIALIZATION */
  		pr_debug("\tSKB addresses:\nskb\t\tskb data\tdma data\n");
  	}
! 	for (i = 0; i < rxsize; i++) {
  		struct dma_desc *p;
  		if (priv->extend_desc)
  			p = &((priv->dma_erx + i)->basic);
--- 1053,1059 ----
  		/* RX INITIALIZATION */
  		pr_debug("\tSKB addresses:\nskb\t\tskb data\tdma data\n");
  	}
! 	for (i = 0; i < DMA_RX_SIZE; i++) {
  		struct dma_desc *p;
  		if (priv->extend_desc)
  			p = &((priv->dma_erx + i)->basic);
***************
*** 1075,1100 ****
  				 (unsigned int)priv->rx_skbuff_dma[i]);
  	}
  	priv->cur_rx = 0;
! 	priv->dirty_rx = (unsigned int)(i - rxsize);
  	buf_sz = bfsize;
  
  	/* Setup the chained descriptor addresses */
  	if (priv->mode == STMMAC_CHAIN_MODE) {
  		if (priv->extend_desc) {
  			priv->hw->mode->init(priv->dma_erx, priv->dma_rx_phy,
! 					     rxsize, 1);
  			priv->hw->mode->init(priv->dma_etx, priv->dma_tx_phy,
! 					     txsize, 1);
  		} else {
  			priv->hw->mode->init(priv->dma_rx, priv->dma_rx_phy,
! 					     rxsize, 0);
  			priv->hw->mode->init(priv->dma_tx, priv->dma_tx_phy,
! 					     txsize, 0);
  		}
  	}
  
  	/* TX INITIALIZATION */
! 	for (i = 0; i < txsize; i++) {
  		struct dma_desc *p;
  		if (priv->extend_desc)
  			p = &((priv->dma_etx + i)->basic);
--- 1070,1095 ----
  				 (unsigned int)priv->rx_skbuff_dma[i]);
  	}
  	priv->cur_rx = 0;
! 	priv->dirty_rx = (unsigned int)(i - DMA_RX_SIZE);
  	buf_sz = bfsize;
  
  	/* Setup the chained descriptor addresses */
  	if (priv->mode == STMMAC_CHAIN_MODE) {
  		if (priv->extend_desc) {
  			priv->hw->mode->init(priv->dma_erx, priv->dma_rx_phy,
! 					     DMA_RX_SIZE, 1);
  			priv->hw->mode->init(priv->dma_etx, priv->dma_tx_phy,
! 					     DMA_TX_SIZE, 1);
  		} else {
  			priv->hw->mode->init(priv->dma_rx, priv->dma_rx_phy,
! 					     DMA_RX_SIZE, 0);
  			priv->hw->mode->init(priv->dma_tx, priv->dma_tx_phy,
! 					     DMA_TX_SIZE, 0);
  		}
  	}
  
  	/* TX INITIALIZATION */
! 	for (i = 0; i < DMA_TX_SIZE; i++) {
  		struct dma_desc *p;
  		if (priv->extend_desc)
  			p = &((priv->dma_etx + i)->basic);
***************
*** 1103,1108 ****
--- 1098,1105 ----
  		p->des2 = 0;
  		priv->tx_skbuff_dma[i].buf = 0;
  		priv->tx_skbuff_dma[i].map_as_page = false;
+ 		priv->tx_skbuff_dma[i].len = 0;
+ 		priv->tx_skbuff_dma[i].last_segment = false;
  		priv->tx_skbuff[i] = NULL;
  	}
  
***************
*** 1126,1132 ****
  {
  	int i;
  
! 	for (i = 0; i < priv->dma_rx_size; i++)
  		stmmac_free_rx_buffers(priv, i);
  }
  
--- 1123,1129 ----
  {
  	int i;
  
! 	for (i = 0; i < DMA_RX_SIZE; i++)
  		stmmac_free_rx_buffers(priv, i);
  }
  
***************
*** 1134,1140 ****
  {
  	int i;
  
! 	for (i = 0; i < priv->dma_tx_size; i++) {
  		struct dma_desc *p;
  
  		if (priv->extend_desc)
--- 1131,1137 ----
  {
  	int i;
  
! 	for (i = 0; i < DMA_TX_SIZE; i++) {
  		struct dma_desc *p;
  
  		if (priv->extend_desc)
***************
*** 1146,1157 ****
  			if (priv->tx_skbuff_dma[i].map_as_page)
  				dma_unmap_page(priv->device,
  					       priv->tx_skbuff_dma[i].buf,
! 					       priv->hw->desc->get_tx_len(p),
  					       DMA_TO_DEVICE);
  			else
  				dma_unmap_single(priv->device,
  						 priv->tx_skbuff_dma[i].buf,
! 						 priv->hw->desc->get_tx_len(p),
  						 DMA_TO_DEVICE);
  		}
  
--- 1143,1154 ----
  			if (priv->tx_skbuff_dma[i].map_as_page)
  				dma_unmap_page(priv->device,
  					       priv->tx_skbuff_dma[i].buf,
! 					       priv->tx_skbuff_dma[i].len,
  					       DMA_TO_DEVICE);
  			else
  				dma_unmap_single(priv->device,
  						 priv->tx_skbuff_dma[i].buf,
! 						 priv->tx_skbuff_dma[i].len,
  						 DMA_TO_DEVICE);
  		}
  
***************
*** 1174,1206 ****
   */
  static int alloc_dma_desc_resources(struct stmmac_priv *priv)
  {
- 	unsigned int txsize = priv->dma_tx_size;
- 	unsigned int rxsize = priv->dma_rx_size;
  	int ret = -ENOMEM;
  
! 	priv->rx_skbuff_dma = kmalloc_array(rxsize, sizeof(dma_addr_t),
  					    GFP_KERNEL);
  	if (!priv->rx_skbuff_dma)
  		return -ENOMEM;
  
! 	priv->rx_skbuff = kmalloc_array(rxsize, sizeof(struct sk_buff *),
  					GFP_KERNEL);
  	if (!priv->rx_skbuff)
  		goto err_rx_skbuff;
  
! 	priv->tx_skbuff_dma = kmalloc_array(txsize,
  					    sizeof(*priv->tx_skbuff_dma),
  					    GFP_KERNEL);
  	if (!priv->tx_skbuff_dma)
  		goto err_tx_skbuff_dma;
  
! 	priv->tx_skbuff = kmalloc_array(txsize, sizeof(struct sk_buff *),
  					GFP_KERNEL);
  	if (!priv->tx_skbuff)
  		goto err_tx_skbuff;
  
  	if (priv->extend_desc) {
! 		priv->dma_erx = dma_zalloc_coherent(priv->device, rxsize *
  						    sizeof(struct
  							   dma_extended_desc),
  						    &priv->dma_rx_phy,
--- 1171,1201 ----
   */
  static int alloc_dma_desc_resources(struct stmmac_priv *priv)
  {
  	int ret = -ENOMEM;
  
! 	priv->rx_skbuff_dma = kmalloc_array(DMA_RX_SIZE, sizeof(dma_addr_t),
  					    GFP_KERNEL);
  	if (!priv->rx_skbuff_dma)
  		return -ENOMEM;
  
! 	priv->rx_skbuff = kmalloc_array(DMA_RX_SIZE, sizeof(struct sk_buff *),
  					GFP_KERNEL);
  	if (!priv->rx_skbuff)
  		goto err_rx_skbuff;
  
! 	priv->tx_skbuff_dma = kmalloc_array(DMA_TX_SIZE,
  					    sizeof(*priv->tx_skbuff_dma),
  					    GFP_KERNEL);
  	if (!priv->tx_skbuff_dma)
  		goto err_tx_skbuff_dma;
  
! 	priv->tx_skbuff = kmalloc_array(DMA_TX_SIZE, sizeof(struct sk_buff *),
  					GFP_KERNEL);
  	if (!priv->tx_skbuff)
  		goto err_tx_skbuff;
  
  	if (priv->extend_desc) {
! 		priv->dma_erx = dma_zalloc_coherent(priv->device, DMA_RX_SIZE *
  						    sizeof(struct
  							   dma_extended_desc),
  						    &priv->dma_rx_phy,
***************
*** 1208,1238 ****
  		if (!priv->dma_erx)
  			goto err_dma;
  
! 		priv->dma_etx = dma_zalloc_coherent(priv->device, txsize *
  						    sizeof(struct
  							   dma_extended_desc),
  						    &priv->dma_tx_phy,
  						    GFP_KERNEL);
  		if (!priv->dma_etx) {
! 			dma_free_coherent(priv->device, priv->dma_rx_size *
  					  sizeof(struct dma_extended_desc),
  					  priv->dma_erx, priv->dma_rx_phy);
  			goto err_dma;
  		}
  	} else {
! 		priv->dma_rx = dma_zalloc_coherent(priv->device, rxsize *
  						   sizeof(struct dma_desc),
  						   &priv->dma_rx_phy,
  						   GFP_KERNEL);
  		if (!priv->dma_rx)
  			goto err_dma;
  
! 		priv->dma_tx = dma_zalloc_coherent(priv->device, txsize *
  						   sizeof(struct dma_desc),
  						   &priv->dma_tx_phy,
  						   GFP_KERNEL);
  		if (!priv->dma_tx) {
! 			dma_free_coherent(priv->device, priv->dma_rx_size *
  					  sizeof(struct dma_desc),
  					  priv->dma_rx, priv->dma_rx_phy);
  			goto err_dma;
--- 1203,1233 ----
  		if (!priv->dma_erx)
  			goto err_dma;
  
! 		priv->dma_etx = dma_zalloc_coherent(priv->device, DMA_TX_SIZE *
  						    sizeof(struct
  							   dma_extended_desc),
  						    &priv->dma_tx_phy,
  						    GFP_KERNEL);
  		if (!priv->dma_etx) {
! 			dma_free_coherent(priv->device, DMA_RX_SIZE *
  					  sizeof(struct dma_extended_desc),
  					  priv->dma_erx, priv->dma_rx_phy);
  			goto err_dma;
  		}
  	} else {
! 		priv->dma_rx = dma_zalloc_coherent(priv->device, DMA_RX_SIZE *
  						   sizeof(struct dma_desc),
  						   &priv->dma_rx_phy,
  						   GFP_KERNEL);
  		if (!priv->dma_rx)
  			goto err_dma;
  
! 		priv->dma_tx = dma_zalloc_coherent(priv->device, DMA_TX_SIZE *
  						   sizeof(struct dma_desc),
  						   &priv->dma_tx_phy,
  						   GFP_KERNEL);
  		if (!priv->dma_tx) {
! 			dma_free_coherent(priv->device, DMA_RX_SIZE *
  					  sizeof(struct dma_desc),
  					  priv->dma_rx, priv->dma_rx_phy);
  			goto err_dma;
***************
*** 1261,1276 ****
  	/* Free DMA regions of consistent memory previously allocated */
  	if (!priv->extend_desc) {
  		dma_free_coherent(priv->device,
! 				  priv->dma_tx_size * sizeof(struct dma_desc),
  				  priv->dma_tx, priv->dma_tx_phy);
  		dma_free_coherent(priv->device,
! 				  priv->dma_rx_size * sizeof(struct dma_desc),
  				  priv->dma_rx, priv->dma_rx_phy);
  	} else {
! 		dma_free_coherent(priv->device, priv->dma_tx_size *
  				  sizeof(struct dma_extended_desc),
  				  priv->dma_etx, priv->dma_tx_phy);
! 		dma_free_coherent(priv->device, priv->dma_rx_size *
  				  sizeof(struct dma_extended_desc),
  				  priv->dma_erx, priv->dma_rx_phy);
  	}
--- 1256,1271 ----
  	/* Free DMA regions of consistent memory previously allocated */
  	if (!priv->extend_desc) {
  		dma_free_coherent(priv->device,
! 				  DMA_TX_SIZE * sizeof(struct dma_desc),
  				  priv->dma_tx, priv->dma_tx_phy);
  		dma_free_coherent(priv->device,
! 				  DMA_RX_SIZE * sizeof(struct dma_desc),
  				  priv->dma_rx, priv->dma_rx_phy);
  	} else {
! 		dma_free_coherent(priv->device, DMA_TX_SIZE *
  				  sizeof(struct dma_extended_desc),
  				  priv->dma_etx, priv->dma_tx_phy);
! 		dma_free_coherent(priv->device, DMA_RX_SIZE *
  				  sizeof(struct dma_extended_desc),
  				  priv->dma_erx, priv->dma_rx_phy);
  	}
***************
*** 1315,1376 ****
   */
  static void stmmac_tx_clean(struct stmmac_priv *priv)
  {
- 	unsigned int txsize = priv->dma_tx_size;
  	unsigned int bytes_compl = 0, pkts_compl = 0;
  
  	spin_lock(&priv->tx_lock);
  
  	priv->xstats.tx_clean++;
  
! 	while (priv->dirty_tx != priv->cur_tx) {
! 		int last;
! 		unsigned int entry = priv->dirty_tx % txsize;
! 		struct sk_buff *skb = priv->tx_skbuff[entry];
  		struct dma_desc *p;
  
  		if (priv->extend_desc)
  			p = (struct dma_desc *)(priv->dma_etx + entry);
  		else
  			p = priv->dma_tx + entry;
  
! 		/* Check if the descriptor is owned by the DMA. */
! 		if (priv->hw->desc->get_tx_owner(p))
! 			break;
  
! 		/* Verify tx error by looking at the last segment. */
! 		last = priv->hw->desc->get_tx_ls(p);
! 		if (likely(last)) {
! 			int tx_error =
! 			    priv->hw->desc->tx_status(&priv->dev->stats,
  						      &priv->xstats, p,
  						      priv->ioaddr);
! 			if (likely(tx_error == 0)) {
  				priv->dev->stats.tx_packets++;
  				priv->xstats.tx_pkt_n++;
! 			} else
! 				priv->dev->stats.tx_errors++;
! 
  			stmmac_get_tx_hwtstamp(priv, entry, skb);
  		}
- 		if (netif_msg_tx_done(priv))
- 			pr_debug("%s: curr %d, dirty %d\n", __func__,
- 				 priv->cur_tx, priv->dirty_tx);
  
  		if (likely(priv->tx_skbuff_dma[entry].buf)) {
  			if (priv->tx_skbuff_dma[entry].map_as_page)
  				dma_unmap_page(priv->device,
  					       priv->tx_skbuff_dma[entry].buf,
! 					       priv->hw->desc->get_tx_len(p),
  					       DMA_TO_DEVICE);
  			else
  				dma_unmap_single(priv->device,
  						 priv->tx_skbuff_dma[entry].buf,
! 						 priv->hw->desc->get_tx_len(p),
  						 DMA_TO_DEVICE);
  			priv->tx_skbuff_dma[entry].buf = 0;
  			priv->tx_skbuff_dma[entry].map_as_page = false;
  		}
  		priv->hw->mode->clean_desc3(priv, p);
  
  		if (likely(skb != NULL)) {
  			pkts_compl++;
--- 1310,1375 ----
   */
  static void stmmac_tx_clean(struct stmmac_priv *priv)
  {
  	unsigned int bytes_compl = 0, pkts_compl = 0;
+ 	unsigned int entry = priv->dirty_tx;
  
  	spin_lock(&priv->tx_lock);
  
  	priv->xstats.tx_clean++;
  
! 	while (entry != priv->cur_tx) {
! 		struct sk_buff *skb;
  		struct dma_desc *p;
+ 		int status;
  
  		if (priv->extend_desc)
  			p = (struct dma_desc *)(priv->dma_etx + entry);
  		else
  			p = priv->dma_tx + entry;
  
! 		smp_rmb();
! 
! 		skb = priv->tx_skbuff[entry];
  
! 		status = priv->hw->desc->tx_status(&priv->dev->stats,
  						      &priv->xstats, p,
  						      priv->ioaddr);
! #ifdef CONFIG_CPU_HAS_PREFETCH
! 		prefetch((const void *)&priv->tx_skbuff_dma[entry]);
! #endif
! 		/* Check if the descriptor is owned by the DMA */
! 		if (unlikely(status & tx_dma_own))
! 			break;
! 
! 		/* Just consider the last segment and ...*/
! 		if (likely(!(status & tx_not_ls))) {
! 			/* ... verify the status error condition */
! 			if (unlikely(status & tx_err)) {
! 				priv->dev->stats.tx_errors++;
! 			} else {
  				priv->dev->stats.tx_packets++;
  				priv->xstats.tx_pkt_n++;
! 			}
  			stmmac_get_tx_hwtstamp(priv, entry, skb);
  		}
  
  		if (likely(priv->tx_skbuff_dma[entry].buf)) {
  			if (priv->tx_skbuff_dma[entry].map_as_page)
  				dma_unmap_page(priv->device,
  					       priv->tx_skbuff_dma[entry].buf,
! 					       priv->tx_skbuff_dma[entry].len,
  					       DMA_TO_DEVICE);
  			else
  				dma_unmap_single(priv->device,
  						 priv->tx_skbuff_dma[entry].buf,
! 						 priv->tx_skbuff_dma[entry].len,
  						 DMA_TO_DEVICE);
  			priv->tx_skbuff_dma[entry].buf = 0;
  			priv->tx_skbuff_dma[entry].map_as_page = false;
  		}
  		priv->hw->mode->clean_desc3(priv, p);
+ 		priv->tx_skbuff_dma[entry].last_segment = false;
+ 		priv->tx_skbuff_dma[entry].is_jumbo = false;
  
  		if (likely(skb != NULL)) {
  			pkts_compl++;
***************
*** 1381,1396 ****
  
  		priv->hw->desc->release_tx_desc(p, priv->mode);
  
! 		priv->dirty_tx++;
  	}
  
  	netdev_completed_queue(priv->dev, pkts_compl, bytes_compl);
  
  	if (unlikely(netif_queue_stopped(priv->dev) &&
! 		     stmmac_tx_avail(priv) > STMMAC_TX_THRESH(priv))) {
  		netif_tx_lock(priv->dev);
  		if (netif_queue_stopped(priv->dev) &&
! 		    stmmac_tx_avail(priv) > STMMAC_TX_THRESH(priv)) {
  			if (netif_msg_tx_done(priv))
  				pr_debug("%s: restart transmit\n", __func__);
  			netif_wake_queue(priv->dev);
--- 1380,1396 ----
  
  		priv->hw->desc->release_tx_desc(p, priv->mode);
  
! 		entry = STMMAC_GET_ENTRY(entry, DMA_TX_SIZE);
  	}
+ 	priv->dirty_tx = entry;
  
  	netdev_completed_queue(priv->dev, pkts_compl, bytes_compl);
  
  	if (unlikely(netif_queue_stopped(priv->dev) &&
! 		     stmmac_tx_avail(priv) > STMMAC_TX_THRESH)) {
  		netif_tx_lock(priv->dev);
  		if (netif_queue_stopped(priv->dev) &&
! 		    stmmac_tx_avail(priv) > STMMAC_TX_THRESH) {
  			if (netif_msg_tx_done(priv))
  				pr_debug("%s: restart transmit\n", __func__);
  			netif_wake_queue(priv->dev);
***************
*** 1424,1443 ****
  static void stmmac_tx_err(struct stmmac_priv *priv)
  {
  	int i;
- 	int txsize = priv->dma_tx_size;
  	netif_stop_queue(priv->dev);
  
  	priv->hw->dma->stop_tx(priv->ioaddr);
  	dma_free_tx_skbufs(priv);
! 	for (i = 0; i < txsize; i++)
  		if (priv->extend_desc)
  			priv->hw->desc->init_tx_desc(&priv->dma_etx[i].basic,
  						     priv->mode,
! 						     (i == txsize - 1));
  		else
  			priv->hw->desc->init_tx_desc(&priv->dma_tx[i],
  						     priv->mode,
! 						     (i == txsize - 1));
  	priv->dirty_tx = 0;
  	priv->cur_tx = 0;
  	netdev_reset_queue(priv->dev);
--- 1424,1442 ----
  static void stmmac_tx_err(struct stmmac_priv *priv)
  {
  	int i;
  	netif_stop_queue(priv->dev);
  
  	priv->hw->dma->stop_tx(priv->ioaddr);
  	dma_free_tx_skbufs(priv);
! 	for (i = 0; i < DMA_TX_SIZE; i++)
  		if (priv->extend_desc)
  			priv->hw->desc->init_tx_desc(&priv->dma_etx[i].basic,
  						     priv->mode,
! 						     (i == DMA_TX_SIZE - 1));
  		else
  			priv->hw->desc->init_tx_desc(&priv->dma_tx[i],
  						     priv->mode,
! 						     (i == DMA_TX_SIZE - 1));
  	priv->dirty_tx = 0;
  	priv->cur_tx = 0;
  	netdev_reset_queue(priv->dev);
***************
*** 1638,1660 ****
   */
  static int stmmac_init_dma_engine(struct stmmac_priv *priv)
  {
! 	int pbl = DEFAULT_DMA_PBL, fixed_burst = 0, burst_len = 0;
  	int mixed_burst = 0;
  	int atds = 0;
  
  	if (priv->plat->dma_cfg) {
  		pbl = priv->plat->dma_cfg->pbl;
  		fixed_burst = priv->plat->dma_cfg->fixed_burst;
  		mixed_burst = priv->plat->dma_cfg->mixed_burst;
! 		burst_len = priv->plat->dma_cfg->burst_len;
  	}
  
  	if (priv->extend_desc && (priv->mode == STMMAC_RING_MODE))
  		atds = 1;
  
! 	return priv->hw->dma->init(priv->ioaddr, pbl, fixed_burst, mixed_burst,
! 				   burst_len, priv->dma_tx_phy,
! 				   priv->dma_rx_phy, atds);
  }
  
  /**
--- 1637,1671 ----
   */
  static int stmmac_init_dma_engine(struct stmmac_priv *priv)
  {
! 	int pbl = DEFAULT_DMA_PBL, fixed_burst = 0, aal = 0;
  	int mixed_burst = 0;
  	int atds = 0;
+ 	int ret = 0;
  
  	if (priv->plat->dma_cfg) {
  		pbl = priv->plat->dma_cfg->pbl;
  		fixed_burst = priv->plat->dma_cfg->fixed_burst;
  		mixed_burst = priv->plat->dma_cfg->mixed_burst;
! 		aal = priv->plat->dma_cfg->aal;
  	}
  
  	if (priv->extend_desc && (priv->mode == STMMAC_RING_MODE))
  		atds = 1;
  
! 	ret = priv->hw->dma->reset(priv->ioaddr);
! 	if (ret) {
! 		dev_err(priv->device, "Failed to reset the dma\n");
! 		return ret;
! 	}
! 
! 	priv->hw->dma->init(priv->ioaddr, pbl, fixed_burst, mixed_burst,
! 			    aal, priv->dma_tx_phy, priv->dma_rx_phy, atds);
! 
! 	if ((priv->synopsys_id >= DWMAC_CORE_3_50) &&
! 	    (priv->plat->axi && priv->hw->dma->axi))
! 		priv->hw->dma->axi(priv->ioaddr, priv->plat->axi);
! 
! 	return ret;
  }
  
  /**
***************
*** 1802,1811 ****
  	memset(&priv->xstats, 0, sizeof(struct stmmac_extra_stats));
  	priv->xstats.threshold = tc;
  
- 	/* Create and initialize the TX/RX descriptors chains. */
- 	priv->dma_tx_size = STMMAC_ALIGN(dma_txsize);
- 	priv->dma_rx_size = STMMAC_ALIGN(dma_rxsize);
  	priv->dma_buf_sz = STMMAC_ALIGN(buf_sz);
  
  	ret = alloc_dma_desc_resources(priv);
  	if (ret < 0) {
--- 1813,1820 ----
  	memset(&priv->xstats, 0, sizeof(struct stmmac_extra_stats));
  	priv->xstats.threshold = tc;
  
  	priv->dma_buf_sz = STMMAC_ALIGN(buf_sz);
+ 	priv->rx_copybreak = STMMAC_RX_COPYBREAK;
  
  	ret = alloc_dma_desc_resources(priv);
  	if (ret < 0) {
***************
*** 1946,1958 ****
  static netdev_tx_t stmmac_xmit(struct sk_buff *skb, struct net_device *dev)
  {
  	struct stmmac_priv *priv = netdev_priv(dev);
! 	unsigned int txsize = priv->dma_tx_size;
! 	int entry;
  	int i, csum_insertion = 0, is_jumbo = 0;
  	int nfrags = skb_shinfo(skb)->nr_frags;
  	struct dma_desc *desc, *first;
! 	unsigned int nopaged_len = skb_headlen(skb);
! 	unsigned int enh_desc = priv->plat->enh_desc;
  
  	spin_lock(&priv->tx_lock);
  
--- 1955,1966 ----
  static netdev_tx_t stmmac_xmit(struct sk_buff *skb, struct net_device *dev)
  {
  	struct stmmac_priv *priv = netdev_priv(dev);
! 	unsigned int nopaged_len = skb_headlen(skb);
  	int i, csum_insertion = 0, is_jumbo = 0;
  	int nfrags = skb_shinfo(skb)->nr_frags;
+ 	unsigned int entry, first_entry;
  	struct dma_desc *desc, *first;
! 	unsigned int enh_desc;
  
  	spin_lock(&priv->tx_lock);
  
***************
*** 1969,1999 ****
  	if (priv->tx_path_in_lpi_mode)
  		stmmac_disable_eee_mode(priv);
  
! 	entry = priv->cur_tx % txsize;
  
  	csum_insertion = (skb->ip_summed == CHECKSUM_PARTIAL);
  
! 	if (priv->extend_desc)
  		desc = (struct dma_desc *)(priv->dma_etx + entry);
  	else
  		desc = priv->dma_tx + entry;
  
  	first = desc;
  
  	/* To program the descriptors according to the size of the frame */
  	if (enh_desc)
  		is_jumbo = priv->hw->mode->is_jumbo_frm(skb->len, enh_desc);
  
! 	if (likely(!is_jumbo)) {
! 		desc->des2 = dma_map_single(priv->device, skb->data,
! 					    nopaged_len, DMA_TO_DEVICE);
! 		if (dma_mapping_error(priv->device, desc->des2))
! 			goto dma_map_err;
! 		priv->tx_skbuff_dma[entry].buf = desc->des2;
! 		priv->hw->desc->prepare_tx_desc(desc, 1, nopaged_len,
! 						csum_insertion, priv->mode);
! 	} else {
! 		desc = first;
  		entry = priv->hw->mode->jumbo_frm(priv, skb, csum_insertion);
  		if (unlikely(entry < 0))
  			goto dma_map_err;
--- 1977,2004 ----
  	if (priv->tx_path_in_lpi_mode)
  		stmmac_disable_eee_mode(priv);
  
! 	entry = priv->cur_tx;
! 	first_entry = entry;
  
  	csum_insertion = (skb->ip_summed == CHECKSUM_PARTIAL);
  
! 	if (likely(priv->extend_desc))
  		desc = (struct dma_desc *)(priv->dma_etx + entry);
  	else
  		desc = priv->dma_tx + entry;
  
  	first = desc;
  
+ 	smp_rmb();
+ 
+ 	priv->tx_skbuff[first_entry] = skb;
+ 
+ 	enh_desc = priv->plat->enh_desc;
  	/* To program the descriptors according to the size of the frame */
  	if (enh_desc)
  		is_jumbo = priv->hw->mode->is_jumbo_frm(skb->len, enh_desc);
  
! 	if (unlikely(is_jumbo)) {
  		entry = priv->hw->mode->jumbo_frm(priv, skb, csum_insertion);
  		if (unlikely(entry < 0))
  			goto dma_map_err;
***************
*** 2002,2011 ****
  	for (i = 0; i < nfrags; i++) {
  		const skb_frag_t *frag = &skb_shinfo(skb)->frags[i];
  		int len = skb_frag_size(frag);
  
! 		priv->tx_skbuff[entry] = NULL;
! 		entry = (++priv->cur_tx) % txsize;
! 		if (priv->extend_desc)
  			desc = (struct dma_desc *)(priv->dma_etx + entry);
  		else
  			desc = priv->dma_tx + entry;
--- 2007,2017 ----
  	for (i = 0; i < nfrags; i++) {
  		const skb_frag_t *frag = &skb_shinfo(skb)->frags[i];
  		int len = skb_frag_size(frag);
+ 		bool last_segment = (i == (nfrags - 1));
  
! 		entry = STMMAC_GET_ENTRY(entry, DMA_TX_SIZE);
! 
! 		if (likely(priv->extend_desc))
  			desc = (struct dma_desc *)(priv->dma_etx + entry);
  		else
  			desc = priv->dma_tx + entry;
***************
*** 2015,2067 ****
  		if (dma_mapping_error(priv->device, desc->des2))
  			goto dma_map_err; /* should reuse desc w/o issues */
  
  		priv->tx_skbuff_dma[entry].buf = desc->des2;
  		priv->tx_skbuff_dma[entry].map_as_page = true;
  		priv->hw->desc->prepare_tx_desc(desc, 0, len, csum_insertion,
! 						priv->mode);
! 		wmb();
! 		priv->hw->desc->set_tx_owner(desc);
! 		wmb();
  	}
  
! 	priv->tx_skbuff[entry] = skb;
! 
! 	/* Finalize the latest segment. */
! 	priv->hw->desc->close_tx_desc(desc);
! 
! 	wmb();
! 	/* According to the coalesce parameter the IC bit for the latest
! 	 * segment could be reset and the timer re-started to invoke the
! 	 * stmmac_tx function. This approach takes care about the fragments.
! 	 */
! 	priv->tx_count_frames += nfrags + 1;
! 	if (priv->tx_coal_frames > priv->tx_count_frames) {
! 		priv->hw->desc->clear_tx_ic(desc);
! 		priv->xstats.tx_reset_ic_bit++;
! 		mod_timer(&priv->txtimer,
! 			  STMMAC_COAL_TIMER(priv->tx_coal_timer));
! 	} else
! 		priv->tx_count_frames = 0;
! 
! 	/* To avoid raise condition */
! 	priv->hw->desc->set_tx_owner(first);
! 	wmb();
  
! 	priv->cur_tx++;
  
  	if (netif_msg_pktdata(priv)) {
! 		pr_debug("%s: curr %d dirty=%d entry=%d, first=%p, nfrags=%d",
! 			__func__, (priv->cur_tx % txsize),
! 			(priv->dirty_tx % txsize), entry, first, nfrags);
  
  		if (priv->extend_desc)
! 			stmmac_display_ring((void *)priv->dma_etx, txsize, 1);
  		else
! 			stmmac_display_ring((void *)priv->dma_tx, txsize, 0);
  
  		pr_debug(">>> frame to be transmitted: ");
  		print_pkt(skb->data, skb->len);
  	}
  	if (unlikely(stmmac_tx_avail(priv) <= (MAX_SKB_FRAGS + 1))) {
  		if (netif_msg_hw(priv))
  			pr_debug("%s: stop transmitted packets\n", __func__);
--- 2021,2057 ----
  		if (dma_mapping_error(priv->device, desc->des2))
  			goto dma_map_err; /* should reuse desc w/o issues */
  
+ 		priv->tx_skbuff[entry] = NULL;
  		priv->tx_skbuff_dma[entry].buf = desc->des2;
  		priv->tx_skbuff_dma[entry].map_as_page = true;
+ 		priv->tx_skbuff_dma[entry].len = len;
+ 		priv->tx_skbuff_dma[entry].last_segment = last_segment;
+ 
+ 		/* Prepare the descriptor and set the own bit too */
  		priv->hw->desc->prepare_tx_desc(desc, 0, len, csum_insertion,
! 						priv->mode, 1, last_segment);
  	}
  
! 	entry = STMMAC_GET_ENTRY(entry, DMA_TX_SIZE);
  
! 	priv->cur_tx = entry;
  
  	if (netif_msg_pktdata(priv)) {
! 		pr_debug("%s: curr=%d dirty=%d f=%d, e=%d, first=%p, nfrags=%d",
! 			 __func__, priv->cur_tx, priv->dirty_tx, first_entry,
! 			 entry, first, nfrags);
  
  		if (priv->extend_desc)
! 			stmmac_display_ring((void *)priv->dma_etx,
! 					    DMA_TX_SIZE, 1);
  		else
! 			stmmac_display_ring((void *)priv->dma_tx,
! 					    DMA_TX_SIZE, 0);
  
  		pr_debug(">>> frame to be transmitted: ");
  		print_pkt(skb->data, skb->len);
  	}
+ 
  	if (unlikely(stmmac_tx_avail(priv) <= (MAX_SKB_FRAGS + 1))) {
  		if (netif_msg_hw(priv))
  			pr_debug("%s: stop transmitted packets\n", __func__);
***************
*** 2070,2087 ****
  
  	dev->stats.tx_bytes += skb->len;
  
! 	if (unlikely((skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP) &&
! 		     priv->hwts_tx_en)) {
! 		/* declare that device is doing timestamping */
! 		skb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;
! 		priv->hw->desc->enable_tx_timestamp(first);
  	}
  
  	if (!priv->hwts_tx_en)
  		skb_tx_timestamp(skb);
  
! 	netdev_sent_queue(dev, skb->len);
  	priv->hw->dma->enable_dma_transmission(priv->ioaddr);
  
  	spin_unlock(&priv->tx_lock);
  	return NETDEV_TX_OK;
--- 2060,2120 ----
  
  	dev->stats.tx_bytes += skb->len;
  
! 	/* According to the coalesce parameter the IC bit for the latest
! 	 * segment is reset and the timer re-started to clean the tx status.
! 	 * This approach takes care about the fragments: desc is the first
! 	 * element in case of no SG.
! 	 */
! 	priv->tx_count_frames += nfrags + 1;
! 	if (likely(priv->tx_coal_frames > priv->tx_count_frames)) {
! 		mod_timer(&priv->txtimer,
! 			  STMMAC_COAL_TIMER(priv->tx_coal_timer));
! 	} else {
! 		priv->tx_count_frames = 0;
! 		priv->hw->desc->set_tx_ic(desc);
! 		priv->xstats.tx_set_ic_bit++;
  	}
  
  	if (!priv->hwts_tx_en)
  		skb_tx_timestamp(skb);
  
! 	/* Ready to fill the first descriptor and set the OWN bit w/o any
! 	 * problems because all the descriptors are actually ready to be
! 	 * passed to the DMA engine.
! 	 */
! 	if (likely(!is_jumbo)) {
! 		bool last_segment = (nfrags == 0);
! 
! 		first->des2 = dma_map_single(priv->device, skb->data,
! 					     nopaged_len, DMA_TO_DEVICE);
! 		if (dma_mapping_error(priv->device, first->des2))
! 			goto dma_map_err;
! 
! 		priv->tx_skbuff_dma[first_entry].buf = first->des2;
! 		priv->tx_skbuff_dma[first_entry].len = nopaged_len;
! 		priv->tx_skbuff_dma[first_entry].last_segment = last_segment;
! 
! 		if (unlikely((skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP) &&
! 			     priv->hwts_tx_en)) {
! 			/* declare that device is doing timestamping */
! 			skb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;
! 			priv->hw->desc->enable_tx_timestamp(first);
! 		}
! 		smp_wmb();
! 		/* Prepare the first descriptor setting the OWN bit too */
! 		priv->hw->desc->prepare_tx_desc(first, 1, nopaged_len,
! 						csum_insertion, priv->mode, 1,
! 						last_segment);
! 
! 		/* The own bit must be the latest setting done when prepare the
! 		 * descriptor and then barrier is needed to make sure that
! 		 * all is coherent before granting the DMA engine.
! 		 */
! 		smp_wmb();
! 	}
! 
  	priv->hw->dma->enable_dma_transmission(priv->ioaddr);
+ 	netdev_sent_queue(dev, skb->len);
  
  	spin_unlock(&priv->tx_lock);
  	return NETDEV_TX_OK;
***************
*** 2111,2116 ****
--- 2144,2157 ----
  }
  
  
+ static inline int stmmac_rx_threshold_count(struct stmmac_priv *priv)
+ {
+ 	if (priv->rx_zeroc_thresh < STMMAC_RX_THRESH)
+ 		return 0;
+ 
+ 	return 1;
+ }
+ 
  /**
   * stmmac_rx_refill - refill used skb preallocated buffers
   * @priv: driver private structure
***************
*** 2119,2129 ****
   */
  static inline void stmmac_rx_refill(struct stmmac_priv *priv)
  {
- 	unsigned int rxsize = priv->dma_rx_size;
  	int bfsize = priv->dma_buf_sz;
  
! 	for (; priv->cur_rx - priv->dirty_rx > 0; priv->dirty_rx++) {
! 		unsigned int entry = priv->dirty_rx % rxsize;
  		struct dma_desc *p;
  
  		if (priv->extend_desc)
--- 2160,2170 ----
   */
  static inline void stmmac_rx_refill(struct stmmac_priv *priv)
  {
  	int bfsize = priv->dma_buf_sz;
+ 	unsigned int entry = priv->dirty_rx;
+ 	int dirty = stmmac_rx_dirty(priv);
  
! 	while (dirty-- > 0) {
  		struct dma_desc *p;
  
  		if (priv->extend_desc)
***************
*** 2135,2143 ****
  			struct sk_buff *skb;
  
  			skb = netdev_alloc_skb_ip_align(priv->dev, bfsize);
! 
! 			if (unlikely(skb == NULL))
  				break;
  
  			priv->rx_skbuff[entry] = skb;
  			priv->rx_skbuff_dma[entry] =
--- 2176,2190 ----
  			struct sk_buff *skb;
  
  			skb = netdev_alloc_skb_ip_align(priv->dev, bfsize);
! 			if (unlikely(!skb)) {
! 				/* so for a while no zero-copy! */
! 				priv->rx_zeroc_thresh = STMMAC_RX_THRESH;
! 				if (unlikely(net_ratelimit()))
! 					dev_err(priv->device,
! 						"fail to alloc skb entry %d\n",
! 						entry);
  				break;
+ 			}
  
  			priv->rx_skbuff[entry] = skb;
  			priv->rx_skbuff_dma[entry] =
***************
*** 2153,2165 ****
--- 2200,2219 ----
  
  			priv->hw->mode->refill_desc3(priv, p);
  
+ 			if (priv->rx_zeroc_thresh > 0)
+ 				priv->rx_zeroc_thresh--;
+ 
  			if (netif_msg_rx_status(priv))
  				pr_debug("\trefill entry #%d\n", entry);
  		}
+ 
  		wmb();
  		priv->hw->desc->set_rx_owner(p);
  		wmb();
+ 
+ 		entry = STMMAC_GET_ENTRY(entry, DMA_RX_SIZE);
  	}
+ 	priv->dirty_rx = entry;
  }
  
  /**
***************
*** 2171,2178 ****
   */
  static int stmmac_rx(struct stmmac_priv *priv, int limit)
  {
! 	unsigned int rxsize = priv->dma_rx_size;
! 	unsigned int entry = priv->cur_rx % rxsize;
  	unsigned int next_entry;
  	unsigned int count = 0;
  	int coe = priv->hw->rx_csum;
--- 2225,2231 ----
   */
  static int stmmac_rx(struct stmmac_priv *priv, int limit)
  {
! 	unsigned int entry = priv->cur_rx;
  	unsigned int next_entry;
  	unsigned int count = 0;
  	int coe = priv->hw->rx_csum;
***************
*** 2180,2188 ****
  	if (netif_msg_rx_status(priv)) {
  		pr_debug("%s: descriptor ring:\n", __func__);
  		if (priv->extend_desc)
! 			stmmac_display_ring((void *)priv->dma_erx, rxsize, 1);
  		else
! 			stmmac_display_ring((void *)priv->dma_rx, rxsize, 0);
  	}
  	while (count < limit) {
  		int status;
--- 2233,2243 ----
  	if (netif_msg_rx_status(priv)) {
  		pr_debug("%s: descriptor ring:\n", __func__);
  		if (priv->extend_desc)
! 			stmmac_display_ring((void *)priv->dma_erx,
! 					    DMA_RX_SIZE, 1);
  		else
! 			stmmac_display_ring((void *)priv->dma_rx,
! 					    DMA_RX_SIZE, 0);
  	}
  	while (count < limit) {
  		int status;
***************
*** 2193,2212 ****
  		else
  			p = priv->dma_rx + entry;
  
! 		if (priv->hw->desc->get_rx_owner(p))
  			break;
  
  		count++;
  
! 		next_entry = (++priv->cur_rx) % rxsize;
  		if (priv->extend_desc)
  			prefetch(priv->dma_erx + next_entry);
  		else
  			prefetch(priv->dma_rx + next_entry);
  
- 		/* read the status of the incoming frame */
- 		status = priv->hw->desc->rx_status(&priv->dev->stats,
- 						   &priv->xstats, p);
  		if ((priv->extend_desc) && (priv->hw->desc->rx_extended_status))
  			priv->hw->desc->rx_extended_status(&priv->dev->stats,
  							   &priv->xstats,
--- 2248,2272 ----
  		else
  			p = priv->dma_rx + entry;
  
! 		/* read the status of the incoming frame */
! 		status = priv->hw->desc->rx_status(&priv->dev->stats,
! 						   &priv->xstats, p);
! 		/* check if managed by the DMA otherwise go ahead */
! 		if (unlikely(status & dma_own))
  			break;
  
  		count++;
  
! 		priv->cur_rx = STMMAC_GET_ENTRY(priv->cur_rx, DMA_RX_SIZE);
! 		next_entry = priv->cur_rx;
! 
! #ifdef CONFIG_CPU_HAS_PREFETCH
  		if (priv->extend_desc)
  			prefetch(priv->dma_erx + next_entry);
  		else
  			prefetch(priv->dma_rx + next_entry);
+ #endif
  
  		if ((priv->extend_desc) && (priv->hw->desc->rx_extended_status))
  			priv->hw->desc->rx_extended_status(&priv->dev->stats,
  							   &priv->xstats,
***************
*** 2251,2273 ****
  					pr_debug("\tframe size %d, COE: %d\n",
  						 frame_len, status);
  			}
! 			skb = priv->rx_skbuff[entry];
! 			if (unlikely(!skb)) {
! 				pr_err("%s: Inconsistent Rx descriptor chain\n",
! 				       priv->dev->name);
! 				priv->dev->stats.rx_dropped++;
! 				break;
  			}
- 			prefetch(skb->data - NET_IP_ALIGN);
- 			priv->rx_skbuff[entry] = NULL;
  
  			stmmac_get_rx_hwtstamp(priv, entry, skb);
  
- 			skb_put(skb, frame_len);
- 			dma_unmap_single(priv->device,
- 					 priv->rx_skbuff_dma[entry],
- 					 priv->dma_buf_sz, DMA_FROM_DEVICE);
- 
  			if (netif_msg_pktdata(priv)) {
  				pr_debug("frame received (%dbytes)", frame_len);
  				print_pkt(skb->data, frame_len);
--- 2311,2366 ----
  					pr_debug("\tframe size %d, COE: %d\n",
  						 frame_len, status);
  			}
! 
! 			if (unlikely((frame_len < priv->rx_copybreak) ||
! 				     stmmac_rx_threshold_count(priv))) {
! 				skb = netdev_alloc_skb_ip_align(priv->dev,
! 								frame_len);
! 				if (unlikely(!skb)) {
! 					if (net_ratelimit())
! 						dev_warn(priv->device,
! 							 "packet dropped\n");
! 					priv->dev->stats.rx_dropped++;
! 					break;
! 				}
! 
! 				dma_sync_single_for_cpu(priv->device,
! 							priv->rx_skbuff_dma
! 							[entry], frame_len,
! 							DMA_FROM_DEVICE);
! 				skb_copy_to_linear_data(skb,
! 							priv->
! 							rx_skbuff[entry]->data,
! 							frame_len);
! 
! 				skb_put(skb, frame_len);
! 				dma_sync_single_for_device(priv->device,
! 							   priv->rx_skbuff_dma
! 							   [entry], frame_len,
! 							   DMA_FROM_DEVICE);
! 			} else {
! 				skb = priv->rx_skbuff[entry];
! 				if (unlikely(!skb)) {
! 					pr_err("%s: Inconsistent Rx chain\n",
! 					       priv->dev->name);
! 					priv->dev->stats.rx_dropped++;
! 					break;
! 				}
! #ifdef CONFIG_CPU_HAS_PREFETCH
! 				prefetch(skb->data - NET_IP_ALIGN);
! #endif
! 				priv->rx_skbuff[entry] = NULL;
! 				priv->rx_zeroc_thresh++;
! 
! 				skb_put(skb, frame_len);
! 				dma_unmap_single(priv->device,
! 						 priv->rx_skbuff_dma[entry],
! 						 priv->dma_buf_sz,
! 						 DMA_FROM_DEVICE);
  			}
  
  			stmmac_get_rx_hwtstamp(priv, entry, skb);
  
  			if (netif_msg_pktdata(priv)) {
  				pr_debug("frame received (%dbytes)", frame_len);
  				print_pkt(skb->data, frame_len);
***************
*** 2316,2323 ****
--- 2409,2421 ----
  	work_done = stmmac_rx(priv, budget);
  	if (work_done < budget) {
  		napi_complete(napi);
+ #ifdef CONFIG_STMMAC_POLL_MODE
+ 		napi_reschedule(napi);
+ #else
  		stmmac_enable_dma_irq(priv);
+ #endif
  	}
+ 
  	return work_done;
  }
  
***************
*** 2402,2408 ****
  		features &= ~NETIF_F_RXCSUM;
  
  	if (!priv->plat->tx_coe)
! 		features &= ~NETIF_F_ALL_CSUM;
  
  	/* Some GMAC devices have a bugged Jumbo frame support that
  	 * needs to have the Tx COE disabled for oversized frames
--- 2500,2506 ----
  		features &= ~NETIF_F_RXCSUM;
  
  	if (!priv->plat->tx_coe)
! 		features &= ~NETIF_F_CSUM_MASK;
  
  	/* Some GMAC devices have a bugged Jumbo frame support that
  	 * needs to have the Tx COE disabled for oversized frames
***************
*** 2410,2416 ****
  	 * the TX csum insertionin the TDES and not use SF.
  	 */
  	if (priv->plat->bugged_jumbo && (dev->mtu > ETH_DATA_LEN))
! 		features &= ~NETIF_F_ALL_CSUM;
  
  	return features;
  }
--- 2508,2514 ----
  	 * the TX csum insertionin the TDES and not use SF.
  	 */
  	if (priv->plat->bugged_jumbo && (dev->mtu > ETH_DATA_LEN))
! 		features &= ~NETIF_F_CSUM_MASK;
  
  	return features;
  }
***************
*** 2558,2576 ****
  {
  	struct net_device *dev = seq->private;
  	struct stmmac_priv *priv = netdev_priv(dev);
- 	unsigned int txsize = priv->dma_tx_size;
- 	unsigned int rxsize = priv->dma_rx_size;
  
  	if (priv->extend_desc) {
  		seq_printf(seq, "Extended RX descriptor ring:\n");
! 		sysfs_display_ring((void *)priv->dma_erx, rxsize, 1, seq);
  		seq_printf(seq, "Extended TX descriptor ring:\n");
! 		sysfs_display_ring((void *)priv->dma_etx, txsize, 1, seq);
  	} else {
  		seq_printf(seq, "RX descriptor ring:\n");
! 		sysfs_display_ring((void *)priv->dma_rx, rxsize, 0, seq);
  		seq_printf(seq, "TX descriptor ring:\n");
! 		sysfs_display_ring((void *)priv->dma_tx, txsize, 0, seq);
  	}
  
  	return 0;
--- 2656,2672 ----
  {
  	struct net_device *dev = seq->private;
  	struct stmmac_priv *priv = netdev_priv(dev);
  
  	if (priv->extend_desc) {
  		seq_printf(seq, "Extended RX descriptor ring:\n");
! 		sysfs_display_ring((void *)priv->dma_erx, DMA_RX_SIZE, 1, seq);
  		seq_printf(seq, "Extended TX descriptor ring:\n");
! 		sysfs_display_ring((void *)priv->dma_etx, DMA_TX_SIZE, 1, seq);
  	} else {
  		seq_printf(seq, "RX descriptor ring:\n");
! 		sysfs_display_ring((void *)priv->dma_rx, DMA_RX_SIZE, 0, seq);
  		seq_printf(seq, "TX descriptor ring:\n");
! 		sysfs_display_ring((void *)priv->dma_tx, DMA_TX_SIZE, 0, seq);
  	}
  
  	return 0;
***************
*** 3140,3151 ****
  		} else if (!strncmp(opt, "phyaddr:", 8)) {
  			if (kstrtoint(opt + 8, 0, &phyaddr))
  				goto err;
- 		} else if (!strncmp(opt, "dma_txsize:", 11)) {
- 			if (kstrtoint(opt + 11, 0, &dma_txsize))
- 				goto err;
- 		} else if (!strncmp(opt, "dma_rxsize:", 11)) {
- 			if (kstrtoint(opt + 11, 0, &dma_rxsize))
- 				goto err;
  		} else if (!strncmp(opt, "buf_sz:", 7)) {
  			if (kstrtoint(opt + 7, 0, &buf_sz))
  				goto err;
--- 3236,3241 ----
diff -rcNP linux-4.4.24/drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c linux-4.4.24-baikal/drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c
*** linux-4.4.24/drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c	2016-11-11 14:49:53.000000000 +0300
***************
*** 81,87 ****
  	plat->mdio_bus_data->phy_mask = 0;
  
  	plat->dma_cfg->pbl = 32;
! 	plat->dma_cfg->burst_len = DMA_AXI_BLEN_256;
  
  	/* Set default value for multicast hash bins */
  	plat->multicast_filter_bins = HASH_TABLE_SIZE;
--- 81,87 ----
  	plat->mdio_bus_data->phy_mask = 0;
  
  	plat->dma_cfg->pbl = 32;
! 	/* TODO: AXI */
  
  	/* Set default value for multicast hash bins */
  	plat->multicast_filter_bins = HASH_TABLE_SIZE;
***************
*** 115,122 ****
  	plat->mdio_bus_data->phy_mask = 0;
  
  	plat->dma_cfg->pbl = 16;
- 	plat->dma_cfg->burst_len = DMA_AXI_BLEN_256;
  	plat->dma_cfg->fixed_burst = 1;
  
  	/* Set default value for multicast hash bins */
  	plat->multicast_filter_bins = HASH_TABLE_SIZE;
--- 115,122 ----
  	plat->mdio_bus_data->phy_mask = 0;
  
  	plat->dma_cfg->pbl = 16;
  	plat->dma_cfg->fixed_burst = 1;
+ 	/* AXI (TODO) */
  
  	/* Set default value for multicast hash bins */
  	plat->multicast_filter_bins = HASH_TABLE_SIZE;
diff -rcNP linux-4.4.24/drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c linux-4.4.24-baikal/drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c
*** linux-4.4.24/drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c	2016-11-11 14:49:53.000000000 +0300
***************
*** 96,101 ****
--- 96,200 ----
  }
  
  /**
+  * stmmac_axi_setup - parse DT parameters for programming the AXI register
+  * @pdev: platform device
+  * @priv: driver private struct.
+  * Description:
+  * if required, from device-tree the AXI internal register can be tuned
+  * by using platform parameters.
+  */
+ static struct stmmac_axi *stmmac_axi_setup(struct platform_device *pdev)
+ {
+ 	struct device_node *np;
+ 	struct stmmac_axi *axi;
+ 
+ 	np = of_parse_phandle(pdev->dev.of_node, "snps,axi-config", 0);
+ 	if (!np)
+ 		return NULL;
+ 
+ 	axi = kzalloc(sizeof(*axi), GFP_KERNEL);
+ 	if (!axi)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	axi->axi_lpi_en = of_property_read_bool(np, "snps,lpi_en");
+ 	axi->axi_xit_frm = of_property_read_bool(np, "snps,xit_frm");
+ 	axi->axi_kbbe = of_property_read_bool(np, "snps,axi_kbbe");
+ 	axi->axi_axi_all = of_property_read_bool(np, "snps,axi_all");
+ 	axi->axi_fb = of_property_read_bool(np, "snps,axi_fb");
+ 	axi->axi_mb = of_property_read_bool(np, "snps,axi_mb");
+ 	axi->axi_rb =  of_property_read_bool(np, "snps,axi_rb");
+ 
+ 	of_property_read_u32(np, "snps,wr_osr_lmt", &axi->axi_wr_osr_lmt);
+ 	of_property_read_u32(np, "snps,rd_osr_lmt", &axi->axi_rd_osr_lmt);
+ 	of_property_read_u32_array(np, "snps,blen", axi->axi_blen, AXI_BLEN);
+ 
+ 	return axi;
+ }
+ 
+ /**
+  * stmmac_dt_phy - parse device-tree driver parameters to allocate PHY resources
+  * @plat: driver data platform structure
+  * @np: device tree node
+  * @dev: device pointer
+  * Description:
+  * The mdio bus will be allocated in case of a phy transceiver is on board;
+  * it will be NULL if the fixed-link is configured.
+  * If there is the "snps,dwmac-mdio" sub-node the mdio will be allocated
+  * in any case (for DSA, mdio must be registered even if fixed-link).
+  * The table below sums the supported configurations:
+  *	-------------------------------
+  *	snps,phy-addr	|     Y
+  *	-------------------------------
+  *	phy-handle	|     Y
+  *	-------------------------------
+  *	fixed-link	|     N
+  *	-------------------------------
+  *	snps,dwmac-mdio	|
+  *	  even if	|     Y
+  *	fixed-link	|
+  *	-------------------------------
+  *
+  * It returns 0 in case of success otherwise -ENODEV.
+  */
+ static int stmmac_dt_phy(struct plat_stmmacenet_data *plat,
+ 			 struct device_node *np, struct device *dev)
+ {
+ 	bool mdio = true;
+ 
+ 	/* If phy-handle property is passed from DT, use it as the PHY */
+ 	plat->phy_node = of_parse_phandle(np, "phy-handle", 0);
+ 	if (plat->phy_node)
+ 		dev_dbg(dev, "Found phy-handle subnode\n");
+ 
+ 	/* If phy-handle is not specified, check if we have a fixed-phy */
+ 	if (!plat->phy_node && of_phy_is_fixed_link(np)) {
+ 		if ((of_phy_register_fixed_link(np) < 0))
+ 			return -ENODEV;
+ 
+ 		dev_dbg(dev, "Found fixed-link subnode\n");
+ 		plat->phy_node = of_node_get(np);
+ 		mdio = false;
+ 	}
+ 
+ 	/* If snps,dwmac-mdio is passed from DT, always register the MDIO */
+ 	for_each_child_of_node(np, plat->mdio_node) {
+ 		if (of_device_is_compatible(plat->mdio_node, "snps,dwmac-mdio"))
+ 			break;
+ 	}
+ 
+ 	if (plat->mdio_node) {
+ 		dev_dbg(dev, "Found MDIO subnode\n");
+ 		mdio = true;
+ 	}
+ 
+ 	if (mdio)
+ 		plat->mdio_bus_data =
+ 			devm_kzalloc(dev, sizeof(struct stmmac_mdio_bus_data),
+ 				     GFP_KERNEL);
+ 	return 0;
+ }
+ 
+ /**
   * stmmac_probe_config_dt - parse device-tree driver parameters
   * @pdev: platform_device structure
   * @plat: driver data platform structure
***************
*** 129,158 ****
  	/* Default to phy auto-detection */
  	plat->phy_addr = -1;
  
- 	/* If we find a phy-handle property, use it as the PHY */
- 	plat->phy_node = of_parse_phandle(np, "phy-handle", 0);
- 
- 	/* If phy-handle is not specified, check if we have a fixed-phy */
- 	if (!plat->phy_node && of_phy_is_fixed_link(np)) {
- 		if ((of_phy_register_fixed_link(np) < 0))
- 			return ERR_PTR(-ENODEV);
- 
- 		plat->phy_node = of_node_get(np);
- 	}
- 
  	/* "snps,phy-addr" is not a standard property. Mark it as deprecated
  	 * and warn of its use. Remove this when phy node support is added.
  	 */
  	if (of_property_read_u32(np, "snps,phy-addr", &plat->phy_addr) == 0)
  		dev_warn(&pdev->dev, "snps,phy-addr property is deprecated\n");
  
! 	if (plat->phy_node || plat->phy_bus_name)
! 		plat->mdio_bus_data = NULL;
! 	else
! 		plat->mdio_bus_data =
! 			devm_kzalloc(&pdev->dev,
! 				     sizeof(struct stmmac_mdio_bus_data),
! 				     GFP_KERNEL);
  
  	of_property_read_u32(np, "tx-fifo-depth", &plat->tx_fifo_size);
  
--- 228,242 ----
  	/* Default to phy auto-detection */
  	plat->phy_addr = -1;
  
  	/* "snps,phy-addr" is not a standard property. Mark it as deprecated
  	 * and warn of its use. Remove this when phy node support is added.
  	 */
  	if (of_property_read_u32(np, "snps,phy-addr", &plat->phy_addr) == 0)
  		dev_warn(&pdev->dev, "snps,phy-addr property is deprecated\n");
  
! 	/* To Configure PHY by using all device-tree supported properties */
! 	if (stmmac_dt_phy(plat, np, &pdev->dev))
! 		return ERR_PTR(-ENODEV);
  
  	of_property_read_u32(np, "tx-fifo-depth", &plat->tx_fifo_size);
  
***************
*** 216,228 ****
  		}
  		plat->dma_cfg = dma_cfg;
  		of_property_read_u32(np, "snps,pbl", &dma_cfg->pbl);
  		dma_cfg->fixed_burst =
  			of_property_read_bool(np, "snps,fixed-burst");
  		dma_cfg->mixed_burst =
  			of_property_read_bool(np, "snps,mixed-burst");
- 		of_property_read_u32(np, "snps,burst_len", &dma_cfg->burst_len);
- 		if (dma_cfg->burst_len < 0 || dma_cfg->burst_len > 256)
- 			dma_cfg->burst_len = 0;
  	}
  	plat->force_thresh_dma_mode = of_property_read_bool(np, "snps,force_thresh_dma_mode");
  	if (plat->force_thresh_dma_mode) {
--- 300,310 ----
  		}
  		plat->dma_cfg = dma_cfg;
  		of_property_read_u32(np, "snps,pbl", &dma_cfg->pbl);
+ 		dma_cfg->aal = of_property_read_bool(np, "snps,aal");
  		dma_cfg->fixed_burst =
  			of_property_read_bool(np, "snps,fixed-burst");
  		dma_cfg->mixed_burst =
  			of_property_read_bool(np, "snps,mixed-burst");
  	}
  	plat->force_thresh_dma_mode = of_property_read_bool(np, "snps,force_thresh_dma_mode");
  	if (plat->force_thresh_dma_mode) {
***************
*** 230,235 ****
--- 312,319 ----
  		pr_warn("force_sf_dma_mode is ignored if force_thresh_dma_mode is set.");
  	}
  
+ 	plat->axi = stmmac_axi_setup(pdev);
+ 
  	return plat;
  }
  #else
diff -rcNP linux-4.4.24/drivers/net/phy/be-xgbe-phy.c linux-4.4.24-baikal/drivers/net/phy/be-xgbe-phy.c
*** linux-4.4.24/drivers/net/phy/be-xgbe-phy.c	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/drivers/net/phy/be-xgbe-phy.c	2016-11-11 14:49:53.000000000 +0300
***************
*** 0 ****
--- 1,672 ----
+ /*
+  * Baikal Electronics 10Gb Ethernet PHY driver
+  *
+  * based on AMD 10Gb Ethernet PHY driver
+  * drivers/net/phy/amd-xgbe-phy.c
+  *
+  * This file is available to you under your choice of the following two
+  * licenses:
+  *
+  * License 1: GPLv2
+  *
+  * Copyright (c) 2015,2016 Baikal Electronics, JSC
+  * Copyright (c) 2014 Advanced Micro Devices, Inc.
+  * 
+  * Adopted by:
+  *   Dmitry Dunaev <dmitry.dunaev@baikalelectronics.ru>
+  *
+  * This file is free software; you may copy, redistribute and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation, either version 2 of the License, or (at
+  * your option) any later version.
+  *
+  * This file is distributed in the hope that it will be useful, but
+  * WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+  * General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+  *
+  *
+  * License 2: Modified BSD
+  *
+  * Copyright (c) 2015 Baikal Electronics, JSC
+  * Copyright (c) 2014 Advanced Micro Devices, Inc.
+  * All rights reserved.
+  *
+  * Redistribution and use in source and binary forms, with or without
+  * modification, are permitted provided that the following conditions are met:
+  *     * Redistributions of source code must retain the above copyright
+  *       notice, this list of conditions and the following disclaimer.
+  *     * Redistributions in binary form must reproduce the above copyright
+  *       notice, this list of conditions and the following disclaimer in the
+  *       documentation and/or other materials provided with the distribution.
+  *     * Neither the name of Advanced Micro Devices, Inc. nor the
+  *       names of its contributors may be used to endorse or promote products
+  *       derived from this software without specific prior written permission.
+  *
+  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+  * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
+  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+  */
+ 
+ #include <linux/kernel.h>
+ #include <linux/device.h>
+ #include <linux/platform_device.h>
+ #include <linux/string.h>
+ #include <linux/errno.h>
+ #include <linux/unistd.h>
+ #include <linux/slab.h>
+ #include <linux/interrupt.h>
+ #include <linux/init.h>
+ #include <linux/clk.h>
+ #include <linux/delay.h>
+ #include <linux/netdevice.h>
+ #include <linux/etherdevice.h>
+ #include <linux/skbuff.h>
+ #include <linux/mm.h>
+ #include <linux/module.h>
+ #include <linux/mii.h>
+ #include <linux/ethtool.h>
+ #include <linux/phy.h>
+ #include <linux/mdio.h>
+ #include <linux/io.h>
+ #include <linux/of.h>
+ #include <linux/of_platform.h>
+ #include <linux/of_device.h>
+ #include <linux/uaccess.h>
+ #include <linux/of_mdio.h>
+ 
+ 
+ MODULE_AUTHOR(
+     "Tom Lendacky <thomas.lendacky@amd.com>\n"
+     "Dmitry Dunaev <dmitry.dunaev@baikalelectronics.ru>"
+ );
+ MODULE_LICENSE("Dual BSD/GPL");
+ MODULE_VERSION("1.0.1");
+ MODULE_DESCRIPTION("Baikal Electronics 10GbE (be-xgbe) PHY driver. Based on amd-xgbe.");
+ 
+ #define BE_T_XGBE_PHY_ID				0x7996ced0
+ #define BE_T1_XGBE_PHY_ID				0x7996ced0
+ #define BE_XGBE_PHY_MASK				0xfffffff0
+ 
+ #define XGBE_PHY_MODESET_PROPERTY		"be,mode-set"
+ #define XGBE_PHY_CLOCK_PROPERTY			"be,external-clock"
+ #define XGBE_PHY_SYS_CLOCK				"xgbe_clk"
+ 
+ #ifndef MDIO_PMA_10GBR_PMD_CTRL
+ #define MDIO_PMA_10GBR_PMD_CTRL			0x0096
+ #endif
+ #ifndef MDIO_PMA_10GBR_FEC_CTRL
+ #define MDIO_PMA_10GBR_FEC_CTRL			0x00ab
+ #endif
+ #ifndef MDIO_AN_XNP
+ #define MDIO_AN_XNP						0x0016
+ #endif
+ 
+ #ifndef MDIO_AN_INTMASK
+ #define MDIO_AN_INTMASK					0x8001
+ #endif
+ #ifndef MDIO_AN_INT
+ #define MDIO_AN_INT						0x8002
+ #endif
+ #ifndef PORT_BACKPLANE
+ #define PORT_BACKPLANE					0x06
+ #endif
+ 
+ #ifndef VR_XS_PMA_MII_Gen5_MPLL_CTRL
+ #define VR_XS_PMA_MII_Gen5_MPLL_CTRL 	0x807A
+ #endif
+ #define VR_XS_PMA_MII_Gen5_MPLL_CTRL_REF_CLK_SEL_bit	(1 << 13)
+ #define VR_XS_PCS_DIG_CTRL1				0x8000
+ #define VR_XS_PCS_DIG_CTRL1_VR_RST_Bit		MDIO_CTRL1_RESET
+ #define SR_XC_or_PCS_MMD_Control1			MDIO_CTRL1
+ #define SR_XC_or_PCS_MMD_Control1_RST_Bit	MDIO_CTRL1_RESET
+ #define DWC_GLBL_PLL_MONITOR			0x8010
+ #define SDS_PCS_CLOCK_READY_mask		0x1C
+ #define SDS_PCS_CLOCK_READY_bit			0x10
+ 
+ 
+ #ifndef MDIO_CTRL1_SPEED1G
+ #define MDIO_CTRL1_SPEED1G		(MDIO_CTRL1_SPEED10G & ~BMCR_SPEED100)
+ #endif
+ 
+ enum be_xgbe_phy_mode {
+ 	BE_XGBE_MODE_KR,
+ 	BE_XGBE_MODE_KX,
+ };
+ 
+ enum be_xgbe_phy_speedset {
+ 	BE_XGBE_PHY_SPEEDSET_1000_10000,
+ 	BE_XGBE_PHY_SPEEDSET_2500_10000,
+ };
+ 
+ struct be_xgbe_phy_priv {
+ 	struct platform_device *pdev;
+ 	struct device *dev;
+ 
+ 	/* Self phydevice and tranciever */
+ 	struct phy_device *phydev;
+ 	struct phy_device *xmit;
+ 
+ 	/* Device clock */
+ 	struct clk *sysclk;
+ 	unsigned int ext_clk;
+ 
+ 	/* Maintain link status for re-starting auto-negotiation */
+ 	unsigned int link;
+ 	enum be_xgbe_phy_mode mode;
+ 	unsigned int speed_set;
+ 
+ 	/* Auto-negotiation state machine support */
+ 	struct mutex an_mutex;
+ 	struct work_struct an_work;
+ 	struct workqueue_struct *an_workqueue;
+ };
+ 
+ static int be_xgbe_an_enable_kr_training(struct phy_device *phydev)
+ {
+ 	int ret;
+ 
+ 	return 0;
+ 
+ 	ret = phy_read_mmd(phydev, MDIO_MMD_PMAPMD, MDIO_PMA_10GBR_PMD_CTRL);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	ret |= 0x02;
+ 	phy_write_mmd(phydev, MDIO_MMD_PMAPMD, MDIO_PMA_10GBR_PMD_CTRL, ret);
+ 
+ 	return 0;
+ }
+ 
+ static int be_xgbe_phy_pcs_power_cycle(struct phy_device *phydev)
+ {
+ 	int ret;
+ 
+ 	return 0;
+ 
+ 	ret = phy_read_mmd(phydev, MDIO_MMD_PCS, MDIO_CTRL1);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	ret |= MDIO_CTRL1_LPOWER;
+ 	phy_write_mmd(phydev, MDIO_MMD_PCS, MDIO_CTRL1, ret);
+ 
+ 	usleep_range(75, 100);
+ 
+ 	ret &= ~MDIO_CTRL1_LPOWER;
+ 	phy_write_mmd(phydev, MDIO_MMD_PCS, MDIO_CTRL1, ret);
+ 
+ 	return 0;
+ }
+ 
+ static int be_xgbe_phy_xgmii_mode(struct phy_device *phydev)
+ {
+ 	struct be_xgbe_phy_priv *priv = phydev->priv;
+ 	int ret;
+ 
+ 	/* Enable KR training */
+ 	ret = be_xgbe_an_enable_kr_training(phydev);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	/* Set PCS to KR/10G speed */
+ 	ret = phy_read_mmd(phydev, MDIO_MMD_PCS, MDIO_CTRL2);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	ret &= ~MDIO_PCS_CTRL2_TYPE;
+ 	ret |= MDIO_PCS_CTRL2_10GBR;
+ 	phy_write_mmd(phydev, MDIO_MMD_PCS, MDIO_CTRL2, ret);
+ 
+ 	ret = phy_read_mmd(phydev, MDIO_MMD_PCS, MDIO_CTRL1);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	ret &= ~MDIO_CTRL1_SPEEDSEL;
+ 	ret |= MDIO_CTRL1_SPEED10G;
+ 	phy_write_mmd(phydev, MDIO_MMD_PCS, MDIO_CTRL1, ret);
+ 
+ 	ret = be_xgbe_phy_pcs_power_cycle(phydev);
+ 	if (ret < 0)
+ 	return ret;
+ 
+ 	priv->mode = BE_XGBE_MODE_KR;
+ 
+ 	return 0;
+ }
+ 
+ static int __maybe_unused be_xgbe_phy_soft_reset(struct phy_device *phydev)
+ {
+ 	int count, ret;
+ 
+ 	ret = phy_read_mmd(phydev, MDIO_MMD_PCS, MDIO_CTRL1);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	ret |= MDIO_CTRL1_RESET;
+ 	phy_write_mmd(phydev, MDIO_MMD_PCS, MDIO_CTRL1, ret);
+ 
+ 	count = 50;
+ 	do {
+ 		msleep(20);
+ 		ret = phy_read_mmd(phydev, MDIO_MMD_PCS, MDIO_CTRL1);
+ 		if (ret < 0)
+ 			return ret;
+ 	} while ((ret & MDIO_CTRL1_RESET) && --count);
+ 
+ 	if (ret & MDIO_CTRL1_RESET)
+ 		return -ETIMEDOUT;
+ 
+ 	return 0;
+ }
+ 
+ static int be_xgbe_phy_config_init(struct phy_device *phydev)
+ {
+ 	struct be_xgbe_phy_priv *priv = phydev->priv;
+ 	int ret = 0;
+ 
+ 
+ 	/* Initialize supported features */
+ 	phydev->supported = SUPPORTED_Autoneg;
+ 	phydev->supported |= SUPPORTED_Pause | SUPPORTED_Asym_Pause;
+ 	phydev->supported |= SUPPORTED_Backplane |
+ 				SUPPORTED_10000baseKX4_Full;
+ 	phydev->supported |= SUPPORTED_10000baseKR_Full |
+ 			    SUPPORTED_10000baseR_FEC;
+ 	switch (priv->speed_set) {
+ 	case BE_XGBE_PHY_SPEEDSET_1000_10000:
+ 		phydev->supported |= SUPPORTED_1000baseKX_Full;
+ 		break;
+ 	case BE_XGBE_PHY_SPEEDSET_2500_10000:
+ 		phydev->supported |= SUPPORTED_2500baseX_Full;
+ 		break;
+ 	}
+ 
+ 	if (priv->xmit)
+ 		phydev->supported |= SUPPORTED_10000baseT_Full;
+ 
+ 	phydev->advertising = phydev->supported;
+ 	phydev->pause = 0;
+ 	phydev->asym_pause = 0;
+ 
+ 	if (priv->ext_clk) {
+ 		/* Switch XGMAC PHY PLL to use extrnal ref clock from pad */
+ 		ret = phy_read_mmd(phydev, MDIO_MMD_PMAPMD, VR_XS_PMA_MII_Gen5_MPLL_CTRL);
+ 		ret &= ~(VR_XS_PMA_MII_Gen5_MPLL_CTRL_REF_CLK_SEL_bit);
+ 		phy_write_mmd(phydev, MDIO_MMD_PMAPMD, VR_XS_PMA_MII_Gen5_MPLL_CTRL, ret);
+ 		wmb();
+ #ifdef CONFIG_BAIKAL_XGBE_EXTCLK
+ 		/* Turn off internal XGMAC PHY clock */
+ 		clk_disable_unprepare(priv->sysclk);
+ #endif
+ 	}
+ 
+ 	/* Make vendor specific soft reset */
+ 	ret = phy_read_mmd(phydev, MDIO_MMD_PCS, VR_XS_PCS_DIG_CTRL1);
+ 	ret |= VR_XS_PCS_DIG_CTRL1_VR_RST_Bit;
+ 	phy_write_mmd(phydev, MDIO_MMD_PCS, VR_XS_PCS_DIG_CTRL1, ret);
+ 	wmb();
+ 
+ 	/* Wait reset finish */
+ 	do {
+ 		usleep_range(500, 600);
+ 		ret = phy_read_mmd(phydev, MDIO_MMD_PCS, VR_XS_PCS_DIG_CTRL1);
+ 	} while ( (ret & VR_XS_PCS_DIG_CTRL1_VR_RST_Bit) != 0 );
+ 
+ 	/*
+ 	 * Wait for the RST (bit 15) of the “SR XS or PCS MMD Control1” Register is 0.
+ 	 * This bit is self-cleared when Bits[4:2] in VR XS or PCS MMD Digital
+ 	 * Status Register are equal to 3’b100, that is, Tx/Rx clocks are stable
+ 	 * and in Power_Good state.
+ 	 */
+ 	do {
+ 		usleep_range(500, 600);
+ 		ret = phy_read_mmd(phydev, MDIO_MMD_PCS, SR_XC_or_PCS_MMD_Control1);
+ 	} while ( (ret & SR_XC_or_PCS_MMD_Control1_RST_Bit) != 0 );
+ 
+ 	/*
+ 	 * This bit is self-cleared when Bits[4:2] in VR XS or PCS MMD Digital
+ 	 * Status Register are equal to 3’b100, that is, Tx/Rx clocks are stable
+ 	 * and in Power_Good state.
+ 	 */
+ 	do {
+ 		usleep_range(500, 600);
+ 		ret = phy_read_mmd(phydev, MDIO_MMD_PCS, DWC_GLBL_PLL_MONITOR);
+ 	} while ( (ret & SDS_PCS_CLOCK_READY_mask) != SDS_PCS_CLOCK_READY_bit );
+ 
+ 	/* Turn off and clear interrupts */
+ 	phy_write_mmd(phydev, MDIO_MMD_AN, MDIO_AN_INTMASK, 0);
+ 	phy_write_mmd(phydev, MDIO_MMD_AN, MDIO_AN_INT, 0);
+ 	wmb();
+ 
+ 	ret = be_xgbe_phy_xgmii_mode(phydev);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	return 0;
+ }
+ 
+ static int be_xgbe_phy_config_aneg(struct phy_device *phydev)
+ {
+ 	struct be_xgbe_phy_priv *priv = phydev->priv;
+ 	int reg;
+ 
+ 	reg = phy_read_mmd(phydev, MDIO_MMD_AN, MDIO_CTRL1);
+ 	if (reg < 0)
+ 		return reg;
+ 	/* Disable autonegotiation with tranceiver */
+ 	if (priv->xmit) {
+ 		reg &= ~MDIO_AN_CTRL1_ENABLE;
+ 		phydev->autoneg = AUTONEG_DISABLE;
+ 	}
+ 	else {
+ 		reg |= MDIO_AN_CTRL1_ENABLE;
+ 		phydev->autoneg = AUTONEG_ENABLE;
+ 	}
+ 
+ 	phy_write_mmd(phydev, MDIO_MMD_AN, MDIO_CTRL1, reg);
+ 
+ 	return 0;
+ }
+ 
+ static int be_xgbe_phy_aneg_done(struct phy_device *phydev)
+ {
+ 	int reg;
+ 
+ 	reg = phy_read_mmd(phydev, MDIO_MMD_AN, MDIO_STAT1);
+ 	if (reg < 0)
+ 		return reg;
+ 
+ 	return (reg & MDIO_AN_STAT1_COMPLETE) ? 1 : 0;
+ }
+ 
+ static int be_xgbe_phy_update_link(struct phy_device *phydev)
+ {
+ 	struct be_xgbe_phy_priv *priv = phydev->priv;
+ 	int reg;
+ 
+ 	/* Set default values */
+ 	phydev->link = 1;
+ 
+ 	/* Check tranceiver status */
+ 	if (priv->xmit) {
+ 		priv->xmit->drv->read_status(priv->xmit);
+ 		if (!priv->xmit->link)
+ 			phydev->link = 0;
+ 	}
+ 
+ 	/* Check PMA status */
+ 	reg = phy_read_mmd(phydev, MDIO_MMD_PMAPMD, MDIO_STAT1);
+ 	if ((reg < 0) || !(reg & MDIO_STAT1_LSTATUS))
+ 		phydev->link = 0;
+ 	dev_dbg(&phydev->dev, "PMA link=%d\n", (reg & MDIO_STAT1_LSTATUS)?1:0);
+ 
+ 	/* Check PCS status */
+ 	reg = phy_read_mmd(phydev, MDIO_MMD_PCS, MDIO_STAT1);
+ 	if ((reg < 0) || !(reg & MDIO_STAT1_LSTATUS))
+ 		phydev->link = 0;
+ 	dev_dbg(&phydev->dev, "PCS link=%d\n", (reg & MDIO_STAT1_LSTATUS)?1:0);
+ 
+ 	return 0;
+ }
+ 
+ static int be_xgbe_phy_read_status(struct phy_device *phydev)
+ {
+ 	struct be_xgbe_phy_priv *priv = phydev->priv;
+ 	int reg;
+ 
+ 	/* Read current mode */
+ 	reg = phy_read_mmd(phydev, MDIO_MMD_PCS, MDIO_CTRL2);
+ 	reg &= MDIO_PCS_CTRL2_TYPE;
+ 
+ 	/* Set speed */
+ 	if (reg == MDIO_PCS_CTRL2_10GBR) {
+ 		phydev->speed = SPEED_10000;
+ 	} else {
+ 		if (priv->speed_set ==
+ 			BE_XGBE_PHY_SPEEDSET_1000_10000)
+ 			phydev->speed = SPEED_1000;
+ 		else
+ 			phydev->speed = SPEED_2500;
+ 	}
+ 
+ 	/* Update link status */
+ 	be_xgbe_phy_update_link(phydev);
+ 
+ 	/* Set duplex */
+ 	if (priv->xmit)
+ 		phydev->duplex = priv->xmit->duplex;
+ 	else
+ 		phydev->duplex = DUPLEX_FULL;
+ 
+ 	return 0;
+ }
+ 
+ static int be_xgbe_phy_resume(struct phy_device *phydev)
+ {
+ 	int ret;
+ 
+ 	mutex_lock(&phydev->lock);
+ 
+ 	ret = phy_read_mmd(phydev, MDIO_MMD_PCS, MDIO_CTRL1);
+ 	if (ret < 0)
+ 		goto unlock;
+ 
+ 	ret &= ~MDIO_CTRL1_LPOWER;
+ 	phy_write_mmd(phydev, MDIO_MMD_PCS, MDIO_CTRL1, ret);
+ 
+ 	ret = 0;
+ 
+ unlock:
+ 	mutex_unlock(&phydev->lock);
+ 
+ 	return ret;
+ }
+ 
+ static int be_xgbe_phy_suspend(struct phy_device *phydev)
+ {
+ 	int ret;
+ 
+ 	mutex_lock(&phydev->lock);
+ 
+ 	ret = phy_read_mmd(phydev, MDIO_MMD_PCS, MDIO_CTRL1);
+ 	if (ret < 0)
+ 		goto unlock;
+ 
+ 	ret |= MDIO_CTRL1_LPOWER;
+ 	phy_write_mmd(phydev, MDIO_MMD_PCS, MDIO_CTRL1, ret);
+ 
+ 	ret = 0;
+ 
+ unlock:
+ 	mutex_unlock(&phydev->lock);
+ 
+ 	return ret;
+ }
+ 
+ static int be_xgbe_xmit_probe(struct phy_device *phydev)
+ {
+ 	struct device_node *xmit_node;
+ 	struct be_xgbe_phy_priv *priv = phydev->priv;
+ 	struct phy_device *xmit;
+ 	int ret;
+ 
+ 	/* Retrieve the xmit-handle */
+ 	xmit_node = of_parse_phandle(phydev->dev.of_node, "phy-handle", 0);
+ 	if (!xmit_node) {
+ 		dev_info(&phydev->dev, "no phy-handle, work in KR/KX mode\n");
+ 		return -ENODEV;
+ 	}
+ 
+ 	xmit = of_phy_find_device(xmit_node);
+ 	if (!xmit)
+ 		return -EINVAL;
+ 
+ 	ret = phy_init_hw(xmit);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	xmit->speed = SPEED_10000;
+ 	xmit->duplex = DUPLEX_FULL;
+ 
+ 	priv->xmit = xmit;
+ 	/* refcount is held by phy_attach_direct() on success */
+ 	put_device(&xmit->dev);
+ #if 0
+ 	/* Add sysfs link to netdevice */
+ 	ret = sysfs_create_link(&(xmit->bus->dev.kobj),
+ 		&(phydev->attached_dev->dev.kobj), "traceiver");
+ 	if (ret)
+ 		dev_warn(&xmit->dev, "sysfs link to netdevice failed\n");
+ #endif
+ 	return 0;
+ }
+ 
+ static int be_xgbe_phy_probe(struct phy_device *phydev)
+ {
+ 	struct be_xgbe_phy_priv *priv;
+ 	struct platform_device *pdev;
+ 	struct device *dev;
+ 	unsigned int mode_set;
+ 	int ret;
+ 
+ 	if (!phydev->dev.of_node)
+ 		return -EINVAL;
+ 
+ 	pdev = of_find_device_by_node(phydev->dev.of_node);
+ 	if (!pdev)
+ 		return -EINVAL;
+ 	dev = &pdev->dev;
+ 
+ 	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+ 	if (!priv) {
+ 		ret = -ENOMEM;
+ 		goto err_pdev;
+ 	}
+ 
+ 	priv->pdev = pdev;
+ 	priv->dev = dev;
+ 	priv->phydev = phydev;
+ 
+ 	mode_set = 0;
+ 	ret = of_property_read_u32(dev->of_node, XGBE_PHY_MODESET_PROPERTY,
+ 				   &mode_set);
+ 	if (!ret) {
+ 		if (mode_set > MDIO_PCS_CTRL2_10GBT) {
+ 			dev_err(dev, "invalid be,mode-set property\n");
+ 			ret = -EINVAL;
+ 			goto err_speed;
+ 		}
+ 		phy_write_mmd(phydev, MDIO_MMD_PCS, MDIO_CTRL2, mode_set);
+ 	}
+ 
+ 	/* XGBE internal system clock */
+ 	priv->ext_clk = of_property_read_bool(dev->of_node,
+ 				XGBE_PHY_CLOCK_PROPERTY);
+ 	priv->sysclk = devm_clk_get(dev, XGBE_PHY_SYS_CLOCK);
+ 	if (IS_ERR(priv->sysclk))
+ 		dev_warn(dev, "xgbe_clk devm_clk_get failed\n");
+ 
+ 	priv->link = 0;
+ 	priv->mode = BE_XGBE_MODE_KR;
+ 
+ 	phydev->priv = priv;
+     phydev->speed = SPEED_10000;
+     phydev->duplex = DUPLEX_FULL;
+ 	phydev->state = PHY_READY;
+ 
+ 	of_dev_put(pdev);
+ 
+ 	ret = be_xgbe_xmit_probe(phydev);
+ 	dev_info(dev, "xmit probe result %d\n", ret);
+ 
+ 	return 0;
+ 
+ err_speed:
+ 	devm_kfree(dev, priv);
+ 
+ err_pdev:
+ 	of_dev_put(pdev);
+ 
+ 	return ret;
+ }
+ 
+ 
+ static int be_xgbe_match_phy_device(struct phy_device *phydev)
+ {
+ 	unsigned int phy_id = phydev->c45_ids.device_ids[MDIO_MMD_PCS] &
+ 					BE_XGBE_PHY_MASK;
+ 	return  (phy_id == BE_T_XGBE_PHY_ID) ||
+ 			(phy_id == BE_T1_XGBE_PHY_ID);
+ }
+ 
+ static struct phy_driver be_xgbe_phy_driver[] = {
+ 	{
+ 		.phy_id				= BE_T_XGBE_PHY_ID,
+ 		.phy_id_mask		= BE_XGBE_PHY_MASK,
+ 		.name				= "BE-T XGBE PHY",
+ 		.features			= 0,
+ 		.config_init		= &be_xgbe_phy_config_init,
+ 		.suspend			= &be_xgbe_phy_suspend,
+ 		.resume				= &be_xgbe_phy_resume,
+ 		.config_aneg		= &be_xgbe_phy_config_aneg,
+ 		.aneg_done			= &be_xgbe_phy_aneg_done,
+ 		.read_status		= &be_xgbe_phy_read_status,
+ 		.probe				= &be_xgbe_phy_probe,
+ 		.soft_reset			= &be_xgbe_phy_soft_reset,
+ 		.match_phy_device	= &be_xgbe_match_phy_device,
+ 		.driver			= {
+ 			.owner = THIS_MODULE,
+ 		},
+ 	},
+ 	{
+ 		.phy_id				= BE_T1_XGBE_PHY_ID,
+ 		.phy_id_mask		= BE_XGBE_PHY_MASK,
+ 		.name				= "BE-T1 XGBE PHY",
+ 		.features			= 0,
+ 		.config_init		= &be_xgbe_phy_config_init,
+ 		.suspend			= &be_xgbe_phy_suspend,
+ 		.resume				= &be_xgbe_phy_resume,
+ 		.config_aneg		= &be_xgbe_phy_config_aneg,
+ 		.aneg_done			= &be_xgbe_phy_aneg_done,
+ 		.read_status		= &be_xgbe_phy_read_status,
+ 		.probe				= &be_xgbe_phy_probe,
+ 		.soft_reset			= &be_xgbe_phy_soft_reset,
+ 		.match_phy_device	= &be_xgbe_match_phy_device,
+ 		.driver			= {
+ 			.owner = THIS_MODULE,
+ 		},
+ 	},
+ };
+ 
+ static int __init be_xgbe_phy_init(void)
+ {
+ 	return phy_drivers_register(be_xgbe_phy_driver,
+ 				    ARRAY_SIZE(be_xgbe_phy_driver));
+ }
+ 
+ static void __exit be_xgbe_phy_exit(void)
+ {
+ 	phy_drivers_unregister(be_xgbe_phy_driver,
+ 			       ARRAY_SIZE(be_xgbe_phy_driver));
+ }
+ 
+ module_init(be_xgbe_phy_init);
+ module_exit(be_xgbe_phy_exit);
+ 
+ static struct mdio_device_id __maybe_unused be_xgbe_phy_ids[] = {
+ 	{ BE_T_XGBE_PHY_ID, BE_XGBE_PHY_MASK },
+ 	{ BE_T1_XGBE_PHY_ID, BE_XGBE_PHY_MASK },
+ 	{ }
+ };
+ MODULE_DEVICE_TABLE(mdio, be_xgbe_phy_ids);
diff -rcNP linux-4.4.24/drivers/net/phy/Kconfig linux-4.4.24-baikal/drivers/net/phy/Kconfig
*** linux-4.4.24/drivers/net/phy/Kconfig	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/net/phy/Kconfig	2016-11-11 14:49:53.000000000 +0300
***************
*** 29,39 ****
  	---help---
  	  Currently supports the am79c874
  
  config MARVELL_PHY
  	tristate "Drivers for Marvell PHYs"
  	---help---
  	  Currently has a driver for the 88E1011S
! 	
  config DAVICOM_PHY
  	tristate "Drivers for Davicom PHYs"
  	---help---
--- 29,59 ----
  	---help---
  	  Currently supports the am79c874
  
+ config BAIKAL_XGBE_PHY
+ 	tristate "Driver for the Baikal Electronics 10GbE PHYs"
+ 	depends on OF && HAS_IOMEM
+ 	---help---
+ 	  Currently supports basic fatures of the Baikal 10GbE PHY
+ 	  and usage with external traceiver.
+ 
+ config BAIKAL_MDIO
+ 	tristate "Driver for the Baikal Electronics GPIO MDIO bus"
+ 	depends on OF && GPIOLIB && MDIO_BITBANG
+ 	---help---
+ 	  Support for Baikal Electronics GPIO MDIO bus
+ 
  config MARVELL_PHY
  	tristate "Drivers for Marvell PHYs"
  	---help---
  	  Currently has a driver for the 88E1011S
! 
! config 88X2222_PHY
! 	tristate "Drivers for Marvell 88X2222 Tanceiver"
! 	---help---
! 	  Support for Marvell Integrated Dual-port
! 	  Multi-speed Ethernet Transceivers.
! 	  Currently supports 88x2222
! 
  config DAVICOM_PHY
  	tristate "Drivers for Davicom PHYs"
  	---help---
diff -rcNP linux-4.4.24/drivers/net/phy/Makefile linux-4.4.24-baikal/drivers/net/phy/Makefile
*** linux-4.4.24/drivers/net/phy/Makefile	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/net/phy/Makefile	2016-11-11 14:49:53.000000000 +0300
***************
*** 42,44 ****
--- 42,48 ----
  obj-$(CONFIG_MDIO_BCM_UNIMAC)	+= mdio-bcm-unimac.o
  obj-$(CONFIG_MICROCHIP_PHY)	+= microchip.o
  obj-$(CONFIG_MDIO_BCM_IPROC)	+= mdio-bcm-iproc.o
+ obj-$(CONFIG_BAIKAL_MDIO)	+= mdio-be-gpio.o
+ obj-$(CONFIG_BAIKAL_XGBE_PHY)	+= be-xgbe-phy.o
+ obj-$(CONFIG_88X2222_PHY)	+= mv88x2222.o
+ 
diff -rcNP linux-4.4.24/drivers/net/phy/mdio-be-gpio.c linux-4.4.24-baikal/drivers/net/phy/mdio-be-gpio.c
*** linux-4.4.24/drivers/net/phy/mdio-be-gpio.c	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/drivers/net/phy/mdio-be-gpio.c	2016-11-11 14:49:53.000000000 +0300
***************
*** 0 ****
--- 1,558 ----
+ /*
+  * Baikal Electronics SFP+ mezzanine card MDIO bus driver
+  * Supports OpenFirmware.
+  *
+  * Based on Bitbanged MDIO support driver.
+  * drivers/net/phy/mdio-bitbang.c
+  *
+  * Author: Scott Wood <scottwood@freescale.com>
+  * Copyright (c) 2007 Freescale Semiconductor
+  *
+  * Based on CPM2 MDIO code which is:
+  *
+  * Copyright (c) 2003 Intracom S.A.
+  *  by Pantelis Antoniou <panto@intracom.gr>
+  *
+  * 2005 (c) MontaVista Software, Inc.
+  * Vitaly Bordug <vbordug@ru.mvista.com>
+  *
+  * Paritaly based on GPIO based MDIO bitbang driver.
+  * drivers/net/phy/mdio-gpio.c
+  *
+  * Copyright (c) 2015,2016 Baikal Electronics JSC.
+  *
+  * Author:
+  *   Dmitry Dunaev <dmitry.dunaev@baikalelectronics.ru>
+  *
+  * This file is licensed under the terms of the GNU General Public License
+  * version 2. This program is licensed "as is" without any warranty of any
+  * kind, whether express or implied.
+  *
+  * Redistribution and use in source and binary forms, with or without
+  * modification, are permitted provided that the following conditions are met:
+  *     * Redistributions of source code must retain the above copyright
+  *       notice, this list of conditions and the following disclaimer.
+  *     * Redistributions in binary form must reproduce the above copyright
+  *       notice, this list of conditions and the following disclaimer in the
+  *       documentation and/or other materials provided with the distribution.
+  *     * Neither the name of Baikal Electronics JSC nor the names of its
+  *       contributors may be used to endorse or promote products derived
+  *       from this software without specific prior written permission.
+  */
+ 
+ #include <linux/module.h>
+ #include <linux/slab.h>
+ #include <linux/interrupt.h>
+ #include <linux/platform_device.h>
+ #include <linux/mdio-bitbang.h>
+ #include <linux/gpio.h>
+ #include <linux/delay.h>
+ #include <linux/mdio.h>
+ #include <linux/phy.h>
+ #include <linux/clk.h>
+ 
+ #include <linux/of_device.h>
+ #include <linux/of_gpio.h>
+ #include <linux/of_mdio.h>
+ 
+ #define MDIO_READ 			2
+ #define MDIO_WRITE 			1
+ 
+ #define MDIO_C45			(1<<15)
+ #define MDIO_C45_ADDR		(MDIO_C45 | 0)
+ #define MDIO_C45_READ		(MDIO_C45 | 3)
+ #define MDIO_C45_WRITE		(MDIO_C45 | 1)
+ #define MDIO_C45_READ_INC	(MDIO_C45 | 2)
+ 
+ /*
+  * Minimum MDC period is 400 ns, plus some margin for error.
+  * MDIO_DELAY is done twice per period.
+  * Baikal-T SoC GPIO pins trigger clock is 1 MHz.
+  */
+ #define MDIO_DELAY_US		2
+ 
+ /*
+  * The PHY may take up to 300 ns to produce data, plus some margin
+  * for error.
+  * Baikal-T SoC GPIO pins trigger clock is 1 MHz.
+  */
+ #define MDIO_READ_DELAY_US	10
+ #define MDIO_RELAX_DELAY_US	10
+ #define MDIO_RESET_DELAY_US	100
+ /*
+  * Driver specific defines
+  */
+ #define DRIVER_NAME		"Baikal Electronics mezzanine card MDIO bus driver"
+ #define DRIVER_VERSION	"1.05"
+ #define DRIVER_DEV		"be-mdio"
+ 
+ /* Default GPIO trigger freq is 1 MHz */
+ #define MDIO_TRIG_FREQ	1000000
+ 
+ /*
+  * Basic driver function
+  */
+ struct be_mdio_data {
+ 	struct phy_device *phydev;
+ 	struct mii_bus *mii;
+ 	struct clk *clk;
+ 	int mdc, mdio, mdo, rst;
+ 	int mdc_active_low, mdio_active_low;
+ 	int mdo_active_low, rst_active_low;
+ 	unsigned int delay, read_delay, reset_delay;
+     /* PHY addresses to be ignored when probing */
+     unsigned int phy_mask;
+     /* IRQ mask */
+ 	int irqs[PHY_MAX_ADDR];
+ };
+ 
+ /*
+  * Physical level of MDIO bus
+  */
+ static inline void be_mdio_dir(struct be_mdio_data *data, int dir)
+ {
+ 	if (data->mdo >= 0) {
+ 		/* Separate output pin. Always set its value to high
+ 		 * when changing direction. If direction is input,
+ 		 * assume the pin serves as pull-up. If direction is
+ 		 * output, the default value is high.
+ 		 */
+ 		gpio_set_value(data->mdo, 1 ^ data->mdo_active_low);
+ 		return;
+ 	}
+ 
+ 	if (dir)
+ 		gpio_direction_output(data->mdio,
+ 				      1 ^ data->mdio_active_low);
+ 	else
+ 		gpio_direction_input(data->mdio);
+ }
+ 
+ static inline int be_mdio_get(struct be_mdio_data *data)
+ {
+ 	return gpio_get_value(data->mdio) ^ data->mdio_active_low;
+ }
+ 
+ static inline void be_mdio_set(struct be_mdio_data *data, int what)
+ {
+ 	if (data->mdo >= 0)
+ 		gpio_set_value(data->mdo, what ^ data->mdo_active_low);
+ 	else
+ 		gpio_set_value(data->mdio, what ^ data->mdio_active_low);
+ }
+ 
+ static inline void be_mdc_set(struct be_mdio_data *data, int what)
+ {
+ 	gpio_set_value(data->mdc, what ^ data->mdc_active_low);
+ }
+ 
+ /*
+  * Logical level of MDIO bus
+  */
+ 
+ /* MDIO must already be configured as output. */
+ static void be_mdio_send_bit(struct be_mdio_data *data, int val)
+ {
+ 	be_mdio_set(data, val);
+ 	usleep_range(data->delay, MDIO_RELAX_DELAY_US);
+ 	be_mdc_set(data, 1);
+ 	usleep_range(data->delay, MDIO_RELAX_DELAY_US);
+ 	be_mdc_set(data, 0);
+ }
+ 
+ /* MDIO must already be configured as output. */
+ static void be_mdio_send_ta(struct be_mdio_data *data, int val)
+ {
+ 	be_mdio_set(data, val);
+ 	usleep_range(data->delay, MDIO_RELAX_DELAY_US);
+ 	be_mdc_set(data, 1);
+ 	usleep_range(data->delay, MDIO_RELAX_DELAY_US);
+ 	be_mdc_set(data, 0);
+ }
+ 
+ /* MDIO must already be configured as input. */
+ static int be_mdio_get_bit(struct be_mdio_data *data)
+ {
+ 	usleep_range(data->delay, MDIO_RELAX_DELAY_US);
+ 	be_mdc_set(data, 1);
+ 	usleep_range(data->delay, MDIO_RELAX_DELAY_US);
+ 	be_mdc_set(data, 0);
+ 	return be_mdio_get(data);
+ }
+ 
+ /* MDIO must already be configured as output. */
+ static void be_mdio_send_num(struct be_mdio_data *data, u16 val, int bits)
+ {
+ 	int i;
+ 
+ 	be_mdio_dir(data, 1);
+ 
+ 	for (i = bits - 1; i >= 0; i--)
+ 		be_mdio_send_bit(data, (val >> i) & 1);
+ }
+ 
+ /* MDIO must already be configured as input. */
+ static u16 be_mdio_get_num(struct be_mdio_data *data, int bits)
+ {
+ 	int i;
+ 	u16 ret = 0;
+ 
+ 	be_mdio_dir(data, 0);
+ 
+ 	for (i = bits - 1; i >= 0; i--) {
+ 		ret <<= 1;
+ 		ret |= be_mdio_get_bit(data);
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ /*
+  * Utility to send the preamble, address, and
+  * register (common to read and write).
+  */
+ static void be_mdio_cmd(struct be_mdio_data *data, int op, u8 phy, u8 reg)
+ {
+ 	int i;
+ 
+ 	be_mdio_dir(data, 1);
+ 	/*
+ 	 * Send a 32 bit preamble ('1's) with an extra '1' bit for good
+ 	 * measure.  The IEEE spec says this is a PHY optional
+ 	 * requirement. This means that we are doing more preambles
+ 	 * than we need, but it is safer and will be much more robust.
+ 	 */
+ 	for (i = 0; i < 32; i++)
+ 		be_mdio_send_bit(data, 1);
+ 	/*
+ 	 * Send the start bit (01) and the read opcode (10) or write (10).
+ 	 * Clause 45 operation uses 00 for the start and 11, 10 for
+ 	 * read/write.
+ 	 */
+ 	be_mdio_send_bit(data, 0);
+ 	if (op & MDIO_C45)
+ 		be_mdio_send_bit(data, 0);
+ 	else
+ 		be_mdio_send_bit(data, 1);
+ 	be_mdio_send_bit(data, (op >> 1) & 1);
+ 	be_mdio_send_bit(data, (op >> 0) & 1);
+ 
+ 	be_mdio_send_num(data, phy, 5);
+ 	be_mdio_send_num(data, reg, 5);
+ }
+ 
+ /* In clause 45 mode all commands are prefixed by MDIO_ADDR to specify the
+    lower 16 bits of the 21 bit address. This transfer is done identically to a
+    MDIO_WRITE except for a different code. To enable clause 45 mode or
+    MII_ADDR_C45 into the address. Theoretically clause 45 and normal devices
+    can exist on the same bus. Normal devices should ignore the MDIO_ADDR
+    phase. */
+ static int be_mdio_cmd_addr(struct be_mdio_data *data, int phy, u32 addr)
+ {
+ 	unsigned int dev_addr = (addr >> 16) & 0x1F;
+ 	unsigned int reg = addr & 0xFFFF;
+ 	be_mdio_cmd(data, MDIO_C45_ADDR, phy, dev_addr);
+ 
+ 	/* send the turnaround (10) */
+ 	be_mdio_send_ta(data, 1);
+ 	be_mdio_send_ta(data, 0);
+ 
+ 	be_mdio_send_num(data, reg, 16);
+ 
+ 	be_mdio_dir(data, 0);
+ 	be_mdio_get_bit(data);
+ 
+ 	return dev_addr;
+ }
+ 
+ static int be_mdio_read(struct mii_bus *bus, int phy, int reg)
+ {
+ 	struct be_mdio_data *data = bus->priv;
+ 	int ret, i;
+ 
+ 	if (reg & MII_ADDR_C45) {
+ 		reg = be_mdio_cmd_addr(data, phy, reg);
+ 		be_mdio_cmd(data, MDIO_C45_READ, phy, reg);
+ 	} else
+ 		be_mdio_cmd(data, MDIO_READ, phy, reg);
+ 
+ 	be_mdio_dir(data, 0);
+ 
+ 	/* check the turnaround bit: the PHY should be driving it to zero */
+ 	if (be_mdio_get_bit(data) != 0) {
+ 		/* PHY didn't drive TA low -- flush any bits it
+ 		 * may be trying to send.
+ 		 */
+ 		for (i = 0; i < 32; i++)
+ 			be_mdio_get_bit(data);
+ 
+ 		return 0xffff;
+ 	}
+ 
+ 	ret = be_mdio_get_num(data, 16);
+ 	be_mdio_get_bit(data);
+ 
+ 	return ret;
+ }
+ 
+ static int be_mdio_write(struct mii_bus *bus, int phy, int reg, u16 val)
+ {
+ 	struct be_mdio_data *data = bus->priv;
+ 
+ 	if (reg & MII_ADDR_C45) {
+ 		reg = be_mdio_cmd_addr(data, phy, reg);
+ 		be_mdio_cmd(data, MDIO_C45_WRITE, phy, reg);
+ 	} else
+ 		be_mdio_cmd(data, MDIO_WRITE, phy, reg);
+ 
+ 	/* send the turnaround (10) */
+ 	be_mdio_send_bit(data, 1);
+ 	be_mdio_send_bit(data, 0);
+ 
+ 	be_mdio_send_num(data, val, 16);
+ 
+ 	be_mdio_dir(data, 0);
+ 	be_mdio_get_bit(data);
+ 
+ 	return 0;
+ }
+ 
+ static int __maybe_unused be_mdio_reset(struct mii_bus *bus)
+ {
+ 	struct be_mdio_data *data = bus->priv;
+ 
+ 	if (data->rst < 0)
+ 		return 0;
+ 
+ 	gpio_set_value(data->rst, 1 ^ data->rst_active_low);
+ 	udelay(data->reset_delay);
+ 
+ 	gpio_set_value(data->rst, 0 ^ data->rst_active_low);
+ 	udelay(data->reset_delay);
+ 
+ 	return 0;
+ }
+ 
+ /*
+  * MDIO bus open firmware data
+  */
+ static void *be_mdio_of_get_data(struct platform_device *pdev)
+ {
+ 	struct device_node *np = pdev->dev.of_node;
+ 	struct be_mdio_data *pdata;
+ 	enum of_gpio_flags flags;
+ 	unsigned int freq = 0; 
+ 	int ret;
+ 
+ 	pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
+ 	if (!pdata)
+ 		return NULL;
+ 
+ 	ret =  of_get_named_gpio_flags(np, "mdc-pin", 0, &flags);
+ 	if (ret < 0)
+ 		return NULL;
+ 
+ 	pdata->mdc = ret;
+ 	pdata->mdc_active_low = flags & OF_GPIO_ACTIVE_LOW;
+ 
+ 	ret =  of_get_named_gpio_flags(np, "mdio-pin", 0, &flags);
+ 	if (ret < 0)
+ 		return NULL;
+ 	pdata->mdio = ret;
+ 	pdata->mdio_active_low = flags & OF_GPIO_ACTIVE_LOW;
+ 
+ 	pdata->mdo = -1;
+ 	ret = of_get_named_gpio_flags(np, "mdo-pin", 0, &flags);
+ 	if (ret >= 0) {
+ 		pdata->mdo = ret;
+ 		pdata->mdo_active_low = flags & OF_GPIO_ACTIVE_LOW;
+ 	}
+ 
+ 	pdata->rst = -1;
+ 	ret =  of_get_named_gpio_flags(np, "rst-pin", 0, &flags);
+ 	if (ret >= 0) {
+ 		pdata->rst = ret;
+ 		pdata->rst_active_low = flags & OF_GPIO_ACTIVE_LOW;
+ 	}
+ 
+ 	pdata->clk = of_clk_get(np, 0);
+ 
+ 	if (IS_ERR(pdata->clk))
+ 		of_property_read_u32(pdev->dev.of_node, "clock-frequency", &freq);
+ 	else
+ 		freq =  clk_get_rate(pdata->clk);
+ 
+ 	if (!freq)
+ 		freq = MDIO_TRIG_FREQ;
+ 
+ 	ret = 1000000 / freq;
+ 
+ 	/* Timing */
+ 	pdata->delay = (ret > MDIO_DELAY_US) ? ret : MDIO_DELAY_US;
+ 	pdata->read_delay = (ret > MDIO_READ_DELAY_US) ?
+ 					ret : MDIO_READ_DELAY_US;
+ 	pdata->reset_delay = (ret > MDIO_RESET_DELAY_US) ? 
+ 					ret : MDIO_RESET_DELAY_US;
+ 
+ 	return pdata;
+ }
+ 
+ /*
+  * MDIO bus init
+  */
+ static struct mii_bus *be_mdio_bus_init(struct device *dev,
+ 					  struct be_mdio_data *pdata, int bus_id)
+ {
+ 	struct mii_bus *bus;
+ 	int i;
+ 
+ 	bus = mdiobus_alloc();
+ 	if (!bus) {
+ 		dev_err(dev, "Unable to allocate MDIO bus\n");
+ 		goto error;
+ 	}
+ 
+ 	bus->read = be_mdio_read;
+ 	bus->write = be_mdio_write;
+ 	bus->priv = pdata;
+ 
+ 	bus->name = "Baikal GPIO MDIO bus";
+ 
+ 	bus->phy_mask = pdata->phy_mask;
+ 	bus->irq = pdata->irqs;
+ 	bus->parent = dev;
+ 
+ 	if (bus->phy_mask == ~0) {
+ 		dev_err(dev, "All PHY's are masked - nothing to attach\n");
+ 		goto error_free_bus;
+ 	}
+ 
+ 	for (i = 0; i < PHY_MAX_ADDR; i++)
+ 		if (!bus->irq[i])
+ 			bus->irq[i] = PHY_POLL;
+ 
+ 	snprintf(bus->id, MII_BUS_ID_SIZE, "mdio-gpio%d", bus_id);
+ 
+ 	if (devm_gpio_request(dev, pdata->mdc, "mdc")) {
+ 		dev_err(dev, "MDC line (gpio%d) request failed\n", pdata->mdc);
+ 		goto error_free_bus;
+ 	}
+ 
+ 	if (devm_gpio_request(dev, pdata->mdio, "mdio")){
+ 		dev_err(dev, "MDIO line (gpio%d) request failed\n", pdata->mdc);
+ 		goto error_free_bus;
+ 	}
+ 
+ 	if (pdata->mdo >= 0) {
+ 		if (devm_gpio_request(dev, pdata->mdo, "mdo"))
+ 			goto error_free_bus;
+ 		gpio_direction_output(pdata->mdo, 1);
+ 		gpio_direction_input(pdata->mdio);
+ 	}
+ 
+ 	if (pdata->rst >= 0) {
+ 		if (devm_gpio_request(dev, pdata->rst, "rst"))
+ 			pdata->rst= -1;
+ 		else 
+ 			gpio_direction_output(pdata->rst, 0);
+ 	}
+ 
+ 	gpio_direction_output(pdata->mdc, 0);
+ 
+ 	dev_set_drvdata(dev, bus);
+ 
+ 	return bus;
+ 
+ error_free_bus:
+ 	mdiobus_free(bus);
+ error:
+ 	return NULL;
+ }
+ 
+ static int be_mdio_probe(struct platform_device *pdev)
+ {
+ 	struct be_mdio_data *pdata;
+ 	struct mii_bus *bus;
+ 	int ret, bus_id;
+ 
+ 	if (pdev->dev.of_node) {
+ 		pdata = be_mdio_of_get_data(pdev);
+ 		bus_id = of_alias_get_id(pdev->dev.of_node, "mdio-gpio");
+ 		if (bus_id < 0) {
+ 			dev_warn(&pdev->dev, "failed to get alias id\n");
+ 			bus_id = 0;
+ 		}
+ 	} else {
+ 		pdata = dev_get_platdata(&pdev->dev);
+ 		bus_id = pdev->id;
+ 	}
+ 
+ 	if (!pdata) {
+ 		dev_err(&pdev->dev, "No MDIO bus platform data\n");
+ 		return -ENODEV;
+ 	}
+ 
+ 	bus = be_mdio_bus_init(&pdev->dev, pdata, bus_id);
+ 	if (!bus) {
+ 		dev_err(&pdev->dev, "MDIO bus init failed\n");
+ 		return -ENODEV;
+ 	}
+ 
+ 	if (pdev->dev.of_node)
+ 		ret = of_mdiobus_register(bus, pdev->dev.of_node);
+ 	else
+ 		ret = mdiobus_register(bus);
+ 
+ 	if (ret) {
+ 		dev_err(&pdev->dev, "MDIO bus register failed\n");
+ 		goto err_mdiobus_register;
+ 	}
+ 
+ 	// bus->reset = be_mdio_reset;
+ 
+ 	pdata->mii = bus;
+ 	dev_info(&pdev->dev, "MDIO ptr=%p\n", bus);
+ 
+ 	dev_info(&pdev->dev, DRIVER_NAME);
+ 	dev_info(&pdev->dev, "Version: " DRIVER_VERSION);
+ 
+ 	return 0;
+ 
+ err_mdiobus_register:
+ 	mdiobus_free(bus);
+ 
+ 	return ret;
+ }
+ 
+ static int be_mdio_remove(struct platform_device *pdev)
+ {
+ 
+ 	struct mii_bus *bus = dev_get_drvdata(&pdev->dev);
+ 
+ 	mdiobus_unregister(bus);
+ 	mdiobus_free(bus);
+ 
+ 	return 0;
+ }
+ 
+ static struct of_device_id be_mdio_of_match[] = {
+ 	{ .compatible = "be,mdio-gpio", },
+ 	{ /* sentinel */ }
+ };
+ 
+ static struct platform_driver be_mdio_driver = {
+ 	.probe = be_mdio_probe,
+ 	.remove = be_mdio_remove,
+ 	.driver		= {
+ 		.name	= "be-mdio",
+ 		.of_match_table = be_mdio_of_match,
+ 	},
+ };
+ 
+ module_platform_driver(be_mdio_driver);
+ 
+ MODULE_ALIAS("platform:be-mdio");
+ MODULE_AUTHOR("Dmitry Dunaev");
+ MODULE_LICENSE("Proprinetary");
+ MODULE_VERSION(DRIVER_VERSION);
+ MODULE_DESCRIPTION(DRIVER_NAME);
diff -rcNP linux-4.4.24/drivers/net/phy/mv88x2222.c linux-4.4.24-baikal/drivers/net/phy/mv88x2222.c
*** linux-4.4.24/drivers/net/phy/mv88x2222.c	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/drivers/net/phy/mv88x2222.c	2016-11-11 14:49:53.000000000 +0300
***************
*** 0 ****
--- 1,413 ----
+ /*
+  * drivers/net/phy/mv88x2222c
+  *
+  * Driver for Marvell Integrated Dual-port
+  * Multi-speed Ethernet Transceiver 88x2222
+  *
+  * Now supports only 10GBASE-R (KR to SFP+) for one lane.
+  *
+  * Copyright (c) 2015,2016 Baikal Electronics JSC.
+  *
+  * Author:
+  *   Dmitry Dunaev <dmitry.dunaev@baikalelectronics.ru>
+  *
+  * This file is licensed under the terms of the GNU General Public License
+  * version 2. This program is licensed "as is" without any warranty of any
+  * kind, whether express or implied.
+  *
+  * Redistribution and use in source and binary forms, with or without
+  * modification, are permitted provided that the following conditions are met:
+  *     * Redistributions of source code must retain the above copyright
+  *       notice, this list of conditions and the following disclaimer.
+  *     * Redistributions in binary form must reproduce the above copyright
+  *       notice, this list of conditions and the following disclaimer in the
+  *       documentation and/or other materials provided with the distribution.
+  *     * Neither the name of Baikal Electronics JSC nor the names of its
+  *       contributors may be used to endorse or promote products derived
+  *       from this software without specific prior written permission.
+  */
+ #include <linux/module.h>
+ #include <linux/phy.h>
+ #include <linux/gpio.h>
+ #include <linux/delay.h>
+ #include <linux/mdio.h>
+ #include <linux/marvell_phy.h>
+ #include <linux/of.h>
+ #include <linux/of_device.h>
+ #include <linux/of_gpio.h>
+ 
+ MODULE_DESCRIPTION("Marvell Ethernet Transceiver driver");
+ MODULE_AUTHOR("Dmitry Dunaev <dmitry.dunaev@baikalelectronics.ru>");
+ MODULE_LICENSE("Proprinetary");
+ 
+ /* 31.F002 Line side mode (ch.3.1.2, pg.46) */
+ #define MV_MODE_LINE_SHF					8
+ #define MV_MODE_LINE_10GBR					(_ULCAST_(0x71) << 8)
+ #define MV_MODE_LINE_10GBW					(_ULCAST_(0x74) << 8)
+ #define MV_MODE_LINE_2GBX_AN_OFF			(_ULCAST_(0x76) << 8)
+ #define MV_MODE_LINE_1GBR_AN_OFF			(_ULCAST_(0x72) << 8)
+ #define MV_MODE_LINE_1GBR_AN_ON				(_ULCAST_(0x73) << 8)
+ #define MV_MODE_LINE_SGMII_SYS_AN_OFF		(_ULCAST_(0x7C) << 8)
+ #define MV_MODE_LINE_SGMII_SYS_AN_ON		(_ULCAST_(0x7D) << 8)
+ #define MV_MODE_LINE_SGMII_NET_AN_OFF		(_ULCAST_(0x7E) << 8)
+ #define MV_MODE_LINE_SGMII_NET_AN_ON		(_ULCAST_(0x7F) << 8)
+ #define MV_MODE_LINE_DEFAULT				MV_MODE_LINE_10GBR
+ #define MV_MODE_LINE_OF_NAME				"mv,line-mode"
+ 
+ /* 31.F002 Host side mode (ch.3.1.2, pg.46) */
+ #define MV_MODE_HOST_SHF					0
+ #define MV_MODE_HOST_10GBR					(_ULCAST_(0x71) << 0)
+ #define MV_MODE_HOST_10GBX2					(_ULCAST_(0x72) << 0)
+ #define MV_MODE_HOST_10GBX4					(_ULCAST_(0x73) << 0)
+ #define MV_MODE_HOST_2GBX_AN_OFF			(_ULCAST_(0x76) << 0)
+ #define MV_MODE_HOST_1GBR_AN_OFF			(_ULCAST_(0x7A) << 0)
+ #define MV_MODE_HOST_1GBR_AN_ON				(_ULCAST_(0x7B) << 0)
+ #define MV_MODE_HOST_SGMII_SYS_AN_OFF		(_ULCAST_(0x7C) << 0)
+ #define MV_MODE_HOST_SGMII_SYS_AN_ON		(_ULCAST_(0x7D) << 0)
+ #define MV_MODE_HOST_SGMII_NET_AN_OFF		(_ULCAST_(0x7E) << 0)
+ #define MV_MODE_HOST_SGMII_NET_AN_ON		(_ULCAST_(0x7F) << 0)
+ #define MV_MODE_HOST_DEFAULT				MV_MODE_HOST_10GBR
+ #define MV_MODE_HOST_OF_NAME				"mv,host-mode"
+ 
+ /* 31.F402 Host side line muxing (ch.3.1.5, pg.48) */
+ #define MV_ATT_10GBX2_SHF					11
+ #define MV_ATT_10GBX2_LANE_0145				(_ULCAST_(0) << 11)
+ #define MV_ATT_10GBX2_LANE_0123				(_ULCAST_(1) << 11)
+ #define MV_ATT_10GBR_SHF					9
+ #define MV_ATT_10GBR_LANE_0246				(_ULCAST_(0) << 9)
+ #define MV_ATT_10GBR_LANE_0123				(_ULCAST_(1) << 9)
+ #define MV_ATT_2GBR_SHF						8
+ #define MV_ATT_2GBR_LANE_0246				(_ULCAST_(0) << 8)
+ #define MV_ATT_2GBR_LANE_0123				(_ULCAST_(1) << 8)
+ #define MV_ATT_1GBR_SHF						8
+ #define MV_ATT_1GBR_LANE_0246				(_ULCAST_(0) << 8)
+ #define MV_ATT_1GBR_LANE_0123				(_ULCAST_(1) << 8)
+ #define MV_ATT_DEFAULT						0
+ #define MV_ATT_OF_NAME						"mv,mux"
+ 
+ /* 31.F003 Software reset (ch.3.2 pg.50) */
+ #define MV_SW_RST_HOST_SHF					7
+ #define MV_SW_RST_HOST						(_ULCAST_(1) << 7)
+ #define MV_SW_RST_LINE_SHF					15
+ #define MV_SW_RST_LINE						(_ULCAST_(1) << 15)
+ #define MV_SW_RST_ALL						(MV_SW_RST_HOST | MV_SW_RST_LINE)
+ 
+ /* Devices in package and registers */
+ #define MV_DEV_10GBW_IRQ_ENABLE				0x8000
+ #define MV_DEV_10GBW_IRQ_STATUS				0x8001
+ #define MV_DEV_10GBW_IRQ_REALTIME			0x8002
+ 
+ #define MV_DEV_10GBR_ANEG					0x2000
+ #define MV_DEV_10GBR_IRQ_ENABLE				0x8000
+ #define MV_DEV_10GBR_IRQ_STATUS				0x8001
+ #define MV_DEV_10GBR_IRQ_REALTIME			0x8002
+ 
+ #define MV_DEV_GBX_IRQ_ENABLE				0xA000
+ #define MV_DEV_GBX_IRQ_STATUS				0xA001
+ #define MV_DEV_GBX_IRQ_REALTIME				0xA002
+ 
+ #define MV_DEV_MISC_IRQ_ENABLE				0xF00A
+ #define MV_DEV_MISC_IRQ_STATUS				0xF00B
+ 
+ #define MV_DEV_CHIP_HOST_LINE				0xF002
+ #define MV_DEV_CHIP_RESET					0xF003
+ #define MV_DEV_CHIP_MUX						0xF402
+ #define MV_DEV_CHIP_IRQ_STATUS				0xF420
+ #define MV_DEV_CHIP_IRQ_CONTROL				0xF421
+ 
+ #define MV_RESET_DELAY_US					500
+ 
+ static const unsigned int mv_modes_line[] =
+ {
+ 	MV_MODE_LINE_10GBR,
+ 	MV_MODE_LINE_10GBW,
+ 	MV_MODE_LINE_2GBX_AN_OFF,
+ 	MV_MODE_LINE_1GBR_AN_OFF,
+ 	MV_MODE_LINE_1GBR_AN_ON,
+ 	MV_MODE_LINE_SGMII_SYS_AN_OFF,
+ 	MV_MODE_LINE_SGMII_SYS_AN_ON,
+ 	MV_MODE_LINE_SGMII_NET_AN_OFF,
+ 	MV_MODE_LINE_SGMII_NET_AN_ON,
+ };
+ 
+ static const unsigned int mv_modes_host[] =
+ {
+ 	MV_MODE_HOST_10GBR,
+ 	MV_MODE_HOST_10GBX2,
+ 	MV_MODE_HOST_10GBX4,
+ 	MV_MODE_HOST_2GBX_AN_OFF,
+ 	MV_MODE_HOST_1GBR_AN_OFF,
+ 	MV_MODE_HOST_1GBR_AN_ON,
+ 	MV_MODE_HOST_SGMII_SYS_AN_OFF,
+ 	MV_MODE_HOST_SGMII_SYS_AN_ON,
+ 	MV_MODE_HOST_SGMII_NET_AN_OFF,
+ 	MV_MODE_HOST_SGMII_NET_AN_ON,
+ };
+ 
+ struct mv88x2222_data {
+ 	int irq;
+ 	int rst_active_low, irq_active_low;
+ 	int line_mode, host_mode, mux;
+ };
+ 
+ static const char* marvell_mode_line(unsigned int mode)
+ {
+ 	switch (mode) {
+ 	case MV_MODE_LINE_10GBR:
+ 		return "10GBASE-R";
+ 	case MV_MODE_LINE_10GBW:
+ 		return "10GBASE-W";
+ 	case MV_MODE_LINE_2GBX_AN_OFF:
+ 		return "2000BASE-X Auto-Negotiation Off";
+ 	case MV_MODE_LINE_1GBR_AN_OFF:
+ 		return "1000BASE-X Auto-Negotiation Off";
+ 	case MV_MODE_LINE_1GBR_AN_ON:
+ 		return "1000BASE-X Auto-Negotiation On";
+ 	case MV_MODE_LINE_SGMII_SYS_AN_OFF:
+ 		return "SGMII (System) Auto-Negotiation Off";
+ 	case MV_MODE_LINE_SGMII_SYS_AN_ON:
+ 		return "SGMII (System) Auto-Negotiation On";
+ 	case MV_MODE_LINE_SGMII_NET_AN_OFF:
+ 		return "SGMII (Network) Auto-Negotiation Off";
+ 	case MV_MODE_LINE_SGMII_NET_AN_ON:
+ 		return "SGMII (Network) Auto-Negotiation On";
+ 	default:
+ 		return "Unknown";
+ 	}
+ }
+ 
+ static const char* marvell_mode_host(unsigned int mode)
+ {
+ 	switch (mode) {
+ 	case MV_MODE_HOST_10GBR:
+ 		return "10GBASE-R";
+ 	case MV_MODE_HOST_10GBX2:
+ 		return "10GBASE-X2";
+ 	case MV_MODE_HOST_10GBX4:
+ 		return "10GBASE-X4";
+ 	case MV_MODE_HOST_2GBX_AN_OFF:
+ 		return "2000BASE-X Auto-Negotiation Off";
+ 	case MV_MODE_HOST_1GBR_AN_OFF:
+ 		return "1000BASE-X Auto-Negotiation Off";
+ 	case MV_MODE_HOST_1GBR_AN_ON:
+ 		return "1000BASE-X Auto-Negotiation On";
+ 	case MV_MODE_HOST_SGMII_SYS_AN_OFF:
+ 		return "SGMII (System) Auto-Negotiation Off";
+ 	case MV_MODE_HOST_SGMII_SYS_AN_ON:
+ 		return "SGMII (System) Auto-Negotiation On";
+ 	case MV_MODE_HOST_SGMII_NET_AN_OFF:
+ 		return "SGMII (Network) Auto-Negotiation Off";
+ 	case MV_MODE_HOST_SGMII_NET_AN_ON:
+ 		return "SGMII (Network) Auto-Negotiation On";
+ 	default:
+ 		return "Unknown";
+ 	}	
+ }
+ 
+ static void *marvell_of_get_data(struct phy_device *phydev)
+ {
+ 	struct device_node *np = phydev->dev.of_node;
+ 	struct mv88x2222_data *pdata;
+ 	enum of_gpio_flags flags;
+ 	unsigned int val;
+ 	int ret;
+ 
+ 	pdata = devm_kzalloc(&phydev->dev, sizeof(*pdata), GFP_KERNEL);
+ 	if (!pdata)
+ 		return NULL;
+ 
+ 	ret =  of_get_named_gpio_flags(np, "irq-pin", 0, &flags);
+ 	if (ret >= 0) {
+ 		pdata->irq = ret;
+ 		pdata->irq_active_low = flags & OF_GPIO_ACTIVE_LOW;
+ 		dev_info(&phydev->dev, "irq gpio pin=%d", ret);
+ 	}
+ 
+ 	pdata->line_mode = MV_MODE_LINE_DEFAULT;
+ 	ret = of_property_read_u32(np, MV_MODE_LINE_OF_NAME, &val);
+ 	if (!ret) {
+ 		if (val < ARRAY_SIZE(mv_modes_line))
+ 			pdata->line_mode = mv_modes_line[val];
+ 		else
+ 			dev_warn(&phydev->dev, "wrong value of %s property\n", MV_MODE_LINE_OF_NAME);
+ 	}
+ 
+ 	pdata->host_mode = MV_MODE_HOST_DEFAULT;
+ 	ret = of_property_read_u32(np, MV_MODE_HOST_OF_NAME, &val);
+ 	if (!ret) {
+ 		if (val < ARRAY_SIZE(mv_modes_host))
+ 			pdata->host_mode = mv_modes_host[val];
+ 		else
+ 			dev_warn(&phydev->dev, "wrong value of %s property\n", MV_MODE_HOST_OF_NAME);
+ 	}
+ 
+ 	/* Default value at now */
+ 	pdata->mux = MV_ATT_DEFAULT;
+ 
+ 	return pdata;
+ }
+ 
+ static int marvell_soft_reset(struct phy_device *phydev)
+ {
+ 	int ret = phy_write_mmd(phydev, MDIO_MMD_VEND2, MV_DEV_CHIP_RESET,
+ 						MV_SW_RST_ALL);
+ 	if (ret) {
+ 		dev_warn(&phydev->dev, "software reset failed\n");
+ 		return ret;
+ 	}
+ 
+ 	do {
+ 		usleep_range(MV_RESET_DELAY_US, MV_RESET_DELAY_US + 100);
+ 		ret = phy_read_mmd(phydev, MDIO_MMD_VEND2, MV_DEV_CHIP_RESET);
+ 	} while (ret & MV_SW_RST_ALL);
+ 
+ 	return 0;
+ }
+ 
+ static int marvell_config_init(struct phy_device *phydev)
+ {
+ 	struct mv88x2222_data *pdata = phydev->priv;
+ 	int ret;
+ 
+ 	ret = phy_write_mmd(phydev, MDIO_MMD_VEND2, MV_DEV_CHIP_HOST_LINE,
+ 				pdata->line_mode | pdata->host_mode);
+ 	if (ret)
+ 		dev_warn(&phydev->dev, "phy mode set failed\n");
+ 
+ 	marvell_soft_reset(phydev);
+ 
+ 	dev_info(&phydev->dev, "Host mode %s\n", marvell_mode_host(pdata->host_mode));
+ 	dev_info(&phydev->dev, "Line mode %s\n", marvell_mode_line(pdata->line_mode));
+ 
+ 	phydev->supported = 0;
+ 	phydev->supported |= SUPPORTED_Backplane;
+ 	phydev->supported |= SUPPORTED_10000baseKR_Full |
+ 			    SUPPORTED_10000baseR_FEC;
+ 	phydev->supported |= SUPPORTED_10000baseKX4_Full |
+ 				SUPPORTED_1000baseKX_Full |
+ 				SUPPORTED_2500baseX_Full;
+ 
+ 	phydev->pause = 0;
+ 	phydev->asym_pause = 0;
+ 	phydev->interface = PHY_INTERFACE_MODE_XGMII;
+ 	phydev->duplex = DUPLEX_FULL;
+ 
+ 	switch (pdata->line_mode) {
+ 	case MV_MODE_LINE_10GBR:
+ 	case MV_MODE_LINE_10GBW:
+ 		phydev->speed = SPEED_10000;
+ 		break;
+ 	case MV_MODE_LINE_2GBX_AN_OFF:
+ 		phydev->speed = SPEED_2500;
+ 		break;
+ 	default:
+ 		phydev->speed = SPEED_1000;
+ 		break;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int marvell_update_link(struct phy_device *phydev)
+ {
+ 	int reg;
+ 
+ 	/* Default link status */
+ 	phydev->link = 1;
+ 
+ 	/* Read line link status */
+ 	reg = phy_read_mmd(phydev, MDIO_MMD_PCS, MDIO_STAT1);
+ 	if ((reg < 0) || !(reg & MDIO_STAT1_LSTATUS))
+ 		phydev->link = 0;
+ 	dev_dbg(&phydev->dev, "LINE link=%d\n", (reg & MDIO_STAT1_LSTATUS)?1:0);
+ 
+ 	/* Read host link status */
+ 	reg = phy_read_mmd(phydev, MDIO_MMD_PHYXS, MDIO_STAT1);
+ 	if ((reg < 0) || !(reg & MDIO_STAT1_LSTATUS))
+ 		phydev->link = 0;
+ 	dev_dbg(&phydev->dev, "HOST link=%d\n", (reg & MDIO_STAT1_LSTATUS)?1:0);
+ 
+ 	return 0;
+ }
+ 
+ static int marvell_read_status(struct phy_device *phydev)
+ {
+ 	int reg;
+ 
+ 	/* Update the link, but return if there was an error */
+ 	reg = marvell_update_link(phydev);
+ 	if (reg < 0)
+ 		return reg;
+ 
+ 	/* Read line control reg */
+ 	reg = phy_read_mmd(phydev, MDIO_MMD_PCS, MDIO_CTRL1);
+ 	if (reg < 0)
+ 		return reg;
+ 
+ 	return 0;
+ }
+ 
+ static int marvell_config_aneg(struct phy_device *phydev)
+ {
+ 	/* Not supported yet */
+ 	phydev->lp_advertising = 0;
+ 	phydev->autoneg = AUTONEG_DISABLE;
+ 	/* Link partner advertising modes */
+ 	phydev->advertising = phydev->supported;
+ 
+ 	return 0;
+ }
+ 
+ static int marvell_probe(struct phy_device *phydev)
+ {
+ 	struct mv88x2222_data *pdata = NULL;
+ 
+ 	if (phydev->dev.of_node)
+ 		pdata = marvell_of_get_data(phydev);
+ 
+ 	if (!pdata) {
+ 		dev_err(&phydev->dev, "No PHY platform data\n");
+ 		return -ENODEV;
+ 	}
+ 
+ 	phydev->priv = pdata;
+ 
+ 	dev_info(&phydev->dev, "probed %s at 0x%02x\n", phydev->drv->name,
+ 		phydev->addr);
+ 
+ 	return 0;
+ }
+ 
+ static int marvell_match_phy_device(struct phy_device *phydev)
+ {
+ 	unsigned int phy_id = phydev->c45_ids.device_ids[MDIO_MMD_PCS] &
+ 					MARVELL_PHY_ID_MASK;
+ 	return  (phy_id == MARVELL_PHY_ID_88X2222) ||
+ 			(phy_id == MARVELL_PHY_ID_88X2222R);
+ }
+ 
+ static struct phy_driver marvell_drivers[] = {
+ 	{
+ 		.phy_id = MARVELL_PHY_ID_88X2222,
+ 		.phy_id_mask = MARVELL_PHY_ID_MASK,
+ 		.name = "Marvell 88X2222",
+ 		.features = 0,
+ 		.config_init = marvell_config_init,
+ 		.config_aneg = marvell_config_aneg,
+ 		.probe = marvell_probe,
+ 		.match_phy_device = marvell_match_phy_device,
+ 		.read_status = marvell_read_status,
+ 		.soft_reset = marvell_soft_reset,
+ 		.resume = genphy_resume,
+ 		.suspend = genphy_suspend,
+ 		.driver = {	.owner = THIS_MODULE },
+ 	},
+ };
+ module_phy_driver(marvell_drivers);
+ 
+ static struct mdio_device_id __maybe_unused marvell_tbl[] = {
+ 	{ MARVELL_PHY_ID_88X2222, MARVELL_PHY_ID_MASK },
+ 	{ MARVELL_PHY_ID_88X2222R, MARVELL_PHY_ID_MASK },
+ 	{ }
+ };
+ MODULE_DEVICE_TABLE(mdio, marvell_tbl);
diff -rcNP linux-4.4.24/drivers/pci/pcie/aspm.c linux-4.4.24-baikal/drivers/pci/pcie/aspm.c
*** linux-4.4.24/drivers/pci/pcie/aspm.c	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/pci/pcie/aspm.c	2016-11-11 14:49:53.000000000 +0300
***************
*** 522,528 ****
  	INIT_LIST_HEAD(&link->children);
  	INIT_LIST_HEAD(&link->link);
  	link->pdev = pdev;
! 	if (pci_pcie_type(pdev) != PCI_EXP_TYPE_ROOT_PORT) {
  		struct pcie_link_state *parent;
  		parent = pdev->bus->parent->self->link_state;
  		if (!parent) {
--- 522,529 ----
  	INIT_LIST_HEAD(&link->children);
  	INIT_LIST_HEAD(&link->link);
  	link->pdev = pdev;
!     if ((pci_pcie_type(pdev) != PCI_EXP_TYPE_ROOT_PORT) &&
!         (!pci_is_root_bus(pdev->bus->parent))) {
  		struct pcie_link_state *parent;
  		parent = pdev->bus->parent->self->link_state;
  		if (!parent) {
diff -rcNP linux-4.4.24/drivers/rtc/Kconfig linux-4.4.24-baikal/drivers/rtc/Kconfig
*** linux-4.4.24/drivers/rtc/Kconfig	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/rtc/Kconfig	2016-11-11 14:49:53.000000000 +0300
***************
*** 174,179 ****
--- 174,190 ----
  	  This driver can also be built as a module. If so, the module
  	  will be called rtc-ab-b5ze-s3.
  
+ config RTC_DRV_ABEOZ9S3
+ 	depends on I2C
+ 	select REGMAP_I2C
+ 	tristate "Abracon AB-RTCMC-32.768kHz-EOZ9-S3"
+ 	help
+ 	  If you say yes here you get support for the Abracon
+ 	  AB-RTCMC-32.768kHz-EOZ9-S3 I2C RTC chip.
+ 
+ 	  This driver can also be built as a module. If so, the module
+ 	  will be called rtc-ab-eoz9-s3.
+ 
  config RTC_DRV_ABX80X
  	tristate "Abracon ABx80x"
  	help
***************
*** 1114,1119 ****
--- 1125,1135 ----
  	  If you say yes here you get support for the RTC subsystem of the
  	  NUC910/NUC920 used in embedded systems.
  
+ config RTC_DRV_DW
+         tristate "Support for Synopsys DesignWare RTC"
+         help
+           Selecting this option will enable the Synopsys DesignWare APB RTC.
+ 
  config RTC_DRV_OPAL
  	tristate "IBM OPAL RTC driver"
  	depends on PPC_POWERNV
diff -rcNP linux-4.4.24/drivers/rtc/Makefile linux-4.4.24-baikal/drivers/rtc/Makefile
*** linux-4.4.24/drivers/rtc/Makefile	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/rtc/Makefile	2016-11-11 14:49:53.000000000 +0300
***************
*** 25,30 ****
--- 25,31 ----
  obj-$(CONFIG_RTC_DRV_AB3100)	+= rtc-ab3100.o
  obj-$(CONFIG_RTC_DRV_AB8500)	+= rtc-ab8500.o
  obj-$(CONFIG_RTC_DRV_ABB5ZES3)	+= rtc-ab-b5ze-s3.o
+ obj-$(CONFIG_RTC_DRV_ABEOZ9S3)	+= rtc-ab-eoz9-s3.o
  obj-$(CONFIG_RTC_DRV_ABX80X)	+= rtc-abx80x.o
  obj-$(CONFIG_RTC_DRV_ARMADA38X)	+= rtc-armada38x.o
  obj-$(CONFIG_RTC_DRV_AS3722)	+= rtc-as3722.o
***************
*** 60,65 ****
--- 61,67 ----
  obj-$(CONFIG_RTC_DRV_DS2404)	+= rtc-ds2404.o
  obj-$(CONFIG_RTC_DRV_DS3232)	+= rtc-ds3232.o
  obj-$(CONFIG_RTC_DRV_DS3234)	+= rtc-ds3234.o
+ obj-$(CONFIG_RTC_DRV_DW)	+= rtc-dw.o
  obj-$(CONFIG_RTC_DRV_EFI)	+= rtc-efi.o
  obj-$(CONFIG_RTC_DRV_EM3027)	+= rtc-em3027.o
  obj-$(CONFIG_RTC_DRV_EP93XX)	+= rtc-ep93xx.o
diff -rcNP linux-4.4.24/drivers/rtc/rtc-ab-eoz9-s3.c linux-4.4.24-baikal/drivers/rtc/rtc-ab-eoz9-s3.c
*** linux-4.4.24/drivers/rtc/rtc-ab-eoz9-s3.c	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/drivers/rtc/rtc-ab-eoz9-s3.c	2016-11-11 14:49:53.000000000 +0300
***************
*** 0 ****
--- 1,578 ----
+ /*
+  * rtc-ab-eoz9-s3 - Driver for Abracon AB-RTCMC-32.768Khz-EOZ9-S3
+  *                  I2C RTC / Alarm chip (reduced smbus version)
+  *
+  * Copyright (C) 2015,2016 Baikal Electronics JSC
+  * 
+  *  Author:
+  *    Dmitry Dunaev <dmitry.dunaev@baikalelectronics.ru>
+  *
+  * Detailed datasheet of the chip is available here:
+  *
+  * http://www.abracon.com/realtimeclock/AB-RTCMC-32.768kHz-EOZ9-S3-Application-Manual.pdf
+  *
+  * This work is based on AB-RTCMC-32.768Khz-B5ZE-S3 driver (drivers/rtc/rtc-ab-b5ze-s3.c).
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation; either version 2 of the License, or
+  * (at your option) any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  */
+ 
+ #include <linux/module.h>
+ #include <linux/mutex.h>
+ #include <linux/rtc.h>
+ #include <linux/i2c.h>
+ #include <linux/bcd.h>
+ #include <linux/of.h>
+ #include <linux/hwmon.h>
+ #include <linux/hwmon-sysfs.h>
+ #include <linux/thermal.h>
+ 
+ #define DRV_NAME "rtc-ab-eoz9-s3"
+ #define DRV_VERSION "1.0.2"
+ 
+ /* Control section */
+ #define ABEOZ9S3_REG_CTRL1	   0x00	   /* Control 1 register */
+ #define ABEOZ9S3_REG_CTRL1_WE	   BIT(0)  /* 1Hz watch enable */
+ #define ABEOZ9S3_REG_CTRL1_TE	   BIT(1)  /* Countdown timer enable */
+ #define ABEOZ9S3_REG_CTRL1_TAR	   BIT(2)  /*  */
+ #define ABEOZ9S3_REG_CTRL1_EERE	   BIT(3)  /*  */
+ #define ABEOZ9S3_REG_CTRL1_SRO	   BIT(4)  /*  */
+ #define ABEOZ9S3_REG_CTRL1_TD0	   BIT(5)  /*  */
+ #define ABEOZ9S3_REG_CTRL1_TD1	   BIT(6)  /*  */
+ #define ABEOZ9S3_REG_CTRL1_INT	   BIT(7)
+ 
+ #define ABEOZ9S3_REG_CTRL2	   0x01	   /* Control 2 register */
+ #define ABEOZ9S3_REG_CTRL2_AIE	   BIT(0)  /*  */
+ #define ABEOZ9S3_REG_CTRL2_TIE	   BIT(1)  /*  */
+ #define ABEOZ9S3_REG_CTRL2_V1IE	   BIT(2)  /*  */
+ #define ABEOZ9S3_REG_CTRL2_V2IE	   BIT(3)  /*  */
+ #define ABEOZ9S3_REG_CTRL2_SRIE	   BIT(4)  /*  */
+ 
+ #define ABEOZ9S3_REG_CTRL3	   0x02	   /* Control 3 register */
+ #define ABEOZ9S3_REG_CTRL3_AF	   BIT(0)  /*  */
+ #define ABEOZ9S3_REG_CTRL3_TF	   BIT(1)  /*  */
+ #define ABEOZ9S3_REG_CTRL3_V1IF	   BIT(2)  /*  */
+ #define ABEOZ9S3_REG_CTRL3_V2IF	   BIT(3)  /*  */
+ #define ABEOZ9S3_REG_CTRL3_SRF	   BIT(4)  /*  */
+ 
+ #define ABEOZ9S3_REG_CTRL4	   0x03	   /* Control 4 register */
+ #define ABEOZ9S3_REG_CTRL4_V1F	   BIT(2)  /*  */
+ #define ABEOZ9S3_REG_CTRL4_V2F	   BIT(3)  /*  */
+ #define ABEOZ9S3_REG_CTRL4_SR	   BIT(4)  /*  */
+ #define ABEOZ9S3_REG_CTRL4_PON	   BIT(5)  /*  */
+ #define ABEOZ9S3_REG_CTRL4_EEBUSY  BIT(7)  /*  */
+ 
+ #define ABEOZ9S3_REG_CTRL5	   0x04	   /* Control 5 register */
+ #define ABEOZ9S3_REG_CTRL5_SYSR	   BIT(4)  /*  */
+ 
+ #define ABEOZ9S3_CTRL_SEC_OFS  0  /* Section offset */
+ #define ABEOZ9S3_CTRL_SEC_LEN  5  /* Section length */
+ 
+ /* RTC section */
+ #define ABEOZ9S3_REG_RTC_SC	   0x00	   /* RTC Seconds register */
+ #define ABEOZ9S3_REG_RTC_MN	   0x01	   /* RTC Minutes register */
+ #define ABEOZ9S3_REG_RTC_HR	   0x02	   /* RTC Hours register */
+ #define ABEOZ9S3_REG_RTC_HR_PM BIT(6)  /* RTC Hours PM bit */
+ #define ABEOZ9S3_REG_RTC_DT	   0x03	   /* RTC Date register */
+ #define ABEOZ9S3_REG_RTC_DW	   0x04	   /* RTC Day of the week register */
+ #define ABEOZ9S3_REG_RTC_MO	   0x05	   /* RTC Month register */
+ #define ABEOZ9S3_REG_RTC_YR	   0x06	   /* RTC Year register */
+ 
+ #define ABEOZ9S3_RTC_SEC_OFS       0x08  /* Section offset */
+ #define ABEOZ9S3_RTC_SEC_LEN  	   7 	/* Section length */
+ #define ABEOZ9S3_RTC_SEC_REG(R)    (ABEOZ9S3_RTC_SEC_OFS + R)
+ 
+ /* Alarm section (enable bits are all active low) */
+ #define ABEOZ9S3_REG_ALRM_SC	   0x00	   /* Alarm - seconds register */
+ #define ABEOZ9S3_REG_ALRM_SC_AE	   BIT(7)  /* Second enable */
+ #define ABEOZ9S3_REG_ALRM_MN	   0x01	   /* Alarm - minute register */
+ #define ABEOZ9S3_REG_ALRM_MN_AE	   BIT(7)  /* Minute enable */
+ #define ABEOZ9S3_REG_ALRM_HR	   0x02	   /* Alarm - hours register */
+ #define ABEOZ9S3_REG_ALRM_HR_AE	   BIT(7)  /* Hour enable */
+ #define ABEOZ9S3_REG_ALRM_DT	   0x03	   /* Alarm - date register */
+ #define ABEOZ9S3_REG_ALRM_DT_AE	   BIT(7)  /* Date (day of the month) enable */
+ #define ABEOZ9S3_REG_ALRM_DW	   0x04	   /* Alarm - day of the week reg. */
+ #define ABEOZ9S3_REG_ALRM_DW_AE	   BIT(7)  /* Day of the week enable */
+ #define ABEOZ9S3_REG_ALRM_MO	   0x05	   /* Alarm - month reg. */
+ #define ABEOZ9S3_REG_ALRM_MO_AE	   BIT(7)  /* Month enable */
+ #define ABEOZ9S3_REG_ALRM_YR	   0x06	   /* Alarm - year reg. */
+ #define ABEOZ9S3_REG_ALRM_YR_AE	   BIT(7)  /* Year enable */
+ 
+ #define ABEOZ9S3_ALRM_SEC_OFS  0x10  /* Section offset */
+ #define ABEOZ9S3_ALRM_SEC_LEN  7 	/* Section length */
+ 
+ /* Timer counter section */
+ #define ABEOZ9S3_REG_TIMER_LOW	   0x18	   /* Timer counter low byte register */
+ #define ABEOZ9S3_REG_TIMER_HIGH	   0x19	   /* Timer counter high byte register */
+ 
+ /* Temperature sensor section */
+ #define ABEOZ9S3_REG_TEMP	   		0x20	   /* Temperature sensor register */
+ #define ABEOZ9S3_TEMP_MAX_POS		194
+ #define ABEOZ9S3_TEMP_MAX_NEG		60
+ 
+ /* EEPROM user section */
+ #define ABEOZ9S3_REG_EEPROM_USR1   0x28	   /* User EEPROM data byte 1 register */
+ #define ABEOZ9S3_REG_EEPROM_USR2   0x29	   /* User EEPROM data byte 2 register */
+ 
+ /* EEPROM control section */
+ #define ABEOZ9S3_REG_EEPROM_CTL	   0x30	   /* EEPROM control register */
+ #define ABEOZ9S3_REG_EEPROM_THP	   BIT(0)  /*  */
+ #define ABEOZ9S3_REG_EEPROM_THE	   BIT(1)  /*  */
+ #define ABEOZ9S3_REG_EEPROM_FD0	   BIT(2)  /*  */
+ #define ABEOZ9S3_REG_EEPROM_FD1	   BIT(3)  /*  */
+ #define ABEOZ9S3_REG_EEPROM_R1K	   BIT(4)  /*  */
+ #define ABEOZ9S3_REG_EEPROM_R5K	   BIT(4)  /*  */
+ #define ABEOZ9S3_REG_EEPROM_R20K   BIT(4)  /*  */
+ #define ABEOZ9S3_REG_EEPROM_R80K   BIT(4)  /*  */
+ 
+ #define ABEOZ9S3_MEM_MAP_LEN	   0x30
+ 
+ struct abeoz9s3_rtc_data {
+ 	struct i2c_client *client;
+ 	struct rtc_device *rtc;
+ 	struct mutex lock;
+ 	struct device		*hwmon_dev;
+ 	struct thermal_zone_device	*tz;
+ };
+ 
+ /*
+  * Try and match register bits w/ fixed null values to see whether we
+  * are dealing with an ABEOZ9S3. Note: this function is called early
+  * during init and hence does need mutex protection.
+  */
+ static int abeoz9s3_i2c_validate_client(struct i2c_client *client)
+ {
+ 	static const unsigned char regmask[] = {
+ 			/* Control page */
+ 			ABEOZ9S3_CTRL_SEC_OFS + ABEOZ9S3_REG_CTRL1, 0x00,
+ 			ABEOZ9S3_CTRL_SEC_OFS + ABEOZ9S3_REG_CTRL2, 0xe0,
+ 			ABEOZ9S3_CTRL_SEC_OFS + ABEOZ9S3_REG_CTRL3, 0xe0,
+ 			ABEOZ9S3_CTRL_SEC_OFS + ABEOZ9S3_REG_CTRL4, 0x43,
+ 			ABEOZ9S3_CTRL_SEC_OFS + ABEOZ9S3_REG_CTRL5, 0xef,
+ 			/* Time page */
+ 			ABEOZ9S3_RTC_SEC_OFS + ABEOZ9S3_REG_RTC_SC, 0x80,
+ 			ABEOZ9S3_RTC_SEC_OFS + ABEOZ9S3_REG_RTC_MN, 0x80,
+ 			ABEOZ9S3_RTC_SEC_OFS + ABEOZ9S3_REG_RTC_HR, 0x80,
+ 			ABEOZ9S3_RTC_SEC_OFS + ABEOZ9S3_REG_RTC_DT, 0xc0,
+ 			ABEOZ9S3_RTC_SEC_OFS + ABEOZ9S3_REG_RTC_DW, 0xf8,
+ 			ABEOZ9S3_RTC_SEC_OFS + ABEOZ9S3_REG_RTC_MO, 0xe0,
+ 			ABEOZ9S3_RTC_SEC_OFS + ABEOZ9S3_REG_RTC_YR, 0x80,
+ 			/* Alarm page */
+ 			ABEOZ9S3_ALRM_SEC_OFS + ABEOZ9S3_REG_ALRM_HR, 0x40,
+ 			ABEOZ9S3_ALRM_SEC_OFS + ABEOZ9S3_REG_ALRM_DT, 0x40,
+ 			ABEOZ9S3_ALRM_SEC_OFS + ABEOZ9S3_REG_ALRM_DW, 0x78,
+ 			ABEOZ9S3_ALRM_SEC_OFS + ABEOZ9S3_REG_ALRM_MO, 0x60,
+ 		};
+ 
+ 	int i, ret;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(regmask); i += 2) {
+ 
+ 		ret = i2c_smbus_read_byte_data(client, regmask[i]);
+ 
+ 		if (ret < 0) {
+ 			dev_err(&client->dev, "%s: could not read register %x\n",
+ 				__func__, regmask[i]);
+ 
+ 			return -EIO;
+ 		}
+ 
+ 		if (ret & regmask[i+1]) {
+ 			dev_err(&client->dev,
+ 				"%s: register=%02x, mask=0x%02x, value=0x%02x\n",
+ 				__func__, regmask[i], regmask[i+1], ret);
+ 
+ 			return -ENODEV;
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /*
+  * Note: we only read, so regmap inner lock protection is sufficient, i.e.
+  * we do not need driver's main lock protection.
+  */
+ static int abeoz9s3_rtc_read_time(struct device *dev, struct rtc_time *tm)
+ {
+ //	struct abeoz9s3_rtc_data *data = dev_get_drvdata(dev);
+ 	struct i2c_client *client = to_i2c_client(dev);
+ 	unsigned char regs[ABEOZ9S3_RTC_SEC_LEN];
+ 	int i;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(regs); i++) {
+ 
+ 		regs[i] = i2c_smbus_read_byte_data(client, ABEOZ9S3_RTC_SEC_REG(i));
+ 
+ 		if (regs[i] < 0) {
+ 			dev_err(dev, "%s: could not read register %x\n",
+ 				__func__, ABEOZ9S3_RTC_SEC_OFS + i);
+ 
+ 			return -EIO;
+ 		}
+ 	}
+ 
+ 	tm->tm_sec = bcd2bin(regs[ABEOZ9S3_REG_RTC_SC] & 0x7F);
+ 	tm->tm_min = bcd2bin(regs[ABEOZ9S3_REG_RTC_MN] & 0x7F);
+ 
+ 	if (regs[ABEOZ9S3_REG_RTC_HR] & ABEOZ9S3_REG_RTC_HR_PM) { /* 12hr mode */
+ 		tm->tm_hour = bcd2bin(regs[ABEOZ9S3_REG_RTC_HR] & 0x1f);
+ 		if (regs[ABEOZ9S3_REG_RTC_HR] & ABEOZ9S3_REG_RTC_HR_PM) /* PM */
+ 			tm->tm_hour += 12;
+ 	} else {
+ 		/* 24hr mode */
+ 		tm->tm_hour = bcd2bin(regs[ABEOZ9S3_REG_RTC_HR]);
+ 	}
+ 
+ 	tm->tm_mday = bcd2bin(regs[ABEOZ9S3_REG_RTC_DT]);
+ 	tm->tm_wday = bcd2bin(regs[ABEOZ9S3_REG_RTC_DW]);
+ 	tm->tm_mon  = bcd2bin(regs[ABEOZ9S3_REG_RTC_MO]) - 1; /* starts at 1 */
+ 	tm->tm_year = bcd2bin(regs[ABEOZ9S3_REG_RTC_YR]) + 100; /* starts at 20xx */
+ 
+ 	return rtc_valid_tm(tm);
+ }
+ 
+ static int abeoz9s3_rtc_set_time(struct device *dev, struct rtc_time *tm)
+ {
+ 	struct i2c_client *client = to_i2c_client(dev);
+ 	struct abeoz9s3_rtc_data *data = dev_get_drvdata(dev);
+ 	unsigned char regs[ABEOZ9S3_RTC_SEC_LEN];
+ 	int i, ret = 0;
+ 
+ 	/*
+ 	 * Year register is 8-bit wide and bcd-coded, i.e records values
+ 	 * between 0 and 99. tm_year is an offset from 1900 and we are
+ 	 * interested in the 2000-2099 range, so any value less than 100
+ 	 * is invalid.
+ 	 */
+ 	if (tm->tm_year < 100)
+ 		return -EINVAL;
+ 
+ 	regs[ABEOZ9S3_REG_RTC_SC] = bin2bcd(tm->tm_sec); /* MSB=0 clears OSC */
+ 	regs[ABEOZ9S3_REG_RTC_MN] = bin2bcd(tm->tm_min);
+ 	regs[ABEOZ9S3_REG_RTC_HR] = bin2bcd(tm->tm_hour); /* 24-hour format */
+ 	regs[ABEOZ9S3_REG_RTC_DT] = bin2bcd(tm->tm_mday);
+ 	regs[ABEOZ9S3_REG_RTC_DW] = bin2bcd(tm->tm_wday);
+ 	regs[ABEOZ9S3_REG_RTC_MO] = bin2bcd(tm->tm_mon + 1);
+ 	regs[ABEOZ9S3_REG_RTC_YR] = bin2bcd(tm->tm_year - 100);
+ 
+ 	mutex_lock(&data->lock);
+ 
+ 	for (i = 0; i < ARRAY_SIZE(regs); i++) {
+ 
+ 		ret = i2c_smbus_write_byte_data(client, ABEOZ9S3_RTC_SEC_REG(i), regs[i]);
+ 
+ 		if (ret < 0) {
+ 			dev_err(&client->dev, "%s: could not write register %x\n",
+ 				__func__, ABEOZ9S3_RTC_SEC_OFS + i);
+ 			goto err;
+ 		}
+ 	}
+ 	/* Check and clean PON flag */
+ 	ret = i2c_smbus_read_byte_data(client, ABEOZ9S3_REG_CTRL4);
+ 	if (ret < 0) {
+ 		dev_err(dev, "%s: unable to get CTRL4 register (%d)\n",
+ 			__func__, ret);
+ 		goto err;
+ 	}
+ 	/* Check and clear */
+ 	if (ret & ABEOZ9S3_REG_CTRL4_PON) {
+ 		ret = i2c_smbus_write_byte_data(client, ABEOZ9S3_REG_CTRL4,
+ 									ret & ~(ABEOZ9S3_REG_CTRL4_PON));
+ 		if (ret < 0)
+ 			dev_err(dev, "%s: unable to set CTRL4 register (%d)\n",
+ 				__func__, ret);
+ 	}
+ err:
+ 	mutex_unlock(&data->lock);
+ 
+ 	return ret;
+ }
+ 
+ static int abeoz9s3_rtc_temp(void *sensor)
+ {
+ 	struct abeoz9s3_rtc_data *data = sensor;
+ 	struct i2c_client *client = data->client;
+ 	int ret;
+ 
+ 	ret = i2c_smbus_read_byte_data(client, ABEOZ9S3_REG_TEMP);
+ 
+ 	if (ret < 0) {
+ 		dev_err(data->hwmon_dev, "%s: could not read register %x\n",
+ 			__func__, ABEOZ9S3_REG_TEMP);
+ 	}
+ 
+ 	return (ret - ABEOZ9S3_TEMP_MAX_NEG);
+ }
+ 
+ static inline int abeoz9s3_rtc_temp_valid(int temp)
+ {
+ 	return (temp >= ABEOZ9S3_TEMP_MAX_NEG) ||
+ 		   (temp <= ABEOZ9S3_TEMP_MAX_POS);
+ }
+ 
+ /* sysfs attributes for hwmon */
+ 
+ static int abeoz9s3_read_temp(void *sensor, int *temp)
+ {
+ 	*temp = abeoz9s3_rtc_temp(sensor) * 1000;
+ 
+ 	return 0;
+ }
+ 
+ static ssize_t abeoz9s3_show_temp(struct device *dev, struct device_attribute *da,
+ 			 char *buf)
+ {
+ 	struct abeoz9s3_rtc_data *data = dev_get_drvdata(dev);
+ 	struct sensor_device_attribute *attr = to_sensor_dev_attr(da);
+ 	int temp;
+ 
+ 	switch (attr->index) {
+ 	case 0:
+ 		temp = abeoz9s3_rtc_temp(data);
+ 		break;
+ 	case 1:
+ 		temp = -ABEOZ9S3_TEMP_MAX_NEG;
+ 		break;
+ 	case 2:
+ 		temp = ABEOZ9S3_TEMP_MAX_POS;
+ 		break;
+ 	default:
+ 		temp = -EINVAL;
+ 	}
+ 
+ 	return sprintf(buf, "%d\n", temp * 1000);
+ }
+ 
+ static int abeoz9s3_rtc_proc(struct device *dev, struct seq_file *seq)
+ {
+ 	int temp = abeoz9s3_rtc_temp(dev);
+ 
+ 	if (abeoz9s3_rtc_temp_valid(temp))
+ 		seq_printf(seq, "Temperature	: %2d°C\n", temp);
+ 
+ 	return 0;
+ }
+ 
+ /*
+  * Check current RTC status and enable/disable what needs to be. Return 0 if
+  * everything went ok and a negative value upon error. Note: this function
+  * is called early during init and hence does need mutex protection.
+  */
+ static int abeoz9s3_rtc_setup(struct device *dev)
+ {
+ 	struct i2c_client *client = to_i2c_client(dev);
+ 	int ret;
+ 
+ 	/* Control1 register setup */
+ 	ret = i2c_smbus_read_byte_data(client, ABEOZ9S3_REG_CTRL1);
+ 	if (ret < 0) {
+ 		dev_err(dev, "%s: unable to get CTRL1 register (%d)\n",
+ 			__func__, ret);
+ 		return ret;
+ 	}
+ 	/* Enable Self Recovery, Clock for Watch, EEPROM refresh */
+ 	ret |= (ABEOZ9S3_REG_CTRL1_WE | ABEOZ9S3_REG_CTRL1_EERE |
+ 		ABEOZ9S3_REG_CTRL1_SRO);
+ 	/* Disable Countdown Timer, Set INT function on CLKOUT pin */
+ 	ret &= ~(ABEOZ9S3_REG_CTRL1_TE | ABEOZ9S3_REG_CTRL1_TAR |
+ 		ABEOZ9S3_REG_CTRL1_INT);
+ 	/* Set new value */
+ 	ret = i2c_smbus_write_byte_data(client, ABEOZ9S3_REG_CTRL1, ret);
+ 	if (ret < 0) {
+ 		dev_err(dev, "%s: unable to set CTRL1 register (%d)\n",
+ 			__func__, ret);
+ 		return ret;
+ 	}
+ 
+ 	/* Control INT register setup. No interrupts */
+ 	ret = i2c_smbus_write_byte_data(client, ABEOZ9S3_REG_CTRL2, 0);
+ 	if (ret < 0) {
+ 		dev_err(dev, "%s: unable to set CTRL2 register (%d)\n",
+ 			__func__, ret);
+ 		return ret;
+ 	}
+ 
+ 	/* Control INT Flag register setup. Clear flags */
+ 	ret = i2c_smbus_write_byte_data(client, ABEOZ9S3_REG_CTRL3, 0);
+ 	if (ret < 0) {
+ 		dev_err(dev, "%s: unable to set CTRL3 register (%d)\n",
+ 			__func__, ret);
+ 		return ret;
+ 	}
+ 
+ 	/* Control Status register setup. */
+ 	ret = i2c_smbus_read_byte_data(client, ABEOZ9S3_REG_CTRL4);
+ 	if (ret < 0) {
+ 		dev_err(dev, "%s: unable to get CTRL4 register (%d)\n",
+ 			__func__, ret);
+ 		return ret;
+ 	}
+ 
+ 	if (ret & ABEOZ9S3_REG_CTRL4_PON)
+ 		dev_warn(dev, "RTC Date/Time may be corrupted!\n");
+ 
+ 	/* Clear all status bits */
+ 	ret = i2c_smbus_write_byte_data(client, ABEOZ9S3_REG_CTRL4, 0);
+ 	if (ret < 0) {
+ 		dev_err(dev, "%s: unable to set CTRL4 register (%d)\n",
+ 			__func__, ret);
+ 		return ret;
+ 	}
+ 
+ 	ret = i2c_smbus_read_byte_data(client, ABEOZ9S3_REG_EEPROM_CTL);
+ 	if (ret < 0) {
+ 		dev_err(dev, "%s: unable to get EEPROM Control register (%d)\n",
+ 			__func__, ret);
+ 		return ret;
+ 	}
+ 	/* Enable Termometer */
+ 	ret |= (ABEOZ9S3_REG_EEPROM_THE);
+ 	/* Disable charge resistors, Temperature Scanning Interval: 1 sec */
+ 	ret &= ~((ABEOZ9S3_REG_EEPROM_R1K | ABEOZ9S3_REG_EEPROM_R5K |
+ 		ABEOZ9S3_REG_EEPROM_R20K | ABEOZ9S3_REG_EEPROM_R80K |
+ 		ABEOZ9S3_REG_EEPROM_THP));
+ 
+ 	ret = i2c_smbus_write_byte_data(client, ABEOZ9S3_REG_EEPROM_CTL, ret);
+ 	if (ret < 0) {
+ 		dev_err(dev, "%s: unable to set EEPROM Control register (%d)\n",
+ 			__func__, ret);
+ 		return ret;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static SENSOR_DEVICE_ATTR(temp1_input, S_IRUGO, abeoz9s3_show_temp, NULL, 0);
+ static SENSOR_DEVICE_ATTR(temp1_min, S_IRUGO, abeoz9s3_show_temp, NULL, 1);
+ static SENSOR_DEVICE_ATTR(temp1_max, S_IRUGO, abeoz9s3_show_temp, NULL, 2);
+ 
+ static struct attribute *abeoz9s3_attrs[] = {
+ 	&sensor_dev_attr_temp1_input.dev_attr.attr,
+ 	&sensor_dev_attr_temp1_min.dev_attr.attr,
+ 	&sensor_dev_attr_temp1_max.dev_attr.attr,
+ 	NULL
+ };
+ ATTRIBUTE_GROUPS(abeoz9s3);
+ 
+ static const struct thermal_zone_of_device_ops abeoz9s3_of_thermal_ops = {
+ 	.get_temp = abeoz9s3_read_temp,
+ };
+ 
+ static const struct rtc_class_ops rtc_ops = {
+ 	.read_time 	= abeoz9s3_rtc_read_time,
+ 	.set_time 	= abeoz9s3_rtc_set_time,
+ 	.proc 		= abeoz9s3_rtc_proc,
+ };
+ 
+ static int abeoz9s3_probe(struct i2c_client *client,
+ 			  const struct i2c_device_id *id)
+ {
+ 	struct abeoz9s3_rtc_data *data = NULL;
+ 	struct device *dev = &client->dev;
+ 	int ret;
+ 
+ 	dev_dbg(&client->dev, "%s\n", __func__);
+ 
+ 	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C |
+ 				     I2C_FUNC_SMBUS_BYTE_DATA |
+ 				     I2C_FUNC_SMBUS_I2C_BLOCK))
+ 		return -ENODEV;
+ 
+ 	ret = abeoz9s3_i2c_validate_client(client);
+ 	if (ret)
+ 		return ret;
+ 
+ 	dev_info(&client->dev, "chip found, driver version " DRV_VERSION "\n");
+ 
+ 	data = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);
+ 	if (!data)
+ 		return -ENOMEM;
+ 
+ 	dev_set_drvdata(dev, data);
+ 	mutex_init(&data->lock);
+ 	data->client = client;
+ 
+ 	ret = abeoz9s3_rtc_setup(dev);
+ 	if (ret)
+ 		goto err;
+ 
+ 	data->rtc = devm_rtc_device_register(dev, DRV_NAME, &rtc_ops,
+ 					     THIS_MODULE);
+ 	ret = PTR_ERR_OR_ZERO(data->rtc);
+ 	if (ret) {
+ 		dev_err(dev, "%s: unable to register RTC device (%d)\n",
+ 			__func__, ret);
+ 		goto err;
+ 	}
+ 
+ 	data->hwmon_dev = hwmon_device_register_with_groups(dev, client->name,
+ 							    data, abeoz9s3_groups);
+ 	if (IS_ERR(data->hwmon_dev)) {
+ 		data->hwmon_dev = NULL;
+ 		goto err;
+ 	}
+ 
+ 	data->tz = thermal_zone_of_sensor_register(data->hwmon_dev, 0,
+ 						   data->hwmon_dev,
+ 						   &abeoz9s3_of_thermal_ops);
+ 	if (IS_ERR(data->tz))
+ 		data->tz = NULL;
+ 
+ 	dev_info(dev, "%s: sensor '%s'\n",
+ 		 dev_name(data->hwmon_dev), client->name);
+ 
+ 
+ err:
+ 	return ret;
+ }
+ 
+ static int abeoz9s3_remove(struct i2c_client *client)
+ {
+ 	struct abeoz9s3_rtc_data *data = i2c_get_clientdata(client);
+ 
+ 	if (data->hwmon_dev) {
+ 		thermal_zone_of_sensor_unregister(data->hwmon_dev, data->tz);
+ 		hwmon_device_unregister(data->hwmon_dev);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ #ifdef CONFIG_OF
+ static const struct of_device_id abeoz9s3_dt_match[] = {
+ 	{ .compatible = "abracon,abeoz9s3" },
+ 	{ },
+ };
+ #endif
+ 
+ static const struct i2c_device_id abeoz9s3_id[] = {
+ 	{ "abeoz9s3", 0 },
+ 	{ }
+ };
+ MODULE_DEVICE_TABLE(i2c, abeoz9s3_id);
+ 
+ static struct i2c_driver abeoz9s3_driver = {
+ 	.class		= I2C_CLASS_HWMON,
+ 	.driver = {
+ 		.name = DRV_NAME,
+ 		.owner = THIS_MODULE,
+ 		.of_match_table = of_match_ptr(abeoz9s3_dt_match),
+ 	},
+ 	.probe	  = abeoz9s3_probe,
+ 	.remove	  = abeoz9s3_remove,
+ 	.id_table = abeoz9s3_id,
+ };
+ module_i2c_driver(abeoz9s3_driver);
+ 
+ MODULE_AUTHOR("Dmitry Dunaev");
+ MODULE_DESCRIPTION("Abracon AB-RTCMC-32.768kHz-EOZ9-S3 RTC/Alarm driver");
+ MODULE_LICENSE("GPL2");
+ MODULE_VERSION(DRV_VERSION);
diff -rcNP linux-4.4.24/drivers/rtc/rtc-dw.c linux-4.4.24-baikal/drivers/rtc/rtc-dw.c
*** linux-4.4.24/drivers/rtc/rtc-dw.c	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/drivers/rtc/rtc-dw.c	2016-11-11 14:48:06.000000000 +0300
***************
*** 0 ****
--- 1,379 ----
+ /*
+  * Synopsis DesignWare RTC driver.
+  *
+  * Copyright (C) 2013 Baikal Electronics.
+  *
+  * Author: Alexey Malahov <Alexey.Malahov@baikalelectronics.com>
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License version 2 as
+  * published by the Free Software Foundation.
+  */
+ #include <linux/module.h>
+ #include <linux/module.h>
+ #include <linux/rtc.h>
+ #include <linux/init.h>
+ #include <linux/platform_device.h>
+ #include <linux/interrupt.h>
+ #include <linux/io.h>
+ #include <linux/slab.h>
+ #include <linux/of_device.h>
+ #include <linux/of.h>
+ 
+ /* RTC registers. */
+ #define RTC_CCVR		(0x0) /* Current Counter Value Register. */
+ #define RTC_CMR			(0x4) /* Current Match Register. */
+ #define RTC_CLR 		(0x8) /* Current Load Register. */
+ #define RTC_CCR			(0xc) /* Counter Control Register. */
+ #define RTC_STAT		(0x10) /* Interrupt Status Register. */
+ #define RTC_RSTAT		(0x14) /* Interrupt Raw Status Register. */
+ #define RTC_EOI			(0x18) /* End of Interrupt Register. */
+ #define RTC_COMP_VERSION	(0x1c) /* Component Version Register. */
+ #define RTC_COMP_VERSION_VAL	0x3230332a
+ 
+ /* RTC_CCR bits. */
+ #define RTC_CCR_WEN	(1 << 3)	/* Wrap enable. */
+ #define RTC_CCR_EN	(1 << 2)	/* Counter enable. */
+ #define RTC_CCR_IMASK	(1 << 1)	/* Interrupt masked. */
+ #define RTC_CCR_IEN	(1 << 0)	/* Interrupt enabled. */
+ 
+ /* rtc_clk frequency by default. 1kHz. */
+ #define	RTC_CLK_FREQ_DEFAULT	1000
+ 
+ /* default RTC epoch. */
+ #define RTC_EPOCH_DEFAULT	1970 /* Jan 1 1970 00:00:00 */
+ 
+ struct dw_rtc {
+ 	struct rtc_device	*rtc_dev;
+ 	void __iomem		*base;
+ 	uint32_t		freq;
+ 	uint32_t		epoch;
+ 	unsigned long		epoch_seconds;
+ 	uint32_t		irq;
+ };
+ 
+ static int dw_alarm_irq_enable(struct device *dev, unsigned int enabled)
+ {
+ 	struct dw_rtc *rtc = dev_get_drvdata(dev);
+ 	uint32_t reg;
+ 
+ 	if (!rtc)
+ 		return -ENODEV;
+ 
+ 	/* Read the control register. */
+ 	reg = readl(rtc->base + RTC_CCR);
+ 
+ 	if (enabled) {
+ 		/* Check the pending interrupt. */
+ 		if (readl(rtc->base + RTC_RSTAT)) {
+ 			/*
+ 			 *  According to the databook the rtc_en bit of the RTC_CCR
+ 			 *  register should be set to 0 to clear the interrupt.
+  			 */
+ 			reg &= ~RTC_CCR_EN;
+ 			writel(reg, rtc->base + RTC_CCR);
+ 
+ 			reg |= RTC_CCR_EN;
+ 		}
+ 
+ 		/* Unmask and enable an interrupt. */
+ 		reg &= ~RTC_CCR_IMASK;
+ 		reg |= RTC_CCR_IEN;
+ 	} else {
+ 		/* Disable and mask interrupt. */
+ 		reg &= ~RTC_CCR_IEN;
+ 		reg |= RTC_CCR_IMASK;
+ 	}
+ 
+ 	writel(reg, rtc->base + RTC_CCR);
+ 
+ 	dev_dbg(dev, "%s: Set RTC_CCR to 0x%x\n", __FUNCTION__, reg);
+ 	return 0;
+ }
+ 
+ static int dw_read_reg(struct device *dev, int reg, struct rtc_time *tm)
+ {
+ 	struct dw_rtc *rtc = dev_get_drvdata(dev);
+ 	unsigned long seconds;
+ 
+ 	if (!rtc)
+ 		return -ENODEV;
+ 
+ 	/* Get elapsed seconds. */
+ 	seconds = readl(rtc->base + reg) / rtc->freq;
+ 
+ 	dev_dbg(dev, "Read %ld sec from 0x%x register, epoch secs =%ld\n",
+ 			seconds, reg, rtc->epoch_seconds);
+ 
+ 	rtc_time_to_tm((seconds + rtc->epoch_seconds), tm);
+ 
+ 	dev_dbg(dev, "%s: Read time: year=%d, mon=%d, mday=%d, hour=%d, min=%d sec=%d\n",
+ 				__FUNCTION__, tm->tm_year, tm->tm_mon, tm->tm_mday,
+ 				tm->tm_hour, tm->tm_min, tm->tm_sec);
+ 	return 0;
+ }
+ 
+ static int dw_set_reg(struct device *dev, int reg, struct rtc_time *tm)
+ {
+ 	struct dw_rtc *rtc = dev_get_drvdata(dev);
+ 	unsigned long seconds;
+ 
+ 	if (!rtc)
+ 		return -ENODEV;
+ 
+ 	dev_dbg(dev, "%s: Set time: year=%d, mon=%d, mday=%d, hour=%d, min=%d sec=%d\n",
+ 				__FUNCTION__, tm->tm_year, tm->tm_mon, tm->tm_mday,
+ 				tm->tm_hour, tm->tm_min, tm->tm_sec);
+ 
+ 	/* Check time passed. */
+ 	if (rtc_valid_tm(tm) != 0) {
+ 		dev_err(dev, "time is unvalid.\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	seconds = mktime(tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday,
+ 			tm->tm_hour, tm->tm_min, tm->tm_sec);
+ 
+ 	dev_dbg(dev, "%s: sec=%ld epoch_sec=%ld delta=%ld\n", __FUNCTION__, seconds, rtc->epoch_seconds,
+ 			seconds - rtc->epoch_seconds);
+ 
+ 	seconds -= rtc->epoch_seconds;
+ 
+ 	if ((seconds >= 0) && ((uint64_t) seconds * rtc->freq) < ULONG_MAX) {
+ 		dev_dbg(dev, "Write %ld sec to 0x%x register\n", seconds, reg);
+ 		writel((rtc->freq * seconds), rtc->base + reg);
+ 	} else {
+ 		dev_err(dev, "Change the RTC epoch: %d year\n", rtc->epoch);
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ 
+ static irqreturn_t dw_irq(int irq, void *dev_id)
+ {
+ 	struct dw_rtc *rtc = dev_id;
+ 
+ 	/* Clear the interrupt. */
+ 	readl(rtc->base + RTC_EOI);
+ 
+ 	rtc_update_irq(rtc->rtc_dev, 1, (RTC_AF | RTC_IRQF));
+ 	return IRQ_HANDLED;
+ }
+ 
+ static int dw_read_alarm(struct device *dev, struct rtc_wkalrm *alm)
+ {
+ 	/* Read time from RTC_CMR. */
+ 	return dw_read_reg(dev, RTC_CMR, &alm->time);
+ }
+ 
+ static int dw_set_alarm(struct device *dev, struct rtc_wkalrm *alm)
+ {
+ 	int ret;
+ 
+ 	/* Set time to RTC_CMR. */
+ 	if ((ret = dw_set_reg(dev, RTC_CMR, &alm->time)) != 0) {
+ 		return ret;
+ 	}
+ 
+ 	/* Does alarm need to be enalbed? */
+ 	if (alm->enabled) {
+ 		dw_alarm_irq_enable(dev, alm->enabled);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int dw_read_time(struct device *dev, struct rtc_time *tm)
+ {
+ 	/* Read time from RTC_CCVR. */
+ 	return dw_read_reg(dev, RTC_CCVR, tm);
+ }
+ 
+ static int dw_set_time(struct device *dev, struct rtc_time *tm)
+ {
+ 	/* Set time to RTC_CLR. */
+ 	return dw_set_reg(dev, RTC_CLR, tm);
+ }
+ 
+ static int dw_ioctl(struct device *dev, unsigned int cmd, unsigned long arg)
+ {
+ 	struct dw_rtc *rtc = dev_get_drvdata(dev);
+ 	
+ 	if (!rtc)
+ 		return -ENODEV;
+ 
+ 	switch (cmd) {
+ 	case RTC_EPOCH_READ:
+ 		return put_user(rtc->epoch, (unsigned long __user *)arg);
+ 	case RTC_EPOCH_SET:
+ 		/* Doesn't support before 1900 */
+ 		if (arg < 1900)
+ 			return -EINVAL;
+ 		rtc->epoch = arg;
+ 		rtc->epoch_seconds = mktime(rtc->epoch, 1, 1, 0, 0, 0);
+ 		break;
+ 	default:
+ 		return -ENOIOCTLCMD;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ 
+ static int dw_proc(struct device *dev, struct seq_file *seq)
+ {
+ 	uint32_t reg;
+ 	struct dw_rtc *rtc = dev_get_drvdata(dev);
+ 	
+ 	if (!rtc)
+ 		return -ENODEV;
+ 
+ 	reg = readl(rtc->base + RTC_CCR);
+ 	seq_printf(seq, "Wrap enable\t: %s\n", reg & RTC_CCR_WEN ? "yes" : "no");
+ 	seq_printf(seq, "Counter enable\t: %s\n", reg & RTC_CCR_EN ? "yes" : "no");
+ 	seq_printf(seq, "Interrupt masked\t: %s\n", reg & RTC_CCR_IMASK ? "yes" : "no");
+ 	seq_printf(seq, "Interrupt enabled\t: %s\n", reg & RTC_CCR_IEN ? "yes" : "no");
+ 
+ 	seq_printf(seq, "RTC epoch\t\t: %d year\n", rtc->epoch);
+ 	seq_printf(seq, "RTC base\t\t: 0x%p\n", rtc->base);
+ 	seq_printf(seq, "RTC freq\t\t: %d\n", rtc->freq);
+ 
+ 	reg = readl(rtc->base + RTC_CCVR);
+ 	seq_printf(seq, "RTC_CCVR\t\t: 0x%x\n", reg);
+ 
+ 	reg = readl(rtc->base + RTC_CMR);
+ 	seq_printf(seq, "RTC_CMR \t\t: 0x%x\n", reg);
+ 
+ 	return 0;
+ }
+ 
+ static const struct rtc_class_ops dw_ops = {
+ 	.ioctl			= dw_ioctl,
+ 	.read_time		= dw_read_time,
+ 	.set_time		= dw_set_time,
+ 	.read_alarm		= dw_read_alarm,
+ 	.set_alarm		= dw_set_alarm,
+ 	.proc			= dw_proc,
+ 	.alarm_irq_enable 	= dw_alarm_irq_enable,
+ };
+ 
+ static int dw_probe(struct platform_device *pdev)
+ {
+ 	struct resource *res;
+ 	struct dw_rtc *rtc;
+         struct device_node *np = pdev->dev.of_node;
+         const uint32_t *iprop;
+ 
+ 	/* Allocate resources. */
+ 	if (!(rtc = devm_kzalloc(&pdev->dev, sizeof(struct dw_rtc), GFP_KERNEL))) {
+ 		dev_err(&pdev->dev, "cannot allocate memory\n");
+ 		return -ENOMEM;
+ 	}
+ 
+ 	if (!(res = platform_get_resource(pdev, IORESOURCE_MEM, 0))) {
+ 		dev_err(&pdev->dev, "cannot get resource\n");
+ 		return -ENXIO;
+ 	}
+ 
+ 	if (!(rtc->base = devm_ioremap(&pdev->dev, res->start, resource_size(res)))) {
+ 		dev_err(&pdev->dev, "cannot ioremap\n");
+ 		return -EIO;
+ 	}
+ 
+ 	dev_info(&pdev->dev, "rtc_base = %p rtc_version = 0x%x\n", rtc->base,
+ 				readl(rtc->base + RTC_COMP_VERSION));
+ 
+ 
+ 	rtc->rtc_dev = devm_rtc_device_register(&pdev->dev, pdev->name,
+ 						&dw_ops, THIS_MODULE);
+ 
+ 	if (IS_ERR(rtc->rtc_dev)) {
+ 		dev_err(&pdev->dev, "cannot register rtc device\n");
+ 		return PTR_ERR(rtc->rtc_dev);
+ 	}
+ 
+ 	/* Clear pending interrupts. */
+ 	writel(0, rtc->base + RTC_CCR);
+ 
+ 	/* Enable counter. */
+ 	writel(RTC_CCR_EN, rtc->base + RTC_CCR);
+ 
+ 	if ((rtc->irq = platform_get_irq(pdev, 0)) <= 0) {
+ 		dev_err(&pdev->dev, "cannot get irq.\n");
+ 		return -ENXIO;
+ 	}
+ 
+ 	dev_info(&pdev->dev, "rtc_irq = %d\n", rtc->irq);
+ 
+ 	if (devm_request_irq(&pdev->dev, rtc->irq, dw_irq, 0, "dw_rtc", rtc) < 0) {
+ 		dev_err(&pdev->dev, "cannot request irq%d\n", rtc->irq);
+ 		return -EIO;
+ 	}
+ 
+ 	platform_set_drvdata(pdev, rtc);
+ 
+ 	np = pdev->dev.of_node;
+ 	iprop = of_get_property(np, "rt-clk-frequency", NULL);
+ 	if (iprop)
+ 		rtc->freq = be32_to_cpup(iprop);
+ 	else
+ 		rtc->freq = RTC_CLK_FREQ_DEFAULT;
+ 
+ 	dev_info(&pdev->dev, "rtc_clk freq = %d Hz\n", rtc->freq);
+ 
+ 	/* Set RTC epoch. */
+ 	rtc->epoch = RTC_EPOCH_DEFAULT;
+ 	rtc->epoch_seconds = mktime(rtc->epoch, 1, 1, 0, 0, 0);
+ 
+ 
+ 	/* Disable irq. */
+ 	dw_alarm_irq_enable(&pdev->dev, 0);
+ 
+ 	dev_info(&pdev->dev, "Synopsis DesignWare Real Time Clock\n");
+ 
+ 	return 0;
+ 
+ }
+ 
+ static int dw_remove(struct platform_device *pdev)
+ {
+         struct dw_rtc *rtc = platform_get_drvdata(pdev);
+ 
+         if (!rtc)
+                 return 0;
+ 
+ 	/* Disable irq. */
+ 	dw_alarm_irq_enable(&pdev->dev, 0);
+ 
+         platform_set_drvdata(pdev, NULL);
+ 
+         return 0;
+ }
+ 
+ 
+ //static SIMPLE_DEV_PM_OPS(dw_pm_ops, dw_suspend, dw_resume); //TODO
+ 
+ static const struct of_device_id rtc_dt_ids[] = {
+ 	{ .compatible = "snps,dw-rtc", },
+ 	{ /* sentinel */ }
+ };
+ MODULE_DEVICE_TABLE(of, rtc_dt_ids);
+ 
+ static struct platform_driver dw_rtcdrv = {
+ 	.probe          = dw_probe,
+ 	.remove         = dw_remove,
+ 	.driver         = {
+ 		.name   = "dw-rtc",
+ 		.owner  = THIS_MODULE,
+ //		.pm     = &dw_rtc_pm_ops,
+ 		.of_match_table = of_match_ptr(rtc_dt_ids),
+ 	},
+ };
+ 
+ module_platform_driver(dw_rtcdrv);
+ 
+ MODULE_AUTHOR(" Alexey Malahov <Alexey.Malahov@baikalelectronics.com>");
+ MODULE_DESCRIPTION("Synopsis DesignWare RTC driver.");
+ MODULE_LICENSE("GPL");
diff -rcNP linux-4.4.24/drivers/spi/spi-dw.c linux-4.4.24-baikal/drivers/spi/spi-dw.c
*** linux-4.4.24/drivers/spi/spi-dw.c	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/spi/spi-dw.c	2016-11-11 14:49:54.000000000 +0300
***************
*** 26,42 ****
--- 26,54 ----
  
  #ifdef CONFIG_DEBUG_FS
  #include <linux/debugfs.h>
+ #define SSI_RESOURCE_NAME "mrst_spi"
  #endif
  
+ #define START_STATE	((void *)0)
+ #define RUNNING_STATE	((void *)1)
+ #define DONE_STATE	((void *)2)
+ #define ERROR_STATE	((void *)-1)
+ 
  /* Slave spi_dev related */
  struct chip_data {
+ 	u16 cr0;
  	u8 cs;			/* chip select pin */
+ 	u8 n_bytes;		/* current is a 1/2/4 byte op */
  	u8 tmode;		/* TR/TO/RO/EEPROM */
  	u8 type;		/* SPI/SSP/MicroWire */
  
  	u8 poll_mode;		/* 1 means use poll mode */
  
+ 	u32 dma_width;
+ 	u32 rx_threshold;
+ 	u32 tx_threshold;
  	u8 enable_dma;
+ 	u8 bits_per_word;
  	u16 clk_div;		/* baud rate divider */
  	u32 speed_hz;		/* baud rate */
  	void (*cs_control)(u32 command);
***************
*** 107,113 ****
  
  static int dw_spi_debugfs_init(struct dw_spi *dws)
  {
! 	dws->debugfs = debugfs_create_dir("dw_spi", NULL);
  	if (!dws->debugfs)
  		return -ENOMEM;
  
--- 119,130 ----
  
  static int dw_spi_debugfs_init(struct dw_spi *dws)
  {
! 	char name[12];
! 
! 	/* Create instance name */
! 	sprintf(name, "%s%d", SSI_RESOURCE_NAME, dws->bus_num);
! 	/* Create debugfs entries */
! 	dws->debugfs = debugfs_create_dir(name, NULL);
  	if (!dws->debugfs)
  		return -ENOMEM;
  
***************
*** 188,194 ****
  			else
  				txw = *(u16 *)(dws->tx);
  		}
! 		dw_write_io_reg(dws, DW_SPI_DR, txw);
  		dws->tx += dws->n_bytes;
  	}
  }
--- 205,211 ----
  			else
  				txw = *(u16 *)(dws->tx);
  		}
! 		dw_writel(dws, DW_SPI_DR, txw);
  		dws->tx += dws->n_bytes;
  	}
  }
***************
*** 199,205 ****
  	u16 rxw;
  
  	while (max--) {
! 		rxw = dw_read_io_reg(dws, DW_SPI_DR);
  		/* Care rx only if the transfer's original "rx" is not null */
  		if (dws->rx_end - dws->len) {
  			if (dws->n_bytes == 1)
--- 216,222 ----
  	u16 rxw;
  
  	while (max--) {
! 		rxw = dw_readl(dws, DW_SPI_DR);
  		/* Care rx only if the transfer's original "rx" is not null */
  		if (dws->rx_end - dws->len) {
  			if (dws->n_bytes == 1)
***************
*** 211,224 ****
  	}
  }
  
  static void int_error_stop(struct dw_spi *dws, const char *msg)
  {
! 	spi_reset_chip(dws);
  
  	dev_err(&dws->master->dev, "%s\n", msg);
! 	dws->master->cur_msg->status = -EIO;
! 	spi_finalize_current_transfer(dws->master);
  }
  
  static irqreturn_t interrupt_transfer(struct dw_spi *dws)
  {
--- 228,320 ----
  	}
  }
  
+ static void *next_transfer(struct dw_spi *dws)
+ {
+ 	struct spi_message *msg = dws->cur_msg;
+ 	struct spi_transfer *trans = dws->cur_transfer;
+ 
+ 	/* Move to next transfer */
+ 	if (trans->transfer_list.next != &msg->transfers) {
+ 		dws->cur_transfer =
+ 			list_entry(trans->transfer_list.next,
+ 					struct spi_transfer,
+ 					transfer_list);
+ 		return RUNNING_STATE;
+ 	}
+ 
+ 	return DONE_STATE;
+ }
+ 
+ /*
+  * Note: first step is the protocol driver prepares
+  * a dma-capable memory, and this func just need translate
+  * the virt addr to physical
+  */
+ static int map_dma_buffers(struct dw_spi *dws)
+ {
+ 	if (!dws->cur_msg->is_dma_mapped
+ 		|| !dws->dma_inited
+ 		|| !dws->cur_chip->enable_dma
+ 		|| !dws->dma_ops)
+ 		return 0;
+ 
+ 	if (dws->cur_transfer->tx_dma)
+ 		dws->tx_dma = dws->cur_transfer->tx_dma;
+ 
+ 	if (dws->cur_transfer->rx_dma)
+ 		dws->rx_dma = dws->cur_transfer->rx_dma;
+ 
+ 	return 1;
+ }
+ 
+ /* Caller already set message->status; dma and pio irqs are blocked */
+ static void giveback(struct dw_spi *dws)
+ {
+ 	struct spi_transfer *last_transfer;
+ 	struct spi_message *msg;
+ 
+ 	msg = dws->cur_msg;
+ 	dws->cur_msg = NULL;
+ 	dws->cur_transfer = NULL;
+ 	dws->prev_chip = dws->cur_chip;
+ 	dws->cur_chip = NULL;
+ 	dws->dma_mapped = 0;
+ 
+ 	last_transfer = list_last_entry(&msg->transfers, struct spi_transfer,
+ 					transfer_list);
+ 
+ 	if (!last_transfer->cs_change)
+ 		spi_chip_sel(dws, msg->spi, 0);
+ 
+ 	spi_finalize_current_message(dws->master);
+ }
+ 
  static void int_error_stop(struct dw_spi *dws, const char *msg)
  {
! 	/* Stop the hw */
! 	spi_enable_chip(dws, 0);
  
  	dev_err(&dws->master->dev, "%s\n", msg);
! 	dws->cur_msg->state = ERROR_STATE;
! 	tasklet_schedule(&dws->pump_transfers);
! }
! 
! void dw_spi_xfer_done(struct dw_spi *dws)
! {
! 	/* Update total byte transferred return count actual bytes read */
! 	dws->cur_msg->actual_length += dws->len;
! 
! 	/* Move to next transfer */
! 	dws->cur_msg->state = next_transfer(dws);
! 
! 	/* Handle end of message */
! 	if (dws->cur_msg->state == DONE_STATE) {
! 		dws->cur_msg->status = 0;
! 		giveback(dws);
! 	} else
! 		tasklet_schedule(&dws->pump_transfers);
  }
+ EXPORT_SYMBOL_GPL(dw_spi_xfer_done);
  
  static irqreturn_t interrupt_transfer(struct dw_spi *dws)
  {
***************
*** 226,232 ****
  
  	/* Error handling */
  	if (irq_status & (SPI_INT_TXOI | SPI_INT_RXOI | SPI_INT_RXUI)) {
! 		dw_readl(dws, DW_SPI_ICR);
  		int_error_stop(dws, "interrupt_transfer: fifo overrun/underrun");
  		return IRQ_HANDLED;
  	}
--- 322,330 ----
  
  	/* Error handling */
  	if (irq_status & (SPI_INT_TXOI | SPI_INT_RXOI | SPI_INT_RXUI)) {
! 		dw_readl(dws, DW_SPI_TXOICR);
! 		dw_readl(dws, DW_SPI_RXOICR);
! 		dw_readl(dws, DW_SPI_RXUICR);
  		int_error_stop(dws, "interrupt_transfer: fifo overrun/underrun");
  		return IRQ_HANDLED;
  	}
***************
*** 234,240 ****
  	dw_reader(dws);
  	if (dws->rx_end == dws->rx) {
  		spi_mask_intr(dws, SPI_INT_TXEI);
! 		spi_finalize_current_transfer(dws->master);
  		return IRQ_HANDLED;
  	}
  	if (irq_status & SPI_INT_TXEI) {
--- 332,338 ----
  	dw_reader(dws);
  	if (dws->rx_end == dws->rx) {
  		spi_mask_intr(dws, SPI_INT_TXEI);
! 		dw_spi_xfer_done(dws);
  		return IRQ_HANDLED;
  	}
  	if (irq_status & SPI_INT_TXEI) {
***************
*** 249,262 ****
  
  static irqreturn_t dw_spi_irq(int irq, void *dev_id)
  {
! 	struct spi_master *master = dev_id;
! 	struct dw_spi *dws = spi_master_get_devdata(master);
  	u16 irq_status = dw_readl(dws, DW_SPI_ISR) & 0x3f;
  
  	if (!irq_status)
  		return IRQ_NONE;
  
! 	if (!master->cur_msg) {
  		spi_mask_intr(dws, SPI_INT_TXEI);
  		return IRQ_HANDLED;
  	}
--- 347,359 ----
  
  static irqreturn_t dw_spi_irq(int irq, void *dev_id)
  {
! 	struct dw_spi *dws = dev_id;
  	u16 irq_status = dw_readl(dws, DW_SPI_ISR) & 0x3f;
  
  	if (!irq_status)
  		return IRQ_NONE;
  
! 	if (!dws->cur_msg) {
  		spi_mask_intr(dws, SPI_INT_TXEI);
  		return IRQ_HANDLED;
  	}
***************
*** 265,271 ****
  }
  
  /* Must be called inside pump_transfers() */
! static int poll_transfer(struct dw_spi *dws)
  {
  	do {
  		dw_writer(dws);
--- 362,368 ----
  }
  
  /* Must be called inside pump_transfers() */
! static void poll_transfer(struct dw_spi *dws)
  {
  	do {
  		dw_writer(dws);
***************
*** 273,332 ****
  		cpu_relax();
  	} while (dws->rx_end > dws->rx);
  
! 	return 0;
  }
  
! static int dw_spi_transfer_one(struct spi_master *master,
! 		struct spi_device *spi, struct spi_transfer *transfer)
  {
! 	struct dw_spi *dws = spi_master_get_devdata(master);
! 	struct chip_data *chip = spi_get_ctldata(spi);
  	u8 imask = 0;
! 	u16 txlevel = 0;
! 	u16 clk_div;
! 	u32 cr0;
! 	int ret;
! 
! 	dws->dma_mapped = 0;
  
  	dws->tx = (void *)transfer->tx_buf;
  	dws->tx_end = dws->tx + transfer->len;
  	dws->rx = transfer->rx_buf;
  	dws->rx_end = dws->rx + transfer->len;
! 	dws->len = transfer->len;
  
! 	spi_enable_chip(dws, 0);
  
  	/* Handle per transfer options for bpw and speed */
! 	if (transfer->speed_hz != chip->speed_hz) {
! 		/* clk_div doesn't support odd number */
! 		clk_div = (dws->max_freq / transfer->speed_hz + 1) & 0xfffe;
! 
! 		chip->speed_hz = transfer->speed_hz;
! 		chip->clk_div = clk_div;
! 
! 		spi_set_clk(dws, chip->clk_div);
! 	}
! 	if (transfer->bits_per_word == 8) {
! 		dws->n_bytes = 1;
! 		dws->dma_width = 1;
! 	} else if (transfer->bits_per_word == 16) {
! 		dws->n_bytes = 2;
! 		dws->dma_width = 2;
! 	} else {
! 		return -EINVAL;
  	}
! 	/* Default SPI mode is SCPOL = 0, SCPH = 0 */
! 	cr0 = (transfer->bits_per_word - 1)
! 		| (chip->type << SPI_FRF_OFFSET)
! 		| (spi->mode << SPI_MODE_OFFSET)
! 		| (chip->tmode << SPI_TMOD_OFFSET);
  
  	/*
  	 * Adjust transfer mode if necessary. Requires platform dependent
  	 * chipselect mechanism.
  	 */
! 	if (chip->cs_control) {
  		if (dws->rx && dws->tx)
  			chip->tmode = SPI_TMOD_TR;
  		else if (dws->rx)
--- 370,466 ----
  		cpu_relax();
  	} while (dws->rx_end > dws->rx);
  
! 	dw_spi_xfer_done(dws);
  }
  
! static void pump_transfers(unsigned long data)
  {
! 	struct dw_spi *dws = (struct dw_spi *)data;
! 	struct spi_message *message = NULL;
! 	struct spi_transfer *transfer = NULL;
! 	struct spi_transfer *previous = NULL;
! 	struct spi_device *spi = NULL;
! 	struct chip_data *chip = NULL;
! 	u8 bits = 0;
  	u8 imask = 0;
! 	u8 cs_change = 0;
! 	u16 txint_level = 0;
! 	u16 clk_div = 0;
! 	u32 speed = 0;
! 	u32 cr0 = 0;
! 
! 	/* Get current state information */
! 	message = dws->cur_msg;
! 	transfer = dws->cur_transfer;
! 	chip = dws->cur_chip;
! 	spi = message->spi;
! 
! 	if (message->state == ERROR_STATE) {
! 		message->status = -EIO;
! 		goto early_exit;
! 	}
! 
! 	/* Handle end of message */
! 	if (message->state == DONE_STATE) {
! 		message->status = 0;
! 		goto early_exit;
! 	}
! 
! 	/* Delay if requested at end of transfer */
! 	if (message->state == RUNNING_STATE) {
! 		previous = list_entry(transfer->transfer_list.prev,
! 					struct spi_transfer,
! 					transfer_list);
! 		if (previous->delay_usecs)
! 			udelay(previous->delay_usecs);
! 	}
! 
! 	dws->n_bytes = chip->n_bytes;
! 	dws->dma_width = chip->dma_width;
! 	dws->cs_control = chip->cs_control;
  
+ 	dws->rx_dma = transfer->rx_dma;
+ 	dws->tx_dma = transfer->tx_dma;
  	dws->tx = (void *)transfer->tx_buf;
  	dws->tx_end = dws->tx + transfer->len;
  	dws->rx = transfer->rx_buf;
  	dws->rx_end = dws->rx + transfer->len;
! 	dws->len = dws->cur_transfer->len;
! 	if (chip != dws->prev_chip)
! 		cs_change = 1;
  
! 	cr0 = chip->cr0;
  
  	/* Handle per transfer options for bpw and speed */
! 	if (transfer->speed_hz) {
! 		speed = chip->speed_hz;
! 
! 		if ((transfer->speed_hz != speed) || (!chip->clk_div)) {
! 			speed = transfer->speed_hz;
! 
! 			/* clk_div doesn't support odd number */
! 			clk_div = dws->max_freq / speed;
! 			clk_div = (clk_div + 1) & 0xfffe;
! 
! 			chip->speed_hz = speed;
! 			chip->clk_div = clk_div;
! 		}
  	}
! 	if (transfer->bits_per_word) {
! 		bits = transfer->bits_per_word;
! 		dws->n_bytes = dws->dma_width = bits >> 3;
! 		cr0 = (bits - 1)
! 			| (chip->type << SPI_FRF_OFFSET)
! 			| (spi->mode << SPI_MODE_OFFSET)
! 			| (chip->tmode << SPI_TMOD_OFFSET);
! 	}
! 	message->state = RUNNING_STATE;
  
  	/*
  	 * Adjust transfer mode if necessary. Requires platform dependent
  	 * chipselect mechanism.
  	 */
! 	if (dws->cs_control) {
  		if (dws->rx && dws->tx)
  			chip->tmode = SPI_TMOD_TR;
  		else if (dws->rx)
***************
*** 338,397 ****
  		cr0 |= (chip->tmode << SPI_TMOD_OFFSET);
  	}
  
- 	dw_writel(dws, DW_SPI_CTRL0, cr0);
- 
  	/* Check if current transfer is a DMA transaction */
! 	if (master->can_dma && master->can_dma(master, spi, transfer))
! 		dws->dma_mapped = master->cur_msg_mapped;
! 
! 	/* For poll mode just disable all interrupts */
! 	spi_mask_intr(dws, 0xff);
  
  	/*
  	 * Interrupt mode
  	 * we only need set the TXEI IRQ, as TX/RX always happen syncronizely
  	 */
! 	if (dws->dma_mapped) {
! 		ret = dws->dma_ops->dma_setup(dws, transfer);
! 		if (ret < 0) {
! 			spi_enable_chip(dws, 1);
! 			return ret;
! 		}
! 	} else if (!chip->poll_mode) {
! 		txlevel = min_t(u16, dws->fifo_len / 2, dws->len / dws->n_bytes);
! 		dw_writel(dws, DW_SPI_TXFLTR, txlevel);
  
- 		/* Set the interrupt mask */
  		imask |= SPI_INT_TXEI | SPI_INT_TXOI |
  			 SPI_INT_RXUI | SPI_INT_RXOI;
- 		spi_umask_intr(dws, imask);
- 
  		dws->transfer_handler = interrupt_transfer;
  	}
  
! 	spi_enable_chip(dws, 1);
  
! 	if (dws->dma_mapped) {
! 		ret = dws->dma_ops->dma_transfer(dws, transfer);
! 		if (ret < 0)
! 			return ret;
  	}
  
  	if (chip->poll_mode)
! 		return poll_transfer(dws);
  
! 	return 1;
  }
  
! static void dw_spi_handle_err(struct spi_master *master,
  		struct spi_message *msg)
  {
  	struct dw_spi *dws = spi_master_get_devdata(master);
  
! 	if (dws->dma_mapped)
! 		dws->dma_ops->dma_stop(dws);
  
! 	spi_reset_chip(dws);
  }
  
  /* This may be called twice for each spi dev */
--- 472,551 ----
  		cr0 |= (chip->tmode << SPI_TMOD_OFFSET);
  	}
  
  	/* Check if current transfer is a DMA transaction */
! 	dws->dma_mapped = map_dma_buffers(dws);
  
  	/*
  	 * Interrupt mode
  	 * we only need set the TXEI IRQ, as TX/RX always happen syncronizely
  	 */
! 	if (!dws->dma_mapped && !chip->poll_mode) {
! 		int templen = dws->len / dws->n_bytes;
! 
! 		txint_level = dws->fifo_len / 2;
! 		txint_level = (templen > txint_level) ? txint_level : templen;
  
  		imask |= SPI_INT_TXEI | SPI_INT_TXOI |
  			 SPI_INT_RXUI | SPI_INT_RXOI;
  		dws->transfer_handler = interrupt_transfer;
  	}
  
! 	/*
! 	 * Reprogram registers only if
! 	 *	1. chip select changes
! 	 *	2. clk_div is changed
! 	 *	3. control value changes
! 	 */
! 	if (dw_readl(dws, DW_SPI_CTRL0) != cr0 || cs_change || clk_div || imask) {
! 		spi_enable_chip(dws, 0);
  
! 		if (dw_readl(dws, DW_SPI_CTRL0) != cr0)
! 			dw_writel(dws, DW_SPI_CTRL0, cr0);
! 
! 		spi_set_clk(dws, clk_div ? clk_div : chip->clk_div);
! 		spi_chip_sel(dws, spi, 1);
! 
! 		/* Set the interrupt mask, for poll mode just disable all int */
! 		spi_mask_intr(dws, 0xff);
! 		if (imask)
! 			spi_umask_intr(dws, imask);
! 		if (txint_level)
! 			dw_writel(dws, DW_SPI_TXFLTR, txint_level);
! 
! 		spi_enable_chip(dws, 1);
! 		if (cs_change)
! 			dws->prev_chip = chip;
  	}
  
+ 	if (dws->dma_mapped)
+ 		dws->dma_ops->dma_transfer(dws, cs_change);
+ 
  	if (chip->poll_mode)
! 		poll_transfer(dws);
  
! 	return;
! 
! early_exit:
! 	giveback(dws);
  }
  
! static int dw_spi_transfer_one_message(struct spi_master *master,
  		struct spi_message *msg)
  {
  	struct dw_spi *dws = spi_master_get_devdata(master);
  
! 	dws->cur_msg = msg;
! 	/* Initial message state */
! 	dws->cur_msg->state = START_STATE;
! 	dws->cur_transfer = list_entry(dws->cur_msg->transfers.next,
! 						struct spi_transfer,
! 						transfer_list);
! 	dws->cur_chip = spi_get_ctldata(dws->cur_msg->spi);
  
! 	/* Launch transfers */
! 	tasklet_schedule(&dws->pump_transfers);
! 
! 	return 0;
  }
  
  /* This may be called twice for each spi dev */
***************
*** 423,431 ****
--- 577,612 ----
  
  		chip->poll_mode = chip_info->poll_mode;
  		chip->type = chip_info->type;
+ 
+ 		chip->rx_threshold = 0;
+ 		chip->tx_threshold = 0;
+ 
+ 		chip->enable_dma = chip_info->enable_dma;
+ 	}
+ 
+ 	if (spi->bits_per_word == 8) {
+ 		chip->n_bytes = 1;
+ 		chip->dma_width = 1;
+ 	} else if (spi->bits_per_word == 16) {
+ 		chip->n_bytes = 2;
+ 		chip->dma_width = 2;
+ 	}
+ 	chip->bits_per_word = spi->bits_per_word;
+ 
+ 	if (!spi->max_speed_hz) {
+ 		dev_err(&spi->dev, "No max speed HZ parameter\n");
+ 		return -EINVAL;
  	}
  
  	chip->tmode = 0; /* Tx & Rx */
+ 	/* Default SPI mode is SCPOL = 0, SCPH = 0 */
+ 	chip->cr0 = (chip->bits_per_word - 1)
+ 			| (chip->type << SPI_FRF_OFFSET)
+ 			| (spi->mode  << SPI_MODE_OFFSET)
+ 			| (chip->tmode << SPI_TMOD_OFFSET);
+ 
+ 	if (spi->mode & SPI_LOOP)
+ 		chip->cr0 |= 1 << SPI_SRL_OFFSET;
  
  	if (gpio_is_valid(spi->cs_gpio)) {
  		ret = gpio_direction_output(spi->cs_gpio,
***************
*** 446,454 ****
  }
  
  /* Restart the controller, disable all interrupts, clean rx fifo */
! static void spi_hw_init(struct device *dev, struct dw_spi *dws)
  {
! 	spi_reset_chip(dws);
  
  	/*
  	 * Try to detect the FIFO depth if not set by interface driver,
--- 627,636 ----
  }
  
  /* Restart the controller, disable all interrupts, clean rx fifo */
! static void spi_hw_init(struct dw_spi *dws)
  {
! 	spi_enable_chip(dws, 0);
! 	spi_mask_intr(dws, 0xff);
  
  	/*
  	 * Try to detect the FIFO depth if not set by interface driver,
***************
*** 457,472 ****
  	if (!dws->fifo_len) {
  		u32 fifo;
  
! 		for (fifo = 1; fifo < 256; fifo++) {
  			dw_writel(dws, DW_SPI_TXFLTR, fifo);
  			if (fifo != dw_readl(dws, DW_SPI_TXFLTR))
  				break;
  		}
- 		dw_writel(dws, DW_SPI_TXFLTR, 0);
  
! 		dws->fifo_len = (fifo == 1) ? 0 : fifo;
! 		dev_dbg(dev, "Detected FIFO size: %u bytes\n", dws->fifo_len);
  	}
  }
  
  int dw_spi_add_host(struct device *dev, struct dw_spi *dws)
--- 639,654 ----
  	if (!dws->fifo_len) {
  		u32 fifo;
  
! 		for (fifo = 2; fifo <= 256; fifo++) {
  			dw_writel(dws, DW_SPI_TXFLTR, fifo);
  			if (fifo != dw_readl(dws, DW_SPI_TXFLTR))
  				break;
  		}
  
! 		dws->fifo_len = (fifo == 2) ? 0 : fifo - 1;
! 		dw_writel(dws, DW_SPI_TXFLTR, 0);
  	}
+ 	spi_enable_chip(dws, 1);
  }
  
  int dw_spi_add_host(struct device *dev, struct dw_spi *dws)
***************
*** 482,492 ****
  
  	dws->master = master;
  	dws->type = SSI_MOTO_SPI;
  	dws->dma_inited = 0;
! 	dws->dma_addr = (dma_addr_t)(dws->paddr + DW_SPI_DR);
  	snprintf(dws->name, sizeof(dws->name), "dw_spi%d", dws->bus_num);
  
! 	ret = request_irq(dws->irq, dw_spi_irq, IRQF_SHARED, dws->name, master);
  	if (ret < 0) {
  		dev_err(dev, "can not get IRQ\n");
  		goto err_free_master;
--- 664,675 ----
  
  	dws->master = master;
  	dws->type = SSI_MOTO_SPI;
+ 	dws->prev_chip = NULL;
  	dws->dma_inited = 0;
! 	dws->dma_addr = (dma_addr_t)(dws->paddr + 0x60);
  	snprintf(dws->name, sizeof(dws->name), "dw_spi%d", dws->bus_num);
  
! 	ret = request_irq(dws->irq, dw_spi_irq, IRQF_SHARED, dws->name, dws);
  	if (ret < 0) {
  		dev_err(dev, "can not get IRQ\n");
  		goto err_free_master;
***************
*** 499,522 ****
  	master->setup = dw_spi_setup;
  	master->cleanup = dw_spi_cleanup;
  	master->set_cs = dw_spi_set_cs;
! 	master->transfer_one = dw_spi_transfer_one;
! 	master->handle_err = dw_spi_handle_err;
  	master->max_speed_hz = dws->max_freq;
  	master->dev.of_node = dev->of_node;
  
  	/* Basic HW init */
! 	spi_hw_init(dev, dws);
  
  	if (dws->dma_ops && dws->dma_ops->dma_init) {
  		ret = dws->dma_ops->dma_init(dws);
  		if (ret) {
  			dev_warn(dev, "DMA init failed\n");
  			dws->dma_inited = 0;
- 		} else {
- 			master->can_dma = dws->dma_ops->can_dma;
  		}
  	}
  
  	spi_master_set_devdata(master, dws);
  	ret = devm_spi_register_master(dev, master);
  	if (ret) {
--- 682,704 ----
  	master->setup = dw_spi_setup;
  	master->cleanup = dw_spi_cleanup;
  	master->set_cs = dw_spi_set_cs;
! 	master->transfer_one_message = dw_spi_transfer_one_message;
  	master->max_speed_hz = dws->max_freq;
  	master->dev.of_node = dev->of_node;
  
  	/* Basic HW init */
! 	spi_hw_init(dws);
  
  	if (dws->dma_ops && dws->dma_ops->dma_init) {
  		ret = dws->dma_ops->dma_init(dws);
  		if (ret) {
  			dev_warn(dev, "DMA init failed\n");
  			dws->dma_inited = 0;
  		}
  	}
  
+ 	tasklet_init(&dws->pump_transfers, pump_transfers, (unsigned long)dws);
+ 
  	spi_master_set_devdata(master, dws);
  	ret = devm_spi_register_master(dev, master);
  	if (ret) {
***************
*** 531,537 ****
  	if (dws->dma_ops && dws->dma_ops->dma_exit)
  		dws->dma_ops->dma_exit(dws);
  	spi_enable_chip(dws, 0);
- 	free_irq(dws->irq, master);
  err_free_master:
  	spi_master_put(master);
  	return ret;
--- 713,718 ----
***************
*** 540,566 ****
  
  void dw_spi_remove_host(struct dw_spi *dws)
  {
  	dw_spi_debugfs_remove(dws);
  
  	if (dws->dma_ops && dws->dma_ops->dma_exit)
  		dws->dma_ops->dma_exit(dws);
! 
! 	spi_shutdown_chip(dws);
! 
! 	free_irq(dws->irq, dws->master);
  }
  EXPORT_SYMBOL_GPL(dw_spi_remove_host);
  
  int dw_spi_suspend_host(struct dw_spi *dws)
  {
! 	int ret;
  
  	ret = spi_master_suspend(dws->master);
  	if (ret)
  		return ret;
! 
! 	spi_shutdown_chip(dws);
! 	return 0;
  }
  EXPORT_SYMBOL_GPL(dw_spi_suspend_host);
  
--- 721,748 ----
  
  void dw_spi_remove_host(struct dw_spi *dws)
  {
+ 	if (!dws)
+ 		return;
  	dw_spi_debugfs_remove(dws);
  
  	if (dws->dma_ops && dws->dma_ops->dma_exit)
  		dws->dma_ops->dma_exit(dws);
! 	spi_enable_chip(dws, 0);
! 	/* Disable clk */
! 	spi_set_clk(dws, 0);
  }
  EXPORT_SYMBOL_GPL(dw_spi_remove_host);
  
  int dw_spi_suspend_host(struct dw_spi *dws)
  {
! 	int ret = 0;
  
  	ret = spi_master_suspend(dws->master);
  	if (ret)
  		return ret;
! 	spi_enable_chip(dws, 0);
! 	spi_set_clk(dws, 0);
! 	return ret;
  }
  EXPORT_SYMBOL_GPL(dw_spi_suspend_host);
  
***************
*** 568,574 ****
  {
  	int ret;
  
! 	spi_hw_init(&dws->master->dev, dws);
  	ret = spi_master_resume(dws->master);
  	if (ret)
  		dev_err(&dws->master->dev, "fail to start queue (%d)\n", ret);
--- 750,756 ----
  {
  	int ret;
  
! 	spi_hw_init(dws);
  	ret = spi_master_resume(dws->master);
  	if (ret)
  		dev_err(&dws->master->dev, "fail to start queue (%d)\n", ret);
***************
*** 576,581 ****
--- 758,764 ----
  }
  EXPORT_SYMBOL_GPL(dw_spi_resume_host);
  
+ MODULE_ALIAS("platform:dw_spi");
  MODULE_AUTHOR("Feng Tang <feng.tang@intel.com>");
  MODULE_DESCRIPTION("Driver for DesignWare SPI controller core");
  MODULE_LICENSE("GPL v2");
diff -rcNP linux-4.4.24/drivers/spi/spi-dw.h linux-4.4.24-baikal/drivers/spi/spi-dw.h
*** linux-4.4.24/drivers/spi/spi-dw.h	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/spi/spi-dw.h	2016-11-11 14:48:07.000000000 +0300
***************
*** 91,105 ****
  struct dw_spi_dma_ops {
  	int (*dma_init)(struct dw_spi *dws);
  	void (*dma_exit)(struct dw_spi *dws);
! 	int (*dma_setup)(struct dw_spi *dws, struct spi_transfer *xfer);
! 	bool (*can_dma)(struct spi_master *master, struct spi_device *spi,
! 			struct spi_transfer *xfer);
! 	int (*dma_transfer)(struct dw_spi *dws, struct spi_transfer *xfer);
! 	void (*dma_stop)(struct dw_spi *dws);
  };
  
  struct dw_spi {
  	struct spi_master	*master;
  	enum dw_ssi_type	type;
  	char			name[16];
  
--- 91,102 ----
  struct dw_spi_dma_ops {
  	int (*dma_init)(struct dw_spi *dws);
  	void (*dma_exit)(struct dw_spi *dws);
! 	int (*dma_transfer)(struct dw_spi *dws, int cs_change);
  };
  
  struct dw_spi {
  	struct spi_master	*master;
+ 	struct spi_device	*cur_dev;
  	enum dw_ssi_type	type;
  	char			name[16];
  
***************
*** 109,138 ****
  	u32			fifo_len;	/* depth of the FIFO buffer */
  	u32			max_freq;	/* max bus freq supported */
  
- 	u32			reg_io_width;	/* DR I/O width in bytes */
  	u16			bus_num;
  	u16			num_cs;		/* supported slave numbers */
  
  	/* Current message transfer state info */
  	size_t			len;
  	void			*tx;
  	void			*tx_end;
  	void			*rx;
  	void			*rx_end;
  	int			dma_mapped;
  	u8			n_bytes;	/* current is a 1/2 bytes op */
  	u32			dma_width;
  	irqreturn_t		(*transfer_handler)(struct dw_spi *dws);
  
! 	/* DMA info */
  	int			dma_inited;
  	struct dma_chan		*txchan;
  	struct dma_chan		*rxchan;
  	unsigned long		dma_chan_busy;
  	dma_addr_t		dma_addr; /* phy address of the Data register */
  	struct dw_spi_dma_ops	*dma_ops;
! 	void			*dma_tx;
! 	void			*dma_rx;
  
  	/* Bus interface info */
  	void			*priv;
--- 106,149 ----
  	u32			fifo_len;	/* depth of the FIFO buffer */
  	u32			max_freq;	/* max bus freq supported */
  
  	u16			bus_num;
  	u16			num_cs;		/* supported slave numbers */
  
+ 	/* Message Transfer pump */
+ 	struct tasklet_struct	pump_transfers;
+ 
  	/* Current message transfer state info */
+ 	struct spi_message	*cur_msg;
+ 	struct spi_transfer	*cur_transfer;
+ 	struct chip_data	*cur_chip;
+ 	struct chip_data	*prev_chip;
  	size_t			len;
  	void			*tx;
  	void			*tx_end;
  	void			*rx;
  	void			*rx_end;
  	int			dma_mapped;
+ 	dma_addr_t		rx_dma;
+ 	dma_addr_t		tx_dma;
+ 	size_t			rx_map_len;
+ 	size_t			tx_map_len;
  	u8			n_bytes;	/* current is a 1/2 bytes op */
+ 	u8			max_bits_per_word;	/* maxim is 16b */
  	u32			dma_width;
  	irqreturn_t		(*transfer_handler)(struct dw_spi *dws);
+ 	void			(*cs_control)(u32 command);
  
! 	/* Dma info */
  	int			dma_inited;
  	struct dma_chan		*txchan;
+ 	struct scatterlist	tx_sgl;
  	struct dma_chan		*rxchan;
+ 	struct scatterlist	rx_sgl;
  	unsigned long		dma_chan_busy;
+ 	struct device		*dma_dev;
  	dma_addr_t		dma_addr; /* phy address of the Data register */
  	struct dw_spi_dma_ops	*dma_ops;
! 	void			*dma_priv; /* platform relate info */
  
  	/* Bus interface info */
  	void			*priv;
***************
*** 146,188 ****
  	return __raw_readl(dws->regs + offset);
  }
  
- static inline u16 dw_readw(struct dw_spi *dws, u32 offset)
- {
- 	return __raw_readw(dws->regs + offset);
- }
- 
  static inline void dw_writel(struct dw_spi *dws, u32 offset, u32 val)
  {
  	__raw_writel(val, dws->regs + offset);
  }
  
! static inline void dw_writew(struct dw_spi *dws, u32 offset, u16 val)
  {
! 	__raw_writew(val, dws->regs + offset);
  }
  
! static inline u32 dw_read_io_reg(struct dw_spi *dws, u32 offset)
  {
! 	switch (dws->reg_io_width) {
! 	case 2:
! 		return dw_readw(dws, offset);
! 	case 4:
! 	default:
! 		return dw_readl(dws, offset);
! 	}
! }
! 
! static inline void dw_write_io_reg(struct dw_spi *dws, u32 offset, u32 val)
! {
! 	switch (dws->reg_io_width) {
! 	case 2:
! 		dw_writew(dws, offset, val);
! 		break;
! 	case 4:
! 	default:
! 		dw_writel(dws, offset, val);
! 		break;
! 	}
  }
  
  static inline void spi_enable_chip(struct dw_spi *dws, int enable)
--- 157,175 ----
  	return __raw_readl(dws->regs + offset);
  }
  
  static inline void dw_writel(struct dw_spi *dws, u32 offset, u32 val)
  {
  	__raw_writel(val, dws->regs + offset);
  }
  
! static inline u16 dw_readw(struct dw_spi *dws, u32 offset)
  {
! 	return __raw_readw(dws->regs + offset);
  }
  
! static inline void dw_writew(struct dw_spi *dws, u32 offset, u16 val)
  {
! 	__raw_writew(val, dws->regs + offset);
  }
  
  static inline void spi_enable_chip(struct dw_spi *dws, int enable)
***************
*** 195,200 ****
--- 182,203 ----
  	dw_writel(dws, DW_SPI_BAUDR, div);
  }
  
+ static inline void spi_chip_sel(struct dw_spi *dws, struct spi_device *spi,
+ 		int active)
+ {
+ 	u16 cs = spi->chip_select;
+ 	int gpio_val = active ? (spi->mode & SPI_CS_HIGH) :
+ 		!(spi->mode & SPI_CS_HIGH);
+ 
+ 	if (dws->cs_control)
+ 		dws->cs_control(active);
+ 	if (gpio_is_valid(spi->cs_gpio))
+ 		gpio_set_value(spi->cs_gpio, gpio_val);
+ 
+ 	if (active)
+ 		dw_writel(dws, DW_SPI_SER, 1 << cs);
+ }
+ 
  /* Disable IRQ bits */
  static inline void spi_mask_intr(struct dw_spi *dws, u32 mask)
  {
***************
*** 214,245 ****
  }
  
  /*
-  * This does disable the SPI controller, interrupts, and re-enable the
-  * controller back. Transmit and receive FIFO buffers are cleared when the
-  * device is disabled.
-  */
- static inline void spi_reset_chip(struct dw_spi *dws)
- {
- 	spi_enable_chip(dws, 0);
- 	spi_mask_intr(dws, 0xff);
- 	spi_enable_chip(dws, 1);
- }
- 
- static inline void spi_shutdown_chip(struct dw_spi *dws)
- {
- 	spi_enable_chip(dws, 0);
- 	spi_set_clk(dws, 0);
- }
- 
- /*
   * Each SPI slave device to work with dw_api controller should
!  * has such a structure claiming its working mode (poll or PIO/DMA),
   * which can be save in the "controller_data" member of the
   * struct spi_device.
   */
  struct dw_spi_chip {
  	u8 poll_mode;	/* 1 for controller polling mode */
  	u8 type;	/* SPI/SSP/MicroWire */
  	void (*cs_control)(u32 command);
  };
  
--- 217,231 ----
  }
  
  /*
   * Each SPI slave device to work with dw_api controller should
!  * has such a structure claiming its working mode (PIO/DMA etc),
   * which can be save in the "controller_data" member of the
   * struct spi_device.
   */
  struct dw_spi_chip {
  	u8 poll_mode;	/* 1 for controller polling mode */
  	u8 type;	/* SPI/SSP/MicroWire */
+ 	u8 enable_dma;
  	void (*cs_control)(u32 command);
  };
  
***************
*** 247,252 ****
--- 233,239 ----
  extern void dw_spi_remove_host(struct dw_spi *dws);
  extern int dw_spi_suspend_host(struct dw_spi *dws);
  extern int dw_spi_resume_host(struct dw_spi *dws);
+ extern void dw_spi_xfer_done(struct dw_spi *dws);
  
  /* platform related setup */
  extern int dw_spi_mid_init(struct dw_spi *dws); /* Intel MID platforms */
diff -rcNP linux-4.4.24/drivers/spi/spi-dw-mmio.c linux-4.4.24-baikal/drivers/spi/spi-dw-mmio.c
*** linux-4.4.24/drivers/spi/spi-dw-mmio.c	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/spi/spi-dw-mmio.c	2016-11-11 14:49:54.000000000 +0300
***************
*** 19,25 ****
  #include <linux/of.h>
  #include <linux/of_gpio.h>
  #include <linux/of_platform.h>
- #include <linux/property.h>
  
  #include "spi-dw.h"
  
--- 19,24 ----
***************
*** 71,85 ****
  	if (ret)
  		return ret;
  
! 	dws->bus_num = pdev->id;
! 
  	dws->max_freq = clk_get_rate(dwsmmio->clk);
  
- 	device_property_read_u32(&pdev->dev, "reg-io-width", &dws->reg_io_width);
- 
  	num_cs = 4;
  
! 	device_property_read_u32(&pdev->dev, "num-cs", &num_cs);
  
  	dws->num_cs = num_cs;
  
--- 70,94 ----
  	if (ret)
  		return ret;
  
! 	/* Dump DW component type */
! 	ret = readl(dws->regs + DW_SPI_IDR);
! 	dev_info(&pdev->dev, "Component ID: 0x%08X\n", ret);
! 
! 	/* Dump DW component version */
! 	ret = readl(dws->regs + DW_SPI_VERSION);
! 	dev_info(&pdev->dev, "Component Version: %c.%c%c\n",
! 		(ret >> 24) & 0xff, (ret >> 16) & 0xff, (ret >> 8) & 0xff);
! 
! 	dws->bus_num =  of_alias_get_id(pdev->dev.of_node, "ssi");
! 	if (dws->bus_num < 0)
! 		dws->bus_num = 0;
!  
  	dws->max_freq = clk_get_rate(dwsmmio->clk);
  
  	num_cs = 4;
  
! 	if (pdev->dev.of_node)
! 		of_property_read_u32(pdev->dev.of_node, "num-cs", &num_cs);
  
  	dws->num_cs = num_cs;
  
***************
*** 92,105 ****
  
  			if (cs_gpio == -EPROBE_DEFER) {
  				ret = cs_gpio;
! 				goto out;
  			}
  
  			if (gpio_is_valid(cs_gpio)) {
  				ret = devm_gpio_request(&pdev->dev, cs_gpio,
  						dev_name(&pdev->dev));
  				if (ret)
! 					goto out;
  			}
  		}
  	}
--- 101,117 ----
  
  			if (cs_gpio == -EPROBE_DEFER) {
  				ret = cs_gpio;
! 				continue;
! //				goto out;
  			}
  
  			if (gpio_is_valid(cs_gpio)) {
  				ret = devm_gpio_request(&pdev->dev, cs_gpio,
  						dev_name(&pdev->dev));
  				if (ret)
! 					continue;
! //
! //					goto out;
  			}
  		}
  	}
***************
*** 122,127 ****
--- 134,143 ----
  
  	clk_disable_unprepare(dwsmmio->clk);
  	dw_spi_remove_host(&dwsmmio->dws);
+ 	/* Clean IO remap region */
+ 	iounmap(dwsmmio->dws.regs);
+ 	/* Free memory */
+ 	kfree(dwsmmio);
  
  	return 0;
  }
***************
*** 144,147 ****
--- 160,164 ----
  
  MODULE_AUTHOR("Jean-Hugues Deschenes <jean-hugues.deschenes@octasic.com>");
  MODULE_DESCRIPTION("Memory-mapped I/O interface driver for DW SPI Core");
+ MODULE_ALIAS("platform:dw_spi_dt");
  MODULE_LICENSE("GPL v2");
diff -rcNP linux-4.4.24/drivers/staging/sm750fb/accel.c linux-4.4.24-baikal/drivers/staging/sm750fb/accel.c
*** linux-4.4.24/drivers/staging/sm750fb/accel.c	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/drivers/staging/sm750fb/accel.c	2016-11-11 14:49:54.000000000 +0300
***************
*** 0 ****
--- 1,310 ----
+ #include <linux/module.h>
+ #include <linux/kernel.h>
+ #include <linux/errno.h>
+ #include <linux/string.h>
+ #include <linux/mm.h>
+ #include <linux/slab.h>
+ #include <linux/delay.h>
+ #include <linux/fb.h>
+ #include <linux/ioport.h>
+ #include <linux/init.h>
+ #include <linux/pci.h>
+ #include <linux/vmalloc.h>
+ #include <linux/pagemap.h>
+ #include <linux/console.h>
+ #include <linux/platform_device.h>
+ #include <linux/screen_info.h>
+ 
+ #include "drv.h"
+ #include "accel.h"
+ static inline void write_dpr(struct lynx_accel *accel, int offset, u32 regValue)
+ {
+ 	writel(regValue, accel->dprBase + offset);
+ }
+ 
+ static inline u32 read_dpr(struct lynx_accel *accel, int offset)
+ {
+ 	return readl(accel->dprBase + offset);
+ }
+ 
+ static inline void write_dpPort(struct lynx_accel *accel, u32 data)
+ {
+ 	writel(data, accel->dpPortBase);
+ }
+ 
+ void hw_de_init(struct lynx_accel *accel)
+ {
+ 	/* setup 2d engine registers */
+ 	u32 reg, clr;
+ 
+ 	write_dpr(accel, DE_MASKS, 0xFFFFFFFF);
+ 
+ 	/* dpr1c */
+ 	reg =  0x3;
+ 
+ 	clr = DE_STRETCH_FORMAT_PATTERN_XY|DE_STRETCH_FORMAT_PATTERN_Y_MASK|DE_STRETCH_FORMAT_PATTERN_X_MASK|DE_STRETCH_FORMAT_ADDRESSING_MASK|DE_STRETCH_FORMAT_SOURCE_HEIGHT_MASK;
+ 
+ 	/* DE_STRETCH bpp format need be initialized in setMode routine */
+ 	write_dpr(accel, DE_STRETCH_FORMAT, (read_dpr(accel, DE_STRETCH_FORMAT)&~clr)|reg);
+ 
+ 	/* disable clipping and transparent */
+ 	write_dpr(accel, DE_CLIP_TL, 0); /* dpr2c */
+ 	write_dpr(accel, DE_CLIP_BR, 0); /* dpr30 */
+ 
+ 	write_dpr(accel, DE_COLOR_COMPARE_MASK, 0); /* dpr24 */
+ 	write_dpr(accel, DE_COLOR_COMPARE, 0);
+ 
+ 	clr = DE_CONTROL_TRANSPARENCY|DE_CONTROL_TRANSPARENCY_MATCH|DE_CONTROL_TRANSPARENCY_SELECT;
+ 
+ 	/* dpr0c */
+ 	write_dpr(accel, DE_CONTROL, read_dpr(accel, DE_CONTROL)&~clr);
+ }
+ 
+ /* set2dformat only be called from setmode functions
+  * but if you need dual framebuffer driver,need call set2dformat
+  * every time you use 2d function */
+ 
+ void hw_set2dformat(struct lynx_accel *accel, int fmt)
+ {
+ 	u32 reg;
+ 
+ 	/* fmt=0,1,2 for 8,16,32,bpp on sm718/750/502 */
+ 	reg = read_dpr(accel, DE_STRETCH_FORMAT);
+ 	reg &= ~DE_STRETCH_FORMAT_PIXEL_FORMAT_MASK;
+ 	reg |= ((fmt<<DE_STRETCH_FORMAT_PIXEL_FORMAT_SHIFT)&DE_STRETCH_FORMAT_PIXEL_FORMAT_MASK);
+ 	write_dpr(accel, DE_STRETCH_FORMAT, reg);
+ }
+ 
+ int hw_fillrect(struct lynx_accel *accel, u32 base, u32 pitch, u32 Bpp, u32 x, u32 y, u32 width, u32 height, u32 color, u32 rop)
+ {
+     u32 deCtrl;
+ 
+     if (accel->de_wait() != 0) {	/* int time wait and always busy,seems hardware got something error De engine always busy */
+ 	return -1;
+     }
+     write_dpr(accel, DE_WINDOW_DESTINATION_BASE, base); /* dpr40 */
+     write_dpr(accel, DE_PITCH, ((pitch/Bpp<<DE_PITCH_DESTINATION_SHIFT)&DE_PITCH_DESTINATION_MASK)|(pitch/Bpp&DE_PITCH_SOURCE_MASK)); /* dpr10 */
+     write_dpr(accel, DE_WINDOW_WIDTH, ((pitch/Bpp<<DE_WINDOW_WIDTH_DST_SHIFT)&DE_WINDOW_WIDTH_DST_MASK)|(pitch/Bpp&DE_WINDOW_WIDTH_SRC_MASK)); /* dpr44 */
+     write_dpr(accel, DE_FOREGROUND, color); /* DPR14 */
+     write_dpr(accel, DE_DESTINATION, ((x<<DE_DESTINATION_X_SHIFT)&DE_DESTINATION_X_MASK)|(y&DE_DESTINATION_Y_MASK)); /* dpr4 */
+     write_dpr(accel, DE_DIMENSION, ((width<<DE_DIMENSION_X_SHIFT)&DE_DIMENSION_X_MASK)|(height&DE_DIMENSION_Y_ET_MASK)); /* dpr8 */
+     deCtrl = DE_CONTROL_STATUS|DE_CONTROL_LAST_PIXEL|DE_CONTROL_COMMAND_RECTANGLE_FILL|DE_CONTROL_ROP_SELECT|(rop&DE_CONTROL_ROP_MASK); /* dpr0xc */
+     write_dpr(accel, DE_CONTROL, deCtrl);
+     return 0;
+ }
+ 
+ int hw_copyarea(
+ struct lynx_accel *accel,
+ unsigned int sBase,  /* Address of source: offset in frame buffer */
+ unsigned int sPitch, /* Pitch value of source surface in BYTE */
+ unsigned int sx,
+ unsigned int sy,     /* Starting coordinate of source surface */
+ unsigned int dBase,  /* Address of destination: offset in frame buffer */
+ unsigned int dPitch, /* Pitch value of destination surface in BYTE */
+ unsigned int Bpp,    /* Color depth of destination surface */
+ unsigned int dx,
+ unsigned int dy,     /* Starting coordinate of destination surface */
+ unsigned int width,
+ unsigned int height, /* width and height of rectangle in pixel value */
+ unsigned int rop2)   /* ROP value */
+ {
+ 	unsigned int nDirection, de_ctrl;
+ 	int opSign;
+ 
+ 	nDirection = LEFT_TO_RIGHT;
+ 	/* Direction of ROP2 operation: 1 = Left to Right, (-1) = Right to Left */
+ 	opSign = 1;
+ 	de_ctrl = 0;
+ 
+ 	/* If source and destination are the same surface, need to check for overlay cases */
+ 	if (sBase == dBase && sPitch == dPitch) {
+ 		/* Determine direction of operation */
+ 		if (sy < dy) {
+ 			/* +----------+
+ 			   |S         |
+ 			   |   +----------+
+ 			   |   |      |   |
+ 			   |   |      |   |
+ 			   +---|------+   |
+ 			   |         D|
+ 			   +----------+ */
+ 
+ 			nDirection = BOTTOM_TO_TOP;
+ 		} else if (sy > dy) {
+ 			/* +----------+
+ 			   |D         |
+ 			   |   +----------+
+ 			   |   |      |   |
+ 			   |   |      |   |
+ 			   +---|------+   |
+ 			   |         S|
+ 			   +----------+ */
+ 
+ 			nDirection = TOP_TO_BOTTOM;
+ 		} else {
+ 			/* sy == dy */
+ 
+ 			if (sx <= dx) {
+ 				/* +------+---+------+
+ 				   |S     |   |     D|
+ 				   |      |   |      |
+ 				   |      |   |      |
+ 				   |      |   |      |
+ 				   +------+---+------+ */
+ 
+ 				nDirection = RIGHT_TO_LEFT;
+ 			} else {
+ 			/* sx > dx */
+ 
+ 				/* +------+---+------+
+ 				   |D     |   |     S|
+ 				   |      |   |      |
+ 				   |      |   |      |
+ 				   |      |   |      |
+ 				   +------+---+------+ */
+ 
+ 				nDirection = LEFT_TO_RIGHT;
+ 			}
+ 		}
+ 	}
+ 
+ 	if ((nDirection == BOTTOM_TO_TOP) || (nDirection == RIGHT_TO_LEFT)) {
+ 		sx += width - 1;
+ 		sy += height - 1;
+ 		dx += width - 1;
+ 		dy += height - 1;
+ 		opSign = (-1);
+ 	}
+ 
+ 	/* Note:
+ 	   DE_FOREGROUND are DE_BACKGROUND are don't care.
+ 	  DE_COLOR_COMPARE and DE_COLOR_COMPARE_MAKS are set by set deSetTransparency().
+ 	 */
+ 
+ 	/* 2D Source Base.
+ 	 It is an address offset (128 bit aligned) from the beginning of frame buffer.
+ 	 */
+ 	write_dpr(accel, DE_WINDOW_SOURCE_BASE, sBase); /* dpr40 */
+ 
+ 	/* 2D Destination Base.
+ 	 It is an address offset (128 bit aligned) from the beginning of frame buffer.
+ 	 */
+ 	write_dpr(accel, DE_WINDOW_DESTINATION_BASE, dBase); /* dpr44 */
+ 
+     /* Program pitch (distance between the 1st points of two adjacent lines).
+        Note that input pitch is BYTE value, but the 2D Pitch register uses
+        pixel values. Need Byte to pixel conversion.
+     */
+ 	write_dpr(accel, DE_PITCH, ((dPitch/Bpp<<DE_PITCH_DESTINATION_SHIFT)&DE_PITCH_DESTINATION_MASK)|(sPitch/Bpp&DE_PITCH_SOURCE_MASK)); /* dpr10 */
+ 
+     /* Screen Window width in Pixels.
+        2D engine uses this value to calculate the linear address in frame buffer for a given point.
+     */
+ 	write_dpr(accel, DE_WINDOW_WIDTH, ((dPitch/Bpp<<DE_WINDOW_WIDTH_DST_SHIFT)&DE_WINDOW_WIDTH_DST_MASK)|(sPitch/Bpp&DE_WINDOW_WIDTH_SRC_MASK)); /* dpr3c */
+ 
+ 	if (accel->de_wait() != 0)
+ 		return -1;
+ 
+ 	{
+ 
+ 	write_dpr(accel, DE_SOURCE, ((sx<<DE_SOURCE_X_K1_SHIFT)&DE_SOURCE_X_K1_MASK)|(sy&DE_SOURCE_Y_K2_MASK)); /* dpr0 */
+ 	write_dpr(accel, DE_DESTINATION, ((dx<<DE_DESTINATION_X_SHIFT)&DE_DESTINATION_X_MASK)|(dy&DE_DESTINATION_Y_MASK)); /* dpr04 */
+ 	write_dpr(accel, DE_DIMENSION, ((width<<DE_DIMENSION_X_SHIFT)&DE_DIMENSION_X_MASK)|(height&DE_DIMENSION_Y_ET_MASK)); /* dpr08 */
+ 
+ 	de_ctrl = (rop2&DE_CONTROL_ROP_MASK)|DE_CONTROL_ROP_SELECT|((nDirection == RIGHT_TO_LEFT)?DE_CONTROL_DIRECTION:0)|DE_CONTROL_COMMAND_BITBLT|DE_CONTROL_STATUS;
+ 	write_dpr(accel, DE_CONTROL, de_ctrl); /* dpr0c */
+ 
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static unsigned int deGetTransparency(struct lynx_accel *accel)
+ {
+ 	unsigned int de_ctrl;
+ 
+ 	de_ctrl = read_dpr(accel, DE_CONTROL);
+ 
+ 	de_ctrl &= (DE_CONTROL_TRANSPARENCY_MATCH|DE_CONTROL_TRANSPARENCY_SELECT|DE_CONTROL_TRANSPARENCY);
+ 
+ 	return de_ctrl;
+ }
+ 
+ int hw_imageblit(struct lynx_accel *accel,
+ 		 const char *pSrcbuf, /* pointer to start of source buffer in system memory */
+ 		 u32 srcDelta,          /* Pitch value (in bytes) of the source buffer, +ive means top down and -ive mean button up */
+ 		 u32 startBit, /* Mono data can start at any bit in a byte, this value should be 0 to 7 */
+ 		 u32 dBase,    /* Address of destination: offset in frame buffer */
+ 		 u32 dPitch,   /* Pitch value of destination surface in BYTE */
+ 		 u32 bytePerPixel,      /* Color depth of destination surface */
+ 		 u32 dx,
+ 		 u32 dy,       /* Starting coordinate of destination surface */
+ 		 u32 width,
+ 		 u32 height,   /* width and height of rectangle in pixel value */
+ 		 u32 fColor,   /* Foreground color (corresponding to a 1 in the monochrome data */
+ 		 u32 bColor,   /* Background color (corresponding to a 0 in the monochrome data */
+ 		 u32 rop2)     /* ROP value */
+ {
+ 	unsigned int ulBytesPerScan;
+ 	unsigned int ul4BytesPerScan;
+ 	unsigned int ulBytesRemain;
+ 	unsigned int de_ctrl = 0;
+ 	unsigned char ajRemain[4];
+ 	int i, j;
+ 
+ 	startBit &= 7; /* Just make sure the start bit is within legal range */
+ 	ulBytesPerScan = (width + startBit + 7)/8;
+ 	ul4BytesPerScan = ulBytesPerScan&~3;
+ 	ulBytesRemain = ulBytesPerScan&3;
+ 
+ 	if (accel->de_wait() != 0)
+ 		return -1;
+ 
+ 	/* 2D Source Base.
+ 	 Use 0 for HOST Blt.
+ 	 */
+ 	write_dpr(accel, DE_WINDOW_SOURCE_BASE, 0);
+ 
+ 	/* 2D Destination Base.
+ 	 It is an address offset (128 bit aligned) from the beginning of frame buffer.
+ 	 */
+ 	write_dpr(accel, DE_WINDOW_DESTINATION_BASE, dBase);
+     /* Program pitch (distance between the 1st points of two adjacent lines).
+        Note that input pitch is BYTE value, but the 2D Pitch register uses
+        pixel values. Need Byte to pixel conversion.
+     */
+ 	write_dpr(accel, DE_PITCH, ((dPitch/bytePerPixel<<DE_PITCH_DESTINATION_SHIFT)&DE_PITCH_DESTINATION_MASK)|(dPitch/bytePerPixel&DE_PITCH_SOURCE_MASK)); /* dpr10 */
+ 	/* Screen Window width in Pixels.
+ 	 2D engine uses this value to calculate the linear address in frame buffer for a given point.
+ 	 */
+ 	write_dpr(accel, DE_WINDOW_WIDTH, ((dPitch/bytePerPixel<<DE_WINDOW_WIDTH_DST_SHIFT)&DE_WINDOW_WIDTH_DST_MASK)|(dPitch/bytePerPixel&DE_WINDOW_WIDTH_SRC_MASK));
+ 	 /* Note: For 2D Source in Host Write, only X_K1_MONO field is needed, and Y_K2 field is not used.
+ 	    For mono bitmap, use startBit for X_K1. */
+ 	write_dpr(accel, DE_SOURCE, (startBit<<DE_SOURCE_X_K1_SHIFT)&DE_SOURCE_X_K1_MONO_MASK); /* dpr00 */
+ 	write_dpr(accel, DE_DESTINATION, ((dx<<DE_DESTINATION_X_SHIFT)&DE_DESTINATION_X_MASK)|(dy&DE_DESTINATION_Y_MASK)); /* dpr04 */
+ 	write_dpr(accel, DE_DIMENSION, ((width<<DE_DIMENSION_X_SHIFT)&DE_DIMENSION_X_MASK)|(height&DE_DIMENSION_Y_ET_MASK)); /* dpr08 */
+ 
+ 	write_dpr(accel, DE_FOREGROUND, fColor);
+ 	write_dpr(accel, DE_BACKGROUND, bColor);
+ 
+ 	de_ctrl = (rop2&DE_CONTROL_ROP_MASK)|DE_CONTROL_ROP_SELECT|DE_CONTROL_COMMAND_HOST_WRITE|DE_CONTROL_HOST|DE_CONTROL_STATUS;
+ 
+ 	write_dpr(accel, DE_CONTROL, de_ctrl|deGetTransparency(accel));
+ 
+ 	/* Write MONO data (line by line) to 2D Engine data port */
+ 	for (i = 0; i < height; i++) {
+ 		/* For each line, send the data in chunks of 4 bytes */
+ 		for (j = 0; j < (ul4BytesPerScan/4); j++)
+ 			write_dpPort(accel, *(unsigned int *)(pSrcbuf + (j * 4)));
+ 
+ 		if (ulBytesRemain) {
+ 			memcpy(ajRemain, pSrcbuf+ul4BytesPerScan, ulBytesRemain);
+ 			write_dpPort(accel, *(unsigned int *)ajRemain);
+ 		}
+ 
+ 		pSrcbuf += srcDelta;
+ 	}
+ 
+ 	    return 0;
+ }
+ 
diff -rcNP linux-4.4.24/drivers/staging/sm750fb/accel.h linux-4.4.24-baikal/drivers/staging/sm750fb/accel.h
*** linux-4.4.24/drivers/staging/sm750fb/accel.h	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/drivers/staging/sm750fb/accel.h	2016-11-11 14:49:54.000000000 +0300
***************
*** 0 ****
--- 1,222 ----
+ #ifndef ACCEL_H__
+ #define ACCEL_H__
+ 
+ #define HW_ROP2_COPY 0xc
+ #define HW_ROP2_XOR 0x6
+ 
+ /* notes: below address are the offset value from de_base_address (0x100000)*/
+ 
+ /* for sm718/750/502 de_base is at mmreg_1mb*/
+ #define DE_BASE_ADDR_TYPE1 0x100000
+ /* for sm712,de_base is at mmreg_32kb */
+ #define DE_BASE_ADDR_TYPE2  0x8000
+ /* for sm722,de_base is at mmreg_0 */
+ #define DE_BASE_ADDR_TYPE3 0
+ 
+ /* type1 data port address is at mmreg_0x110000*/
+ #define DE_PORT_ADDR_TYPE1 0x110000
+ /* for sm712,data port address is at mmreg_0 */
+ #define DE_PORT_ADDR_TYPE2 0x100000
+ /* for sm722,data port address is at mmreg_1mb */
+ #define DE_PORT_ADDR_TYPE3 0x100000
+ 
+ #define DE_SOURCE                                       0x0
+ #define DE_SOURCE_WRAP                                  BIT(31)
+ #define DE_SOURCE_X_K1_SHIFT                            16
+ #define DE_SOURCE_X_K1_MASK                             (0x3fff<<16)
+ #define DE_SOURCE_X_K1_MONO_MASK			(0x1f<<16)
+ #define DE_SOURCE_Y_K2_MASK                             0xffff
+ 
+ #define DE_DESTINATION                                  0x4
+ #define DE_DESTINATION_WRAP                             BIT(31)
+ #define DE_DESTINATION_X_SHIFT                          16
+ #define DE_DESTINATION_X_MASK                           (0x1fff<<16)
+ #define DE_DESTINATION_Y_MASK                           0xffff
+ 
+ #define DE_DIMENSION                                    0x8
+ #define DE_DIMENSION_X_SHIFT                            16
+ #define DE_DIMENSION_X_MASK                             (0x1fff<<16)
+ #define DE_DIMENSION_Y_ET_MASK                          0x1fff
+ 
+ #define DE_CONTROL                                      0xC
+ #define DE_CONTROL_STATUS                               BIT(31)
+ #define DE_CONTROL_PATTERN                              BIT(30)
+ #define DE_CONTROL_UPDATE_DESTINATION_X                 BIT(29)
+ #define DE_CONTROL_QUICK_START                          BIT(28)
+ #define DE_CONTROL_DIRECTION                            BIT(27)
+ #define DE_CONTROL_MAJOR                                BIT(26)
+ #define DE_CONTROL_STEP_X                               BIT(25)
+ #define DE_CONTROL_STEP_Y                               BIT(24)
+ #define DE_CONTROL_STRETCH                              BIT(23)
+ #define DE_CONTROL_HOST                                 BIT(22)
+ #define DE_CONTROL_LAST_PIXEL                           BIT(21)
+ #define DE_CONTROL_COMMAND_SHIFT                        16
+ #define DE_CONTROL_COMMAND_MASK                         (0x1f<<16)
+ #define DE_CONTROL_COMMAND_BITBLT                       (0x0<<16)
+ #define DE_CONTROL_COMMAND_RECTANGLE_FILL               (0x1<<16)
+ #define DE_CONTROL_COMMAND_DE_TILE                      (0x2<<16)
+ #define DE_CONTROL_COMMAND_TRAPEZOID_FILL               (0x3<<16)
+ #define DE_CONTROL_COMMAND_ALPHA_BLEND                  (0x4<<16)
+ #define DE_CONTROL_COMMAND_RLE_STRIP                    (0x5<<16)
+ #define DE_CONTROL_COMMAND_SHORT_STROKE                 (0x6<<16)
+ #define DE_CONTROL_COMMAND_LINE_DRAW                    (0x7<<16)
+ #define DE_CONTROL_COMMAND_HOST_WRITE                   (0x8<<16)
+ #define DE_CONTROL_COMMAND_HOST_READ                    (0x9<<16)
+ #define DE_CONTROL_COMMAND_HOST_WRITE_BOTTOM_UP         (0xa<<16)
+ #define DE_CONTROL_COMMAND_ROTATE                       (0xb<<16)
+ #define DE_CONTROL_COMMAND_FONT                         (0xc<<16)
+ #define DE_CONTROL_COMMAND_TEXTURE_LOAD                 (0xe<<16)
+ #define DE_CONTROL_ROP_SELECT                           BIT(15)
+ #define DE_CONTROL_ROP2_SOURCE                          BIT(14)
+ #define DE_CONTROL_MONO_DATA_SHIFT                      12
+ #define DE_CONTROL_MONO_DATA_MASK                       (0x3<<12)
+ #define DE_CONTROL_MONO_DATA_NOT_PACKED                 (0x0<<12)
+ #define DE_CONTROL_MONO_DATA_8_PACKED                   (0x1<<12)
+ #define DE_CONTROL_MONO_DATA_16_PACKED                  (0x2<<12)
+ #define DE_CONTROL_MONO_DATA_32_PACKED                  (0x3<<12)
+ #define DE_CONTROL_REPEAT_ROTATE                        BIT(11)
+ #define DE_CONTROL_TRANSPARENCY_MATCH                   BIT(10)
+ #define DE_CONTROL_TRANSPARENCY_SELECT                  BIT(9)
+ #define DE_CONTROL_TRANSPARENCY                         BIT(8)
+ #define DE_CONTROL_ROP_MASK                             0xff
+ 
+ /* Pseudo fields. */
+ 
+ #define DE_CONTROL_SHORT_STROKE_DIR_MASK                (0xf<<24)
+ #define DE_CONTROL_SHORT_STROKE_DIR_225                 (0x0<<24)
+ #define DE_CONTROL_SHORT_STROKE_DIR_135                 (0x1<<24)
+ #define DE_CONTROL_SHORT_STROKE_DIR_315                 (0x2<<24)
+ #define DE_CONTROL_SHORT_STROKE_DIR_45                  (0x3<<24)
+ #define DE_CONTROL_SHORT_STROKE_DIR_270                 (0x4<<24)
+ #define DE_CONTROL_SHORT_STROKE_DIR_90                  (0x5<<24)
+ #define DE_CONTROL_SHORT_STROKE_DIR_180                 (0x8<<24)
+ #define DE_CONTROL_SHORT_STROKE_DIR_0                   (0xa<<24)
+ #define DE_CONTROL_ROTATION_MASK                        (0x3<<24)
+ #define DE_CONTROL_ROTATION_0                           (0x0<<24)
+ #define DE_CONTROL_ROTATION_270                         (0x1<<24)
+ #define DE_CONTROL_ROTATION_90                          (0x2<<24)
+ #define DE_CONTROL_ROTATION_180                         (0x3<<24)
+ 
+ #define DE_PITCH                                        0x000010
+ #define DE_PITCH_DESTINATION_SHIFT                      16
+ #define DE_PITCH_DESTINATION_MASK                       (0x1fff<<16)
+ #define DE_PITCH_SOURCE_MASK                            0x1fff
+ 
+ #define DE_FOREGROUND                                   0x000014
+ #define DE_FOREGROUND_COLOR_MASK                        0xffffffff
+ 
+ #define DE_BACKGROUND                                   0x000018
+ #define DE_BACKGROUND_COLOR_MASK                        0xffffffff
+ 
+ #define DE_STRETCH_FORMAT                               0x00001C
+ #define DE_STRETCH_FORMAT_PATTERN_XY                    BIT(30)
+ #define DE_STRETCH_FORMAT_PATTERN_Y_SHIFT               27
+ #define DE_STRETCH_FORMAT_PATTERN_Y_MASK                (0x7<<27)
+ #define DE_STRETCH_FORMAT_PATTERN_X_SHIFT               23
+ #define DE_STRETCH_FORMAT_PATTERN_X_MASK                (0x7<<23)
+ #define DE_STRETCH_FORMAT_PIXEL_FORMAT_SHIFT            20
+ #define DE_STRETCH_FORMAT_PIXEL_FORMAT_MASK             (0x3<<20)
+ #define DE_STRETCH_FORMAT_PIXEL_FORMAT_8                (0x0<<20)
+ #define DE_STRETCH_FORMAT_PIXEL_FORMAT_16               (0x1<<20)
+ #define DE_STRETCH_FORMAT_PIXEL_FORMAT_32               (0x2<<20)
+ #define DE_STRETCH_FORMAT_PIXEL_FORMAT_24               (0x3<<20)
+ #define DE_STRETCH_FORMAT_ADDRESSING_SHIFT              16
+ #define DE_STRETCH_FORMAT_ADDRESSING_MASK               (0xf<<16)
+ #define DE_STRETCH_FORMAT_ADDRESSING_XY                 (0x0<<16)
+ #define DE_STRETCH_FORMAT_ADDRESSING_LINEAR             (0xf<<16)
+ #define DE_STRETCH_FORMAT_SOURCE_HEIGHT_MASK            0xfff
+ 
+ #define DE_COLOR_COMPARE                                0x000020
+ #define DE_COLOR_COMPARE_COLOR_MASK                     0xffffff
+ 
+ #define DE_COLOR_COMPARE_MASK                           0x000024
+ #define DE_COLOR_COMPARE_MASK_MASK                      0xffffff
+ 
+ #define DE_MASKS                                        0x000028
+ #define DE_MASKS_BYTE_MASK                              (0xffff<<16)
+ #define DE_MASKS_BIT_MASK                               0xffff
+ 
+ #define DE_CLIP_TL                                      0x00002C
+ #define DE_CLIP_TL_TOP_MASK                             (0xffff<<16)
+ #define DE_CLIP_TL_STATUS                               BIT(13)
+ #define DE_CLIP_TL_INHIBIT                              BIT(12)
+ #define DE_CLIP_TL_LEFT_MASK                            0xfff
+ 
+ #define DE_CLIP_BR                                      0x000030
+ #define DE_CLIP_BR_BOTTOM_MASK                          (0xffff<<16)
+ #define DE_CLIP_BR_RIGHT_MASK                           0x1fff
+ 
+ #define DE_MONO_PATTERN_LOW                             0x000034
+ #define DE_MONO_PATTERN_LOW_PATTERN_MASK                0xffffffff
+ 
+ #define DE_MONO_PATTERN_HIGH                            0x000038
+ #define DE_MONO_PATTERN_HIGH_PATTERN_MASK               0xffffffff
+ 
+ #define DE_WINDOW_WIDTH                                 0x00003C
+ #define DE_WINDOW_WIDTH_DST_SHIFT                       16
+ #define DE_WINDOW_WIDTH_DST_MASK                        (0x1fff<<16)
+ #define DE_WINDOW_WIDTH_SRC_MASK                        0x1fff
+ 
+ #define DE_WINDOW_SOURCE_BASE                           0x000040
+ #define DE_WINDOW_SOURCE_BASE_EXT                       BIT(27)
+ #define DE_WINDOW_SOURCE_BASE_CS                        BIT(26)
+ #define DE_WINDOW_SOURCE_BASE_ADDRESS_MASK              0x3ffffff
+ 
+ #define DE_WINDOW_DESTINATION_BASE                      0x000044
+ #define DE_WINDOW_DESTINATION_BASE_EXT                  BIT(27)
+ #define DE_WINDOW_DESTINATION_BASE_CS                   BIT(26)
+ #define DE_WINDOW_DESTINATION_BASE_ADDRESS_MASK         0x3ffffff
+ 
+ #define DE_ALPHA                                        0x000048
+ #define DE_ALPHA_VALUE_MASK                             0xff
+ 
+ #define DE_WRAP                                         0x00004C
+ #define DE_WRAP_X_MASK                                  (0xffff<<16)
+ #define DE_WRAP_Y_MASK                                  0xffff
+ 
+ #define DE_STATUS                                       0x000050
+ #define DE_STATUS_CSC                                   BIT(1)
+ #define DE_STATUS_2D                                    BIT(0)
+ 
+ /* blt direction */
+ #define TOP_TO_BOTTOM 0
+ #define LEFT_TO_RIGHT 0
+ #define BOTTOM_TO_TOP 1
+ #define RIGHT_TO_LEFT 1
+ 
+ void hw_set2dformat(struct lynx_accel *accel, int fmt);
+ 
+ void hw_de_init(struct lynx_accel *accel);
+ 
+ int hw_fillrect(struct lynx_accel *accel, u32 base, u32 pitch, u32 Bpp, u32 x, u32 y, u32 width, u32 height, u32 color, u32 rop);
+ 
+ int hw_copyarea(
+ struct lynx_accel *accel,
+ unsigned int sBase,  /* Address of source: offset in frame buffer */
+ unsigned int sPitch, /* Pitch value of source surface in BYTE */
+ unsigned int sx,
+ unsigned int sy,     /* Starting coordinate of source surface */
+ unsigned int dBase,  /* Address of destination: offset in frame buffer */
+ unsigned int dPitch, /* Pitch value of destination surface in BYTE */
+ unsigned int bpp,    /* Color depth of destination surface */
+ unsigned int dx,
+ unsigned int dy,     /* Starting coordinate of destination surface */
+ unsigned int width,
+ unsigned int height, /* width and height of rectangle in pixel value */
+ unsigned int rop2);
+ 
+ int hw_imageblit(struct lynx_accel *accel,
+ 		 const char *pSrcbuf, /* pointer to start of source buffer in system memory */
+ 		 u32 srcDelta,          /* Pitch value (in bytes) of the source buffer, +ive means top down and -ive mean button up */
+ 		 u32 startBit, /* Mono data can start at any bit in a byte, this value should be 0 to 7 */
+ 		 u32 dBase,    /* Address of destination: offset in frame buffer */
+ 		 u32 dPitch,   /* Pitch value of destination surface in BYTE */
+ 		 u32 bytePerPixel,      /* Color depth of destination surface */
+ 		 u32 dx,
+ 		 u32 dy,       /* Starting coordinate of destination surface */
+ 		 u32 width,
+ 		 u32 height,   /* width and height of rectangle in pixel value */
+ 		 u32 fColor,   /* Foreground color (corresponding to a 1 in the monochrome data */
+ 		 u32 bColor,   /* Background color (corresponding to a 0 in the monochrome data */
+ 		 u32 rop2);
+ #endif
diff -rcNP linux-4.4.24/drivers/staging/sm750fb/chip.c linux-4.4.24-baikal/drivers/staging/sm750fb/chip.c
*** linux-4.4.24/drivers/staging/sm750fb/chip.c	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/drivers/staging/sm750fb/chip.c	2016-11-11 14:49:54.000000000 +0300
***************
*** 0 ****
--- 1,378 ----
+ #include <linux/kernel.h>
+ #include <linux/sizes.h>
+ 
+ #include "help.h"
+ #include "reg.h"
+ #include "chip.h"
+ #include "power.h"
+ 
+ /* n/d + 1/2 = (2n + d)/2d */
+ #define roundedDiv(num, denom)	((2 * (num) + (denom))/(2 * (denom)))
+ #define MHz(x) ((x) * 1000000)
+ 
+ logical_chip_type_t getChipType(void)
+ {
+     unsigned short physicalID;
+     char physicalRev;
+     logical_chip_type_t chip;
+ 
+     physicalID = devId750; /* either 0x718 or 0x750 */
+     physicalRev = revId750;
+ 
+     if (physicalID == 0x718)
+ 	chip = SM718;
+     else if (physicalID == 0x750) {
+ 	chip = SM750;
+ 	/* SM750 and SM750LE are different in their revision ID only. */
+ 	if (physicalRev == SM750LE_REVISION_ID)
+ 	    chip = SM750LE;
+     } else
+ 	chip = SM_UNKNOWN;
+ 
+     return chip;
+ }
+ 
+ static unsigned int get_mxclk_freq(void)
+ {
+     unsigned int pll_reg;
+     unsigned int M, N, OD, POD;
+ 
+     if (getChipType() == SM750LE)
+ 	return MHz(130);
+ 
+     pll_reg = PEEK32(MXCLK_PLL_CTRL);
+     M = (pll_reg&PLL_CTRL_M_MASK)>>PLL_CTRL_M_SHIFT;
+     N = (pll_reg&PLL_CTRL_N_MASK)>>PLL_CTRL_M_SHIFT;
+     OD = (pll_reg&PLL_CTRL_OD_MASK)>>PLL_CTRL_OD_SHIFT;
+     POD = (pll_reg&PLL_CTRL_POD_MASK)>>PLL_CTRL_POD_SHIFT;
+ 
+     return DEFAULT_INPUT_CLOCK * M/N/(1<<OD)/(1<<POD);
+ }
+ 
+ /*
+  * This function set up the main chip clock.
+  *
+  * Input: Frequency to be set.
+  */
+ static void setChipClock(unsigned int frequency)
+ {
+     pll_value_t pll;
+     unsigned int ulActualMxClk;
+ 
+     /* Cheok_0509: For SM750LE, the chip clock is fixed. Nothing to set. */
+     if (getChipType() == SM750LE)
+ 	return;
+ 
+     if (frequency) {
+ 	/*
+ 	* Set up PLL, a structure to hold the value to be set in clocks.
+ 	*/
+ 	pll.inputFreq = DEFAULT_INPUT_CLOCK; /* Defined in CLOCK.H */
+ 	pll.clockType = MXCLK_PLL;
+ 
+ 	/*
+ 	* Call calcPllValue() to fill up the other fields for PLL structure.
+ 	* Sometime, the chip cannot set up the exact clock required by User.
+ 	* Return value from calcPllValue() gives the actual possible clock.
+ 	*/
+ 	ulActualMxClk = calcPllValue(frequency, &pll);
+ 
+ 	/* Master Clock Control: MXCLK_PLL */
+ 	POKE32(MXCLK_PLL_CTRL, formatPllReg(&pll));
+     }
+ }
+ 
+ static void setMemoryClock(unsigned int frequency)
+ {
+     unsigned int reg, divisor;
+ 
+     /* Cheok_0509: For SM750LE, the memory clock is fixed. Nothing to set. */
+     if (getChipType() == SM750LE)
+ 	return;
+ 
+     if (frequency) {
+ 	/* Set the frequency to the maximum frequency that the DDR Memory can take
+ 	which is 336MHz. */
+ 	if (frequency > MHz(336))
+ 	    frequency = MHz(336);
+ 
+ 	/* Calculate the divisor */
+ 	divisor = roundedDiv(get_mxclk_freq(), frequency);
+ 
+ 	/* Set the corresponding divisor in the register. */
+ 	reg = PEEK32(CURRENT_GATE)&~CURRENT_GATE_M2XCLK_MASK;
+ 	switch (divisor) {
+ 	default:
+ 	case 1:
+ 	    reg |= CURRENT_GATE_M2XCLK_DIV_1;
+ 	    break;
+ 	case 2:
+ 	    reg |= CURRENT_GATE_M2XCLK_DIV_2;
+ 	    break;
+ 	case 3:
+ 	    reg |= CURRENT_GATE_M2XCLK_DIV_3;
+ 	    break;
+ 	case 4:
+ 	    reg |= CURRENT_GATE_M2XCLK_DIV_4;
+ 	    break;
+ 	}
+ 
+ 	setCurrentGate(reg);
+     }
+ }
+ 
+ /*
+  * This function set up the master clock (MCLK).
+  *
+  * Input: Frequency to be set.
+  *
+  * NOTE:
+  *      The maximum frequency the engine can run is 168MHz.
+  */
+ static void setMasterClock(unsigned int frequency)
+ {
+     unsigned int reg, divisor;
+ 
+     /* Cheok_0509: For SM750LE, the memory clock is fixed. Nothing to set. */
+     if (getChipType() == SM750LE)
+ 	return;
+ 
+     if (frequency) {
+ 	/* Set the frequency to the maximum frequency that the SM750 engine can
+ 	run, which is about 190 MHz. */
+ 	if (frequency > MHz(190))
+ 	    frequency = MHz(190);
+ 
+ 	/* Calculate the divisor */
+ 	divisor = roundedDiv(get_mxclk_freq(), frequency);
+ 
+ 	/* Set the corresponding divisor in the register. */
+ 	reg = PEEK32(CURRENT_GATE)&~CURRENT_GATE_MCLK_MASK;
+ 	switch (divisor) {
+ 	default:
+ 	case 3:
+ 	    reg |= CURRENT_GATE_MCLK_DIV_3;
+ 	    break;
+ 	case 4:
+ 	    reg |= CURRENT_GATE_MCLK_DIV_4;
+ 	    break;
+ 	case 6:
+ 	    reg |= CURRENT_GATE_MCLK_DIV_6;
+ 	    break;
+ 	case 8:
+ 	    reg |= CURRENT_GATE_MCLK_DIV_8;
+ 	    break;
+ 	}
+ 
+ 	setCurrentGate(reg);
+     }
+ }
+ 
+ unsigned int getVMSize(void)
+ {
+     unsigned int reg;
+     unsigned int data;
+ 
+     /* sm750le only use 64 mb memory*/
+     if (getChipType() == SM750LE)
+ 	return SZ_64M;
+ 
+     /* for 750,always use power mode0*/
+     reg = PEEK32(MODE0_GATE);
+     reg |= MODE0_GATE_GPIO;
+     POKE32(MODE0_GATE, reg);
+ 
+     /* get frame buffer size from GPIO */
+     reg = PEEK32(MISC_CTRL)&MISC_CTRL_LOCALMEM_SIZE_MASK;
+     switch (reg) {
+     case MISC_CTRL_LOCALMEM_SIZE_8M:
+ 	data = SZ_8M;  break; /* 8  Mega byte */
+     case MISC_CTRL_LOCALMEM_SIZE_16M:
+ 	data = SZ_16M; break; /* 16 Mega byte */
+     case MISC_CTRL_LOCALMEM_SIZE_32M:
+ 	data = SZ_32M; break; /* 32 Mega byte */
+     case MISC_CTRL_LOCALMEM_SIZE_64M:
+ 	data = SZ_64M; break; /* 64 Mega byte */
+     default:
+ 	data = 0;
+ 	break;
+     }
+     return data;
+ }
+ 
+ int initChipParm(initchip_param_t *pInitParam)
+ {
+     unsigned int reg;
+ 
+     if (pInitParam->powerMode != 0)
+ 	pInitParam->powerMode = 0;
+     setPowerMode(pInitParam->powerMode);
+ 
+     /* Enable display power gate&LOCALMEM power gate*/
+     reg = PEEK32(CURRENT_GATE);
+     reg |= (CURRENT_GATE_DISPLAY|CURRENT_GATE_LOCALMEM);
+     setCurrentGate(reg);
+ 
+     if (getChipType() != SM750LE) {
+ 	/* set panel pll and graphic mode via mmio_88 */
+ 	reg = PEEK32(VGA_CONFIGURATION);
+ 	reg |= (VGA_CONFIGURATION_PLL|VGA_CONFIGURATION_MODE);
+ 	POKE32(VGA_CONFIGURATION, reg);
+     } else {
+ #if defined(__i386__) || defined(__x86_64__)
+ 	/* set graphic mode via IO method */
+ 	outb_p(0x88, 0x3d4);
+ 	outb_p(0x06, 0x3d5);
+ #endif
+     }
+ 
+     /* Set the Main Chip Clock */
+     setChipClock(MHz((unsigned int)pInitParam->chipClock));
+ 
+     /* Set up memory clock. */
+     setMemoryClock(MHz(pInitParam->memClock));
+ 
+     /* Set up master clock */
+     setMasterClock(MHz(pInitParam->masterClock));
+ 
+     /* Reset the memory controller. If the memory controller is not reset in SM750, the system might hang when sw accesses the memory. The memory should be resetted after changing the MXCLK. */
+     if (pInitParam->resetMemory == 1) {
+ 	reg = PEEK32(MISC_CTRL);
+ 	reg &= ~MISC_CTRL_LOCALMEM_RESET;
+ 	POKE32(MISC_CTRL, reg);
+ 
+ 	reg |= MISC_CTRL_LOCALMEM_RESET;
+ 	POKE32(MISC_CTRL, reg);
+     }
+ 
+     if (pInitParam->setAllEngOff == 1) {
+ 	enable2DEngine(0);
+ 
+ 	/* Disable Overlay, if a former application left it on */
+ 	reg = PEEK32(VIDEO_DISPLAY_CTRL);
+ 	reg &= ~DISPLAY_CTRL_PLANE;
+ 	POKE32(VIDEO_DISPLAY_CTRL, reg);
+ 
+ 	/* Disable video alpha, if a former application left it on */
+ 	reg = PEEK32(VIDEO_ALPHA_DISPLAY_CTRL);
+ 	reg &= ~DISPLAY_CTRL_PLANE;
+ 	POKE32(VIDEO_ALPHA_DISPLAY_CTRL, reg);
+ 
+ 	/* Disable alpha plane, if a former application left it on */
+ 	reg = PEEK32(ALPHA_DISPLAY_CTRL);
+ 	reg &= ~DISPLAY_CTRL_PLANE;
+ 	POKE32(ALPHA_DISPLAY_CTRL, reg);
+ 
+ 	/* Disable DMA Channel, if a former application left it on */
+ 	reg = PEEK32(DMA_ABORT_INTERRUPT);
+ 	reg |= DMA_ABORT_INTERRUPT_ABORT_1;
+ 	POKE32(DMA_ABORT_INTERRUPT, reg);
+ 
+ 	/* Disable DMA Power, if a former application left it on */
+ 	enableDMA(0);
+     }
+ 
+     /* We can add more initialization as needed. */
+     return 0;
+ }
+ 
+ /*
+     monk liu @ 4/6/2011:
+ 	   re-write the calculatePLL function of ddk750.
+ 	   the original version function does not use some mathematics tricks and shortcut
+ 	   when it doing the calculation of the best N,M,D combination
+ 	   I think this version gives a little upgrade in speed
+ 
+     750 pll clock formular:
+     Request Clock = (Input Clock * M )/(N * X)
+ 
+     Input Clock = 14318181 hz
+     X = 2 power D
+     D ={0,1,2,3,4,5,6}
+     M = {1,...,255}
+     N = {2,...,15}
+ */
+ unsigned int calcPllValue(unsigned int request_orig, pll_value_t *pll)
+ {
+     /* as sm750 register definition, N located in 2,15 and M located in 1,255 */
+     int N, M, X, d;
+     int mini_diff;
+     unsigned int RN, quo, rem, fl_quo;
+     unsigned int input, request;
+     unsigned int tmpClock, ret;
+     const int max_OD = 3;
+     int max_d = 6;
+ 
+     if (getChipType() == SM750LE) {
+ 	/* SM750LE don't have prgrammable PLL and M/N values to work on.
+ 	Just return the requested clock. */
+ 	return request_orig;
+     }
+ 
+     ret = 0;
+     mini_diff = ~0;
+     request = request_orig/1000;
+     input = pll->inputFreq/1000;
+ 
+     /* for MXCLK register , no POD provided, so need be treated differently	*/
+     if (pll->clockType == MXCLK_PLL)
+ 	max_d = 3;
+ 
+     for (N = 15; N > 1; N--) {
+ 	/* RN will not exceed maximum long if @request <= 285 MHZ (for 32bit cpu) */
+ 	RN = N * request;
+ 	quo = RN/input;
+ 	rem = RN % input;/* rem always small than 14318181 */
+ 	fl_quo = (rem * 10000/input);
+ 
+ 	for (d = max_d; d >= 0; d--) {
+ 	    X = (1<<d);
+ 	    M = quo * X;
+ 	    M += fl_quo * X/10000;
+ 	    /* round step */
+ 	    M += (fl_quo * X % 10000) > 5000?1:0;
+ 	    if (M < 256 && M > 0) {
+ 		unsigned int diff;
+ 
+ 		tmpClock = pll->inputFreq * M/N/X;
+ 		diff = abs(tmpClock - request_orig);
+ 		if (diff < mini_diff) {
+ 		    pll->M = M;
+ 		    pll->N = N;
+ 		    pll->POD = 0;
+ 		    if (d > max_OD)
+ 			pll->POD = d - max_OD;
+ 		    pll->OD = d - pll->POD;
+ 		    mini_diff = diff;
+ 		    ret = tmpClock;
+ 		}
+ 	    }
+ 	}
+     }
+     return ret;
+ }
+ 
+ unsigned int formatPllReg(pll_value_t *pPLL)
+ {
+ #ifndef VALIDATION_CHIP
+     unsigned int POD = pPLL->POD;
+ #endif
+     unsigned int OD = pPLL->OD;
+     unsigned int M = pPLL->M;
+     unsigned int N = pPLL->N;
+     unsigned int reg = 0;
+ 
+     /*
+      * Note that all PLL's have the same format. Here, we just use
+      * Panel PLL parameter to work out the bit fields in the
+      * register. On returning a 32 bit number, the value can be
+      * applied to any PLL in the calling function.
+      */
+     reg = PLL_CTRL_POWER |
+ #ifndef VALIDATION_CHIP
+ 	((POD<<PLL_CTRL_POD_SHIFT)&PLL_CTRL_POD_MASK) |
+ #endif
+ 	((OD<<PLL_CTRL_OD_SHIFT)&PLL_CTRL_OD_MASK)|((N<<PLL_CTRL_N_SHIFT)&PLL_CTRL_N_MASK)|((M<<PLL_CTRL_M_SHIFT)&PLL_CTRL_M_MASK);
+ 
+     return reg;
+ }
diff -rcNP linux-4.4.24/drivers/staging/sm750fb/chip.h linux-4.4.24-baikal/drivers/staging/sm750fb/chip.h
*** linux-4.4.24/drivers/staging/sm750fb/chip.h	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/drivers/staging/sm750fb/chip.h	2016-11-11 14:49:54.000000000 +0300
***************
*** 0 ****
--- 1,80 ----
+ #ifndef CHIP_H__
+ #define CHIP_H__
+ 
+ #define DEFAULT_INPUT_CLOCK 14318181 /* Default reference clock */
+ #ifndef SM750LE_REVISION_ID
+ #define SM750LE_REVISION_ID ((unsigned char)0xfe)
+ #endif
+ 
+ #include <linux/io.h>
+ 
+ /* This is all the chips recognized by this library */
+ typedef enum _logical_chip_type_t {
+ 	SM_UNKNOWN,
+ 	SM718,
+ 	SM750,
+ 	SM750LE,
+ }
+ logical_chip_type_t;
+ 
+ typedef enum _clock_type_t {
+ 	MXCLK_PLL,
+ 	PRIMARY_PLL,
+ 	SECONDARY_PLL,
+ 	VGA0_PLL,
+ 	VGA1_PLL,
+ }
+ clock_type_t;
+ 
+ typedef struct _pll_value_t {
+ 	clock_type_t clockType;
+ 	unsigned long inputFreq; /* Input clock frequency to the PLL */
+ 
+ 	/* Use this when clockType = PANEL_PLL */
+ 	unsigned long M;
+ 	unsigned long N;
+ 	unsigned long OD;
+ 	unsigned long POD;
+ }
+ pll_value_t;
+ 
+ /* input struct to initChipParam() function */
+ typedef struct _initchip_param_t {
+ 	unsigned short powerMode;    /* Use power mode 0 or 1 */
+ 	unsigned short chipClock;    /**
+ 				      * Speed of main chip clock in MHz unit
+ 				      * 0 = keep the current clock setting
+ 				      * Others = the new main chip clock
+ 				      */
+ 	unsigned short memClock;     /**
+ 				      * Speed of memory clock in MHz unit
+ 				      * 0 = keep the current clock setting
+ 				      * Others = the new memory clock
+ 				      */
+ 	unsigned short masterClock;  /**
+ 				      * Speed of master clock in MHz unit
+ 				      * 0 = keep the current clock setting
+ 				      * Others = the new master clock
+ 				      */
+ 	unsigned short setAllEngOff; /**
+ 				      * 0 = leave all engine state untouched.
+ 				      * 1 = make sure they are off: 2D, Overlay,
+ 				      * video alpha, alpha, hardware cursors
+ 				      */
+ 	unsigned char resetMemory;   /**
+ 				      * 0 = Do not reset the memory controller
+ 				      * 1 = Reset the memory controller
+ 				      */
+ 
+ 	/* More initialization parameter can be added if needed */
+ }
+ initchip_param_t;
+ 
+ logical_chip_type_t getChipType(void);
+ unsigned int calcPllValue(unsigned int request, pll_value_t *pll);
+ unsigned int formatPllReg(pll_value_t *pPLL);
+ void set_mmio(void __iomem *, unsigned short, char);
+ unsigned int getVMSize(void);
+ int initChipParm(initchip_param_t *);
+ 
+ #endif
diff -rcNP linux-4.4.24/drivers/staging/sm750fb/cursor.c linux-4.4.24-baikal/drivers/staging/sm750fb/cursor.c
*** linux-4.4.24/drivers/staging/sm750fb/cursor.c	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/drivers/staging/sm750fb/cursor.c	2016-11-11 14:49:54.000000000 +0300
***************
*** 0 ****
--- 1,174 ----
+ #include <linux/module.h>
+ #include <linux/kernel.h>
+ #include <linux/errno.h>
+ #include <linux/string.h>
+ #include <linux/mm.h>
+ #include <linux/slab.h>
+ #include <linux/delay.h>
+ #include <linux/fb.h>
+ #include <linux/ioport.h>
+ #include <linux/init.h>
+ #include <linux/pci.h>
+ #include <linux/vmalloc.h>
+ #include <linux/pagemap.h>
+ #include <linux/console.h>
+ #include <linux/platform_device.h>
+ #include <linux/screen_info.h>
+ 
+ #include "drv.h"
+ #include "cursor.h"
+ 
+ #define POKE32(addr, data) \
+ writel((data), cursor->mmio + (addr))
+ 
+ /* cursor control for voyager and 718/750*/
+ #define HWC_ADDRESS                         0x0
+ #define HWC_ADDRESS_ENABLE                  BIT(31)
+ #define HWC_ADDRESS_EXT                     BIT(27)
+ #define HWC_ADDRESS_CS                      BIT(26)
+ #define HWC_ADDRESS_ADDRESS_MASK            0x3ffffff
+ 
+ #define HWC_LOCATION                        0x4
+ #define HWC_LOCATION_TOP                    BIT(27)
+ #define HWC_LOCATION_Y_SHIFT                16
+ #define HWC_LOCATION_Y_MASK                 (0x7ff<<16)
+ #define HWC_LOCATION_LEFT                   BIT(11)
+ #define HWC_LOCATION_X_MASK                 0x7ff
+ 
+ #define HWC_COLOR_12                        0x8
+ #define HWC_COLOR_12_2_RGB565_SHIFT         16
+ #define HWC_COLOR_12_2_RGB565_MASK          (0xffff<<16)
+ #define HWC_COLOR_12_1_RGB565_MASK          0xffff
+ 
+ #define HWC_COLOR_3                         0xC
+ #define HWC_COLOR_3_RGB565_MASK             0xffff
+ 
+ 
+ /* hw_cursor_xxx works for voyager,718 and 750 */
+ void hw_cursor_enable(struct lynx_cursor *cursor)
+ {
+ 	u32 reg;
+ 
+ 	reg = (cursor->offset&HWC_ADDRESS_ADDRESS_MASK)|HWC_ADDRESS_ENABLE;
+ 	POKE32(HWC_ADDRESS, reg);
+ }
+ void hw_cursor_disable(struct lynx_cursor *cursor)
+ {
+ 	POKE32(HWC_ADDRESS, 0);
+ }
+ 
+ void hw_cursor_setSize(struct lynx_cursor *cursor, int w, int h)
+ {
+ 	cursor->w = w;
+ 	cursor->h = h;
+ }
+ void hw_cursor_setPos(struct lynx_cursor *cursor, int x, int y)
+ {
+ 	u32 reg;
+ 
+ 	reg = (((y<<HWC_LOCATION_Y_SHIFT)&HWC_LOCATION_Y_MASK)|(x&HWC_LOCATION_X_MASK));
+ 	POKE32(HWC_LOCATION, reg);
+ }
+ void hw_cursor_setColor(struct lynx_cursor *cursor, u32 fg, u32 bg)
+ {
+ 	u32 reg = (fg<<HWC_COLOR_12_2_RGB565_SHIFT)&HWC_COLOR_12_2_RGB565_MASK;
+ 
+ 	POKE32(HWC_COLOR_12, reg|(bg&HWC_COLOR_12_1_RGB565_MASK));
+ 	POKE32(HWC_COLOR_3, 0xffe0);
+ }
+ 
+ void hw_cursor_setData(struct lynx_cursor *cursor, u16 rop, const u8 *pcol, const u8 *pmsk)
+ {
+ 	int i, j, count, pitch, offset;
+ 	u8 color, mask, opr;
+ 	u16 data;
+ 	void __iomem *pbuffer, *pstart;
+ 
+ 	/*  in byte*/
+ 	pitch = cursor->w>>3;
+ 
+ 	/* in byte	*/
+ 	count = pitch * cursor->h;
+ 
+ 	/* in byte */
+ 	offset = cursor->maxW * 2/8;
+ 
+ 	data = 0;
+ 	pstart = cursor->vstart;
+ 	pbuffer = pstart;
+ 
+ 	for (i = 0; i < count; i++) {
+ 		color = *pcol++;
+ 		mask = *pmsk++;
+ 		data = 0;
+ 
+ 		for (j = 0; j < 8; j++) {
+ 			if (mask&(0x80>>j)) {
+ 				if (rop == ROP_XOR)
+ 					opr = mask ^ color;
+ 				else
+ 					opr = mask&color;
+ 
+ 				/* 2 stands for forecolor and 1 for backcolor */
+ 				data |= ((opr&(0x80>>j))?2:1)<<(j*2);
+ 			}
+ 		}
+ 		iowrite16(data, pbuffer);
+ 
+ 		/* assume pitch is 1,2,4,8,...*/
+ 		if ((i + 1) % pitch == 0) {
+ 			/* need a return */
+ 			pstart += offset;
+ 			pbuffer = pstart;
+ 		} else {
+ 			pbuffer += sizeof(u16);
+ 		}
+ 
+ 	}
+ 
+ 
+ }
+ 
+ 
+ void hw_cursor_setData2(struct lynx_cursor *cursor, u16 rop, const u8 *pcol, const u8 *pmsk)
+ {
+ 	int i, j, count, pitch, offset;
+ 	u8 color, mask;
+ 	u16 data;
+ 	void __iomem *pbuffer, *pstart;
+ 
+ 	/*  in byte*/
+ 	pitch = cursor->w>>3;
+ 
+ 	/* in byte	*/
+ 	count = pitch * cursor->h;
+ 
+ 	/* in byte */
+ 	offset = cursor->maxW * 2/8;
+ 
+ 	data = 0;
+ 	pstart = cursor->vstart;
+ 	pbuffer = pstart;
+ 
+ 	for (i = 0; i < count; i++) {
+ 		color = *pcol++;
+ 		mask = *pmsk++;
+ 		data = 0;
+ 
+ 		for (j = 0; j < 8; j++) {
+ 			if (mask&(1<<j))
+ 				data |= ((color&(1<<j))?1:2)<<(j*2);
+ 		}
+ 		iowrite16(data, pbuffer);
+ 
+ 		/* assume pitch is 1,2,4,8,...*/
+ 		if (!(i&(pitch-1))) {
+ 			/* need a return */
+ 			pstart += offset;
+ 			pbuffer = pstart;
+ 		} else {
+ 			pbuffer += sizeof(u16);
+ 		}
+ 
+ 	}
+ }
diff -rcNP linux-4.4.24/drivers/staging/sm750fb/cursor.h linux-4.4.24-baikal/drivers/staging/sm750fb/cursor.h
*** linux-4.4.24/drivers/staging/sm750fb/cursor.h	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/drivers/staging/sm750fb/cursor.h	2016-11-11 14:49:54.000000000 +0300
***************
*** 0 ****
--- 1,12 ----
+ #ifndef LYNX_CURSOR_H__
+ #define LYNX_CURSOR_H__
+ 
+ /* hw_cursor_xxx works for voyager,718 and 750 */
+ void hw_cursor_enable(struct lynx_cursor *cursor);
+ void hw_cursor_disable(struct lynx_cursor *cursor);
+ void hw_cursor_setSize(struct lynx_cursor *cursor, int w, int h);
+ void hw_cursor_setPos(struct lynx_cursor *cursor, int x, int y);
+ void hw_cursor_setColor(struct lynx_cursor *cursor, u32 fg, u32 bg);
+ void hw_cursor_setData(struct lynx_cursor *cursor, u16 rop, const u8 *data, const u8 *mask);
+ void hw_cursor_setData2(struct lynx_cursor *cursor, u16 rop, const u8 *data, const u8 *mask);
+ #endif
diff -rcNP linux-4.4.24/drivers/staging/sm750fb/ddk750_chip.c linux-4.4.24-baikal/drivers/staging/sm750fb/ddk750_chip.c
*** linux-4.4.24/drivers/staging/sm750fb/ddk750_chip.c	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/staging/sm750fb/ddk750_chip.c	1970-01-01 03:00:00.000000000 +0300
***************
*** 1,379 ****
- #include <linux/sizes.h>
- 
- #include "ddk750_help.h"
- #include "ddk750_reg.h"
- #include "ddk750_chip.h"
- #include "ddk750_power.h"
- 
- logical_chip_type_t getChipType(void)
- {
- 	unsigned short physicalID;
- 	char physicalRev;
- 	logical_chip_type_t chip;
- 
- 	physicalID = devId750; /* either 0x718 or 0x750 */
- 	physicalRev = revId750;
- 
- 	if (physicalID == 0x718)
- 		chip = SM718;
- 	else if (physicalID == 0x750) {
- 		chip = SM750;
- 		/* SM750 and SM750LE are different in their revision ID only. */
- 		if (physicalRev == SM750LE_REVISION_ID)
- 			chip = SM750LE;
- 	} else
- 		chip = SM_UNKNOWN;
- 
- 	return chip;
- }
- 
- static unsigned int get_mxclk_freq(void)
- {
- 	unsigned int pll_reg;
- 	unsigned int M, N, OD, POD;
- 
- 	if (getChipType() == SM750LE)
- 		return MHz(130);
- 
- 	pll_reg = PEEK32(MXCLK_PLL_CTRL);
- 	M = FIELD_GET(pll_reg, PANEL_PLL_CTRL, M);
- 	N = FIELD_GET(pll_reg, PANEL_PLL_CTRL, N);
- 	OD = FIELD_GET(pll_reg, PANEL_PLL_CTRL, OD);
- 	POD = FIELD_GET(pll_reg, PANEL_PLL_CTRL, POD);
- 
- 	return DEFAULT_INPUT_CLOCK * M / N / (1 << OD) / (1 << POD);
- }
- 
- /*
-  * This function set up the main chip clock.
-  *
-  * Input: Frequency to be set.
-  */
- static void setChipClock(unsigned int frequency)
- {
- 	pll_value_t pll;
- 	unsigned int ulActualMxClk;
- 
- 	/* Cheok_0509: For SM750LE, the chip clock is fixed. Nothing to set. */
- 	if (getChipType() == SM750LE)
- 		return;
- 
- 	if (frequency) {
- 		/*
- 		* Set up PLL, a structure to hold the value to be set in clocks.
- 		*/
- 		pll.inputFreq = DEFAULT_INPUT_CLOCK; /* Defined in CLOCK.H */
- 		pll.clockType = MXCLK_PLL;
- 
- 		/*
- 		* Call calcPllValue() to fill up the other fields for PLL structure.
- 		* Sometime, the chip cannot set up the exact clock required by User.
- 		* Return value from calcPllValue() gives the actual possible clock.
- 		*/
- 		ulActualMxClk = calcPllValue(frequency, &pll);
- 
- 		/* Master Clock Control: MXCLK_PLL */
- 		POKE32(MXCLK_PLL_CTRL, formatPllReg(&pll));
- 	}
- }
- 
- static void setMemoryClock(unsigned int frequency)
- {
- 	unsigned int ulReg, divisor;
- 
- 	/* Cheok_0509: For SM750LE, the memory clock is fixed. Nothing to set. */
- 	if (getChipType() == SM750LE)
- 		return;
- 
- 	if (frequency) {
- 		/* Set the frequency to the maximum frequency that the DDR Memory can take
- 		which is 336MHz. */
- 		if (frequency > MHz(336))
- 			frequency = MHz(336);
- 
- 		/* Calculate the divisor */
- 		divisor = roundedDiv(get_mxclk_freq(), frequency);
- 
- 		/* Set the corresponding divisor in the register. */
- 		ulReg = PEEK32(CURRENT_GATE);
- 		switch (divisor) {
- 		default:
- 		case 1:
- 			ulReg = FIELD_SET(ulReg, CURRENT_GATE, M2XCLK, DIV_1);
- 			break;
- 		case 2:
- 			ulReg = FIELD_SET(ulReg, CURRENT_GATE, M2XCLK, DIV_2);
- 			break;
- 		case 3:
- 			ulReg = FIELD_SET(ulReg, CURRENT_GATE, M2XCLK, DIV_3);
- 			break;
- 		case 4:
- 			ulReg = FIELD_SET(ulReg, CURRENT_GATE, M2XCLK, DIV_4);
- 			break;
- 		}
- 
- 		setCurrentGate(ulReg);
- 	}
- }
- 
- /*
-  * This function set up the master clock (MCLK).
-  *
-  * Input: Frequency to be set.
-  *
-  * NOTE:
-  *      The maximum frequency the engine can run is 168MHz.
-  */
- static void setMasterClock(unsigned int frequency)
- {
- 	unsigned int ulReg, divisor;
- 
- 	/* Cheok_0509: For SM750LE, the memory clock is fixed. Nothing to set. */
- 	if (getChipType() == SM750LE)
- 		return;
- 
- 	if (frequency) {
- 		/* Set the frequency to the maximum frequency that the SM750 engine can
- 		run, which is about 190 MHz. */
- 		if (frequency > MHz(190))
- 			frequency = MHz(190);
- 
- 		/* Calculate the divisor */
- 		divisor = roundedDiv(get_mxclk_freq(), frequency);
- 
- 		/* Set the corresponding divisor in the register. */
- 		ulReg = PEEK32(CURRENT_GATE);
- 		switch (divisor) {
- 		default:
- 		case 3:
- 			ulReg = FIELD_SET(ulReg, CURRENT_GATE, MCLK, DIV_3);
- 			break;
- 		case 4:
- 			ulReg = FIELD_SET(ulReg, CURRENT_GATE, MCLK, DIV_4);
- 			break;
- 		case 6:
- 			ulReg = FIELD_SET(ulReg, CURRENT_GATE, MCLK, DIV_6);
- 			break;
- 		case 8:
- 			ulReg = FIELD_SET(ulReg, CURRENT_GATE, MCLK, DIV_8);
- 			break;
- 		}
- 
- 		setCurrentGate(ulReg);
- 		}
- }
- 
- unsigned int ddk750_getVMSize(void)
- {
- 	unsigned int reg;
- 	unsigned int data;
- 
- 	/* sm750le only use 64 mb memory*/
- 	if (getChipType() == SM750LE)
- 		return SZ_64M;
- 
- 	/* for 750,always use power mode0*/
- 	reg = PEEK32(MODE0_GATE);
- 	reg = FIELD_SET(reg, MODE0_GATE, GPIO, ON);
- 	POKE32(MODE0_GATE, reg);
- 
- 	/* get frame buffer size from GPIO */
- 	reg = FIELD_GET(PEEK32(MISC_CTRL), MISC_CTRL, LOCALMEM_SIZE);
- 	switch (reg) {
- 	case MISC_CTRL_LOCALMEM_SIZE_8M:
- 		data = SZ_8M;  break; /* 8  Mega byte */
- 	case MISC_CTRL_LOCALMEM_SIZE_16M:
- 		data = SZ_16M; break; /* 16 Mega byte */
- 	case MISC_CTRL_LOCALMEM_SIZE_32M:
- 		data = SZ_32M; break; /* 32 Mega byte */
- 	case MISC_CTRL_LOCALMEM_SIZE_64M:
- 		data = SZ_64M; break; /* 64 Mega byte */
- 	default:
- 		data = 0;
- 		break;
- 	}
- 	return data;
- }
- 
- int ddk750_initHw(initchip_param_t *pInitParam)
- {
- 	unsigned int ulReg;
- 
- 	if (pInitParam->powerMode != 0)
- 		pInitParam->powerMode = 0;
- 	setPowerMode(pInitParam->powerMode);
- 
- 	/* Enable display power gate & LOCALMEM power gate*/
- 	ulReg = PEEK32(CURRENT_GATE);
- 	ulReg = FIELD_SET(ulReg, CURRENT_GATE, DISPLAY, ON);
- 	ulReg = FIELD_SET(ulReg, CURRENT_GATE, LOCALMEM, ON);
- 	setCurrentGate(ulReg);
- 
- 	if (getChipType() != SM750LE) {
- 		/*	set panel pll and graphic mode via mmio_88 */
- 		ulReg = PEEK32(VGA_CONFIGURATION);
- 		ulReg = FIELD_SET(ulReg, VGA_CONFIGURATION, PLL, PANEL);
- 		ulReg = FIELD_SET(ulReg, VGA_CONFIGURATION, MODE, GRAPHIC);
- 		POKE32(VGA_CONFIGURATION, ulReg);
- 	} else {
- #if defined(__i386__) || defined(__x86_64__)
- 		/* set graphic mode via IO method */
- 		outb_p(0x88, 0x3d4);
- 		outb_p(0x06, 0x3d5);
- #endif
- 	}
- 
- 	/* Set the Main Chip Clock */
- 	setChipClock(MHz((unsigned int)pInitParam->chipClock));
- 
- 	/* Set up memory clock. */
- 	setMemoryClock(MHz(pInitParam->memClock));
- 
- 	/* Set up master clock */
- 	setMasterClock(MHz(pInitParam->masterClock));
- 
- 
- 	/* Reset the memory controller. If the memory controller is not reset in SM750,
- 	   the system might hang when sw accesses the memory.
- 	   The memory should be resetted after changing the MXCLK.
- 	 */
- 	if (pInitParam->resetMemory == 1) {
- 		ulReg = PEEK32(MISC_CTRL);
- 		ulReg = FIELD_SET(ulReg, MISC_CTRL, LOCALMEM_RESET, RESET);
- 		POKE32(MISC_CTRL, ulReg);
- 
- 		ulReg = FIELD_SET(ulReg, MISC_CTRL, LOCALMEM_RESET, NORMAL);
- 		POKE32(MISC_CTRL, ulReg);
- 	}
- 
- 	if (pInitParam->setAllEngOff == 1) {
- 		enable2DEngine(0);
- 
- 		/* Disable Overlay, if a former application left it on */
- 		ulReg = PEEK32(VIDEO_DISPLAY_CTRL);
- 		ulReg = FIELD_SET(ulReg, VIDEO_DISPLAY_CTRL, PLANE, DISABLE);
- 		POKE32(VIDEO_DISPLAY_CTRL, ulReg);
- 
- 		/* Disable video alpha, if a former application left it on */
- 		ulReg = PEEK32(VIDEO_ALPHA_DISPLAY_CTRL);
- 		ulReg = FIELD_SET(ulReg, VIDEO_ALPHA_DISPLAY_CTRL, PLANE, DISABLE);
- 		POKE32(VIDEO_ALPHA_DISPLAY_CTRL, ulReg);
- 
- 		/* Disable alpha plane, if a former application left it on */
- 		ulReg = PEEK32(ALPHA_DISPLAY_CTRL);
- 		ulReg = FIELD_SET(ulReg, ALPHA_DISPLAY_CTRL, PLANE, DISABLE);
- 		POKE32(ALPHA_DISPLAY_CTRL, ulReg);
- 
- 		/* Disable DMA Channel, if a former application left it on */
- 		ulReg = PEEK32(DMA_ABORT_INTERRUPT);
- 		ulReg = FIELD_SET(ulReg, DMA_ABORT_INTERRUPT, ABORT_1, ABORT);
- 		POKE32(DMA_ABORT_INTERRUPT, ulReg);
- 
- 		/* Disable DMA Power, if a former application left it on */
- 		enableDMA(0);
- 	}
- 
- 	/* We can add more initialization as needed. */
- 
- 	return 0;
- }
- 
- /*
- 	monk liu @ 4/6/2011:
- 		   re-write the calculatePLL function of ddk750.
- 		   the original version function does not use some mathematics tricks and shortcut
- 		   when it doing the calculation of the best N,M,D combination
- 		   I think this version gives a little upgrade in speed
- 
- 	750 pll clock formular:
- 	Request Clock = (Input Clock * M )/(N * X)
- 
- 	Input Clock = 14318181 hz
- 	X = 2 power D
- 	D ={0,1,2,3,4,5,6}
- 	M = {1,...,255}
- 	N = {2,...,15}
- */
- unsigned int calcPllValue(unsigned int request_orig, pll_value_t *pll)
- {
- 	/* as sm750 register definition, N located in 2,15 and M located in 1,255	*/
- 	int N, M, X, d;
- 	int mini_diff;
- 	unsigned int RN, quo, rem, fl_quo;
- 	unsigned int input, request;
- 	unsigned int tmpClock, ret;
- 	const int max_OD = 3;
- 	int max_d;
- 
- 	if (getChipType() == SM750LE) {
- 		/* SM750LE don't have prgrammable PLL and M/N values to work on.
- 		Just return the requested clock. */
- 		return request_orig;
- 	}
- 
- 	ret = 0;
- 	mini_diff = ~0;
- 	request = request_orig / 1000;
- 	input = pll->inputFreq / 1000;
- 
- 	/* for MXCLK register , no POD provided, so need be treated differently	*/
- 	if (pll->clockType == MXCLK_PLL)
- 		max_d = 3;
- 
- 	for (N = 15; N > 1; N--) {
- 		/* RN will not exceed maximum long if @request <= 285 MHZ (for 32bit cpu) */
- 		RN = N * request;
- 		quo = RN / input;
- 		rem = RN % input;/* rem always small than 14318181 */
- 		fl_quo = (rem * 10000 / input);
- 
- 		for (d = max_d; d >= 0; d--) {
- 			X = (1 << d);
- 			M = quo * X;
- 			M += fl_quo * X / 10000;
- 			/* round step */
- 			M += (fl_quo * X % 10000) > 5000 ? 1 : 0;
- 			if (M < 256 && M > 0) {
- 				unsigned int diff;
- 
- 				tmpClock = pll->inputFreq * M / N / X;
- 				diff = absDiff(tmpClock, request_orig);
- 				if (diff < mini_diff) {
- 					pll->M = M;
- 					pll->N = N;
- 					pll->POD = 0;
- 					if (d > max_OD)
- 						pll->POD = d - max_OD;
- 					pll->OD = d - pll->POD;
- 					mini_diff = diff;
- 					ret = tmpClock;
- 				}
- 			}
- 		}
- 	}
- 	return ret;
- }
- 
- unsigned int formatPllReg(pll_value_t *pPLL)
- {
- 	unsigned int ulPllReg = 0;
- 
-     /* Note that all PLL's have the same format. Here, we just use Panel PLL parameter
-        to work out the bit fields in the register.
-        On returning a 32 bit number, the value can be applied to any PLL in the calling function.
-     */
- 	ulPllReg =
- 	FIELD_SET(0, PANEL_PLL_CTRL, BYPASS, OFF)
- 	| FIELD_SET(0, PANEL_PLL_CTRL, POWER,  ON)
- 	| FIELD_SET(0, PANEL_PLL_CTRL, INPUT,  OSC)
- #ifndef VALIDATION_CHIP
- 	| FIELD_VALUE(0, PANEL_PLL_CTRL, POD,    pPLL->POD)
- #endif
- 	| FIELD_VALUE(0, PANEL_PLL_CTRL, OD,     pPLL->OD)
- 	| FIELD_VALUE(0, PANEL_PLL_CTRL, N,      pPLL->N)
- 	| FIELD_VALUE(0, PANEL_PLL_CTRL, M,      pPLL->M);
- 
- 	return ulPllReg;
- }
- 
- 
--- 0 ----
diff -rcNP linux-4.4.24/drivers/staging/sm750fb/ddk750_chip.h linux-4.4.24-baikal/drivers/staging/sm750fb/ddk750_chip.h
*** linux-4.4.24/drivers/staging/sm750fb/ddk750_chip.h	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/staging/sm750fb/ddk750_chip.h	1970-01-01 03:00:00.000000000 +0300
***************
*** 1,79 ****
- #ifndef DDK750_CHIP_H__
- #define DDK750_CHIP_H__
- #define DEFAULT_INPUT_CLOCK 14318181 /* Default reference clock */
- #ifndef SM750LE_REVISION_ID
- #define SM750LE_REVISION_ID ((unsigned char)0xfe)
- #endif
- 
- #include <linux/io.h>
- 
- /* This is all the chips recognized by this library */
- typedef enum _logical_chip_type_t {
- 	SM_UNKNOWN,
- 	SM718,
- 	SM750,
- 	SM750LE,
- }
- logical_chip_type_t;
- 
- typedef enum _clock_type_t {
- 	MXCLK_PLL,
- 	PRIMARY_PLL,
- 	SECONDARY_PLL,
- 	VGA0_PLL,
- 	VGA1_PLL,
- }
- clock_type_t;
- 
- typedef struct _pll_value_t {
- 	clock_type_t clockType;
- 	unsigned long inputFreq; /* Input clock frequency to the PLL */
- 
- 	/* Use this when clockType = PANEL_PLL */
- 	unsigned long M;
- 	unsigned long N;
- 	unsigned long OD;
- 	unsigned long POD;
- }
- pll_value_t;
- 
- /* input struct to initChipParam() function */
- typedef struct _initchip_param_t {
- 	unsigned short powerMode;    /* Use power mode 0 or 1 */
- 	unsigned short chipClock;    /**
- 				      * Speed of main chip clock in MHz unit
- 				      * 0 = keep the current clock setting
- 				      * Others = the new main chip clock
- 				      */
- 	unsigned short memClock;     /**
- 				      * Speed of memory clock in MHz unit
- 				      * 0 = keep the current clock setting
- 				      * Others = the new memory clock
- 				      */
- 	unsigned short masterClock;  /**
- 				      * Speed of master clock in MHz unit
- 				      * 0 = keep the current clock setting
- 				      * Others = the new master clock
- 				      */
- 	unsigned short setAllEngOff; /**
- 				      * 0 = leave all engine state untouched.
- 				      * 1 = make sure they are off: 2D, Overlay,
- 				      * video alpha, alpha, hardware cursors
- 				      */
- 	unsigned char resetMemory;   /**
- 				      * 0 = Do not reset the memory controller
- 				      * 1 = Reset the memory controller
- 				      */
- 
- 	/* More initialization parameter can be added if needed */
- }
- initchip_param_t;
- 
- logical_chip_type_t getChipType(void);
- unsigned int calcPllValue(unsigned int request, pll_value_t *pll);
- unsigned int formatPllReg(pll_value_t *pPLL);
- void ddk750_set_mmio(void __iomem *, unsigned short, char);
- unsigned int ddk750_getVMSize(void);
- int ddk750_initHw(initchip_param_t *);
- 
- #endif
--- 0 ----
diff -rcNP linux-4.4.24/drivers/staging/sm750fb/ddk750_display.c linux-4.4.24-baikal/drivers/staging/sm750fb/ddk750_display.c
*** linux-4.4.24/drivers/staging/sm750fb/ddk750_display.c	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/staging/sm750fb/ddk750_display.c	1970-01-01 03:00:00.000000000 +0300
***************
*** 1,249 ****
- #include "ddk750_reg.h"
- #include "ddk750_help.h"
- #include "ddk750_display.h"
- #include "ddk750_power.h"
- #include "ddk750_dvi.h"
- 
- #define primaryWaitVerticalSync(delay) waitNextVerticalSync(0, delay)
- 
- static void setDisplayControl(int ctrl, int disp_state)
- {
- 	/* state != 0 means turn on both timing & plane en_bit */
- 	unsigned long ulDisplayCtrlReg, ulReservedBits;
- 	int cnt;
- 
- 	cnt = 0;
- 
- 	/* Set the primary display control */
- 	if (!ctrl) {
- 		ulDisplayCtrlReg = PEEK32(PANEL_DISPLAY_CTRL);
- 		/* Turn on/off the Panel display control */
- 		if (disp_state) {
- 			/* Timing should be enabled first before enabling the plane
- 			 * because changing at the same time does not guarantee that
- 			 * the plane will also enabled or disabled.
- 			 */
- 			ulDisplayCtrlReg = FIELD_SET(ulDisplayCtrlReg,
- 								PANEL_DISPLAY_CTRL, TIMING, ENABLE);
- 			POKE32(PANEL_DISPLAY_CTRL, ulDisplayCtrlReg);
- 
- 			ulDisplayCtrlReg = FIELD_SET(ulDisplayCtrlReg,
- 								PANEL_DISPLAY_CTRL, PLANE, ENABLE);
- 
- 			/* Added some masks to mask out the reserved bits.
- 			 * Sometimes, the reserved bits are set/reset randomly when
- 			 * writing to the PRIMARY_DISPLAY_CTRL, therefore, the register
- 			 * reserved bits are needed to be masked out.
- 			 */
- 			ulReservedBits = FIELD_SET(0, PANEL_DISPLAY_CTRL, RESERVED_1_MASK, ENABLE) |
- 				FIELD_SET(0, PANEL_DISPLAY_CTRL, RESERVED_2_MASK, ENABLE) |
- 				FIELD_SET(0, PANEL_DISPLAY_CTRL, RESERVED_3_MASK, ENABLE);
- 
- 			/* Somehow the register value on the plane is not set
- 			 * until a few delay. Need to write
- 			 * and read it a couple times
- 			 */
- 			do {
- 				cnt++;
- 				POKE32(PANEL_DISPLAY_CTRL, ulDisplayCtrlReg);
- 			} while ((PEEK32(PANEL_DISPLAY_CTRL) & ~ulReservedBits) !=
- 					(ulDisplayCtrlReg & ~ulReservedBits));
- 			printk("Set Panel Plane enbit:after tried %d times\n", cnt);
- 		} else {
- 			/* When turning off, there is no rule on the programming
- 			 * sequence since whenever the clock is off, then it does not
- 			 * matter whether the plane is enabled or disabled.
- 			 * Note: Modifying the plane bit will take effect on the
- 			 * next vertical sync. Need to find out if it is necessary to
- 			 * wait for 1 vsync before modifying the timing enable bit.
- 			 * */
- 			ulDisplayCtrlReg = FIELD_SET(ulDisplayCtrlReg,
- 								PANEL_DISPLAY_CTRL, PLANE, DISABLE);
- 			POKE32(PANEL_DISPLAY_CTRL, ulDisplayCtrlReg);
- 
- 			ulDisplayCtrlReg = FIELD_SET(ulDisplayCtrlReg,
- 								PANEL_DISPLAY_CTRL, TIMING, DISABLE);
- 			POKE32(PANEL_DISPLAY_CTRL, ulDisplayCtrlReg);
- 		}
- 
- 	} else {
- 		/* Set the secondary display control */
- 		ulDisplayCtrlReg = PEEK32(CRT_DISPLAY_CTRL);
- 
- 		if (disp_state) {
- 			/* Timing should be enabled first before enabling the plane because changing at the
- 			   same time does not guarantee that the plane will also enabled or disabled.
- 			   */
- 			ulDisplayCtrlReg = FIELD_SET(ulDisplayCtrlReg,
- 								CRT_DISPLAY_CTRL, TIMING, ENABLE);
- 			POKE32(CRT_DISPLAY_CTRL, ulDisplayCtrlReg);
- 
- 			ulDisplayCtrlReg = FIELD_SET(ulDisplayCtrlReg,
- 								CRT_DISPLAY_CTRL, PLANE, ENABLE);
- 
- 			/* Added some masks to mask out the reserved bits.
- 			 * Sometimes, the reserved bits are set/reset randomly when
- 			 * writing to the PRIMARY_DISPLAY_CTRL, therefore, the register
- 			 * reserved bits are needed to be masked out.
- 			 */
- 
- 			ulReservedBits = FIELD_SET(0, CRT_DISPLAY_CTRL, RESERVED_1_MASK, ENABLE) |
- 				FIELD_SET(0, CRT_DISPLAY_CTRL, RESERVED_2_MASK, ENABLE) |
- 				FIELD_SET(0, CRT_DISPLAY_CTRL, RESERVED_3_MASK, ENABLE) |
- 				FIELD_SET(0, CRT_DISPLAY_CTRL, RESERVED_4_MASK, ENABLE);
- 
- 			do {
- 				cnt++;
- 				POKE32(CRT_DISPLAY_CTRL, ulDisplayCtrlReg);
- 			} while ((PEEK32(CRT_DISPLAY_CTRL) & ~ulReservedBits) !=
- 					(ulDisplayCtrlReg & ~ulReservedBits));
- 				printk("Set Crt Plane enbit:after tried %d times\n", cnt);
- 		} else {
- 			/* When turning off, there is no rule on the programming
- 			 * sequence since whenever the clock is off, then it does not
- 			 * matter whether the plane is enabled or disabled.
- 			 * Note: Modifying the plane bit will take effect on the next
- 			 * vertical sync. Need to find out if it is necessary to
- 			 * wait for 1 vsync before modifying the timing enable bit.
- 			 */
- 			ulDisplayCtrlReg = FIELD_SET(ulDisplayCtrlReg,
- 								CRT_DISPLAY_CTRL, PLANE, DISABLE);
- 			POKE32(CRT_DISPLAY_CTRL, ulDisplayCtrlReg);
- 
- 			ulDisplayCtrlReg = FIELD_SET(ulDisplayCtrlReg,
- 								CRT_DISPLAY_CTRL, TIMING, DISABLE);
- 			POKE32(CRT_DISPLAY_CTRL, ulDisplayCtrlReg);
- 		}
- 	}
- }
- 
- static void waitNextVerticalSync(int ctrl, int delay)
- {
- 	unsigned int status;
- 
- 	if (!ctrl) {
- 		/* primary controller */
- 
- 		/* Do not wait when the Primary PLL is off or display control is already off.
- 		   This will prevent the software to wait forever. */
- 		if ((FIELD_GET(PEEK32(PANEL_PLL_CTRL), PANEL_PLL_CTRL, POWER) ==
- 			 PANEL_PLL_CTRL_POWER_OFF) ||
- 			(FIELD_GET(PEEK32(PANEL_DISPLAY_CTRL), PANEL_DISPLAY_CTRL, TIMING) ==
- 			 PANEL_DISPLAY_CTRL_TIMING_DISABLE)) {
- 			return;
- 		}
- 
- 		while (delay-- > 0) {
- 			/* Wait for end of vsync. */
- 			do {
- 				status = FIELD_GET(PEEK32(SYSTEM_CTRL),
- 						   SYSTEM_CTRL,
- 						   PANEL_VSYNC);
- 			} while (status == SYSTEM_CTRL_PANEL_VSYNC_ACTIVE);
- 
- 			/* Wait for start of vsync. */
- 			do {
- 				status = FIELD_GET(PEEK32(SYSTEM_CTRL),
- 						   SYSTEM_CTRL,
- 						   PANEL_VSYNC);
- 			} while (status == SYSTEM_CTRL_PANEL_VSYNC_INACTIVE);
- 		}
- 
- 	} else {
- 
- 		/* Do not wait when the Primary PLL is off or display control is already off.
- 			   This will prevent the software to wait forever. */
- 		if ((FIELD_GET(PEEK32(CRT_PLL_CTRL), CRT_PLL_CTRL, POWER) ==
- 			 CRT_PLL_CTRL_POWER_OFF) ||
- 			(FIELD_GET(PEEK32(CRT_DISPLAY_CTRL), CRT_DISPLAY_CTRL, TIMING) ==
- 			 CRT_DISPLAY_CTRL_TIMING_DISABLE)) {
- 			return;
- 		}
- 
- 		while (delay-- > 0) {
- 			/* Wait for end of vsync. */
- 			do {
- 				status = FIELD_GET(PEEK32(SYSTEM_CTRL),
- 								   SYSTEM_CTRL,
- 								   CRT_VSYNC);
- 			} while (status == SYSTEM_CTRL_CRT_VSYNC_ACTIVE);
- 
- 			/* Wait for start of vsync. */
- 			do {
- 				status = FIELD_GET(PEEK32(SYSTEM_CTRL),
- 								   SYSTEM_CTRL,
- 								   CRT_VSYNC);
- 			} while (status == SYSTEM_CTRL_CRT_VSYNC_INACTIVE);
- 		}
- 	}
- }
- 
- static void swPanelPowerSequence(int disp, int delay)
- {
- 	unsigned int reg;
- 
- 	/* disp should be 1 to open sequence */
- 	reg = PEEK32(PANEL_DISPLAY_CTRL);
- 	reg = FIELD_VALUE(reg, PANEL_DISPLAY_CTRL, FPEN, disp);
- 	POKE32(PANEL_DISPLAY_CTRL, reg);
- 	primaryWaitVerticalSync(delay);
- 
- 	reg = PEEK32(PANEL_DISPLAY_CTRL);
- 	reg = FIELD_VALUE(reg, PANEL_DISPLAY_CTRL, DATA, disp);
- 	POKE32(PANEL_DISPLAY_CTRL, reg);
- 	primaryWaitVerticalSync(delay);
- 
- 	reg = PEEK32(PANEL_DISPLAY_CTRL);
- 	reg = FIELD_VALUE(reg, PANEL_DISPLAY_CTRL, VBIASEN, disp);
- 	POKE32(PANEL_DISPLAY_CTRL, reg);
- 	primaryWaitVerticalSync(delay);
- 
- 	reg = PEEK32(PANEL_DISPLAY_CTRL);
- 	reg = FIELD_VALUE(reg, PANEL_DISPLAY_CTRL, FPEN, disp);
- 	POKE32(PANEL_DISPLAY_CTRL, reg);
- 	primaryWaitVerticalSync(delay);
- 
- }
- 
- void ddk750_setLogicalDispOut(disp_output_t output)
- {
- 	unsigned int reg;
- 
- 	if (output & PNL_2_USAGE) {
- 		/* set panel path controller select */
- 		reg = PEEK32(PANEL_DISPLAY_CTRL);
- 		reg = FIELD_VALUE(reg, PANEL_DISPLAY_CTRL, SELECT, (output & PNL_2_MASK)>>PNL_2_OFFSET);
- 		POKE32(PANEL_DISPLAY_CTRL, reg);
- 	}
- 
- 	if (output & CRT_2_USAGE) {
- 		/* set crt path controller select */
- 		reg = PEEK32(CRT_DISPLAY_CTRL);
- 		reg = FIELD_VALUE(reg, CRT_DISPLAY_CTRL, SELECT, (output & CRT_2_MASK)>>CRT_2_OFFSET);
- 		/*se blank off */
- 		reg = FIELD_SET(reg, CRT_DISPLAY_CTRL, BLANK, OFF);
- 		POKE32(CRT_DISPLAY_CTRL, reg);
- 
- 	}
- 
- 	if (output & PRI_TP_USAGE) {
- 		/* set primary timing and plane en_bit */
- 		setDisplayControl(0, (output & PRI_TP_MASK) >> PRI_TP_OFFSET);
- 	}
- 
- 	if (output & SEC_TP_USAGE) {
- 		/* set secondary timing and plane en_bit*/
- 		setDisplayControl(1, (output & SEC_TP_MASK) >> SEC_TP_OFFSET);
- 	}
- 
- 	if (output & PNL_SEQ_USAGE) {
- 		/* set  panel sequence */
- 		swPanelPowerSequence((output & PNL_SEQ_MASK) >> PNL_SEQ_OFFSET, 4);
- 	}
- 
- 	if (output & DAC_USAGE)
- 		setDAC((output & DAC_MASK) >> DAC_OFFSET);
- 
- 	if (output & DPMS_USAGE)
- 		ddk750_setDPMS((output & DPMS_MASK) >> DPMS_OFFSET);
- }
--- 0 ----
diff -rcNP linux-4.4.24/drivers/staging/sm750fb/ddk750_display.h linux-4.4.24-baikal/drivers/staging/sm750fb/ddk750_display.h
*** linux-4.4.24/drivers/staging/sm750fb/ddk750_display.h	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/staging/sm750fb/ddk750_display.h	1970-01-01 03:00:00.000000000 +0300
***************
*** 1,104 ****
- #ifndef DDK750_DISPLAY_H__
- #define DDK750_DISPLAY_H__
- 
- /* panel path select
- 	80000[29:28]
- */
- 
- #define PNL_2_OFFSET 0
- #define PNL_2_MASK (3 << PNL_2_OFFSET)
- #define PNL_2_USAGE	(PNL_2_MASK << 16)
- #define PNL_2_PRI	((0 << PNL_2_OFFSET)|PNL_2_USAGE)
- #define PNL_2_SEC	((2 << PNL_2_OFFSET)|PNL_2_USAGE)
- 
- 
- /* primary timing & plane enable bit
- 	1: 80000[8] & 80000[2] on
- 	0: both off
- */
- #define PRI_TP_OFFSET 4
- #define PRI_TP_MASK BIT(PRI_TP_OFFSET)
- #define PRI_TP_USAGE (PRI_TP_MASK << 16)
- #define PRI_TP_ON ((0x1 << PRI_TP_OFFSET)|PRI_TP_USAGE)
- #define PRI_TP_OFF ((0x0 << PRI_TP_OFFSET)|PRI_TP_USAGE)
- 
- 
- /* panel sequency status
- 	80000[27:24]
- */
- #define PNL_SEQ_OFFSET 6
- #define PNL_SEQ_MASK BIT(PNL_SEQ_OFFSET)
- #define PNL_SEQ_USAGE (PNL_SEQ_MASK << 16)
- #define PNL_SEQ_ON (BIT(PNL_SEQ_OFFSET)|PNL_SEQ_USAGE)
- #define PNL_SEQ_OFF ((0 << PNL_SEQ_OFFSET)|PNL_SEQ_USAGE)
- 
- /* dual digital output
- 	80000[19]
- */
- #define DUAL_TFT_OFFSET 8
- #define DUAL_TFT_MASK BIT(DUAL_TFT_OFFSET)
- #define DUAL_TFT_USAGE (DUAL_TFT_MASK << 16)
- #define DUAL_TFT_ON (BIT(DUAL_TFT_OFFSET)|DUAL_TFT_USAGE)
- #define DUAL_TFT_OFF ((0 << DUAL_TFT_OFFSET)|DUAL_TFT_USAGE)
- 
- /* secondary timing & plane enable bit
- 	1:80200[8] & 80200[2] on
- 	0: both off
- */
- #define SEC_TP_OFFSET 5
- #define SEC_TP_MASK BIT(SEC_TP_OFFSET)
- #define SEC_TP_USAGE (SEC_TP_MASK << 16)
- #define SEC_TP_ON  ((0x1 << SEC_TP_OFFSET)|SEC_TP_USAGE)
- #define SEC_TP_OFF ((0x0 << SEC_TP_OFFSET)|SEC_TP_USAGE)
- 
- /* crt path select
- 	80200[19:18]
- */
- #define CRT_2_OFFSET 2
- #define CRT_2_MASK (3 << CRT_2_OFFSET)
- #define CRT_2_USAGE (CRT_2_MASK << 16)
- #define CRT_2_PRI ((0x0 << CRT_2_OFFSET)|CRT_2_USAGE)
- #define CRT_2_SEC ((0x2 << CRT_2_OFFSET)|CRT_2_USAGE)
- 
- 
- /* DAC affect both DVI and DSUB
- 	4[20]
- */
- #define DAC_OFFSET 7
- #define DAC_MASK BIT(DAC_OFFSET)
- #define DAC_USAGE (DAC_MASK << 16)
- #define DAC_ON ((0x0 << DAC_OFFSET)|DAC_USAGE)
- #define DAC_OFF ((0x1 << DAC_OFFSET)|DAC_USAGE)
- 
- /* DPMS only affect D-SUB head
- 	0[31:30]
- */
- #define DPMS_OFFSET 9
- #define DPMS_MASK (3 << DPMS_OFFSET)
- #define DPMS_USAGE (DPMS_MASK << 16)
- #define DPMS_OFF ((3 << DPMS_OFFSET)|DPMS_USAGE)
- #define DPMS_ON ((0 << DPMS_OFFSET)|DPMS_USAGE)
- 
- 
- 
- /*
- 	LCD1 means panel path TFT1  & panel path DVI (so enable DAC)
- 	CRT means crt path DSUB
- */
- typedef enum _disp_output_t {
- 	do_LCD1_PRI = PNL_2_PRI|PRI_TP_ON|PNL_SEQ_ON|DAC_ON,
- 	do_LCD1_SEC = PNL_2_SEC|SEC_TP_ON|PNL_SEQ_ON|DAC_ON,
- 	do_LCD2_PRI = CRT_2_PRI|PRI_TP_ON|DUAL_TFT_ON,
- 	do_LCD2_SEC = CRT_2_SEC|SEC_TP_ON|DUAL_TFT_ON,
- 	/*
- 	do_DSUB_PRI = CRT_2_PRI|PRI_TP_ON|DPMS_ON|DAC_ON,
- 	do_DSUB_SEC = CRT_2_SEC|SEC_TP_ON|DPMS_ON|DAC_ON,
- 	*/
- 	do_CRT_PRI = CRT_2_PRI|PRI_TP_ON|DPMS_ON|DAC_ON,
- 	do_CRT_SEC = CRT_2_SEC|SEC_TP_ON|DPMS_ON|DAC_ON,
- }
- disp_output_t;
- 
- void ddk750_setLogicalDispOut(disp_output_t);
- 
- #endif
--- 0 ----
diff -rcNP linux-4.4.24/drivers/staging/sm750fb/ddk750_dvi.c linux-4.4.24-baikal/drivers/staging/sm750fb/ddk750_dvi.c
*** linux-4.4.24/drivers/staging/sm750fb/ddk750_dvi.c	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/staging/sm750fb/ddk750_dvi.c	1970-01-01 03:00:00.000000000 +0300
***************
*** 1,96 ****
- #define USE_DVICHIP
- #ifdef USE_DVICHIP
- #include "ddk750_help.h"
- #include "ddk750_reg.h"
- #include "ddk750_dvi.h"
- #include "ddk750_sii164.h"
- 
- 
- /* This global variable contains all the supported driver and its corresponding
-    function API. Please set the function pointer to NULL whenever the function
-    is not supported. */
- static dvi_ctrl_device_t g_dcftSupportedDviController[] = {
- #ifdef DVI_CTRL_SII164
- 	{
- 		.pfnInit = sii164InitChip,
- 		.pfnGetVendorId = sii164GetVendorID,
- 		.pfnGetDeviceId = sii164GetDeviceID,
- #ifdef SII164_FULL_FUNCTIONS
- 		.pfnResetChip = sii164ResetChip,
- 		.pfnGetChipString = sii164GetChipString,
- 		.pfnSetPower = sii164SetPower,
- 		.pfnEnableHotPlugDetection = sii164EnableHotPlugDetection,
- 		.pfnIsConnected = sii164IsConnected,
- 		.pfnCheckInterrupt = sii164CheckInterrupt,
- 		.pfnClearInterrupt = sii164ClearInterrupt,
- #endif
- 	},
- #endif
- };
- 
- 
- int dviInit(
- 	unsigned char edgeSelect,
- 	unsigned char busSelect,
- 	unsigned char dualEdgeClkSelect,
- 	unsigned char hsyncEnable,
- 	unsigned char vsyncEnable,
- 	unsigned char deskewEnable,
- 	unsigned char deskewSetting,
- 	unsigned char continuousSyncEnable,
- 	unsigned char pllFilterEnable,
- 	unsigned char pllFilterValue
- 			)
- {
- 	dvi_ctrl_device_t *pCurrentDviCtrl;
- 
- 	pCurrentDviCtrl = g_dcftSupportedDviController;
- 	if (pCurrentDviCtrl->pfnInit != NULL) {
- 		return pCurrentDviCtrl->pfnInit(edgeSelect, busSelect, dualEdgeClkSelect, hsyncEnable,
- 						vsyncEnable, deskewEnable, deskewSetting, continuousSyncEnable,
- 						pllFilterEnable, pllFilterValue);
- 	}
- 	return -1; /* error */
- }
- 
- 
- /*
-  *  dviGetVendorID
-  *      This function gets the vendor ID of the DVI controller chip.
-  *
-  *  Output:
-  *      Vendor ID
-  */
- unsigned short dviGetVendorID(void)
- {
- 	dvi_ctrl_device_t *pCurrentDviCtrl;
- 
- 	pCurrentDviCtrl = g_dcftSupportedDviController;
- 	if (pCurrentDviCtrl != (dvi_ctrl_device_t *)0)
- 		return pCurrentDviCtrl->pfnGetVendorId();
- 
- 	return 0x0000;
- }
- 
- 
- /*
-  *  dviGetDeviceID
-  *      This function gets the device ID of the DVI controller chip.
-  *
-  *  Output:
-  *      Device ID
-  */
- unsigned short dviGetDeviceID(void)
- {
- 	dvi_ctrl_device_t *pCurrentDviCtrl;
- 
- 	pCurrentDviCtrl = g_dcftSupportedDviController;
- 	if (pCurrentDviCtrl != (dvi_ctrl_device_t *)0)
- 		return pCurrentDviCtrl->pfnGetDeviceId();
- 
- 	return 0x0000;
- }
- 
- #endif
- 
- 
--- 0 ----
diff -rcNP linux-4.4.24/drivers/staging/sm750fb/ddk750_dvi.h linux-4.4.24-baikal/drivers/staging/sm750fb/ddk750_dvi.h
*** linux-4.4.24/drivers/staging/sm750fb/ddk750_dvi.h	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/staging/sm750fb/ddk750_dvi.h	1970-01-01 03:00:00.000000000 +0300
***************
*** 1,62 ****
- #ifndef DDK750_DVI_H__
- #define DDK750_DVI_H__
- 
- /* dvi chip stuffs structros */
- 
- typedef long (*PFN_DVICTRL_INIT)(
- 	unsigned char edgeSelect,
- 	unsigned char busSelect,
- 	unsigned char dualEdgeClkSelect,
- 	unsigned char hsyncEnable,
- 	unsigned char vsyncEnable,
- 	unsigned char deskewEnable,
- 	unsigned char deskewSetting,
- 	unsigned char continuousSyncEnable,
- 	unsigned char pllFilterEnable,
- 	unsigned char pllFilterValue);
- 
- typedef void (*PFN_DVICTRL_RESETCHIP)(void);
- typedef char* (*PFN_DVICTRL_GETCHIPSTRING)(void);
- typedef unsigned short (*PFN_DVICTRL_GETVENDORID)(void);
- typedef unsigned short (*PFN_DVICTRL_GETDEVICEID)(void);
- typedef void (*PFN_DVICTRL_SETPOWER)(unsigned char powerUp);
- typedef void (*PFN_DVICTRL_HOTPLUGDETECTION)(unsigned char enableHotPlug);
- typedef unsigned char (*PFN_DVICTRL_ISCONNECTED)(void);
- typedef unsigned char (*PFN_DVICTRL_CHECKINTERRUPT)(void);
- typedef void (*PFN_DVICTRL_CLEARINTERRUPT)(void);
- 
- /* Structure to hold all the function pointer to the DVI Controller. */
- typedef struct _dvi_ctrl_device_t {
- 	PFN_DVICTRL_INIT		pfnInit;
- 	PFN_DVICTRL_RESETCHIP		pfnResetChip;
- 	PFN_DVICTRL_GETCHIPSTRING	pfnGetChipString;
- 	PFN_DVICTRL_GETVENDORID		pfnGetVendorId;
- 	PFN_DVICTRL_GETDEVICEID		pfnGetDeviceId;
- 	PFN_DVICTRL_SETPOWER		pfnSetPower;
- 	PFN_DVICTRL_HOTPLUGDETECTION	pfnEnableHotPlugDetection;
- 	PFN_DVICTRL_ISCONNECTED		pfnIsConnected;
- 	PFN_DVICTRL_CHECKINTERRUPT	pfnCheckInterrupt;
- 	PFN_DVICTRL_CLEARINTERRUPT	pfnClearInterrupt;
- } dvi_ctrl_device_t;
- 
- #define DVI_CTRL_SII164
- 
- /* dvi functions prototype */
- int dviInit(
- 	unsigned char edgeSelect,
- 	unsigned char busSelect,
- 	unsigned char dualEdgeClkSelect,
- 	unsigned char hsyncEnable,
- 	unsigned char vsyncEnable,
- 	unsigned char deskewEnable,
- 	unsigned char deskewSetting,
- 	unsigned char continuousSyncEnable,
- 	unsigned char pllFilterEnable,
- 	unsigned char pllFilterValue
- );
- 
- unsigned short dviGetVendorID(void);
- unsigned short dviGetDeviceID(void);
- 
- #endif
- 
--- 0 ----
diff -rcNP linux-4.4.24/drivers/staging/sm750fb/ddk750.h linux-4.4.24-baikal/drivers/staging/sm750fb/ddk750.h
*** linux-4.4.24/drivers/staging/sm750fb/ddk750.h	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/staging/sm750fb/ddk750.h	1970-01-01 03:00:00.000000000 +0300
***************
*** 1,24 ****
- #ifndef DDK750_H__
- #define DDK750_H__
- /*******************************************************************
- *
- *         Copyright (c) 2007 by Silicon Motion, Inc. (SMI)
- *
- *  All rights are reserved. Reproduction or in part is prohibited
- *  without the written consent of the copyright owner.
- *
- *  RegSC.h --- SM718 SDK
- *  This file contains the definitions for the System Configuration registers.
- *
- *******************************************************************/
- #include "ddk750_reg.h"
- #include "ddk750_mode.h"
- #include "ddk750_chip.h"
- #include "ddk750_display.h"
- #include "ddk750_power.h"
- #include "ddk750_help.h"
- #ifdef USE_HW_I2C
- #include "ddk750_hwi2c.h"
- #endif
- #include "ddk750_swi2c.h"
- #endif
--- 0 ----
diff -rcNP linux-4.4.24/drivers/staging/sm750fb/ddk750_help.c linux-4.4.24-baikal/drivers/staging/sm750fb/ddk750_help.c
*** linux-4.4.24/drivers/staging/sm750fb/ddk750_help.c	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/staging/sm750fb/ddk750_help.c	1970-01-01 03:00:00.000000000 +0300
***************
*** 1,17 ****
- #include "ddk750_help.h"
- 
- void __iomem *mmio750;
- char revId750;
- unsigned short devId750;
- 
- /* after driver mapped io registers, use this function first */
- void ddk750_set_mmio(void __iomem *addr, unsigned short devId, char revId)
- {
- 	mmio750 = addr;
- 	devId750 = devId;
- 	revId750 = revId;
- 	if (revId == 0xfe)
- 		printk("found sm750le\n");
- }
- 
- 
--- 0 ----
diff -rcNP linux-4.4.24/drivers/staging/sm750fb/ddk750_help.h linux-4.4.24-baikal/drivers/staging/sm750fb/ddk750_help.h
*** linux-4.4.24/drivers/staging/sm750fb/ddk750_help.h	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/staging/sm750fb/ddk750_help.h	1970-01-01 03:00:00.000000000 +0300
***************
*** 1,22 ****
- #ifndef DDK750_HELP_H__
- #define DDK750_HELP_H__
- #include "ddk750_chip.h"
- #ifndef USE_INTERNAL_REGISTER_ACCESS
- 
- #include <linux/ioport.h>
- #include <linux/io.h>
- #include <linux/uaccess.h>
- #include "sm750_help.h"
- 
- /* software control endianness */
- #define PEEK32(addr) readl(addr + mmio750)
- #define POKE32(addr, data) writel(data, addr + mmio750)
- 
- extern void __iomem *mmio750;
- extern char revId750;
- extern unsigned short devId750;
- #else
- /* implement if you want use it*/
- #endif
- 
- #endif
--- 0 ----
diff -rcNP linux-4.4.24/drivers/staging/sm750fb/ddk750_hwi2c.c linux-4.4.24-baikal/drivers/staging/sm750fb/ddk750_hwi2c.c
*** linux-4.4.24/drivers/staging/sm750fb/ddk750_hwi2c.c	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/staging/sm750fb/ddk750_hwi2c.c	1970-01-01 03:00:00.000000000 +0300
***************
*** 1,262 ****
- #define USE_HW_I2C
- #ifdef USE_HW_I2C
- #include "ddk750_help.h"
- #include "ddk750_reg.h"
- #include "ddk750_hwi2c.h"
- #include "ddk750_power.h"
- 
- #define MAX_HWI2C_FIFO                  16
- #define HWI2C_WAIT_TIMEOUT              0xF0000
- 
- int sm750_hw_i2c_init(
- unsigned char bus_speed_mode
- )
- {
- 	unsigned int value;
- 
- 	/* Enable GPIO 30 & 31 as IIC clock & data */
- 	value = PEEK32(GPIO_MUX);
- 
- 	value = FIELD_SET(value, GPIO_MUX, 30, I2C) |
- 			  FIELD_SET(0, GPIO_MUX, 31, I2C);
- 	POKE32(GPIO_MUX, value);
- 
- 	/* Enable Hardware I2C power.
- 	 TODO: Check if we need to enable GPIO power?
- 	 */
- 	enableI2C(1);
- 
- 	/* Enable the I2C Controller and set the bus speed mode */
- 	value = PEEK32(I2C_CTRL);
- 	if (bus_speed_mode == 0)
- 		value = FIELD_SET(value, I2C_CTRL, MODE, STANDARD);
- 	else
- 		value = FIELD_SET(value, I2C_CTRL, MODE, FAST);
- 	value = FIELD_SET(value, I2C_CTRL, EN, ENABLE);
- 	POKE32(I2C_CTRL, value);
- 
- 	return 0;
- }
- 
- void sm750_hw_i2c_close(void)
- {
- 	unsigned int value;
- 
- 	/* Disable I2C controller */
- 	value = PEEK32(I2C_CTRL);
- 	value = FIELD_SET(value, I2C_CTRL, EN, DISABLE);
- 	POKE32(I2C_CTRL, value);
- 
- 	/* Disable I2C Power */
- 	enableI2C(0);
- 
- 	/* Set GPIO 30 & 31 back as GPIO pins */
- 	value = PEEK32(GPIO_MUX);
- 	value = FIELD_SET(value, GPIO_MUX, 30, GPIO);
- 	value = FIELD_SET(value, GPIO_MUX, 31, GPIO);
- 	POKE32(GPIO_MUX, value);
- }
- 
- static long hw_i2c_wait_tx_done(void)
- {
- 	unsigned int timeout;
- 
- 	/* Wait until the transfer is completed. */
- 	timeout = HWI2C_WAIT_TIMEOUT;
- 	while ((FIELD_GET(PEEK32(I2C_STATUS),
- 			  I2C_STATUS, TX) != I2C_STATUS_TX_COMPLETED) &&
- 	       (timeout != 0))
- 		timeout--;
- 
- 	if (timeout == 0)
- 		return (-1);
- 
- 	return 0;
- }
- 
- /*
-  *  This function writes data to the i2c slave device registers.
-  *
-  *  Parameters:
-  *      addr            - i2c Slave device address
-  *      length          - Total number of bytes to be written to the device
-  *      buf             - The buffer that contains the data to be written to the
-  *                     i2c device.
-  *
-  *  Return Value:
-  *      Total number of bytes those are actually written.
-  */
- static unsigned int hw_i2c_write_data(
- 	unsigned char addr,
- 	unsigned int length,
- 	unsigned char *buf
- )
- {
- 	unsigned char count, i;
- 	unsigned int total_bytes = 0;
- 
- 	/* Set the Device Address */
- 	POKE32(I2C_SLAVE_ADDRESS, addr & ~0x01);
- 
- 	/* Write data.
- 	 * Note:
- 	 *      Only 16 byte can be accessed per i2c start instruction.
- 	 */
- 	do {
- 		/*
- 		 * Reset I2C by writing 0 to I2C_RESET register to
- 		 * clear the previous status.
- 		 */
- 		POKE32(I2C_RESET, 0);
- 
- 		/* Set the number of bytes to be written */
- 		if (length < MAX_HWI2C_FIFO)
- 			count = length - 1;
- 		else
- 			count = MAX_HWI2C_FIFO - 1;
- 		POKE32(I2C_BYTE_COUNT, count);
- 
- 		/* Move the data to the I2C data register */
- 		for (i = 0; i <= count; i++)
- 			POKE32(I2C_DATA0 + i, *buf++);
- 
- 		/* Start the I2C */
- 		POKE32(I2C_CTRL,
- 		       FIELD_SET(PEEK32(I2C_CTRL), I2C_CTRL, CTRL, START));
- 
- 		/* Wait until the transfer is completed. */
- 		if (hw_i2c_wait_tx_done() != 0)
- 			break;
- 
- 		/* Substract length */
- 		length -= (count + 1);
- 
- 		/* Total byte written */
- 		total_bytes += (count + 1);
- 
- 	} while (length > 0);
- 
- 	return total_bytes;
- }
- 
- /*
-  *  This function reads data from the slave device and stores them
-  *  in the given buffer
-  *
-  *  Parameters:
-  *      addr            - i2c Slave device address
-  *      length          - Total number of bytes to be read
-  *      buf             - Pointer to a buffer to be filled with the data read
-  *                     from the slave device. It has to be the same size as the
-  *                     length to make sure that it can keep all the data read.
-  *
-  *  Return Value:
-  *      Total number of actual bytes read from the slave device
-  */
- static unsigned int hw_i2c_read_data(
- 	unsigned char addr,
- 	unsigned int length,
- 	unsigned char *buf
- )
- {
- 	unsigned char count, i;
- 	unsigned int total_bytes = 0;
- 
- 	/* Set the Device Address */
- 	POKE32(I2C_SLAVE_ADDRESS, addr | 0x01);
- 
- 	/* Read data and save them to the buffer.
- 	 * Note:
- 	 *      Only 16 byte can be accessed per i2c start instruction.
- 	 */
- 	do {
- 		/*
- 		 * Reset I2C by writing 0 to I2C_RESET register to
- 		 * clear all the status.
- 		 */
- 		POKE32(I2C_RESET, 0);
- 
- 		/* Set the number of bytes to be read */
- 		if (length <= MAX_HWI2C_FIFO)
- 			count = length - 1;
- 		else
- 			count = MAX_HWI2C_FIFO - 1;
- 		POKE32(I2C_BYTE_COUNT, count);
- 
- 		/* Start the I2C */
- 		POKE32(I2C_CTRL,
- 		       FIELD_SET(PEEK32(I2C_CTRL), I2C_CTRL, CTRL, START));
- 
- 		/* Wait until transaction done. */
- 		if (hw_i2c_wait_tx_done() != 0)
- 			break;
- 
- 		/* Save the data to the given buffer */
- 		for (i = 0; i <= count; i++)
- 			*buf++ = PEEK32(I2C_DATA0 + i);
- 
- 		/* Substract length by 16 */
- 		length -= (count + 1);
- 
- 		/* Number of bytes read. */
- 		total_bytes += (count + 1);
- 
- 	} while (length > 0);
- 
- 	return total_bytes;
- }
- 
- /*
-  *  This function reads the slave device's register
-  *
-  *  Parameters:
-  *      deviceAddress   - i2c Slave device address which register
-  *                        to be read from
-  *      registerIndex   - Slave device's register to be read
-  *
-  *  Return Value:
-  *      Register value
-  */
- unsigned char sm750_hw_i2c_read_reg(
- 	unsigned char addr,
- 	unsigned char reg
- )
- {
- 	unsigned char value = (0xFF);
- 
- 	if (hw_i2c_write_data(addr, 1, &reg) == 1)
- 		hw_i2c_read_data(addr, 1, &value);
- 
- 	return value;
- }
- 
- /*
-  *  This function writes a value to the slave device's register
-  *
-  *  Parameters:
-  *      deviceAddress   - i2c Slave device address which register
-  *                        to be written
-  *      registerIndex   - Slave device's register to be written
-  *      data            - Data to be written to the register
-  *
-  *  Result:
-  *          0   - Success
-  *         -1   - Fail
-  */
- int sm750_hw_i2c_write_reg(
- 	unsigned char addr,
- 	unsigned char reg,
- 	unsigned char data
- )
- {
- 	unsigned char value[2];
- 
- 	value[0] = reg;
- 	value[1] = data;
- 	if (hw_i2c_write_data(addr, 2, value) == 2)
- 		return 0;
- 
- 	return (-1);
- }
- 
- #endif
--- 0 ----
diff -rcNP linux-4.4.24/drivers/staging/sm750fb/ddk750_hwi2c.h linux-4.4.24-baikal/drivers/staging/sm750fb/ddk750_hwi2c.h
*** linux-4.4.24/drivers/staging/sm750fb/ddk750_hwi2c.h	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/staging/sm750fb/ddk750_hwi2c.h	1970-01-01 03:00:00.000000000 +0300
***************
*** 1,11 ****
- #ifndef DDK750_HWI2C_H__
- #define DDK750_HWI2C_H__
- 
- /* hwi2c functions */
- int sm750_hw_i2c_init(unsigned char bus_speed_mode);
- void sm750_hw_i2c_close(void);
- 
- unsigned char sm750_hw_i2c_read_reg(unsigned char addr, unsigned char reg);
- int sm750_hw_i2c_write_reg(unsigned char addr, unsigned char reg,
- 			   unsigned char data);
- #endif
--- 0 ----
diff -rcNP linux-4.4.24/drivers/staging/sm750fb/ddk750_mode.c linux-4.4.24-baikal/drivers/staging/sm750fb/ddk750_mode.c
*** linux-4.4.24/drivers/staging/sm750fb/ddk750_mode.c	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/staging/sm750fb/ddk750_mode.c	1970-01-01 03:00:00.000000000 +0300
***************
*** 1,202 ****
- 
- #include "ddk750_help.h"
- #include "ddk750_reg.h"
- #include "ddk750_mode.h"
- #include "ddk750_chip.h"
- 
- /*
- 	SM750LE only:
-     This function takes care extra registers and bit fields required to set
-     up a mode in SM750LE
- 
- 	Explanation about Display Control register:
-     HW only supports 7 predefined pixel clocks, and clock select is
-     in bit 29:27 of	Display Control register.
- */
- static unsigned long displayControlAdjust_SM750LE(mode_parameter_t *pModeParam, unsigned long dispControl)
- {
- 	unsigned long x, y;
- 
- 	x = pModeParam->horizontal_display_end;
- 	y = pModeParam->vertical_display_end;
- 
- 	/* SM750LE has to set up the top-left and bottom-right
- 	   registers as well.
- 	   Note that normal SM750/SM718 only use those two register for
- 	   auto-centering mode.
- 	 */
- 	POKE32(CRT_AUTO_CENTERING_TL,
- 	FIELD_VALUE(0, CRT_AUTO_CENTERING_TL, TOP, 0)
- 	| FIELD_VALUE(0, CRT_AUTO_CENTERING_TL, LEFT, 0));
- 
- 	POKE32(CRT_AUTO_CENTERING_BR,
- 	FIELD_VALUE(0, CRT_AUTO_CENTERING_BR, BOTTOM, y-1)
- 	| FIELD_VALUE(0, CRT_AUTO_CENTERING_BR, RIGHT, x-1));
- 
- 	/* Assume common fields in dispControl have been properly set before
- 	   calling this function.
- 	   This function only sets the extra fields in dispControl.
- 	 */
- 
- 	/* Clear bit 29:27 of display control register */
- 	dispControl &= FIELD_CLEAR(CRT_DISPLAY_CTRL, CLK);
- 
- 	/* Set bit 29:27 of display control register for the right clock */
- 	/* Note that SM750LE only need to supported 7 resoluitons. */
- 	if (x == 800 && y == 600)
- 		dispControl = FIELD_SET(dispControl, CRT_DISPLAY_CTRL, CLK, PLL41);
- 	else if (x == 1024 && y == 768)
- 		dispControl = FIELD_SET(dispControl, CRT_DISPLAY_CTRL, CLK, PLL65);
- 	else if (x == 1152 && y == 864)
- 		dispControl = FIELD_SET(dispControl, CRT_DISPLAY_CTRL, CLK, PLL80);
- 	else if (x == 1280 && y == 768)
- 		dispControl = FIELD_SET(dispControl, CRT_DISPLAY_CTRL, CLK, PLL80);
- 	else if (x == 1280 && y == 720)
- 		dispControl = FIELD_SET(dispControl, CRT_DISPLAY_CTRL, CLK, PLL74);
- 	else if (x == 1280 && y == 960)
- 		dispControl = FIELD_SET(dispControl, CRT_DISPLAY_CTRL, CLK, PLL108);
- 	else if (x == 1280 && y == 1024)
- 		dispControl = FIELD_SET(dispControl, CRT_DISPLAY_CTRL, CLK, PLL108);
- 	else /* default to VGA clock */
- 	dispControl = FIELD_SET(dispControl, CRT_DISPLAY_CTRL, CLK, PLL25);
- 
- 	/* Set bit 25:24 of display controller */
- 	dispControl = FIELD_SET(dispControl, CRT_DISPLAY_CTRL, CRTSELECT, CRT);
- 	dispControl = FIELD_SET(dispControl, CRT_DISPLAY_CTRL, RGBBIT, 24BIT);
- 
- 	/* Set bit 14 of display controller */
- 	dispControl = FIELD_SET(dispControl, CRT_DISPLAY_CTRL, CLOCK_PHASE, ACTIVE_LOW);
- 
- 	POKE32(CRT_DISPLAY_CTRL, dispControl);
- 
- 	return dispControl;
- }
- 
- 
- 
- /* only timing related registers will be  programed */
- static int programModeRegisters(mode_parameter_t *pModeParam, pll_value_t *pll)
- {
- 	int ret = 0;
- 	int cnt = 0;
- 	unsigned int ulTmpValue, ulReg;
- 
- 	if (pll->clockType == SECONDARY_PLL) {
- 		/* programe secondary pixel clock */
- 		POKE32(CRT_PLL_CTRL, formatPllReg(pll));
- 		POKE32(CRT_HORIZONTAL_TOTAL,
- 		FIELD_VALUE(0, CRT_HORIZONTAL_TOTAL, TOTAL, pModeParam->horizontal_total - 1)
- 		| FIELD_VALUE(0, CRT_HORIZONTAL_TOTAL, DISPLAY_END, pModeParam->horizontal_display_end - 1));
- 
- 		POKE32(CRT_HORIZONTAL_SYNC,
- 		FIELD_VALUE(0, CRT_HORIZONTAL_SYNC, WIDTH, pModeParam->horizontal_sync_width)
- 		| FIELD_VALUE(0, CRT_HORIZONTAL_SYNC, START, pModeParam->horizontal_sync_start - 1));
- 
- 		POKE32(CRT_VERTICAL_TOTAL,
- 		FIELD_VALUE(0, CRT_VERTICAL_TOTAL, TOTAL, pModeParam->vertical_total - 1)
- 		| FIELD_VALUE(0, CRT_VERTICAL_TOTAL, DISPLAY_END, pModeParam->vertical_display_end - 1));
- 
- 		POKE32(CRT_VERTICAL_SYNC,
- 		FIELD_VALUE(0, CRT_VERTICAL_SYNC, HEIGHT, pModeParam->vertical_sync_height)
- 		| FIELD_VALUE(0, CRT_VERTICAL_SYNC, START, pModeParam->vertical_sync_start - 1));
- 
- 
- 		ulTmpValue = FIELD_VALUE(0, CRT_DISPLAY_CTRL, VSYNC_PHASE, pModeParam->vertical_sync_polarity)|
- 					  FIELD_VALUE(0, CRT_DISPLAY_CTRL, HSYNC_PHASE, pModeParam->horizontal_sync_polarity)|
- 					  FIELD_SET(0, CRT_DISPLAY_CTRL, TIMING, ENABLE)|
- 					  FIELD_SET(0, CRT_DISPLAY_CTRL, PLANE, ENABLE);
- 
- 
- 		if (getChipType() == SM750LE) {
- 			displayControlAdjust_SM750LE(pModeParam, ulTmpValue);
- 		} else {
- 			ulReg = PEEK32(CRT_DISPLAY_CTRL)
- 					& FIELD_CLEAR(CRT_DISPLAY_CTRL, VSYNC_PHASE)
- 					& FIELD_CLEAR(CRT_DISPLAY_CTRL, HSYNC_PHASE)
- 					& FIELD_CLEAR(CRT_DISPLAY_CTRL, TIMING)
- 					& FIELD_CLEAR(CRT_DISPLAY_CTRL, PLANE);
- 
- 			 POKE32(CRT_DISPLAY_CTRL, ulTmpValue|ulReg);
- 		}
- 
- 	} else if (pll->clockType == PRIMARY_PLL) {
- 		unsigned int ulReservedBits;
- 
- 		POKE32(PANEL_PLL_CTRL, formatPllReg(pll));
- 
- 		POKE32(PANEL_HORIZONTAL_TOTAL,
- 		FIELD_VALUE(0, PANEL_HORIZONTAL_TOTAL, TOTAL, pModeParam->horizontal_total - 1)
- 		| FIELD_VALUE(0, PANEL_HORIZONTAL_TOTAL, DISPLAY_END, pModeParam->horizontal_display_end - 1));
- 
- 		POKE32(PANEL_HORIZONTAL_SYNC,
- 		FIELD_VALUE(0, PANEL_HORIZONTAL_SYNC, WIDTH, pModeParam->horizontal_sync_width)
- 		| FIELD_VALUE(0, PANEL_HORIZONTAL_SYNC, START, pModeParam->horizontal_sync_start - 1));
- 
- 		POKE32(PANEL_VERTICAL_TOTAL,
- 		FIELD_VALUE(0, PANEL_VERTICAL_TOTAL, TOTAL, pModeParam->vertical_total - 1)
- 			| FIELD_VALUE(0, PANEL_VERTICAL_TOTAL, DISPLAY_END, pModeParam->vertical_display_end - 1));
- 
- 		POKE32(PANEL_VERTICAL_SYNC,
- 		FIELD_VALUE(0, PANEL_VERTICAL_SYNC, HEIGHT, pModeParam->vertical_sync_height)
- 		| FIELD_VALUE(0, PANEL_VERTICAL_SYNC, START, pModeParam->vertical_sync_start - 1));
- 
- 		ulTmpValue = FIELD_VALUE(0, PANEL_DISPLAY_CTRL, VSYNC_PHASE, pModeParam->vertical_sync_polarity)|
- 			     FIELD_VALUE(0, PANEL_DISPLAY_CTRL, HSYNC_PHASE, pModeParam->horizontal_sync_polarity)|
- 			     FIELD_VALUE(0, PANEL_DISPLAY_CTRL, CLOCK_PHASE, pModeParam->clock_phase_polarity)|
- 			     FIELD_SET(0, PANEL_DISPLAY_CTRL, TIMING, ENABLE)|
- 			     FIELD_SET(0, PANEL_DISPLAY_CTRL, PLANE, ENABLE);
- 
- 		ulReservedBits = FIELD_SET(0, PANEL_DISPLAY_CTRL, RESERVED_1_MASK, ENABLE) |
- 				 FIELD_SET(0, PANEL_DISPLAY_CTRL, RESERVED_2_MASK, ENABLE) |
- 				 FIELD_SET(0, PANEL_DISPLAY_CTRL, RESERVED_3_MASK, ENABLE)|
- 				 FIELD_SET(0, PANEL_DISPLAY_CTRL, VSYNC, ACTIVE_LOW);
- 
- 		ulReg = (PEEK32(PANEL_DISPLAY_CTRL) & ~ulReservedBits)
- 			& FIELD_CLEAR(PANEL_DISPLAY_CTRL, CLOCK_PHASE)
- 			& FIELD_CLEAR(PANEL_DISPLAY_CTRL, VSYNC_PHASE)
- 			& FIELD_CLEAR(PANEL_DISPLAY_CTRL, HSYNC_PHASE)
- 			& FIELD_CLEAR(PANEL_DISPLAY_CTRL, TIMING)
- 			& FIELD_CLEAR(PANEL_DISPLAY_CTRL, PLANE);
- 
- 
- 		/* May a hardware bug or just my test chip (not confirmed).
- 		* PANEL_DISPLAY_CTRL register seems requiring few writes
- 		* before a value can be successfully written in.
- 		* Added some masks to mask out the reserved bits.
- 		* Note: This problem happens by design. The hardware will wait for the
- 		*       next vertical sync to turn on/off the plane.
- 		*/
- 
- 		POKE32(PANEL_DISPLAY_CTRL, ulTmpValue|ulReg);
- 
- 		while ((PEEK32(PANEL_DISPLAY_CTRL) & ~ulReservedBits) != (ulTmpValue|ulReg)) {
- 			cnt++;
- 			if (cnt > 1000)
- 				break;
- 			POKE32(PANEL_DISPLAY_CTRL, ulTmpValue|ulReg);
- 		}
- 	} else {
- 		ret = -1;
- 	}
- 	return ret;
- }
- 
- int ddk750_setModeTiming(mode_parameter_t *parm, clock_type_t clock)
- {
- 	pll_value_t pll;
- 	unsigned int uiActualPixelClk;
- 
- 	pll.inputFreq = DEFAULT_INPUT_CLOCK;
- 	pll.clockType = clock;
- 
- 	uiActualPixelClk = calcPllValue(parm->pixel_clock, &pll);
- 	if (getChipType() == SM750LE) {
- 		/* set graphic mode via IO method */
- 		outb_p(0x88, 0x3d4);
- 		outb_p(0x06, 0x3d5);
- 	}
- 	programModeRegisters(parm, &pll);
- 	return 0;
- }
- 
- 
--- 0 ----
diff -rcNP linux-4.4.24/drivers/staging/sm750fb/ddk750_mode.h linux-4.4.24-baikal/drivers/staging/sm750fb/ddk750_mode.h
*** linux-4.4.24/drivers/staging/sm750fb/ddk750_mode.h	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/staging/sm750fb/ddk750_mode.h	1970-01-01 03:00:00.000000000 +0300
***************
*** 1,41 ****
- #ifndef DDK750_MODE_H__
- #define DDK750_MODE_H__
- 
- #include "ddk750_chip.h"
- 
- typedef enum _spolarity_t {
- 	POS = 0, /* positive */
- 	NEG, /* negative */
- }
- spolarity_t;
- 
- 
- typedef struct _mode_parameter_t {
- 	/* Horizontal timing. */
- 	unsigned long horizontal_total;
- 	unsigned long horizontal_display_end;
- 	unsigned long horizontal_sync_start;
- 	unsigned long horizontal_sync_width;
- 	spolarity_t horizontal_sync_polarity;
- 
- 	/* Vertical timing. */
- 	unsigned long vertical_total;
- 	unsigned long vertical_display_end;
- 	unsigned long vertical_sync_start;
- 	unsigned long vertical_sync_height;
- 	spolarity_t vertical_sync_polarity;
- 
- 	/* Refresh timing. */
- 	unsigned long pixel_clock;
- 	unsigned long horizontal_frequency;
- 	unsigned long vertical_frequency;
- 
- 	/* Clock Phase. This clock phase only applies to Panel. */
- 	spolarity_t clock_phase_polarity;
- }
- mode_parameter_t;
- 
- int ddk750_setModeTiming(mode_parameter_t *, clock_type_t);
- 
- 
- #endif
--- 0 ----
diff -rcNP linux-4.4.24/drivers/staging/sm750fb/ddk750_power.c linux-4.4.24-baikal/drivers/staging/sm750fb/ddk750_power.c
*** linux-4.4.24/drivers/staging/sm750fb/ddk750_power.c	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/staging/sm750fb/ddk750_power.c	1970-01-01 03:00:00.000000000 +0300
***************
*** 1,173 ****
- #include "ddk750_help.h"
- #include "ddk750_reg.h"
- #include "ddk750_power.h"
- 
- void ddk750_setDPMS(DPMS_t state)
- {
- 	unsigned int value;
- 
- 	if (getChipType() == SM750LE) {
- 		value = PEEK32(CRT_DISPLAY_CTRL);
- 		POKE32(CRT_DISPLAY_CTRL, FIELD_VALUE(value, CRT_DISPLAY_CTRL,
- 						     DPMS, state));
- 	} else {
- 		value = PEEK32(SYSTEM_CTRL);
- 		value = FIELD_VALUE(value, SYSTEM_CTRL, DPMS, state);
- 		POKE32(SYSTEM_CTRL, value);
- 	}
- }
- 
- static unsigned int getPowerMode(void)
- {
- 	if (getChipType() == SM750LE)
- 		return 0;
- 	return FIELD_GET(PEEK32(POWER_MODE_CTRL), POWER_MODE_CTRL, MODE);
- }
- 
- 
- /*
-  * SM50x can operate in one of three modes: 0, 1 or Sleep.
-  * On hardware reset, power mode 0 is default.
-  */
- void setPowerMode(unsigned int powerMode)
- {
- 	unsigned int control_value = 0;
- 
- 	control_value = PEEK32(POWER_MODE_CTRL);
- 
- 	if (getChipType() == SM750LE)
- 		return;
- 
- 	switch (powerMode) {
- 	case POWER_MODE_CTRL_MODE_MODE0:
- 		control_value = FIELD_SET(control_value, POWER_MODE_CTRL, MODE,
- 					  MODE0);
- 		break;
- 
- 	case POWER_MODE_CTRL_MODE_MODE1:
- 		control_value = FIELD_SET(control_value, POWER_MODE_CTRL, MODE,
- 					  MODE1);
- 		break;
- 
- 	case POWER_MODE_CTRL_MODE_SLEEP:
- 		control_value = FIELD_SET(control_value, POWER_MODE_CTRL, MODE,
- 					  SLEEP);
- 		break;
- 
- 	default:
- 		break;
- 	}
- 
- 	/* Set up other fields in Power Control Register */
- 	if (powerMode == POWER_MODE_CTRL_MODE_SLEEP) {
- 		control_value =
- #ifdef VALIDATION_CHIP
- 		FIELD_SET(control_value, POWER_MODE_CTRL, 336CLK, OFF) |
- #endif
- 		FIELD_SET(control_value, POWER_MODE_CTRL, OSC_INPUT,  OFF);
- 	} else {
- 		control_value =
- #ifdef VALIDATION_CHIP
- 		FIELD_SET(control_value, POWER_MODE_CTRL, 336CLK, ON) |
- #endif
- 		FIELD_SET(control_value, POWER_MODE_CTRL, OSC_INPUT,  ON);
- 	}
- 
- 	/* Program new power mode. */
- 	POKE32(POWER_MODE_CTRL, control_value);
- }
- 
- void setCurrentGate(unsigned int gate)
- {
- 	unsigned int gate_reg;
- 	unsigned int mode;
- 
- 	/* Get current power mode. */
- 	mode = getPowerMode();
- 
- 	switch (mode) {
- 	case POWER_MODE_CTRL_MODE_MODE0:
- 		gate_reg = MODE0_GATE;
- 		break;
- 
- 	case POWER_MODE_CTRL_MODE_MODE1:
- 		gate_reg = MODE1_GATE;
- 		break;
- 
- 	default:
- 		gate_reg = MODE0_GATE;
- 		break;
- 	}
- 	POKE32(gate_reg, gate);
- }
- 
- 
- 
- /*
-  * This function enable/disable the 2D engine.
-  */
- void enable2DEngine(unsigned int enable)
- {
- 	u32 gate;
- 
- 	gate = PEEK32(CURRENT_GATE);
- 	if (enable) {
- 		gate = FIELD_SET(gate, CURRENT_GATE, DE,  ON);
- 		gate = FIELD_SET(gate, CURRENT_GATE, CSC, ON);
- 	} else {
- 		gate = FIELD_SET(gate, CURRENT_GATE, DE,  OFF);
- 		gate = FIELD_SET(gate, CURRENT_GATE, CSC, OFF);
- 	}
- 
- 	setCurrentGate(gate);
- }
- 
- void enableDMA(unsigned int enable)
- {
- 	u32 gate;
- 
- 	/* Enable DMA Gate */
- 	gate = PEEK32(CURRENT_GATE);
- 	if (enable)
- 		gate = FIELD_SET(gate, CURRENT_GATE, DMA, ON);
- 	else
- 		gate = FIELD_SET(gate, CURRENT_GATE, DMA, OFF);
- 
- 	setCurrentGate(gate);
- }
- 
- /*
-  * This function enable/disable the GPIO Engine
-  */
- void enableGPIO(unsigned int enable)
- {
- 	u32 gate;
- 
- 	/* Enable GPIO Gate */
- 	gate = PEEK32(CURRENT_GATE);
- 	if (enable)
- 		gate = FIELD_SET(gate, CURRENT_GATE, GPIO, ON);
- 	else
- 		gate = FIELD_SET(gate, CURRENT_GATE, GPIO, OFF);
- 
- 	setCurrentGate(gate);
- }
- 
- /*
-  * This function enable/disable the I2C Engine
-  */
- void enableI2C(unsigned int enable)
- {
- 	u32 gate;
- 
- 	/* Enable I2C Gate */
- 	gate = PEEK32(CURRENT_GATE);
- 	if (enable)
- 		gate = FIELD_SET(gate, CURRENT_GATE, I2C, ON);
- 	else
- 	gate = FIELD_SET(gate, CURRENT_GATE, I2C, OFF);
- 
- 	setCurrentGate(gate);
- }
- 
- 
--- 0 ----
diff -rcNP linux-4.4.24/drivers/staging/sm750fb/ddk750_power.h linux-4.4.24-baikal/drivers/staging/sm750fb/ddk750_power.h
*** linux-4.4.24/drivers/staging/sm750fb/ddk750_power.h	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/staging/sm750fb/ddk750_power.h	1970-01-01 03:00:00.000000000 +0300
***************
*** 1,53 ****
- #ifndef DDK750_POWER_H__
- #define DDK750_POWER_H__
- 
- typedef enum _DPMS_t {
- 	crtDPMS_ON = 0x0,
- 	crtDPMS_STANDBY = 0x1,
- 	crtDPMS_SUSPEND = 0x2,
- 	crtDPMS_OFF = 0x3,
- }
- DPMS_t;
- 
- #define setDAC(off) \
- 		{	\
- 		POKE32(MISC_CTRL, FIELD_VALUE(PEEK32(MISC_CTRL), \
- 									MISC_CTRL,	\
- 									DAC_POWER,	\
- 									off));	\
- 		}
- 
- void ddk750_setDPMS(DPMS_t);
- 
- /*
-  * This function sets the current power mode
-  */
- void setPowerMode(unsigned int powerMode);
- 
- /*
-  * This function sets current gate
-  */
- void setCurrentGate(unsigned int gate);
- 
- /*
-  * This function enable/disable the 2D engine.
-  */
- void enable2DEngine(unsigned int enable);
- 
- /*
-  * This function enable/disable the DMA Engine
-  */
- void enableDMA(unsigned int enable);
- 
- /*
-  * This function enable/disable the GPIO Engine
-  */
- void enableGPIO(unsigned int enable);
- 
- /*
-  * This function enable/disable the I2C Engine
-  */
- void enableI2C(unsigned int enable);
- 
- 
- #endif
--- 0 ----
diff -rcNP linux-4.4.24/drivers/staging/sm750fb/ddk750_reg.h linux-4.4.24-baikal/drivers/staging/sm750fb/ddk750_reg.h
*** linux-4.4.24/drivers/staging/sm750fb/ddk750_reg.h	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/staging/sm750fb/ddk750_reg.h	1970-01-01 03:00:00.000000000 +0300
***************
*** 1,2372 ****
- #ifndef DDK750_REG_H__
- #define DDK750_REG_H__
- 
- /* New register for SM750LE */
- #define DE_STATE1                                        0x100054
- #define DE_STATE1_DE_ABORT                               0:0
- #define DE_STATE1_DE_ABORT_OFF                           0
- #define DE_STATE1_DE_ABORT_ON                            1
- 
- #define DE_STATE2                                        0x100058
- #define DE_STATE2_DE_FIFO                                3:3
- #define DE_STATE2_DE_FIFO_NOTEMPTY                       0
- #define DE_STATE2_DE_FIFO_EMPTY                          1
- #define DE_STATE2_DE_STATUS                              2:2
- #define DE_STATE2_DE_STATUS_IDLE                         0
- #define DE_STATE2_DE_STATUS_BUSY                         1
- #define DE_STATE2_DE_MEM_FIFO                            1:1
- #define DE_STATE2_DE_MEM_FIFO_NOTEMPTY                   0
- #define DE_STATE2_DE_MEM_FIFO_EMPTY                      1
- #define DE_STATE2_DE_RESERVED                            0:0
- 
- 
- 
- #define SYSTEM_CTRL                                   0x000000
- #define SYSTEM_CTRL_DPMS                              31:30
- #define SYSTEM_CTRL_DPMS_VPHP                         0
- #define SYSTEM_CTRL_DPMS_VPHN                         1
- #define SYSTEM_CTRL_DPMS_VNHP                         2
- #define SYSTEM_CTRL_DPMS_VNHN                         3
- #define SYSTEM_CTRL_PCI_BURST                         29:29
- #define SYSTEM_CTRL_PCI_BURST_OFF                     0
- #define SYSTEM_CTRL_PCI_BURST_ON                      1
- #define SYSTEM_CTRL_PCI_MASTER                        25:25
- #define SYSTEM_CTRL_PCI_MASTER_OFF                    0
- #define SYSTEM_CTRL_PCI_MASTER_ON                     1
- #define SYSTEM_CTRL_LATENCY_TIMER                     24:24
- #define SYSTEM_CTRL_LATENCY_TIMER_ON                  0
- #define SYSTEM_CTRL_LATENCY_TIMER_OFF                 1
- #define SYSTEM_CTRL_DE_FIFO                           23:23
- #define SYSTEM_CTRL_DE_FIFO_NOTEMPTY                  0
- #define SYSTEM_CTRL_DE_FIFO_EMPTY                     1
- #define SYSTEM_CTRL_DE_STATUS                         22:22
- #define SYSTEM_CTRL_DE_STATUS_IDLE                    0
- #define SYSTEM_CTRL_DE_STATUS_BUSY                    1
- #define SYSTEM_CTRL_DE_MEM_FIFO                       21:21
- #define SYSTEM_CTRL_DE_MEM_FIFO_NOTEMPTY              0
- #define SYSTEM_CTRL_DE_MEM_FIFO_EMPTY                 1
- #define SYSTEM_CTRL_CSC_STATUS                        20:20
- #define SYSTEM_CTRL_CSC_STATUS_IDLE                   0
- #define SYSTEM_CTRL_CSC_STATUS_BUSY                   1
- #define SYSTEM_CTRL_CRT_VSYNC                         19:19
- #define SYSTEM_CTRL_CRT_VSYNC_INACTIVE                0
- #define SYSTEM_CTRL_CRT_VSYNC_ACTIVE                  1
- #define SYSTEM_CTRL_PANEL_VSYNC                       18:18
- #define SYSTEM_CTRL_PANEL_VSYNC_INACTIVE              0
- #define SYSTEM_CTRL_PANEL_VSYNC_ACTIVE                1
- #define SYSTEM_CTRL_CURRENT_BUFFER                    17:17
- #define SYSTEM_CTRL_CURRENT_BUFFER_NORMAL             0
- #define SYSTEM_CTRL_CURRENT_BUFFER_FLIP_PENDING       1
- #define SYSTEM_CTRL_DMA_STATUS                        16:16
- #define SYSTEM_CTRL_DMA_STATUS_IDLE                   0
- #define SYSTEM_CTRL_DMA_STATUS_BUSY                   1
- #define SYSTEM_CTRL_PCI_BURST_READ                    15:15
- #define SYSTEM_CTRL_PCI_BURST_READ_OFF                0
- #define SYSTEM_CTRL_PCI_BURST_READ_ON                 1
- #define SYSTEM_CTRL_DE_ABORT                          13:13
- #define SYSTEM_CTRL_DE_ABORT_OFF                      0
- #define SYSTEM_CTRL_DE_ABORT_ON                       1
- #define SYSTEM_CTRL_PCI_SUBSYS_ID_LOCK                11:11
- #define SYSTEM_CTRL_PCI_SUBSYS_ID_LOCK_OFF            0
- #define SYSTEM_CTRL_PCI_SUBSYS_ID_LOCK_ON             1
- #define SYSTEM_CTRL_PCI_RETRY                         7:7
- #define SYSTEM_CTRL_PCI_RETRY_ON                      0
- #define SYSTEM_CTRL_PCI_RETRY_OFF                     1
- #define SYSTEM_CTRL_PCI_SLAVE_BURST_READ_SIZE         5:4
- #define SYSTEM_CTRL_PCI_SLAVE_BURST_READ_SIZE_1       0
- #define SYSTEM_CTRL_PCI_SLAVE_BURST_READ_SIZE_2       1
- #define SYSTEM_CTRL_PCI_SLAVE_BURST_READ_SIZE_4       2
- #define SYSTEM_CTRL_PCI_SLAVE_BURST_READ_SIZE_8       3
- #define SYSTEM_CTRL_CRT_TRISTATE                      3:3
- #define SYSTEM_CTRL_CRT_TRISTATE_OFF                  0
- #define SYSTEM_CTRL_CRT_TRISTATE_ON                   1
- #define SYSTEM_CTRL_PCIMEM_TRISTATE                   2:2
- #define SYSTEM_CTRL_PCIMEM_TRISTATE_OFF               0
- #define SYSTEM_CTRL_PCIMEM_TRISTATE_ON                1
- #define SYSTEM_CTRL_LOCALMEM_TRISTATE                 1:1
- #define SYSTEM_CTRL_LOCALMEM_TRISTATE_OFF             0
- #define SYSTEM_CTRL_LOCALMEM_TRISTATE_ON              1
- #define SYSTEM_CTRL_PANEL_TRISTATE                    0:0
- #define SYSTEM_CTRL_PANEL_TRISTATE_OFF                0
- #define SYSTEM_CTRL_PANEL_TRISTATE_ON                 1
- 
- #define MISC_CTRL                                     0x000004
- #define MISC_CTRL_DRAM_RERESH_COUNT                   27:27
- #define MISC_CTRL_DRAM_RERESH_COUNT_1ROW              0
- #define MISC_CTRL_DRAM_RERESH_COUNT_3ROW              1
- #define MISC_CTRL_DRAM_REFRESH_TIME                   26:25
- #define MISC_CTRL_DRAM_REFRESH_TIME_8                 0
- #define MISC_CTRL_DRAM_REFRESH_TIME_16                1
- #define MISC_CTRL_DRAM_REFRESH_TIME_32                2
- #define MISC_CTRL_DRAM_REFRESH_TIME_64                3
- #define MISC_CTRL_INT_OUTPUT                          24:24
- #define MISC_CTRL_INT_OUTPUT_NORMAL                   0
- #define MISC_CTRL_INT_OUTPUT_INVERT                   1
- #define MISC_CTRL_PLL_CLK_COUNT                       23:23
- #define MISC_CTRL_PLL_CLK_COUNT_OFF                   0
- #define MISC_CTRL_PLL_CLK_COUNT_ON                    1
- #define MISC_CTRL_DAC_POWER                           20:20
- #define MISC_CTRL_DAC_POWER_ON                        0
- #define MISC_CTRL_DAC_POWER_OFF                       1
- #define MISC_CTRL_CLK_SELECT                          16:16
- #define MISC_CTRL_CLK_SELECT_OSC                      0
- #define MISC_CTRL_CLK_SELECT_TESTCLK                  1
- #define MISC_CTRL_DRAM_COLUMN_SIZE                    15:14
- #define MISC_CTRL_DRAM_COLUMN_SIZE_256                0
- #define MISC_CTRL_DRAM_COLUMN_SIZE_512                1
- #define MISC_CTRL_DRAM_COLUMN_SIZE_1024               2
- #define MISC_CTRL_LOCALMEM_SIZE                       13:12
- #define MISC_CTRL_LOCALMEM_SIZE_8M                    3
- #define MISC_CTRL_LOCALMEM_SIZE_16M                   0
- #define MISC_CTRL_LOCALMEM_SIZE_32M                   1
- #define MISC_CTRL_LOCALMEM_SIZE_64M                   2
- #define MISC_CTRL_DRAM_TWTR                           11:11
- #define MISC_CTRL_DRAM_TWTR_2CLK                      0
- #define MISC_CTRL_DRAM_TWTR_1CLK                      1
- #define MISC_CTRL_DRAM_TWR                            10:10
- #define MISC_CTRL_DRAM_TWR_3CLK                       0
- #define MISC_CTRL_DRAM_TWR_2CLK                       1
- #define MISC_CTRL_DRAM_TRP                            9:9
- #define MISC_CTRL_DRAM_TRP_3CLK                       0
- #define MISC_CTRL_DRAM_TRP_4CLK                       1
- #define MISC_CTRL_DRAM_TRFC                           8:8
- #define MISC_CTRL_DRAM_TRFC_12CLK                     0
- #define MISC_CTRL_DRAM_TRFC_14CLK                     1
- #define MISC_CTRL_DRAM_TRAS                           7:7
- #define MISC_CTRL_DRAM_TRAS_7CLK                      0
- #define MISC_CTRL_DRAM_TRAS_8CLK                      1
- #define MISC_CTRL_LOCALMEM_RESET                      6:6
- #define MISC_CTRL_LOCALMEM_RESET_RESET                0
- #define MISC_CTRL_LOCALMEM_RESET_NORMAL               1
- #define MISC_CTRL_LOCALMEM_STATE                      5:5
- #define MISC_CTRL_LOCALMEM_STATE_ACTIVE               0
- #define MISC_CTRL_LOCALMEM_STATE_INACTIVE             1
- #define MISC_CTRL_CPU_CAS_LATENCY                     4:4
- #define MISC_CTRL_CPU_CAS_LATENCY_2CLK                0
- #define MISC_CTRL_CPU_CAS_LATENCY_3CLK                1
- #define MISC_CTRL_DLL                                 3:3
- #define MISC_CTRL_DLL_ON                              0
- #define MISC_CTRL_DLL_OFF                             1
- #define MISC_CTRL_DRAM_OUTPUT                         2:2
- #define MISC_CTRL_DRAM_OUTPUT_LOW                     0
- #define MISC_CTRL_DRAM_OUTPUT_HIGH                    1
- #define MISC_CTRL_LOCALMEM_BUS_SIZE                   1:1
- #define MISC_CTRL_LOCALMEM_BUS_SIZE_32                0
- #define MISC_CTRL_LOCALMEM_BUS_SIZE_64                1
- #define MISC_CTRL_EMBEDDED_LOCALMEM                   0:0
- #define MISC_CTRL_EMBEDDED_LOCALMEM_ON                0
- #define MISC_CTRL_EMBEDDED_LOCALMEM_OFF               1
- 
- #define GPIO_MUX                                      0x000008
- #define GPIO_MUX_31                                   31:31
- #define GPIO_MUX_31_GPIO                              0
- #define GPIO_MUX_31_I2C                               1
- #define GPIO_MUX_30                                   30:30
- #define GPIO_MUX_30_GPIO                              0
- #define GPIO_MUX_30_I2C                               1
- #define GPIO_MUX_29                                   29:29
- #define GPIO_MUX_29_GPIO                              0
- #define GPIO_MUX_29_SSP1                              1
- #define GPIO_MUX_28                                   28:28
- #define GPIO_MUX_28_GPIO                              0
- #define GPIO_MUX_28_SSP1                              1
- #define GPIO_MUX_27                                   27:27
- #define GPIO_MUX_27_GPIO                              0
- #define GPIO_MUX_27_SSP1                              1
- #define GPIO_MUX_26                                   26:26
- #define GPIO_MUX_26_GPIO                              0
- #define GPIO_MUX_26_SSP1                              1
- #define GPIO_MUX_25                                   25:25
- #define GPIO_MUX_25_GPIO                              0
- #define GPIO_MUX_25_SSP1                              1
- #define GPIO_MUX_24                                   24:24
- #define GPIO_MUX_24_GPIO                              0
- #define GPIO_MUX_24_SSP0                              1
- #define GPIO_MUX_23                                   23:23
- #define GPIO_MUX_23_GPIO                              0
- #define GPIO_MUX_23_SSP0                              1
- #define GPIO_MUX_22                                   22:22
- #define GPIO_MUX_22_GPIO                              0
- #define GPIO_MUX_22_SSP0                              1
- #define GPIO_MUX_21                                   21:21
- #define GPIO_MUX_21_GPIO                              0
- #define GPIO_MUX_21_SSP0                              1
- #define GPIO_MUX_20                                   20:20
- #define GPIO_MUX_20_GPIO                              0
- #define GPIO_MUX_20_SSP0                              1
- #define GPIO_MUX_19                                   19:19
- #define GPIO_MUX_19_GPIO                              0
- #define GPIO_MUX_19_PWM                               1
- #define GPIO_MUX_18                                   18:18
- #define GPIO_MUX_18_GPIO                              0
- #define GPIO_MUX_18_PWM                               1
- #define GPIO_MUX_17                                   17:17
- #define GPIO_MUX_17_GPIO                              0
- #define GPIO_MUX_17_PWM                               1
- #define GPIO_MUX_16                                   16:16
- #define GPIO_MUX_16_GPIO_ZVPORT                       0
- #define GPIO_MUX_16_TEST_DATA                         1
- #define GPIO_MUX_15                                   15:15
- #define GPIO_MUX_15_GPIO_ZVPORT                       0
- #define GPIO_MUX_15_TEST_DATA                         1
- #define GPIO_MUX_14                                   14:14
- #define GPIO_MUX_14_GPIO_ZVPORT                       0
- #define GPIO_MUX_14_TEST_DATA                         1
- #define GPIO_MUX_13                                   13:13
- #define GPIO_MUX_13_GPIO_ZVPORT                       0
- #define GPIO_MUX_13_TEST_DATA                         1
- #define GPIO_MUX_12                                   12:12
- #define GPIO_MUX_12_GPIO_ZVPORT                       0
- #define GPIO_MUX_12_TEST_DATA                         1
- #define GPIO_MUX_11                                   11:11
- #define GPIO_MUX_11_GPIO_ZVPORT                       0
- #define GPIO_MUX_11_TEST_DATA                         1
- #define GPIO_MUX_10                                   10:10
- #define GPIO_MUX_10_GPIO_ZVPORT                       0
- #define GPIO_MUX_10_TEST_DATA                         1
- #define GPIO_MUX_9                                    9:9
- #define GPIO_MUX_9_GPIO_ZVPORT                        0
- #define GPIO_MUX_9_TEST_DATA                          1
- #define GPIO_MUX_8                                    8:8
- #define GPIO_MUX_8_GPIO_ZVPORT                        0
- #define GPIO_MUX_8_TEST_DATA                          1
- #define GPIO_MUX_7                                    7:7
- #define GPIO_MUX_7_GPIO_ZVPORT                        0
- #define GPIO_MUX_7_TEST_DATA                          1
- #define GPIO_MUX_6                                    6:6
- #define GPIO_MUX_6_GPIO_ZVPORT                        0
- #define GPIO_MUX_6_TEST_DATA                          1
- #define GPIO_MUX_5                                    5:5
- #define GPIO_MUX_5_GPIO_ZVPORT                        0
- #define GPIO_MUX_5_TEST_DATA                          1
- #define GPIO_MUX_4                                    4:4
- #define GPIO_MUX_4_GPIO_ZVPORT                        0
- #define GPIO_MUX_4_TEST_DATA                          1
- #define GPIO_MUX_3                                    3:3
- #define GPIO_MUX_3_GPIO_ZVPORT                        0
- #define GPIO_MUX_3_TEST_DATA                          1
- #define GPIO_MUX_2                                    2:2
- #define GPIO_MUX_2_GPIO_ZVPORT                        0
- #define GPIO_MUX_2_TEST_DATA                          1
- #define GPIO_MUX_1                                    1:1
- #define GPIO_MUX_1_GPIO_ZVPORT                        0
- #define GPIO_MUX_1_TEST_DATA                          1
- #define GPIO_MUX_0                                    0:0
- #define GPIO_MUX_0_GPIO_ZVPORT                        0
- #define GPIO_MUX_0_TEST_DATA                          1
- 
- #define LOCALMEM_ARBITRATION                          0x00000C
- #define LOCALMEM_ARBITRATION_ROTATE                   28:28
- #define LOCALMEM_ARBITRATION_ROTATE_OFF               0
- #define LOCALMEM_ARBITRATION_ROTATE_ON                1
- #define LOCALMEM_ARBITRATION_VGA                      26:24
- #define LOCALMEM_ARBITRATION_VGA_OFF                  0
- #define LOCALMEM_ARBITRATION_VGA_PRIORITY_1           1
- #define LOCALMEM_ARBITRATION_VGA_PRIORITY_2           2
- #define LOCALMEM_ARBITRATION_VGA_PRIORITY_3           3
- #define LOCALMEM_ARBITRATION_VGA_PRIORITY_4           4
- #define LOCALMEM_ARBITRATION_VGA_PRIORITY_5           5
- #define LOCALMEM_ARBITRATION_VGA_PRIORITY_6           6
- #define LOCALMEM_ARBITRATION_VGA_PRIORITY_7           7
- #define LOCALMEM_ARBITRATION_DMA                      22:20
- #define LOCALMEM_ARBITRATION_DMA_OFF                  0
- #define LOCALMEM_ARBITRATION_DMA_PRIORITY_1           1
- #define LOCALMEM_ARBITRATION_DMA_PRIORITY_2           2
- #define LOCALMEM_ARBITRATION_DMA_PRIORITY_3           3
- #define LOCALMEM_ARBITRATION_DMA_PRIORITY_4           4
- #define LOCALMEM_ARBITRATION_DMA_PRIORITY_5           5
- #define LOCALMEM_ARBITRATION_DMA_PRIORITY_6           6
- #define LOCALMEM_ARBITRATION_DMA_PRIORITY_7           7
- #define LOCALMEM_ARBITRATION_ZVPORT1                  18:16
- #define LOCALMEM_ARBITRATION_ZVPORT1_OFF              0
- #define LOCALMEM_ARBITRATION_ZVPORT1_PRIORITY_1       1
- #define LOCALMEM_ARBITRATION_ZVPORT1_PRIORITY_2       2
- #define LOCALMEM_ARBITRATION_ZVPORT1_PRIORITY_3       3
- #define LOCALMEM_ARBITRATION_ZVPORT1_PRIORITY_4       4
- #define LOCALMEM_ARBITRATION_ZVPORT1_PRIORITY_5       5
- #define LOCALMEM_ARBITRATION_ZVPORT1_PRIORITY_6       6
- #define LOCALMEM_ARBITRATION_ZVPORT1_PRIORITY_7       7
- #define LOCALMEM_ARBITRATION_ZVPORT0                  14:12
- #define LOCALMEM_ARBITRATION_ZVPORT0_OFF              0
- #define LOCALMEM_ARBITRATION_ZVPORT0_PRIORITY_1       1
- #define LOCALMEM_ARBITRATION_ZVPORT0_PRIORITY_2       2
- #define LOCALMEM_ARBITRATION_ZVPORT0_PRIORITY_3       3
- #define LOCALMEM_ARBITRATION_ZVPORT0_PRIORITY_4       4
- #define LOCALMEM_ARBITRATION_ZVPORT0_PRIORITY_5       5
- #define LOCALMEM_ARBITRATION_ZVPORT0_PRIORITY_6       6
- #define LOCALMEM_ARBITRATION_ZVPORT0_PRIORITY_7       7
- #define LOCALMEM_ARBITRATION_VIDEO                    10:8
- #define LOCALMEM_ARBITRATION_VIDEO_OFF                0
- #define LOCALMEM_ARBITRATION_VIDEO_PRIORITY_1         1
- #define LOCALMEM_ARBITRATION_VIDEO_PRIORITY_2         2
- #define LOCALMEM_ARBITRATION_VIDEO_PRIORITY_3         3
- #define LOCALMEM_ARBITRATION_VIDEO_PRIORITY_4         4
- #define LOCALMEM_ARBITRATION_VIDEO_PRIORITY_5         5
- #define LOCALMEM_ARBITRATION_VIDEO_PRIORITY_6         6
- #define LOCALMEM_ARBITRATION_VIDEO_PRIORITY_7         7
- #define LOCALMEM_ARBITRATION_PANEL                    6:4
- #define LOCALMEM_ARBITRATION_PANEL_OFF                0
- #define LOCALMEM_ARBITRATION_PANEL_PRIORITY_1         1
- #define LOCALMEM_ARBITRATION_PANEL_PRIORITY_2         2
- #define LOCALMEM_ARBITRATION_PANEL_PRIORITY_3         3
- #define LOCALMEM_ARBITRATION_PANEL_PRIORITY_4         4
- #define LOCALMEM_ARBITRATION_PANEL_PRIORITY_5         5
- #define LOCALMEM_ARBITRATION_PANEL_PRIORITY_6         6
- #define LOCALMEM_ARBITRATION_PANEL_PRIORITY_7         7
- #define LOCALMEM_ARBITRATION_CRT                      2:0
- #define LOCALMEM_ARBITRATION_CRT_OFF                  0
- #define LOCALMEM_ARBITRATION_CRT_PRIORITY_1           1
- #define LOCALMEM_ARBITRATION_CRT_PRIORITY_2           2
- #define LOCALMEM_ARBITRATION_CRT_PRIORITY_3           3
- #define LOCALMEM_ARBITRATION_CRT_PRIORITY_4           4
- #define LOCALMEM_ARBITRATION_CRT_PRIORITY_5           5
- #define LOCALMEM_ARBITRATION_CRT_PRIORITY_6           6
- #define LOCALMEM_ARBITRATION_CRT_PRIORITY_7           7
- 
- #define PCIMEM_ARBITRATION                            0x000010
- #define PCIMEM_ARBITRATION_ROTATE                     28:28
- #define PCIMEM_ARBITRATION_ROTATE_OFF                 0
- #define PCIMEM_ARBITRATION_ROTATE_ON                  1
- #define PCIMEM_ARBITRATION_VGA                        26:24
- #define PCIMEM_ARBITRATION_VGA_OFF                    0
- #define PCIMEM_ARBITRATION_VGA_PRIORITY_1             1
- #define PCIMEM_ARBITRATION_VGA_PRIORITY_2             2
- #define PCIMEM_ARBITRATION_VGA_PRIORITY_3             3
- #define PCIMEM_ARBITRATION_VGA_PRIORITY_4             4
- #define PCIMEM_ARBITRATION_VGA_PRIORITY_5             5
- #define PCIMEM_ARBITRATION_VGA_PRIORITY_6             6
- #define PCIMEM_ARBITRATION_VGA_PRIORITY_7             7
- #define PCIMEM_ARBITRATION_DMA                        22:20
- #define PCIMEM_ARBITRATION_DMA_OFF                    0
- #define PCIMEM_ARBITRATION_DMA_PRIORITY_1             1
- #define PCIMEM_ARBITRATION_DMA_PRIORITY_2             2
- #define PCIMEM_ARBITRATION_DMA_PRIORITY_3             3
- #define PCIMEM_ARBITRATION_DMA_PRIORITY_4             4
- #define PCIMEM_ARBITRATION_DMA_PRIORITY_5             5
- #define PCIMEM_ARBITRATION_DMA_PRIORITY_6             6
- #define PCIMEM_ARBITRATION_DMA_PRIORITY_7             7
- #define PCIMEM_ARBITRATION_ZVPORT1                    18:16
- #define PCIMEM_ARBITRATION_ZVPORT1_OFF                0
- #define PCIMEM_ARBITRATION_ZVPORT1_PRIORITY_1         1
- #define PCIMEM_ARBITRATION_ZVPORT1_PRIORITY_2         2
- #define PCIMEM_ARBITRATION_ZVPORT1_PRIORITY_3         3
- #define PCIMEM_ARBITRATION_ZVPORT1_PRIORITY_4         4
- #define PCIMEM_ARBITRATION_ZVPORT1_PRIORITY_5         5
- #define PCIMEM_ARBITRATION_ZVPORT1_PRIORITY_6         6
- #define PCIMEM_ARBITRATION_ZVPORT1_PRIORITY_7         7
- #define PCIMEM_ARBITRATION_ZVPORT0                    14:12
- #define PCIMEM_ARBITRATION_ZVPORT0_OFF                0
- #define PCIMEM_ARBITRATION_ZVPORT0_PRIORITY_1         1
- #define PCIMEM_ARBITRATION_ZVPORT0_PRIORITY_2         2
- #define PCIMEM_ARBITRATION_ZVPORT0_PRIORITY_3         3
- #define PCIMEM_ARBITRATION_ZVPORT0_PRIORITY_4         4
- #define PCIMEM_ARBITRATION_ZVPORT0_PRIORITY_5         5
- #define PCIMEM_ARBITRATION_ZVPORT0_PRIORITY_6         6
- #define PCIMEM_ARBITRATION_ZVPORT0_PRIORITY_7         7
- #define PCIMEM_ARBITRATION_VIDEO                      10:8
- #define PCIMEM_ARBITRATION_VIDEO_OFF                  0
- #define PCIMEM_ARBITRATION_VIDEO_PRIORITY_1           1
- #define PCIMEM_ARBITRATION_VIDEO_PRIORITY_2           2
- #define PCIMEM_ARBITRATION_VIDEO_PRIORITY_3           3
- #define PCIMEM_ARBITRATION_VIDEO_PRIORITY_4           4
- #define PCIMEM_ARBITRATION_VIDEO_PRIORITY_5           5
- #define PCIMEM_ARBITRATION_VIDEO_PRIORITY_6           6
- #define PCIMEM_ARBITRATION_VIDEO_PRIORITY_7           7
- #define PCIMEM_ARBITRATION_PANEL                      6:4
- #define PCIMEM_ARBITRATION_PANEL_OFF                  0
- #define PCIMEM_ARBITRATION_PANEL_PRIORITY_1           1
- #define PCIMEM_ARBITRATION_PANEL_PRIORITY_2           2
- #define PCIMEM_ARBITRATION_PANEL_PRIORITY_3           3
- #define PCIMEM_ARBITRATION_PANEL_PRIORITY_4           4
- #define PCIMEM_ARBITRATION_PANEL_PRIORITY_5           5
- #define PCIMEM_ARBITRATION_PANEL_PRIORITY_6           6
- #define PCIMEM_ARBITRATION_PANEL_PRIORITY_7           7
- #define PCIMEM_ARBITRATION_CRT                        2:0
- #define PCIMEM_ARBITRATION_CRT_OFF                    0
- #define PCIMEM_ARBITRATION_CRT_PRIORITY_1             1
- #define PCIMEM_ARBITRATION_CRT_PRIORITY_2             2
- #define PCIMEM_ARBITRATION_CRT_PRIORITY_3             3
- #define PCIMEM_ARBITRATION_CRT_PRIORITY_4             4
- #define PCIMEM_ARBITRATION_CRT_PRIORITY_5             5
- #define PCIMEM_ARBITRATION_CRT_PRIORITY_6             6
- #define PCIMEM_ARBITRATION_CRT_PRIORITY_7             7
- 
- #define RAW_INT                                       0x000020
- #define RAW_INT_ZVPORT1_VSYNC                         4:4
- #define RAW_INT_ZVPORT1_VSYNC_INACTIVE                0
- #define RAW_INT_ZVPORT1_VSYNC_ACTIVE                  1
- #define RAW_INT_ZVPORT1_VSYNC_CLEAR                   1
- #define RAW_INT_ZVPORT0_VSYNC                         3:3
- #define RAW_INT_ZVPORT0_VSYNC_INACTIVE                0
- #define RAW_INT_ZVPORT0_VSYNC_ACTIVE                  1
- #define RAW_INT_ZVPORT0_VSYNC_CLEAR                   1
- #define RAW_INT_CRT_VSYNC                             2:2
- #define RAW_INT_CRT_VSYNC_INACTIVE                    0
- #define RAW_INT_CRT_VSYNC_ACTIVE                      1
- #define RAW_INT_CRT_VSYNC_CLEAR                       1
- #define RAW_INT_PANEL_VSYNC                           1:1
- #define RAW_INT_PANEL_VSYNC_INACTIVE                  0
- #define RAW_INT_PANEL_VSYNC_ACTIVE                    1
- #define RAW_INT_PANEL_VSYNC_CLEAR                     1
- #define RAW_INT_VGA_VSYNC                             0:0
- #define RAW_INT_VGA_VSYNC_INACTIVE                    0
- #define RAW_INT_VGA_VSYNC_ACTIVE                      1
- #define RAW_INT_VGA_VSYNC_CLEAR                       1
- 
- #define INT_STATUS                                    0x000024
- #define INT_STATUS_GPIO31                             31:31
- #define INT_STATUS_GPIO31_INACTIVE                    0
- #define INT_STATUS_GPIO31_ACTIVE                      1
- #define INT_STATUS_GPIO30                             30:30
- #define INT_STATUS_GPIO30_INACTIVE                    0
- #define INT_STATUS_GPIO30_ACTIVE                      1
- #define INT_STATUS_GPIO29                             29:29
- #define INT_STATUS_GPIO29_INACTIVE                    0
- #define INT_STATUS_GPIO29_ACTIVE                      1
- #define INT_STATUS_GPIO28                             28:28
- #define INT_STATUS_GPIO28_INACTIVE                    0
- #define INT_STATUS_GPIO28_ACTIVE                      1
- #define INT_STATUS_GPIO27                             27:27
- #define INT_STATUS_GPIO27_INACTIVE                    0
- #define INT_STATUS_GPIO27_ACTIVE                      1
- #define INT_STATUS_GPIO26                             26:26
- #define INT_STATUS_GPIO26_INACTIVE                    0
- #define INT_STATUS_GPIO26_ACTIVE                      1
- #define INT_STATUS_GPIO25                             25:25
- #define INT_STATUS_GPIO25_INACTIVE                    0
- #define INT_STATUS_GPIO25_ACTIVE                      1
- #define INT_STATUS_I2C                                12:12
- #define INT_STATUS_I2C_INACTIVE                       0
- #define INT_STATUS_I2C_ACTIVE                         1
- #define INT_STATUS_PWM                                11:11
- #define INT_STATUS_PWM_INACTIVE                       0
- #define INT_STATUS_PWM_ACTIVE                         1
- #define INT_STATUS_DMA1                               10:10
- #define INT_STATUS_DMA1_INACTIVE                      0
- #define INT_STATUS_DMA1_ACTIVE                        1
- #define INT_STATUS_DMA0                               9:9
- #define INT_STATUS_DMA0_INACTIVE                      0
- #define INT_STATUS_DMA0_ACTIVE                        1
- #define INT_STATUS_PCI                                8:8
- #define INT_STATUS_PCI_INACTIVE                       0
- #define INT_STATUS_PCI_ACTIVE                         1
- #define INT_STATUS_SSP1                               7:7
- #define INT_STATUS_SSP1_INACTIVE                      0
- #define INT_STATUS_SSP1_ACTIVE                        1
- #define INT_STATUS_SSP0                               6:6
- #define INT_STATUS_SSP0_INACTIVE                      0
- #define INT_STATUS_SSP0_ACTIVE                        1
- #define INT_STATUS_DE                                 5:5
- #define INT_STATUS_DE_INACTIVE                        0
- #define INT_STATUS_DE_ACTIVE                          1
- #define INT_STATUS_ZVPORT1_VSYNC                      4:4
- #define INT_STATUS_ZVPORT1_VSYNC_INACTIVE             0
- #define INT_STATUS_ZVPORT1_VSYNC_ACTIVE               1
- #define INT_STATUS_ZVPORT0_VSYNC                      3:3
- #define INT_STATUS_ZVPORT0_VSYNC_INACTIVE             0
- #define INT_STATUS_ZVPORT0_VSYNC_ACTIVE               1
- #define INT_STATUS_CRT_VSYNC                          2:2
- #define INT_STATUS_CRT_VSYNC_INACTIVE                 0
- #define INT_STATUS_CRT_VSYNC_ACTIVE                   1
- #define INT_STATUS_PANEL_VSYNC                        1:1
- #define INT_STATUS_PANEL_VSYNC_INACTIVE               0
- #define INT_STATUS_PANEL_VSYNC_ACTIVE                 1
- #define INT_STATUS_VGA_VSYNC                          0:0
- #define INT_STATUS_VGA_VSYNC_INACTIVE                 0
- #define INT_STATUS_VGA_VSYNC_ACTIVE                   1
- 
- #define INT_MASK                                      0x000028
- #define INT_MASK_GPIO31                               31:31
- #define INT_MASK_GPIO31_DISABLE                       0
- #define INT_MASK_GPIO31_ENABLE                        1
- #define INT_MASK_GPIO30                               30:30
- #define INT_MASK_GPIO30_DISABLE                       0
- #define INT_MASK_GPIO30_ENABLE                        1
- #define INT_MASK_GPIO29                               29:29
- #define INT_MASK_GPIO29_DISABLE                       0
- #define INT_MASK_GPIO29_ENABLE                        1
- #define INT_MASK_GPIO28                               28:28
- #define INT_MASK_GPIO28_DISABLE                       0
- #define INT_MASK_GPIO28_ENABLE                        1
- #define INT_MASK_GPIO27                               27:27
- #define INT_MASK_GPIO27_DISABLE                       0
- #define INT_MASK_GPIO27_ENABLE                        1
- #define INT_MASK_GPIO26                               26:26
- #define INT_MASK_GPIO26_DISABLE                       0
- #define INT_MASK_GPIO26_ENABLE                        1
- #define INT_MASK_GPIO25                               25:25
- #define INT_MASK_GPIO25_DISABLE                       0
- #define INT_MASK_GPIO25_ENABLE                        1
- #define INT_MASK_I2C                                  12:12
- #define INT_MASK_I2C_DISABLE                          0
- #define INT_MASK_I2C_ENABLE                           1
- #define INT_MASK_PWM                                  11:11
- #define INT_MASK_PWM_DISABLE                          0
- #define INT_MASK_PWM_ENABLE                           1
- #define INT_MASK_DMA1                                 10:10
- #define INT_MASK_DMA1_DISABLE                         0
- #define INT_MASK_DMA1_ENABLE                          1
- #define INT_MASK_DMA                                  9:9
- #define INT_MASK_DMA_DISABLE                          0
- #define INT_MASK_DMA_ENABLE                           1
- #define INT_MASK_PCI                                  8:8
- #define INT_MASK_PCI_DISABLE                          0
- #define INT_MASK_PCI_ENABLE                           1
- #define INT_MASK_SSP1                                 7:7
- #define INT_MASK_SSP1_DISABLE                         0
- #define INT_MASK_SSP1_ENABLE                          1
- #define INT_MASK_SSP0                                 6:6
- #define INT_MASK_SSP0_DISABLE                         0
- #define INT_MASK_SSP0_ENABLE                          1
- #define INT_MASK_DE                                   5:5
- #define INT_MASK_DE_DISABLE                           0
- #define INT_MASK_DE_ENABLE                            1
- #define INT_MASK_ZVPORT1_VSYNC                        4:4
- #define INT_MASK_ZVPORT1_VSYNC_DISABLE                0
- #define INT_MASK_ZVPORT1_VSYNC_ENABLE                 1
- #define INT_MASK_ZVPORT0_VSYNC                        3:3
- #define INT_MASK_ZVPORT0_VSYNC_DISABLE                0
- #define INT_MASK_ZVPORT0_VSYNC_ENABLE                 1
- #define INT_MASK_CRT_VSYNC                            2:2
- #define INT_MASK_CRT_VSYNC_DISABLE                    0
- #define INT_MASK_CRT_VSYNC_ENABLE                     1
- #define INT_MASK_PANEL_VSYNC                          1:1
- #define INT_MASK_PANEL_VSYNC_DISABLE                  0
- #define INT_MASK_PANEL_VSYNC_ENABLE                   1
- #define INT_MASK_VGA_VSYNC                            0:0
- #define INT_MASK_VGA_VSYNC_DISABLE                    0
- #define INT_MASK_VGA_VSYNC_ENABLE                     1
- 
- #define CURRENT_GATE                                  0x000040
- #define CURRENT_GATE_MCLK                             15:14
- #ifdef VALIDATION_CHIP
-     #define CURRENT_GATE_MCLK_112MHZ                      0
-     #define CURRENT_GATE_MCLK_84MHZ                       1
-     #define CURRENT_GATE_MCLK_56MHZ                       2
-     #define CURRENT_GATE_MCLK_42MHZ                       3
- #else
-     #define CURRENT_GATE_MCLK_DIV_3                       0
-     #define CURRENT_GATE_MCLK_DIV_4                       1
-     #define CURRENT_GATE_MCLK_DIV_6                       2
-     #define CURRENT_GATE_MCLK_DIV_8                       3
- #endif
- #define CURRENT_GATE_M2XCLK                           13:12
- #ifdef VALIDATION_CHIP
-     #define CURRENT_GATE_M2XCLK_336MHZ                    0
-     #define CURRENT_GATE_M2XCLK_168MHZ                    1
-     #define CURRENT_GATE_M2XCLK_112MHZ                    2
-     #define CURRENT_GATE_M2XCLK_84MHZ                     3
- #else
-     #define CURRENT_GATE_M2XCLK_DIV_1                     0
-     #define CURRENT_GATE_M2XCLK_DIV_2                     1
-     #define CURRENT_GATE_M2XCLK_DIV_3                     2
-     #define CURRENT_GATE_M2XCLK_DIV_4                     3
- #endif
- #define CURRENT_GATE_VGA                              10:10
- #define CURRENT_GATE_VGA_OFF                          0
- #define CURRENT_GATE_VGA_ON                           1
- #define CURRENT_GATE_PWM                              9:9
- #define CURRENT_GATE_PWM_OFF                          0
- #define CURRENT_GATE_PWM_ON                           1
- #define CURRENT_GATE_I2C                              8:8
- #define CURRENT_GATE_I2C_OFF                          0
- #define CURRENT_GATE_I2C_ON                           1
- #define CURRENT_GATE_SSP                              7:7
- #define CURRENT_GATE_SSP_OFF                          0
- #define CURRENT_GATE_SSP_ON                           1
- #define CURRENT_GATE_GPIO                             6:6
- #define CURRENT_GATE_GPIO_OFF                         0
- #define CURRENT_GATE_GPIO_ON                          1
- #define CURRENT_GATE_ZVPORT                           5:5
- #define CURRENT_GATE_ZVPORT_OFF                       0
- #define CURRENT_GATE_ZVPORT_ON                        1
- #define CURRENT_GATE_CSC                              4:4
- #define CURRENT_GATE_CSC_OFF                          0
- #define CURRENT_GATE_CSC_ON                           1
- #define CURRENT_GATE_DE                               3:3
- #define CURRENT_GATE_DE_OFF                           0
- #define CURRENT_GATE_DE_ON                            1
- #define CURRENT_GATE_DISPLAY                          2:2
- #define CURRENT_GATE_DISPLAY_OFF                      0
- #define CURRENT_GATE_DISPLAY_ON                       1
- #define CURRENT_GATE_LOCALMEM                         1:1
- #define CURRENT_GATE_LOCALMEM_OFF                     0
- #define CURRENT_GATE_LOCALMEM_ON                      1
- #define CURRENT_GATE_DMA                              0:0
- #define CURRENT_GATE_DMA_OFF                          0
- #define CURRENT_GATE_DMA_ON                           1
- 
- #define MODE0_GATE                                    0x000044
- #define MODE0_GATE_MCLK                               15:14
- #define MODE0_GATE_MCLK_112MHZ                        0
- #define MODE0_GATE_MCLK_84MHZ                         1
- #define MODE0_GATE_MCLK_56MHZ                         2
- #define MODE0_GATE_MCLK_42MHZ                         3
- #define MODE0_GATE_M2XCLK                             13:12
- #define MODE0_GATE_M2XCLK_336MHZ                      0
- #define MODE0_GATE_M2XCLK_168MHZ                      1
- #define MODE0_GATE_M2XCLK_112MHZ                      2
- #define MODE0_GATE_M2XCLK_84MHZ                       3
- #define MODE0_GATE_VGA                                10:10
- #define MODE0_GATE_VGA_OFF                            0
- #define MODE0_GATE_VGA_ON                             1
- #define MODE0_GATE_PWM                                9:9
- #define MODE0_GATE_PWM_OFF                            0
- #define MODE0_GATE_PWM_ON                             1
- #define MODE0_GATE_I2C                                8:8
- #define MODE0_GATE_I2C_OFF                            0
- #define MODE0_GATE_I2C_ON                             1
- #define MODE0_GATE_SSP                                7:7
- #define MODE0_GATE_SSP_OFF                            0
- #define MODE0_GATE_SSP_ON                             1
- #define MODE0_GATE_GPIO                               6:6
- #define MODE0_GATE_GPIO_OFF                           0
- #define MODE0_GATE_GPIO_ON                            1
- #define MODE0_GATE_ZVPORT                             5:5
- #define MODE0_GATE_ZVPORT_OFF                         0
- #define MODE0_GATE_ZVPORT_ON                          1
- #define MODE0_GATE_CSC                                4:4
- #define MODE0_GATE_CSC_OFF                            0
- #define MODE0_GATE_CSC_ON                             1
- #define MODE0_GATE_DE                                 3:3
- #define MODE0_GATE_DE_OFF                             0
- #define MODE0_GATE_DE_ON                              1
- #define MODE0_GATE_DISPLAY                            2:2
- #define MODE0_GATE_DISPLAY_OFF                        0
- #define MODE0_GATE_DISPLAY_ON                         1
- #define MODE0_GATE_LOCALMEM                           1:1
- #define MODE0_GATE_LOCALMEM_OFF                       0
- #define MODE0_GATE_LOCALMEM_ON                        1
- #define MODE0_GATE_DMA                                0:0
- #define MODE0_GATE_DMA_OFF                            0
- #define MODE0_GATE_DMA_ON                             1
- 
- #define MODE1_GATE                                    0x000048
- #define MODE1_GATE_MCLK                               15:14
- #define MODE1_GATE_MCLK_112MHZ                        0
- #define MODE1_GATE_MCLK_84MHZ                         1
- #define MODE1_GATE_MCLK_56MHZ                         2
- #define MODE1_GATE_MCLK_42MHZ                         3
- #define MODE1_GATE_M2XCLK                             13:12
- #define MODE1_GATE_M2XCLK_336MHZ                      0
- #define MODE1_GATE_M2XCLK_168MHZ                      1
- #define MODE1_GATE_M2XCLK_112MHZ                      2
- #define MODE1_GATE_M2XCLK_84MHZ                       3
- #define MODE1_GATE_VGA                                10:10
- #define MODE1_GATE_VGA_OFF                            0
- #define MODE1_GATE_VGA_ON                             1
- #define MODE1_GATE_PWM                                9:9
- #define MODE1_GATE_PWM_OFF                            0
- #define MODE1_GATE_PWM_ON                             1
- #define MODE1_GATE_I2C                                8:8
- #define MODE1_GATE_I2C_OFF                            0
- #define MODE1_GATE_I2C_ON                             1
- #define MODE1_GATE_SSP                                7:7
- #define MODE1_GATE_SSP_OFF                            0
- #define MODE1_GATE_SSP_ON                             1
- #define MODE1_GATE_GPIO                               6:6
- #define MODE1_GATE_GPIO_OFF                           0
- #define MODE1_GATE_GPIO_ON                            1
- #define MODE1_GATE_ZVPORT                             5:5
- #define MODE1_GATE_ZVPORT_OFF                         0
- #define MODE1_GATE_ZVPORT_ON                          1
- #define MODE1_GATE_CSC                                4:4
- #define MODE1_GATE_CSC_OFF                            0
- #define MODE1_GATE_CSC_ON                             1
- #define MODE1_GATE_DE                                 3:3
- #define MODE1_GATE_DE_OFF                             0
- #define MODE1_GATE_DE_ON                              1
- #define MODE1_GATE_DISPLAY                            2:2
- #define MODE1_GATE_DISPLAY_OFF                        0
- #define MODE1_GATE_DISPLAY_ON                         1
- #define MODE1_GATE_LOCALMEM                           1:1
- #define MODE1_GATE_LOCALMEM_OFF                       0
- #define MODE1_GATE_LOCALMEM_ON                        1
- #define MODE1_GATE_DMA                                0:0
- #define MODE1_GATE_DMA_OFF                            0
- #define MODE1_GATE_DMA_ON                             1
- 
- #define POWER_MODE_CTRL                               0x00004C
- #ifdef VALIDATION_CHIP
-     #define POWER_MODE_CTRL_336CLK                    4:4
-     #define POWER_MODE_CTRL_336CLK_OFF                0
-     #define POWER_MODE_CTRL_336CLK_ON                 1
- #endif
- #define POWER_MODE_CTRL_OSC_INPUT                     3:3
- #define POWER_MODE_CTRL_OSC_INPUT_OFF                 0
- #define POWER_MODE_CTRL_OSC_INPUT_ON                  1
- #define POWER_MODE_CTRL_ACPI                          2:2
- #define POWER_MODE_CTRL_ACPI_OFF                      0
- #define POWER_MODE_CTRL_ACPI_ON                       1
- #define POWER_MODE_CTRL_MODE                          1:0
- #define POWER_MODE_CTRL_MODE_MODE0                    0
- #define POWER_MODE_CTRL_MODE_MODE1                    1
- #define POWER_MODE_CTRL_MODE_SLEEP                    2
- 
- #define PCI_MASTER_BASE                               0x000050
- #define PCI_MASTER_BASE_ADDRESS                       7:0
- 
- #define DEVICE_ID                                     0x000054
- #define DEVICE_ID_DEVICE_ID                           31:16
- #define DEVICE_ID_REVISION_ID                         7:0
- 
- #define PLL_CLK_COUNT                                 0x000058
- #define PLL_CLK_COUNT_COUNTER                         15:0
- 
- #define PANEL_PLL_CTRL                                0x00005C
- #define PANEL_PLL_CTRL_BYPASS                         18:18
- #define PANEL_PLL_CTRL_BYPASS_OFF                     0
- #define PANEL_PLL_CTRL_BYPASS_ON                      1
- #define PANEL_PLL_CTRL_POWER                          17:17
- #define PANEL_PLL_CTRL_POWER_OFF                      0
- #define PANEL_PLL_CTRL_POWER_ON                       1
- #define PANEL_PLL_CTRL_INPUT                          16:16
- #define PANEL_PLL_CTRL_INPUT_OSC                      0
- #define PANEL_PLL_CTRL_INPUT_TESTCLK                  1
- #ifdef VALIDATION_CHIP
-     #define PANEL_PLL_CTRL_OD                         15:14
- #else
-     #define PANEL_PLL_CTRL_POD                        15:14
-     #define PANEL_PLL_CTRL_OD                         13:12
- #endif
- #define PANEL_PLL_CTRL_N                              11:8
- #define PANEL_PLL_CTRL_M                              7:0
- 
- #define CRT_PLL_CTRL                                  0x000060
- #define CRT_PLL_CTRL_BYPASS                           18:18
- #define CRT_PLL_CTRL_BYPASS_OFF                       0
- #define CRT_PLL_CTRL_BYPASS_ON                        1
- #define CRT_PLL_CTRL_POWER                            17:17
- #define CRT_PLL_CTRL_POWER_OFF                        0
- #define CRT_PLL_CTRL_POWER_ON                         1
- #define CRT_PLL_CTRL_INPUT                            16:16
- #define CRT_PLL_CTRL_INPUT_OSC                        0
- #define CRT_PLL_CTRL_INPUT_TESTCLK                    1
- #ifdef VALIDATION_CHIP
-     #define CRT_PLL_CTRL_OD                           15:14
- #else
-     #define CRT_PLL_CTRL_POD                          15:14
-     #define CRT_PLL_CTRL_OD                           13:12
- #endif
- #define CRT_PLL_CTRL_N                                11:8
- #define CRT_PLL_CTRL_M                                7:0
- 
- #define VGA_PLL0_CTRL                                 0x000064
- #define VGA_PLL0_CTRL_BYPASS                          18:18
- #define VGA_PLL0_CTRL_BYPASS_OFF                      0
- #define VGA_PLL0_CTRL_BYPASS_ON                       1
- #define VGA_PLL0_CTRL_POWER                           17:17
- #define VGA_PLL0_CTRL_POWER_OFF                       0
- #define VGA_PLL0_CTRL_POWER_ON                        1
- #define VGA_PLL0_CTRL_INPUT                           16:16
- #define VGA_PLL0_CTRL_INPUT_OSC                       0
- #define VGA_PLL0_CTRL_INPUT_TESTCLK                   1
- #ifdef VALIDATION_CHIP
-     #define VGA_PLL0_CTRL_OD                          15:14
- #else
-     #define VGA_PLL0_CTRL_POD                         15:14
-     #define VGA_PLL0_CTRL_OD                          13:12
- #endif
- #define VGA_PLL0_CTRL_N                               11:8
- #define VGA_PLL0_CTRL_M                               7:0
- 
- #define VGA_PLL1_CTRL                                 0x000068
- #define VGA_PLL1_CTRL_BYPASS                          18:18
- #define VGA_PLL1_CTRL_BYPASS_OFF                      0
- #define VGA_PLL1_CTRL_BYPASS_ON                       1
- #define VGA_PLL1_CTRL_POWER                           17:17
- #define VGA_PLL1_CTRL_POWER_OFF                       0
- #define VGA_PLL1_CTRL_POWER_ON                        1
- #define VGA_PLL1_CTRL_INPUT                           16:16
- #define VGA_PLL1_CTRL_INPUT_OSC                       0
- #define VGA_PLL1_CTRL_INPUT_TESTCLK                   1
- #ifdef VALIDATION_CHIP
-     #define VGA_PLL1_CTRL_OD                          15:14
- #else
-     #define VGA_PLL1_CTRL_POD                         15:14
-     #define VGA_PLL1_CTRL_OD                          13:12
- #endif
- #define VGA_PLL1_CTRL_N                               11:8
- #define VGA_PLL1_CTRL_M                               7:0
- 
- #define SCRATCH_DATA                                  0x00006c
- 
- #ifndef VALIDATION_CHIP
- 
- #define MXCLK_PLL_CTRL                                0x000070
- #define MXCLK_PLL_CTRL_BYPASS                         18:18
- #define MXCLK_PLL_CTRL_BYPASS_OFF                     0
- #define MXCLK_PLL_CTRL_BYPASS_ON                      1
- #define MXCLK_PLL_CTRL_POWER                          17:17
- #define MXCLK_PLL_CTRL_POWER_OFF                      0
- #define MXCLK_PLL_CTRL_POWER_ON                       1
- #define MXCLK_PLL_CTRL_INPUT                          16:16
- #define MXCLK_PLL_CTRL_INPUT_OSC                      0
- #define MXCLK_PLL_CTRL_INPUT_TESTCLK                  1
- #define MXCLK_PLL_CTRL_POD                            15:14
- #define MXCLK_PLL_CTRL_OD                             13:12
- #define MXCLK_PLL_CTRL_N                              11:8
- #define MXCLK_PLL_CTRL_M                              7:0
- 
- #define VGA_CONFIGURATION                             0x000088
- #define VGA_CONFIGURATION_USER_DEFINE                 5:4
- #define VGA_CONFIGURATION_PLL                         2:2
- #define VGA_CONFIGURATION_PLL_VGA                     0
- #define VGA_CONFIGURATION_PLL_PANEL                   1
- #define VGA_CONFIGURATION_MODE                        1:1
- #define VGA_CONFIGURATION_MODE_TEXT                   0
- #define VGA_CONFIGURATION_MODE_GRAPHIC                1
- 
- #endif
- 
- #define GPIO_DATA                                       0x010000
- #define GPIO_DATA_31                                    31:31
- #define GPIO_DATA_30                                    30:30
- #define GPIO_DATA_29                                    29:29
- #define GPIO_DATA_28                                    28:28
- #define GPIO_DATA_27                                    27:27
- #define GPIO_DATA_26                                    26:26
- #define GPIO_DATA_25                                    25:25
- #define GPIO_DATA_24                                    24:24
- #define GPIO_DATA_23                                    23:23
- #define GPIO_DATA_22                                    22:22
- #define GPIO_DATA_21                                    21:21
- #define GPIO_DATA_20                                    20:20
- #define GPIO_DATA_19                                    19:19
- #define GPIO_DATA_18                                    18:18
- #define GPIO_DATA_17                                    17:17
- #define GPIO_DATA_16                                    16:16
- #define GPIO_DATA_15                                    15:15
- #define GPIO_DATA_14                                    14:14
- #define GPIO_DATA_13                                    13:13
- #define GPIO_DATA_12                                    12:12
- #define GPIO_DATA_11                                    11:11
- #define GPIO_DATA_10                                    10:10
- #define GPIO_DATA_9                                     9:9
- #define GPIO_DATA_8                                     8:8
- #define GPIO_DATA_7                                     7:7
- #define GPIO_DATA_6                                     6:6
- #define GPIO_DATA_5                                     5:5
- #define GPIO_DATA_4                                     4:4
- #define GPIO_DATA_3                                     3:3
- #define GPIO_DATA_2                                     2:2
- #define GPIO_DATA_1                                     1:1
- #define GPIO_DATA_0                                     0:0
- 
- #define GPIO_DATA_DIRECTION                             0x010004
- #define GPIO_DATA_DIRECTION_31                          31:31
- #define GPIO_DATA_DIRECTION_31_INPUT                    0
- #define GPIO_DATA_DIRECTION_31_OUTPUT                   1
- #define GPIO_DATA_DIRECTION_30                          30:30
- #define GPIO_DATA_DIRECTION_30_INPUT                    0
- #define GPIO_DATA_DIRECTION_30_OUTPUT                   1
- #define GPIO_DATA_DIRECTION_29                          29:29
- #define GPIO_DATA_DIRECTION_29_INPUT                    0
- #define GPIO_DATA_DIRECTION_29_OUTPUT                   1
- #define GPIO_DATA_DIRECTION_28                          28:28
- #define GPIO_DATA_DIRECTION_28_INPUT                    0
- #define GPIO_DATA_DIRECTION_28_OUTPUT                   1
- #define GPIO_DATA_DIRECTION_27                          27:27
- #define GPIO_DATA_DIRECTION_27_INPUT                    0
- #define GPIO_DATA_DIRECTION_27_OUTPUT                   1
- #define GPIO_DATA_DIRECTION_26                          26:26
- #define GPIO_DATA_DIRECTION_26_INPUT                    0
- #define GPIO_DATA_DIRECTION_26_OUTPUT                   1
- #define GPIO_DATA_DIRECTION_25                          25:25
- #define GPIO_DATA_DIRECTION_25_INPUT                    0
- #define GPIO_DATA_DIRECTION_25_OUTPUT                   1
- #define GPIO_DATA_DIRECTION_24                          24:24
- #define GPIO_DATA_DIRECTION_24_INPUT                    0
- #define GPIO_DATA_DIRECTION_24_OUTPUT                   1
- #define GPIO_DATA_DIRECTION_23                          23:23
- #define GPIO_DATA_DIRECTION_23_INPUT                    0
- #define GPIO_DATA_DIRECTION_23_OUTPUT                   1
- #define GPIO_DATA_DIRECTION_22                          22:22
- #define GPIO_DATA_DIRECTION_22_INPUT                    0
- #define GPIO_DATA_DIRECTION_22_OUTPUT                   1
- #define GPIO_DATA_DIRECTION_21                          21:21
- #define GPIO_DATA_DIRECTION_21_INPUT                    0
- #define GPIO_DATA_DIRECTION_21_OUTPUT                   1
- #define GPIO_DATA_DIRECTION_20                          20:20
- #define GPIO_DATA_DIRECTION_20_INPUT                    0
- #define GPIO_DATA_DIRECTION_20_OUTPUT                   1
- #define GPIO_DATA_DIRECTION_19                          19:19
- #define GPIO_DATA_DIRECTION_19_INPUT                    0
- #define GPIO_DATA_DIRECTION_19_OUTPUT                   1
- #define GPIO_DATA_DIRECTION_18                          18:18
- #define GPIO_DATA_DIRECTION_18_INPUT                    0
- #define GPIO_DATA_DIRECTION_18_OUTPUT                   1
- #define GPIO_DATA_DIRECTION_17                          17:17
- #define GPIO_DATA_DIRECTION_17_INPUT                    0
- #define GPIO_DATA_DIRECTION_17_OUTPUT                   1
- #define GPIO_DATA_DIRECTION_16                          16:16
- #define GPIO_DATA_DIRECTION_16_INPUT                    0
- #define GPIO_DATA_DIRECTION_16_OUTPUT                   1
- #define GPIO_DATA_DIRECTION_15                          15:15
- #define GPIO_DATA_DIRECTION_15_INPUT                    0
- #define GPIO_DATA_DIRECTION_15_OUTPUT                   1
- #define GPIO_DATA_DIRECTION_14                          14:14
- #define GPIO_DATA_DIRECTION_14_INPUT                    0
- #define GPIO_DATA_DIRECTION_14_OUTPUT                   1
- #define GPIO_DATA_DIRECTION_13                          13:13
- #define GPIO_DATA_DIRECTION_13_INPUT                    0
- #define GPIO_DATA_DIRECTION_13_OUTPUT                   1
- #define GPIO_DATA_DIRECTION_12                          12:12
- #define GPIO_DATA_DIRECTION_12_INPUT                    0
- #define GPIO_DATA_DIRECTION_12_OUTPUT                   1
- #define GPIO_DATA_DIRECTION_11                          11:11
- #define GPIO_DATA_DIRECTION_11_INPUT                    0
- #define GPIO_DATA_DIRECTION_11_OUTPUT                   1
- #define GPIO_DATA_DIRECTION_10                          10:10
- #define GPIO_DATA_DIRECTION_10_INPUT                    0
- #define GPIO_DATA_DIRECTION_10_OUTPUT                   1
- #define GPIO_DATA_DIRECTION_9                           9:9
- #define GPIO_DATA_DIRECTION_9_INPUT                     0
- #define GPIO_DATA_DIRECTION_9_OUTPUT                    1
- #define GPIO_DATA_DIRECTION_8                           8:8
- #define GPIO_DATA_DIRECTION_8_INPUT                     0
- #define GPIO_DATA_DIRECTION_8_OUTPUT                    1
- #define GPIO_DATA_DIRECTION_7                           7:7
- #define GPIO_DATA_DIRECTION_7_INPUT                     0
- #define GPIO_DATA_DIRECTION_7_OUTPUT                    1
- #define GPIO_DATA_DIRECTION_6                           6:6
- #define GPIO_DATA_DIRECTION_6_INPUT                     0
- #define GPIO_DATA_DIRECTION_6_OUTPUT                    1
- #define GPIO_DATA_DIRECTION_5                           5:5
- #define GPIO_DATA_DIRECTION_5_INPUT                     0
- #define GPIO_DATA_DIRECTION_5_OUTPUT                    1
- #define GPIO_DATA_DIRECTION_4                           4:4
- #define GPIO_DATA_DIRECTION_4_INPUT                     0
- #define GPIO_DATA_DIRECTION_4_OUTPUT                    1
- #define GPIO_DATA_DIRECTION_3                           3:3
- #define GPIO_DATA_DIRECTION_3_INPUT                     0
- #define GPIO_DATA_DIRECTION_3_OUTPUT                    1
- #define GPIO_DATA_DIRECTION_2                           2:2
- #define GPIO_DATA_DIRECTION_2_INPUT                     0
- #define GPIO_DATA_DIRECTION_2_OUTPUT                    1
- #define GPIO_DATA_DIRECTION_1                           131
- #define GPIO_DATA_DIRECTION_1_INPUT                     0
- #define GPIO_DATA_DIRECTION_1_OUTPUT                    1
- #define GPIO_DATA_DIRECTION_0                           0:0
- #define GPIO_DATA_DIRECTION_0_INPUT                     0
- #define GPIO_DATA_DIRECTION_0_OUTPUT                    1
- 
- #define GPIO_INTERRUPT_SETUP                            0x010008
- #define GPIO_INTERRUPT_SETUP_TRIGGER_31                 22:22
- #define GPIO_INTERRUPT_SETUP_TRIGGER_31_EDGE            0
- #define GPIO_INTERRUPT_SETUP_TRIGGER_31_LEVEL           1
- #define GPIO_INTERRUPT_SETUP_TRIGGER_30                 21:21
- #define GPIO_INTERRUPT_SETUP_TRIGGER_30_EDGE            0
- #define GPIO_INTERRUPT_SETUP_TRIGGER_30_LEVEL           1
- #define GPIO_INTERRUPT_SETUP_TRIGGER_29                 20:20
- #define GPIO_INTERRUPT_SETUP_TRIGGER_29_EDGE            0
- #define GPIO_INTERRUPT_SETUP_TRIGGER_29_LEVEL           1
- #define GPIO_INTERRUPT_SETUP_TRIGGER_28                 19:19
- #define GPIO_INTERRUPT_SETUP_TRIGGER_28_EDGE            0
- #define GPIO_INTERRUPT_SETUP_TRIGGER_28_LEVEL           1
- #define GPIO_INTERRUPT_SETUP_TRIGGER_27                 18:18
- #define GPIO_INTERRUPT_SETUP_TRIGGER_27_EDGE            0
- #define GPIO_INTERRUPT_SETUP_TRIGGER_27_LEVEL           1
- #define GPIO_INTERRUPT_SETUP_TRIGGER_26                 17:17
- #define GPIO_INTERRUPT_SETUP_TRIGGER_26_EDGE            0
- #define GPIO_INTERRUPT_SETUP_TRIGGER_26_LEVEL           1
- #define GPIO_INTERRUPT_SETUP_TRIGGER_25                 16:16
- #define GPIO_INTERRUPT_SETUP_TRIGGER_25_EDGE            0
- #define GPIO_INTERRUPT_SETUP_TRIGGER_25_LEVEL           1
- #define GPIO_INTERRUPT_SETUP_ACTIVE_31                  14:14
- #define GPIO_INTERRUPT_SETUP_ACTIVE_31_LOW              0
- #define GPIO_INTERRUPT_SETUP_ACTIVE_31_HIGH             1
- #define GPIO_INTERRUPT_SETUP_ACTIVE_30                  13:13
- #define GPIO_INTERRUPT_SETUP_ACTIVE_30_LOW              0
- #define GPIO_INTERRUPT_SETUP_ACTIVE_30_HIGH             1
- #define GPIO_INTERRUPT_SETUP_ACTIVE_29                  12:12
- #define GPIO_INTERRUPT_SETUP_ACTIVE_29_LOW              0
- #define GPIO_INTERRUPT_SETUP_ACTIVE_29_HIGH             1
- #define GPIO_INTERRUPT_SETUP_ACTIVE_28                  11:11
- #define GPIO_INTERRUPT_SETUP_ACTIVE_28_LOW              0
- #define GPIO_INTERRUPT_SETUP_ACTIVE_28_HIGH             1
- #define GPIO_INTERRUPT_SETUP_ACTIVE_27                  10:10
- #define GPIO_INTERRUPT_SETUP_ACTIVE_27_LOW              0
- #define GPIO_INTERRUPT_SETUP_ACTIVE_27_HIGH             1
- #define GPIO_INTERRUPT_SETUP_ACTIVE_26                  9:9
- #define GPIO_INTERRUPT_SETUP_ACTIVE_26_LOW              0
- #define GPIO_INTERRUPT_SETUP_ACTIVE_26_HIGH             1
- #define GPIO_INTERRUPT_SETUP_ACTIVE_25                  8:8
- #define GPIO_INTERRUPT_SETUP_ACTIVE_25_LOW              0
- #define GPIO_INTERRUPT_SETUP_ACTIVE_25_HIGH             1
- #define GPIO_INTERRUPT_SETUP_ENABLE_31                  6:6
- #define GPIO_INTERRUPT_SETUP_ENABLE_31_GPIO             0
- #define GPIO_INTERRUPT_SETUP_ENABLE_31_INTERRUPT        1
- #define GPIO_INTERRUPT_SETUP_ENABLE_30                  5:5
- #define GPIO_INTERRUPT_SETUP_ENABLE_30_GPIO             0
- #define GPIO_INTERRUPT_SETUP_ENABLE_30_INTERRUPT        1
- #define GPIO_INTERRUPT_SETUP_ENABLE_29                  4:4
- #define GPIO_INTERRUPT_SETUP_ENABLE_29_GPIO             0
- #define GPIO_INTERRUPT_SETUP_ENABLE_29_INTERRUPT        1
- #define GPIO_INTERRUPT_SETUP_ENABLE_28                  3:3
- #define GPIO_INTERRUPT_SETUP_ENABLE_28_GPIO             0
- #define GPIO_INTERRUPT_SETUP_ENABLE_28_INTERRUPT        1
- #define GPIO_INTERRUPT_SETUP_ENABLE_27                  2:2
- #define GPIO_INTERRUPT_SETUP_ENABLE_27_GPIO             0
- #define GPIO_INTERRUPT_SETUP_ENABLE_27_INTERRUPT        1
- #define GPIO_INTERRUPT_SETUP_ENABLE_26                  1:1
- #define GPIO_INTERRUPT_SETUP_ENABLE_26_GPIO             0
- #define GPIO_INTERRUPT_SETUP_ENABLE_26_INTERRUPT        1
- #define GPIO_INTERRUPT_SETUP_ENABLE_25                  0:0
- #define GPIO_INTERRUPT_SETUP_ENABLE_25_GPIO             0
- #define GPIO_INTERRUPT_SETUP_ENABLE_25_INTERRUPT        1
- 
- #define GPIO_INTERRUPT_STATUS                           0x01000C
- #define GPIO_INTERRUPT_STATUS_31                        22:22
- #define GPIO_INTERRUPT_STATUS_31_INACTIVE               0
- #define GPIO_INTERRUPT_STATUS_31_ACTIVE                 1
- #define GPIO_INTERRUPT_STATUS_31_RESET                  1
- #define GPIO_INTERRUPT_STATUS_30                        21:21
- #define GPIO_INTERRUPT_STATUS_30_INACTIVE               0
- #define GPIO_INTERRUPT_STATUS_30_ACTIVE                 1
- #define GPIO_INTERRUPT_STATUS_30_RESET                  1
- #define GPIO_INTERRUPT_STATUS_29                        20:20
- #define GPIO_INTERRUPT_STATUS_29_INACTIVE               0
- #define GPIO_INTERRUPT_STATUS_29_ACTIVE                 1
- #define GPIO_INTERRUPT_STATUS_29_RESET                  1
- #define GPIO_INTERRUPT_STATUS_28                        19:19
- #define GPIO_INTERRUPT_STATUS_28_INACTIVE               0
- #define GPIO_INTERRUPT_STATUS_28_ACTIVE                 1
- #define GPIO_INTERRUPT_STATUS_28_RESET                  1
- #define GPIO_INTERRUPT_STATUS_27                        18:18
- #define GPIO_INTERRUPT_STATUS_27_INACTIVE               0
- #define GPIO_INTERRUPT_STATUS_27_ACTIVE                 1
- #define GPIO_INTERRUPT_STATUS_27_RESET                  1
- #define GPIO_INTERRUPT_STATUS_26                        17:17
- #define GPIO_INTERRUPT_STATUS_26_INACTIVE               0
- #define GPIO_INTERRUPT_STATUS_26_ACTIVE                 1
- #define GPIO_INTERRUPT_STATUS_26_RESET                  1
- #define GPIO_INTERRUPT_STATUS_25                        16:16
- #define GPIO_INTERRUPT_STATUS_25_INACTIVE               0
- #define GPIO_INTERRUPT_STATUS_25_ACTIVE                 1
- #define GPIO_INTERRUPT_STATUS_25_RESET                  1
- 
- 
- #define PANEL_DISPLAY_CTRL                            0x080000
- #define PANEL_DISPLAY_CTRL_RESERVED_1_MASK            31:30
- #define PANEL_DISPLAY_CTRL_RESERVED_1_MASK_DISABLE    0
- #define PANEL_DISPLAY_CTRL_RESERVED_1_MASK_ENABLE     3
- #define PANEL_DISPLAY_CTRL_SELECT                     29:28
- #define PANEL_DISPLAY_CTRL_SELECT_PANEL               0
- #define PANEL_DISPLAY_CTRL_SELECT_VGA                 1
- #define PANEL_DISPLAY_CTRL_SELECT_CRT                 2
- #define PANEL_DISPLAY_CTRL_FPEN                       27:27
- #define PANEL_DISPLAY_CTRL_FPEN_LOW                   0
- #define PANEL_DISPLAY_CTRL_FPEN_HIGH                  1
- #define PANEL_DISPLAY_CTRL_VBIASEN                    26:26
- #define PANEL_DISPLAY_CTRL_VBIASEN_LOW                0
- #define PANEL_DISPLAY_CTRL_VBIASEN_HIGH               1
- #define PANEL_DISPLAY_CTRL_DATA                       25:25
- #define PANEL_DISPLAY_CTRL_DATA_DISABLE               0
- #define PANEL_DISPLAY_CTRL_DATA_ENABLE                1
- #define PANEL_DISPLAY_CTRL_FPVDDEN                    24:24
- #define PANEL_DISPLAY_CTRL_FPVDDEN_LOW                0
- #define PANEL_DISPLAY_CTRL_FPVDDEN_HIGH               1
- #define PANEL_DISPLAY_CTRL_RESERVED_2_MASK            23:20
- #define PANEL_DISPLAY_CTRL_RESERVED_2_MASK_DISABLE    0
- #define PANEL_DISPLAY_CTRL_RESERVED_2_MASK_ENABLE     15
- 
- #define PANEL_DISPLAY_CTRL_TFT_DISP 19:18
- #define PANEL_DISPLAY_CTRL_TFT_DISP_24 0
- #define PANEL_DISPLAY_CTRL_TFT_DISP_36 1
- #define PANEL_DISPLAY_CTRL_TFT_DISP_18 2
- 
- 
- #define PANEL_DISPLAY_CTRL_DUAL_DISPLAY               19:19
- #define PANEL_DISPLAY_CTRL_DUAL_DISPLAY_DISABLE       0
- #define PANEL_DISPLAY_CTRL_DUAL_DISPLAY_ENABLE        1
- #define PANEL_DISPLAY_CTRL_DOUBLE_PIXEL               18:18
- #define PANEL_DISPLAY_CTRL_DOUBLE_PIXEL_DISABLE       0
- #define PANEL_DISPLAY_CTRL_DOUBLE_PIXEL_ENABLE        1
- #define PANEL_DISPLAY_CTRL_FIFO                       17:16
- #define PANEL_DISPLAY_CTRL_FIFO_1                     0
- #define PANEL_DISPLAY_CTRL_FIFO_3                     1
- #define PANEL_DISPLAY_CTRL_FIFO_7                     2
- #define PANEL_DISPLAY_CTRL_FIFO_11                    3
- #define PANEL_DISPLAY_CTRL_RESERVED_3_MASK            15:15
- #define PANEL_DISPLAY_CTRL_RESERVED_3_MASK_DISABLE    0
- #define PANEL_DISPLAY_CTRL_RESERVED_3_MASK_ENABLE     1
- #define PANEL_DISPLAY_CTRL_CLOCK_PHASE                14:14
- #define PANEL_DISPLAY_CTRL_CLOCK_PHASE_ACTIVE_HIGH    0
- #define PANEL_DISPLAY_CTRL_CLOCK_PHASE_ACTIVE_LOW     1
- #define PANEL_DISPLAY_CTRL_VSYNC_PHASE                13:13
- #define PANEL_DISPLAY_CTRL_VSYNC_PHASE_ACTIVE_HIGH    0
- #define PANEL_DISPLAY_CTRL_VSYNC_PHASE_ACTIVE_LOW     1
- #define PANEL_DISPLAY_CTRL_HSYNC_PHASE                12:12
- #define PANEL_DISPLAY_CTRL_HSYNC_PHASE_ACTIVE_HIGH    0
- #define PANEL_DISPLAY_CTRL_HSYNC_PHASE_ACTIVE_LOW     1
- #define PANEL_DISPLAY_CTRL_VSYNC                      11:11
- #define PANEL_DISPLAY_CTRL_VSYNC_ACTIVE_HIGH          0
- #define PANEL_DISPLAY_CTRL_VSYNC_ACTIVE_LOW           1
- #define PANEL_DISPLAY_CTRL_CAPTURE_TIMING             10:10
- #define PANEL_DISPLAY_CTRL_CAPTURE_TIMING_DISABLE     0
- #define PANEL_DISPLAY_CTRL_CAPTURE_TIMING_ENABLE      1
- #define PANEL_DISPLAY_CTRL_COLOR_KEY                  9:9
- #define PANEL_DISPLAY_CTRL_COLOR_KEY_DISABLE          0
- #define PANEL_DISPLAY_CTRL_COLOR_KEY_ENABLE           1
- #define PANEL_DISPLAY_CTRL_TIMING                     8:8
- #define PANEL_DISPLAY_CTRL_TIMING_DISABLE             0
- #define PANEL_DISPLAY_CTRL_TIMING_ENABLE              1
- #define PANEL_DISPLAY_CTRL_VERTICAL_PAN_DIR           7:7
- #define PANEL_DISPLAY_CTRL_VERTICAL_PAN_DIR_DOWN      0
- #define PANEL_DISPLAY_CTRL_VERTICAL_PAN_DIR_UP        1
- #define PANEL_DISPLAY_CTRL_VERTICAL_PAN               6:6
- #define PANEL_DISPLAY_CTRL_VERTICAL_PAN_DISABLE       0
- #define PANEL_DISPLAY_CTRL_VERTICAL_PAN_ENABLE        1
- #define PANEL_DISPLAY_CTRL_HORIZONTAL_PAN_DIR         5:5
- #define PANEL_DISPLAY_CTRL_HORIZONTAL_PAN_DIR_RIGHT   0
- #define PANEL_DISPLAY_CTRL_HORIZONTAL_PAN_DIR_LEFT    1
- #define PANEL_DISPLAY_CTRL_HORIZONTAL_PAN             4:4
- #define PANEL_DISPLAY_CTRL_HORIZONTAL_PAN_DISABLE     0
- #define PANEL_DISPLAY_CTRL_HORIZONTAL_PAN_ENABLE      1
- #define PANEL_DISPLAY_CTRL_GAMMA                      3:3
- #define PANEL_DISPLAY_CTRL_GAMMA_DISABLE              0
- #define PANEL_DISPLAY_CTRL_GAMMA_ENABLE               1
- #define PANEL_DISPLAY_CTRL_PLANE                      2:2
- #define PANEL_DISPLAY_CTRL_PLANE_DISABLE              0
- #define PANEL_DISPLAY_CTRL_PLANE_ENABLE               1
- #define PANEL_DISPLAY_CTRL_FORMAT                     1:0
- #define PANEL_DISPLAY_CTRL_FORMAT_8                   0
- #define PANEL_DISPLAY_CTRL_FORMAT_16                  1
- #define PANEL_DISPLAY_CTRL_FORMAT_32                  2
- 
- #define PANEL_PAN_CTRL                                0x080004
- #define PANEL_PAN_CTRL_VERTICAL_PAN                   31:24
- #define PANEL_PAN_CTRL_VERTICAL_VSYNC                 21:16
- #define PANEL_PAN_CTRL_HORIZONTAL_PAN                 15:8
- #define PANEL_PAN_CTRL_HORIZONTAL_VSYNC               5:0
- 
- #define PANEL_COLOR_KEY                               0x080008
- #define PANEL_COLOR_KEY_MASK                          31:16
- #define PANEL_COLOR_KEY_VALUE                         15:0
- 
- #define PANEL_FB_ADDRESS                              0x08000C
- #define PANEL_FB_ADDRESS_STATUS                       31:31
- #define PANEL_FB_ADDRESS_STATUS_CURRENT               0
- #define PANEL_FB_ADDRESS_STATUS_PENDING               1
- #define PANEL_FB_ADDRESS_EXT                          27:27
- #define PANEL_FB_ADDRESS_EXT_LOCAL                    0
- #define PANEL_FB_ADDRESS_EXT_EXTERNAL                 1
- #define PANEL_FB_ADDRESS_ADDRESS                      25:0
- 
- #define PANEL_FB_WIDTH                                0x080010
- #define PANEL_FB_WIDTH_WIDTH                          29:16
- #define PANEL_FB_WIDTH_OFFSET                         13:0
- 
- #define PANEL_WINDOW_WIDTH                            0x080014
- #define PANEL_WINDOW_WIDTH_WIDTH                      27:16
- #define PANEL_WINDOW_WIDTH_X                          11:0
- 
- #define PANEL_WINDOW_HEIGHT                           0x080018
- #define PANEL_WINDOW_HEIGHT_HEIGHT                    27:16
- #define PANEL_WINDOW_HEIGHT_Y                         11:0
- 
- #define PANEL_PLANE_TL                                0x08001C
- #define PANEL_PLANE_TL_TOP                            26:16
- #define PANEL_PLANE_TL_LEFT                           10:0
- 
- #define PANEL_PLANE_BR                                0x080020
- #define PANEL_PLANE_BR_BOTTOM                         26:16
- #define PANEL_PLANE_BR_RIGHT                          10:0
- 
- #define PANEL_HORIZONTAL_TOTAL                        0x080024
- #define PANEL_HORIZONTAL_TOTAL_TOTAL                  27:16
- #define PANEL_HORIZONTAL_TOTAL_DISPLAY_END            11:0
- 
- #define PANEL_HORIZONTAL_SYNC                         0x080028
- #define PANEL_HORIZONTAL_SYNC_WIDTH                   23:16
- #define PANEL_HORIZONTAL_SYNC_START                   11:0
- 
- #define PANEL_VERTICAL_TOTAL                          0x08002C
- #define PANEL_VERTICAL_TOTAL_TOTAL                    26:16
- #define PANEL_VERTICAL_TOTAL_DISPLAY_END              10:0
- 
- #define PANEL_VERTICAL_SYNC                           0x080030
- #define PANEL_VERTICAL_SYNC_HEIGHT                    21:16
- #define PANEL_VERTICAL_SYNC_START                     10:0
- 
- #define PANEL_CURRENT_LINE                            0x080034
- #define PANEL_CURRENT_LINE_LINE                       10:0
- 
- /* Video Control */
- 
- #define VIDEO_DISPLAY_CTRL                              0x080040
- #define VIDEO_DISPLAY_CTRL_LINE_BUFFER                  18:18
- #define VIDEO_DISPLAY_CTRL_LINE_BUFFER_DISABLE          0
- #define VIDEO_DISPLAY_CTRL_LINE_BUFFER_ENABLE           1
- #define VIDEO_DISPLAY_CTRL_FIFO                         17:16
- #define VIDEO_DISPLAY_CTRL_FIFO_1                       0
- #define VIDEO_DISPLAY_CTRL_FIFO_3                       1
- #define VIDEO_DISPLAY_CTRL_FIFO_7                       2
- #define VIDEO_DISPLAY_CTRL_FIFO_11                      3
- #define VIDEO_DISPLAY_CTRL_BUFFER                       15:15
- #define VIDEO_DISPLAY_CTRL_BUFFER_0                     0
- #define VIDEO_DISPLAY_CTRL_BUFFER_1                     1
- #define VIDEO_DISPLAY_CTRL_CAPTURE                      14:14
- #define VIDEO_DISPLAY_CTRL_CAPTURE_DISABLE              0
- #define VIDEO_DISPLAY_CTRL_CAPTURE_ENABLE               1
- #define VIDEO_DISPLAY_CTRL_DOUBLE_BUFFER                13:13
- #define VIDEO_DISPLAY_CTRL_DOUBLE_BUFFER_DISABLE        0
- #define VIDEO_DISPLAY_CTRL_DOUBLE_BUFFER_ENABLE         1
- #define VIDEO_DISPLAY_CTRL_BYTE_SWAP                    12:12
- #define VIDEO_DISPLAY_CTRL_BYTE_SWAP_DISABLE            0
- #define VIDEO_DISPLAY_CTRL_BYTE_SWAP_ENABLE             1
- #define VIDEO_DISPLAY_CTRL_VERTICAL_SCALE               11:11
- #define VIDEO_DISPLAY_CTRL_VERTICAL_SCALE_NORMAL        0
- #define VIDEO_DISPLAY_CTRL_VERTICAL_SCALE_HALF          1
- #define VIDEO_DISPLAY_CTRL_HORIZONTAL_SCALE             10:10
- #define VIDEO_DISPLAY_CTRL_HORIZONTAL_SCALE_NORMAL      0
- #define VIDEO_DISPLAY_CTRL_HORIZONTAL_SCALE_HALF        1
- #define VIDEO_DISPLAY_CTRL_VERTICAL_MODE                9:9
- #define VIDEO_DISPLAY_CTRL_VERTICAL_MODE_REPLICATE      0
- #define VIDEO_DISPLAY_CTRL_VERTICAL_MODE_INTERPOLATE    1
- #define VIDEO_DISPLAY_CTRL_HORIZONTAL_MODE              8:8
- #define VIDEO_DISPLAY_CTRL_HORIZONTAL_MODE_REPLICATE    0
- #define VIDEO_DISPLAY_CTRL_HORIZONTAL_MODE_INTERPOLATE  1
- #define VIDEO_DISPLAY_CTRL_PIXEL                        7:4
- #define VIDEO_DISPLAY_CTRL_GAMMA                        3:3
- #define VIDEO_DISPLAY_CTRL_GAMMA_DISABLE                0
- #define VIDEO_DISPLAY_CTRL_GAMMA_ENABLE                 1
- #define VIDEO_DISPLAY_CTRL_PLANE                        2:2
- #define VIDEO_DISPLAY_CTRL_PLANE_DISABLE                0
- #define VIDEO_DISPLAY_CTRL_PLANE_ENABLE                 1
- #define VIDEO_DISPLAY_CTRL_FORMAT                       1:0
- #define VIDEO_DISPLAY_CTRL_FORMAT_8                     0
- #define VIDEO_DISPLAY_CTRL_FORMAT_16                    1
- #define VIDEO_DISPLAY_CTRL_FORMAT_32                    2
- #define VIDEO_DISPLAY_CTRL_FORMAT_YUV                   3
- 
- #define VIDEO_FB_0_ADDRESS                            0x080044
- #define VIDEO_FB_0_ADDRESS_STATUS                     31:31
- #define VIDEO_FB_0_ADDRESS_STATUS_CURRENT             0
- #define VIDEO_FB_0_ADDRESS_STATUS_PENDING             1
- #define VIDEO_FB_0_ADDRESS_EXT                        27:27
- #define VIDEO_FB_0_ADDRESS_EXT_LOCAL                  0
- #define VIDEO_FB_0_ADDRESS_EXT_EXTERNAL               1
- #define VIDEO_FB_0_ADDRESS_ADDRESS                    25:0
- 
- #define VIDEO_FB_WIDTH                                0x080048
- #define VIDEO_FB_WIDTH_WIDTH                          29:16
- #define VIDEO_FB_WIDTH_OFFSET                         13:0
- 
- #define VIDEO_FB_0_LAST_ADDRESS                       0x08004C
- #define VIDEO_FB_0_LAST_ADDRESS_EXT                   27:27
- #define VIDEO_FB_0_LAST_ADDRESS_EXT_LOCAL             0
- #define VIDEO_FB_0_LAST_ADDRESS_EXT_EXTERNAL          1
- #define VIDEO_FB_0_LAST_ADDRESS_ADDRESS               25:0
- 
- #define VIDEO_PLANE_TL                                0x080050
- #define VIDEO_PLANE_TL_TOP                            26:16
- #define VIDEO_PLANE_TL_LEFT                           10:0
- 
- #define VIDEO_PLANE_BR                                0x080054
- #define VIDEO_PLANE_BR_BOTTOM                         26:16
- #define VIDEO_PLANE_BR_RIGHT                          10:0
- 
- #define VIDEO_SCALE                                   0x080058
- #define VIDEO_SCALE_VERTICAL_MODE                     31:31
- #define VIDEO_SCALE_VERTICAL_MODE_EXPAND              0
- #define VIDEO_SCALE_VERTICAL_MODE_SHRINK              1
- #define VIDEO_SCALE_VERTICAL_SCALE                    27:16
- #define VIDEO_SCALE_HORIZONTAL_MODE                   15:15
- #define VIDEO_SCALE_HORIZONTAL_MODE_EXPAND            0
- #define VIDEO_SCALE_HORIZONTAL_MODE_SHRINK            1
- #define VIDEO_SCALE_HORIZONTAL_SCALE                  11:0
- 
- #define VIDEO_INITIAL_SCALE                           0x08005C
- #define VIDEO_INITIAL_SCALE_FB_1                      27:16
- #define VIDEO_INITIAL_SCALE_FB_0                      11:0
- 
- #define VIDEO_YUV_CONSTANTS                           0x080060
- #define VIDEO_YUV_CONSTANTS_Y                         31:24
- #define VIDEO_YUV_CONSTANTS_R                         23:16
- #define VIDEO_YUV_CONSTANTS_G                         15:8
- #define VIDEO_YUV_CONSTANTS_B                         7:0
- 
- #define VIDEO_FB_1_ADDRESS                            0x080064
- #define VIDEO_FB_1_ADDRESS_STATUS                     31:31
- #define VIDEO_FB_1_ADDRESS_STATUS_CURRENT             0
- #define VIDEO_FB_1_ADDRESS_STATUS_PENDING             1
- #define VIDEO_FB_1_ADDRESS_EXT                        27:27
- #define VIDEO_FB_1_ADDRESS_EXT_LOCAL                  0
- #define VIDEO_FB_1_ADDRESS_EXT_EXTERNAL               1
- #define VIDEO_FB_1_ADDRESS_ADDRESS                    25:0
- 
- #define VIDEO_FB_1_LAST_ADDRESS                       0x080068
- #define VIDEO_FB_1_LAST_ADDRESS_EXT                   27:27
- #define VIDEO_FB_1_LAST_ADDRESS_EXT_LOCAL             0
- #define VIDEO_FB_1_LAST_ADDRESS_EXT_EXTERNAL          1
- #define VIDEO_FB_1_LAST_ADDRESS_ADDRESS               25:0
- 
- /* Video Alpha Control */
- 
- #define VIDEO_ALPHA_DISPLAY_CTRL                        0x080080
- #define VIDEO_ALPHA_DISPLAY_CTRL_SELECT                 28:28
- #define VIDEO_ALPHA_DISPLAY_CTRL_SELECT_PER_PIXEL       0
- #define VIDEO_ALPHA_DISPLAY_CTRL_SELECT_ALPHA           1
- #define VIDEO_ALPHA_DISPLAY_CTRL_ALPHA                  27:24
- #define VIDEO_ALPHA_DISPLAY_CTRL_FIFO                   17:16
- #define VIDEO_ALPHA_DISPLAY_CTRL_FIFO_1                 0
- #define VIDEO_ALPHA_DISPLAY_CTRL_FIFO_3                 1
- #define VIDEO_ALPHA_DISPLAY_CTRL_FIFO_7                 2
- #define VIDEO_ALPHA_DISPLAY_CTRL_FIFO_11                3
- #define VIDEO_ALPHA_DISPLAY_CTRL_VERT_SCALE             11:11
- #define VIDEO_ALPHA_DISPLAY_CTRL_VERT_SCALE_NORMAL      0
- #define VIDEO_ALPHA_DISPLAY_CTRL_VERT_SCALE_HALF        1
- #define VIDEO_ALPHA_DISPLAY_CTRL_HORZ_SCALE             10:10
- #define VIDEO_ALPHA_DISPLAY_CTRL_HORZ_SCALE_NORMAL      0
- #define VIDEO_ALPHA_DISPLAY_CTRL_HORZ_SCALE_HALF        1
- #define VIDEO_ALPHA_DISPLAY_CTRL_VERT_MODE              9:9
- #define VIDEO_ALPHA_DISPLAY_CTRL_VERT_MODE_REPLICATE    0
- #define VIDEO_ALPHA_DISPLAY_CTRL_VERT_MODE_INTERPOLATE  1
- #define VIDEO_ALPHA_DISPLAY_CTRL_HORZ_MODE              8:8
- #define VIDEO_ALPHA_DISPLAY_CTRL_HORZ_MODE_REPLICATE    0
- #define VIDEO_ALPHA_DISPLAY_CTRL_HORZ_MODE_INTERPOLATE  1
- #define VIDEO_ALPHA_DISPLAY_CTRL_PIXEL                  7:4
- #define VIDEO_ALPHA_DISPLAY_CTRL_CHROMA_KEY             3:3
- #define VIDEO_ALPHA_DISPLAY_CTRL_CHROMA_KEY_DISABLE     0
- #define VIDEO_ALPHA_DISPLAY_CTRL_CHROMA_KEY_ENABLE      1
- #define VIDEO_ALPHA_DISPLAY_CTRL_PLANE                  2:2
- #define VIDEO_ALPHA_DISPLAY_CTRL_PLANE_DISABLE          0
- #define VIDEO_ALPHA_DISPLAY_CTRL_PLANE_ENABLE           1
- #define VIDEO_ALPHA_DISPLAY_CTRL_FORMAT                 1:0
- #define VIDEO_ALPHA_DISPLAY_CTRL_FORMAT_8               0
- #define VIDEO_ALPHA_DISPLAY_CTRL_FORMAT_16              1
- #define VIDEO_ALPHA_DISPLAY_CTRL_FORMAT_ALPHA_4_4       2
- #define VIDEO_ALPHA_DISPLAY_CTRL_FORMAT_ALPHA_4_4_4_4   3
- 
- #define VIDEO_ALPHA_FB_ADDRESS                        0x080084
- #define VIDEO_ALPHA_FB_ADDRESS_STATUS                 31:31
- #define VIDEO_ALPHA_FB_ADDRESS_STATUS_CURRENT         0
- #define VIDEO_ALPHA_FB_ADDRESS_STATUS_PENDING         1
- #define VIDEO_ALPHA_FB_ADDRESS_EXT                    27:27
- #define VIDEO_ALPHA_FB_ADDRESS_EXT_LOCAL              0
- #define VIDEO_ALPHA_FB_ADDRESS_EXT_EXTERNAL           1
- #define VIDEO_ALPHA_FB_ADDRESS_ADDRESS                25:0
- 
- #define VIDEO_ALPHA_FB_WIDTH                          0x080088
- #define VIDEO_ALPHA_FB_WIDTH_WIDTH                    29:16
- #define VIDEO_ALPHA_FB_WIDTH_OFFSET                   13:0
- 
- #define VIDEO_ALPHA_FB_LAST_ADDRESS                   0x08008C
- #define VIDEO_ALPHA_FB_LAST_ADDRESS_EXT               27:27
- #define VIDEO_ALPHA_FB_LAST_ADDRESS_EXT_LOCAL         0
- #define VIDEO_ALPHA_FB_LAST_ADDRESS_EXT_EXTERNAL      1
- #define VIDEO_ALPHA_FB_LAST_ADDRESS_ADDRESS           25:0
- 
- #define VIDEO_ALPHA_PLANE_TL                          0x080090
- #define VIDEO_ALPHA_PLANE_TL_TOP                      26:16
- #define VIDEO_ALPHA_PLANE_TL_LEFT                     10:0
- 
- #define VIDEO_ALPHA_PLANE_BR                          0x080094
- #define VIDEO_ALPHA_PLANE_BR_BOTTOM                   26:16
- #define VIDEO_ALPHA_PLANE_BR_RIGHT                    10:0
- 
- #define VIDEO_ALPHA_SCALE                             0x080098
- #define VIDEO_ALPHA_SCALE_VERTICAL_MODE               31:31
- #define VIDEO_ALPHA_SCALE_VERTICAL_MODE_EXPAND        0
- #define VIDEO_ALPHA_SCALE_VERTICAL_MODE_SHRINK        1
- #define VIDEO_ALPHA_SCALE_VERTICAL_SCALE              27:16
- #define VIDEO_ALPHA_SCALE_HORIZONTAL_MODE             15:15
- #define VIDEO_ALPHA_SCALE_HORIZONTAL_MODE_EXPAND      0
- #define VIDEO_ALPHA_SCALE_HORIZONTAL_MODE_SHRINK      1
- #define VIDEO_ALPHA_SCALE_HORIZONTAL_SCALE            11:0
- 
- #define VIDEO_ALPHA_INITIAL_SCALE                     0x08009C
- #define VIDEO_ALPHA_INITIAL_SCALE_VERTICAL            27:16
- #define VIDEO_ALPHA_INITIAL_SCALE_HORIZONTAL          11:0
- 
- #define VIDEO_ALPHA_CHROMA_KEY                        0x0800A0
- #define VIDEO_ALPHA_CHROMA_KEY_MASK                   31:16
- #define VIDEO_ALPHA_CHROMA_KEY_VALUE                  15:0
- 
- #define VIDEO_ALPHA_COLOR_LOOKUP_01                   0x0800A4
- #define VIDEO_ALPHA_COLOR_LOOKUP_01_1                 31:16
- #define VIDEO_ALPHA_COLOR_LOOKUP_01_1_RED             31:27
- #define VIDEO_ALPHA_COLOR_LOOKUP_01_1_GREEN           26:21
- #define VIDEO_ALPHA_COLOR_LOOKUP_01_1_BLUE            20:16
- #define VIDEO_ALPHA_COLOR_LOOKUP_01_0                 15:0
- #define VIDEO_ALPHA_COLOR_LOOKUP_01_0_RED             15:11
- #define VIDEO_ALPHA_COLOR_LOOKUP_01_0_GREEN           10:5
- #define VIDEO_ALPHA_COLOR_LOOKUP_01_0_BLUE            4:0
- 
- #define VIDEO_ALPHA_COLOR_LOOKUP_23                   0x0800A8
- #define VIDEO_ALPHA_COLOR_LOOKUP_23_3                 31:16
- #define VIDEO_ALPHA_COLOR_LOOKUP_23_3_RED             31:27
- #define VIDEO_ALPHA_COLOR_LOOKUP_23_3_GREEN           26:21
- #define VIDEO_ALPHA_COLOR_LOOKUP_23_3_BLUE            20:16
- #define VIDEO_ALPHA_COLOR_LOOKUP_23_2                 15:0
- #define VIDEO_ALPHA_COLOR_LOOKUP_23_2_RED             15:11
- #define VIDEO_ALPHA_COLOR_LOOKUP_23_2_GREEN           10:5
- #define VIDEO_ALPHA_COLOR_LOOKUP_23_2_BLUE            4:0
- 
- #define VIDEO_ALPHA_COLOR_LOOKUP_45                   0x0800AC
- #define VIDEO_ALPHA_COLOR_LOOKUP_45_5                 31:16
- #define VIDEO_ALPHA_COLOR_LOOKUP_45_5_RED             31:27
- #define VIDEO_ALPHA_COLOR_LOOKUP_45_5_GREEN           26:21
- #define VIDEO_ALPHA_COLOR_LOOKUP_45_5_BLUE            20:16
- #define VIDEO_ALPHA_COLOR_LOOKUP_45_4                 15:0
- #define VIDEO_ALPHA_COLOR_LOOKUP_45_4_RED             15:11
- #define VIDEO_ALPHA_COLOR_LOOKUP_45_4_GREEN           10:5
- #define VIDEO_ALPHA_COLOR_LOOKUP_45_4_BLUE            4:0
- 
- #define VIDEO_ALPHA_COLOR_LOOKUP_67                   0x0800B0
- #define VIDEO_ALPHA_COLOR_LOOKUP_67_7                 31:16
- #define VIDEO_ALPHA_COLOR_LOOKUP_67_7_RED             31:27
- #define VIDEO_ALPHA_COLOR_LOOKUP_67_7_GREEN           26:21
- #define VIDEO_ALPHA_COLOR_LOOKUP_67_7_BLUE            20:16
- #define VIDEO_ALPHA_COLOR_LOOKUP_67_6                 15:0
- #define VIDEO_ALPHA_COLOR_LOOKUP_67_6_RED             15:11
- #define VIDEO_ALPHA_COLOR_LOOKUP_67_6_GREEN           10:5
- #define VIDEO_ALPHA_COLOR_LOOKUP_67_6_BLUE            4:0
- 
- #define VIDEO_ALPHA_COLOR_LOOKUP_89                   0x0800B4
- #define VIDEO_ALPHA_COLOR_LOOKUP_89_9                 31:16
- #define VIDEO_ALPHA_COLOR_LOOKUP_89_9_RED             31:27
- #define VIDEO_ALPHA_COLOR_LOOKUP_89_9_GREEN           26:21
- #define VIDEO_ALPHA_COLOR_LOOKUP_89_9_BLUE            20:16
- #define VIDEO_ALPHA_COLOR_LOOKUP_89_8                 15:0
- #define VIDEO_ALPHA_COLOR_LOOKUP_89_8_RED             15:11
- #define VIDEO_ALPHA_COLOR_LOOKUP_89_8_GREEN           10:5
- #define VIDEO_ALPHA_COLOR_LOOKUP_89_8_BLUE            4:0
- 
- #define VIDEO_ALPHA_COLOR_LOOKUP_AB                   0x0800B8
- #define VIDEO_ALPHA_COLOR_LOOKUP_AB_B                 31:16
- #define VIDEO_ALPHA_COLOR_LOOKUP_AB_B_RED             31:27
- #define VIDEO_ALPHA_COLOR_LOOKUP_AB_B_GREEN           26:21
- #define VIDEO_ALPHA_COLOR_LOOKUP_AB_B_BLUE            20:16
- #define VIDEO_ALPHA_COLOR_LOOKUP_AB_A                 15:0
- #define VIDEO_ALPHA_COLOR_LOOKUP_AB_A_RED             15:11
- #define VIDEO_ALPHA_COLOR_LOOKUP_AB_A_GREEN           10:5
- #define VIDEO_ALPHA_COLOR_LOOKUP_AB_A_BLUE            4:0
- 
- #define VIDEO_ALPHA_COLOR_LOOKUP_CD                   0x0800BC
- #define VIDEO_ALPHA_COLOR_LOOKUP_CD_D                 31:16
- #define VIDEO_ALPHA_COLOR_LOOKUP_CD_D_RED             31:27
- #define VIDEO_ALPHA_COLOR_LOOKUP_CD_D_GREEN           26:21
- #define VIDEO_ALPHA_COLOR_LOOKUP_CD_D_BLUE            20:16
- #define VIDEO_ALPHA_COLOR_LOOKUP_CD_C                 15:0
- #define VIDEO_ALPHA_COLOR_LOOKUP_CD_C_RED             15:11
- #define VIDEO_ALPHA_COLOR_LOOKUP_CD_C_GREEN           10:5
- #define VIDEO_ALPHA_COLOR_LOOKUP_CD_C_BLUE            4:0
- 
- #define VIDEO_ALPHA_COLOR_LOOKUP_EF                   0x0800C0
- #define VIDEO_ALPHA_COLOR_LOOKUP_EF_F                 31:16
- #define VIDEO_ALPHA_COLOR_LOOKUP_EF_F_RED             31:27
- #define VIDEO_ALPHA_COLOR_LOOKUP_EF_F_GREEN           26:21
- #define VIDEO_ALPHA_COLOR_LOOKUP_EF_F_BLUE            20:16
- #define VIDEO_ALPHA_COLOR_LOOKUP_EF_E                 15:0
- #define VIDEO_ALPHA_COLOR_LOOKUP_EF_E_RED             15:11
- #define VIDEO_ALPHA_COLOR_LOOKUP_EF_E_GREEN           10:5
- #define VIDEO_ALPHA_COLOR_LOOKUP_EF_E_BLUE            4:0
- 
- /* Panel Cursor Control */
- 
- #define PANEL_HWC_ADDRESS                             0x0800F0
- #define PANEL_HWC_ADDRESS_ENABLE                      31:31
- #define PANEL_HWC_ADDRESS_ENABLE_DISABLE              0
- #define PANEL_HWC_ADDRESS_ENABLE_ENABLE               1
- #define PANEL_HWC_ADDRESS_EXT                         27:27
- #define PANEL_HWC_ADDRESS_EXT_LOCAL                   0
- #define PANEL_HWC_ADDRESS_EXT_EXTERNAL                1
- #define PANEL_HWC_ADDRESS_ADDRESS                     25:0
- 
- #define PANEL_HWC_LOCATION                            0x0800F4
- #define PANEL_HWC_LOCATION_TOP                        27:27
- #define PANEL_HWC_LOCATION_TOP_INSIDE                 0
- #define PANEL_HWC_LOCATION_TOP_OUTSIDE                1
- #define PANEL_HWC_LOCATION_Y                          26:16
- #define PANEL_HWC_LOCATION_LEFT                       11:11
- #define PANEL_HWC_LOCATION_LEFT_INSIDE                0
- #define PANEL_HWC_LOCATION_LEFT_OUTSIDE               1
- #define PANEL_HWC_LOCATION_X                          10:0
- 
- #define PANEL_HWC_COLOR_12                            0x0800F8
- #define PANEL_HWC_COLOR_12_2_RGB565                   31:16
- #define PANEL_HWC_COLOR_12_1_RGB565                   15:0
- 
- #define PANEL_HWC_COLOR_3                             0x0800FC
- #define PANEL_HWC_COLOR_3_RGB565                      15:0
- 
- /* Old Definitions +++ */
- #define PANEL_HWC_COLOR_01                            0x0800F8
- #define PANEL_HWC_COLOR_01_1_RED                      31:27
- #define PANEL_HWC_COLOR_01_1_GREEN                    26:21
- #define PANEL_HWC_COLOR_01_1_BLUE                     20:16
- #define PANEL_HWC_COLOR_01_0_RED                      15:11
- #define PANEL_HWC_COLOR_01_0_GREEN                    10:5
- #define PANEL_HWC_COLOR_01_0_BLUE                     4:0
- 
- #define PANEL_HWC_COLOR_2                             0x0800FC
- #define PANEL_HWC_COLOR_2_RED                         15:11
- #define PANEL_HWC_COLOR_2_GREEN                       10:5
- #define PANEL_HWC_COLOR_2_BLUE                        4:0
- /* Old Definitions --- */
- 
- /* Alpha Control */
- 
- #define ALPHA_DISPLAY_CTRL                            0x080100
- #define ALPHA_DISPLAY_CTRL_SELECT                     28:28
- #define ALPHA_DISPLAY_CTRL_SELECT_PER_PIXEL           0
- #define ALPHA_DISPLAY_CTRL_SELECT_ALPHA               1
- #define ALPHA_DISPLAY_CTRL_ALPHA                      27:24
- #define ALPHA_DISPLAY_CTRL_FIFO                       17:16
- #define ALPHA_DISPLAY_CTRL_FIFO_1                     0
- #define ALPHA_DISPLAY_CTRL_FIFO_3                     1
- #define ALPHA_DISPLAY_CTRL_FIFO_7                     2
- #define ALPHA_DISPLAY_CTRL_FIFO_11                    3
- #define ALPHA_DISPLAY_CTRL_PIXEL                      7:4
- #define ALPHA_DISPLAY_CTRL_CHROMA_KEY                 3:3
- #define ALPHA_DISPLAY_CTRL_CHROMA_KEY_DISABLE         0
- #define ALPHA_DISPLAY_CTRL_CHROMA_KEY_ENABLE          1
- #define ALPHA_DISPLAY_CTRL_PLANE                      2:2
- #define ALPHA_DISPLAY_CTRL_PLANE_DISABLE              0
- #define ALPHA_DISPLAY_CTRL_PLANE_ENABLE               1
- #define ALPHA_DISPLAY_CTRL_FORMAT                     1:0
- #define ALPHA_DISPLAY_CTRL_FORMAT_16                  1
- #define ALPHA_DISPLAY_CTRL_FORMAT_ALPHA_4_4           2
- #define ALPHA_DISPLAY_CTRL_FORMAT_ALPHA_4_4_4_4       3
- 
- #define ALPHA_FB_ADDRESS                              0x080104
- #define ALPHA_FB_ADDRESS_STATUS                       31:31
- #define ALPHA_FB_ADDRESS_STATUS_CURRENT               0
- #define ALPHA_FB_ADDRESS_STATUS_PENDING               1
- #define ALPHA_FB_ADDRESS_EXT                          27:27
- #define ALPHA_FB_ADDRESS_EXT_LOCAL                    0
- #define ALPHA_FB_ADDRESS_EXT_EXTERNAL                 1
- #define ALPHA_FB_ADDRESS_ADDRESS                      25:0
- 
- #define ALPHA_FB_WIDTH                                0x080108
- #define ALPHA_FB_WIDTH_WIDTH                          29:16
- #define ALPHA_FB_WIDTH_OFFSET                         13:0
- 
- #define ALPHA_PLANE_TL                                0x08010C
- #define ALPHA_PLANE_TL_TOP                            26:16
- #define ALPHA_PLANE_TL_LEFT                           10:0
- 
- #define ALPHA_PLANE_BR                                0x080110
- #define ALPHA_PLANE_BR_BOTTOM                         26:16
- #define ALPHA_PLANE_BR_RIGHT                          10:0
- 
- #define ALPHA_CHROMA_KEY                              0x080114
- #define ALPHA_CHROMA_KEY_MASK                         31:16
- #define ALPHA_CHROMA_KEY_VALUE                        15:0
- 
- #define ALPHA_COLOR_LOOKUP_01                         0x080118
- #define ALPHA_COLOR_LOOKUP_01_1                       31:16
- #define ALPHA_COLOR_LOOKUP_01_1_RED                   31:27
- #define ALPHA_COLOR_LOOKUP_01_1_GREEN                 26:21
- #define ALPHA_COLOR_LOOKUP_01_1_BLUE                  20:16
- #define ALPHA_COLOR_LOOKUP_01_0                       15:0
- #define ALPHA_COLOR_LOOKUP_01_0_RED                   15:11
- #define ALPHA_COLOR_LOOKUP_01_0_GREEN                 10:5
- #define ALPHA_COLOR_LOOKUP_01_0_BLUE                  4:0
- 
- #define ALPHA_COLOR_LOOKUP_23                         0x08011C
- #define ALPHA_COLOR_LOOKUP_23_3                       31:16
- #define ALPHA_COLOR_LOOKUP_23_3_RED                   31:27
- #define ALPHA_COLOR_LOOKUP_23_3_GREEN                 26:21
- #define ALPHA_COLOR_LOOKUP_23_3_BLUE                  20:16
- #define ALPHA_COLOR_LOOKUP_23_2                       15:0
- #define ALPHA_COLOR_LOOKUP_23_2_RED                   15:11
- #define ALPHA_COLOR_LOOKUP_23_2_GREEN                 10:5
- #define ALPHA_COLOR_LOOKUP_23_2_BLUE                  4:0
- 
- #define ALPHA_COLOR_LOOKUP_45                         0x080120
- #define ALPHA_COLOR_LOOKUP_45_5                       31:16
- #define ALPHA_COLOR_LOOKUP_45_5_RED                   31:27
- #define ALPHA_COLOR_LOOKUP_45_5_GREEN                 26:21
- #define ALPHA_COLOR_LOOKUP_45_5_BLUE                  20:16
- #define ALPHA_COLOR_LOOKUP_45_4                       15:0
- #define ALPHA_COLOR_LOOKUP_45_4_RED                   15:11
- #define ALPHA_COLOR_LOOKUP_45_4_GREEN                 10:5
- #define ALPHA_COLOR_LOOKUP_45_4_BLUE                  4:0
- 
- #define ALPHA_COLOR_LOOKUP_67                         0x080124
- #define ALPHA_COLOR_LOOKUP_67_7                       31:16
- #define ALPHA_COLOR_LOOKUP_67_7_RED                   31:27
- #define ALPHA_COLOR_LOOKUP_67_7_GREEN                 26:21
- #define ALPHA_COLOR_LOOKUP_67_7_BLUE                  20:16
- #define ALPHA_COLOR_LOOKUP_67_6                       15:0
- #define ALPHA_COLOR_LOOKUP_67_6_RED                   15:11
- #define ALPHA_COLOR_LOOKUP_67_6_GREEN                 10:5
- #define ALPHA_COLOR_LOOKUP_67_6_BLUE                  4:0
- 
- #define ALPHA_COLOR_LOOKUP_89                         0x080128
- #define ALPHA_COLOR_LOOKUP_89_9                       31:16
- #define ALPHA_COLOR_LOOKUP_89_9_RED                   31:27
- #define ALPHA_COLOR_LOOKUP_89_9_GREEN                 26:21
- #define ALPHA_COLOR_LOOKUP_89_9_BLUE                  20:16
- #define ALPHA_COLOR_LOOKUP_89_8                       15:0
- #define ALPHA_COLOR_LOOKUP_89_8_RED                   15:11
- #define ALPHA_COLOR_LOOKUP_89_8_GREEN                 10:5
- #define ALPHA_COLOR_LOOKUP_89_8_BLUE                  4:0
- 
- #define ALPHA_COLOR_LOOKUP_AB                         0x08012C
- #define ALPHA_COLOR_LOOKUP_AB_B                       31:16
- #define ALPHA_COLOR_LOOKUP_AB_B_RED                   31:27
- #define ALPHA_COLOR_LOOKUP_AB_B_GREEN                 26:21
- #define ALPHA_COLOR_LOOKUP_AB_B_BLUE                  20:16
- #define ALPHA_COLOR_LOOKUP_AB_A                       15:0
- #define ALPHA_COLOR_LOOKUP_AB_A_RED                   15:11
- #define ALPHA_COLOR_LOOKUP_AB_A_GREEN                 10:5
- #define ALPHA_COLOR_LOOKUP_AB_A_BLUE                  4:0
- 
- #define ALPHA_COLOR_LOOKUP_CD                         0x080130
- #define ALPHA_COLOR_LOOKUP_CD_D                       31:16
- #define ALPHA_COLOR_LOOKUP_CD_D_RED                   31:27
- #define ALPHA_COLOR_LOOKUP_CD_D_GREEN                 26:21
- #define ALPHA_COLOR_LOOKUP_CD_D_BLUE                  20:16
- #define ALPHA_COLOR_LOOKUP_CD_C                       15:0
- #define ALPHA_COLOR_LOOKUP_CD_C_RED                   15:11
- #define ALPHA_COLOR_LOOKUP_CD_C_GREEN                 10:5
- #define ALPHA_COLOR_LOOKUP_CD_C_BLUE                  4:0
- 
- #define ALPHA_COLOR_LOOKUP_EF                         0x080134
- #define ALPHA_COLOR_LOOKUP_EF_F                       31:16
- #define ALPHA_COLOR_LOOKUP_EF_F_RED                   31:27
- #define ALPHA_COLOR_LOOKUP_EF_F_GREEN                 26:21
- #define ALPHA_COLOR_LOOKUP_EF_F_BLUE                  20:16
- #define ALPHA_COLOR_LOOKUP_EF_E                       15:0
- #define ALPHA_COLOR_LOOKUP_EF_E_RED                   15:11
- #define ALPHA_COLOR_LOOKUP_EF_E_GREEN                 10:5
- #define ALPHA_COLOR_LOOKUP_EF_E_BLUE                  4:0
- 
- /* CRT Graphics Control */
- 
- #define CRT_DISPLAY_CTRL                              0x080200
- #define CRT_DISPLAY_CTRL_RESERVED_1_MASK	      31:27
- #define CRT_DISPLAY_CTRL_RESERVED_1_MASK_DISABLE      0
- #define CRT_DISPLAY_CTRL_RESERVED_1_MASK_ENABLE       0x1F
- 
- /* SM750LE definition */
- #define CRT_DISPLAY_CTRL_DPMS                         31:30
- #define CRT_DISPLAY_CTRL_DPMS_0                       0
- #define CRT_DISPLAY_CTRL_DPMS_1                       1
- #define CRT_DISPLAY_CTRL_DPMS_2                       2
- #define CRT_DISPLAY_CTRL_DPMS_3                       3
- #define CRT_DISPLAY_CTRL_CLK                          29:27
- #define CRT_DISPLAY_CTRL_CLK_PLL25                    0
- #define CRT_DISPLAY_CTRL_CLK_PLL41                    1
- #define CRT_DISPLAY_CTRL_CLK_PLL62                    2
- #define CRT_DISPLAY_CTRL_CLK_PLL65                    3
- #define CRT_DISPLAY_CTRL_CLK_PLL74                    4
- #define CRT_DISPLAY_CTRL_CLK_PLL80                    5
- #define CRT_DISPLAY_CTRL_CLK_PLL108                   6
- #define CRT_DISPLAY_CTRL_CLK_RESERVED                 7
- #define CRT_DISPLAY_CTRL_SHIFT_VGA_DAC                26:26
- #define CRT_DISPLAY_CTRL_SHIFT_VGA_DAC_DISABLE        1
- #define CRT_DISPLAY_CTRL_SHIFT_VGA_DAC_ENABLE         0
- 
- 
- #define CRT_DISPLAY_CTRL_RESERVED_2_MASK	      25:24
- #define CRT_DISPLAY_CTRL_RESERVED_2_MASK_ENABLE	      3
- #define CRT_DISPLAY_CTRL_RESERVED_2_MASK_DISABLE      0
- 
- /* SM750LE definition */
- #define CRT_DISPLAY_CTRL_CRTSELECT                    25:25
- #define CRT_DISPLAY_CTRL_CRTSELECT_VGA                0
- #define CRT_DISPLAY_CTRL_CRTSELECT_CRT                1
- #define CRT_DISPLAY_CTRL_RGBBIT                       24:24
- #define CRT_DISPLAY_CTRL_RGBBIT_24BIT                 0
- #define CRT_DISPLAY_CTRL_RGBBIT_12BIT                 1
- 
- 
- #define CRT_DISPLAY_CTRL_RESERVED_3_MASK	      15:15
- #define CRT_DISPLAY_CTRL_RESERVED_3_MASK_DISABLE      0
- #define CRT_DISPLAY_CTRL_RESERVED_3_MASK_ENABLE       1
- 
- #define CRT_DISPLAY_CTRL_RESERVED_4_MASK	      9:9
- #define CRT_DISPLAY_CTRL_RESERVED_4_MASK_DISABLE      0
- #define CRT_DISPLAY_CTRL_RESERVED_4_MASK_ENABLE       1
- 
- #ifndef VALIDATION_CHIP
-     #define CRT_DISPLAY_CTRL_SHIFT_VGA_DAC            26:26
-     #define CRT_DISPLAY_CTRL_SHIFT_VGA_DAC_DISABLE    1
-     #define CRT_DISPLAY_CTRL_SHIFT_VGA_DAC_ENABLE     0
-     #define CRT_DISPLAY_CTRL_CENTERING                24:24
-     #define CRT_DISPLAY_CTRL_CENTERING_DISABLE        0
-     #define CRT_DISPLAY_CTRL_CENTERING_ENABLE         1
- #endif
- #define CRT_DISPLAY_CTRL_LOCK_TIMING                  23:23
- #define CRT_DISPLAY_CTRL_LOCK_TIMING_DISABLE          0
- #define CRT_DISPLAY_CTRL_LOCK_TIMING_ENABLE           1
- #define CRT_DISPLAY_CTRL_EXPANSION                    22:22
- #define CRT_DISPLAY_CTRL_EXPANSION_DISABLE            0
- #define CRT_DISPLAY_CTRL_EXPANSION_ENABLE             1
- #define CRT_DISPLAY_CTRL_VERTICAL_MODE                21:21
- #define CRT_DISPLAY_CTRL_VERTICAL_MODE_REPLICATE      0
- #define CRT_DISPLAY_CTRL_VERTICAL_MODE_INTERPOLATE    1
- #define CRT_DISPLAY_CTRL_HORIZONTAL_MODE              20:20
- #define CRT_DISPLAY_CTRL_HORIZONTAL_MODE_REPLICATE    0
- #define CRT_DISPLAY_CTRL_HORIZONTAL_MODE_INTERPOLATE  1
- #define CRT_DISPLAY_CTRL_SELECT                       19:18
- #define CRT_DISPLAY_CTRL_SELECT_PANEL                 0
- #define CRT_DISPLAY_CTRL_SELECT_VGA                   1
- #define CRT_DISPLAY_CTRL_SELECT_CRT                   2
- #define CRT_DISPLAY_CTRL_FIFO                         17:16
- #define CRT_DISPLAY_CTRL_FIFO_1                       0
- #define CRT_DISPLAY_CTRL_FIFO_3                       1
- #define CRT_DISPLAY_CTRL_FIFO_7                       2
- #define CRT_DISPLAY_CTRL_FIFO_11                      3
- #define CRT_DISPLAY_CTRL_CLOCK_PHASE                  14:14
- #define CRT_DISPLAY_CTRL_CLOCK_PHASE_ACTIVE_HIGH      0
- #define CRT_DISPLAY_CTRL_CLOCK_PHASE_ACTIVE_LOW       1
- #define CRT_DISPLAY_CTRL_VSYNC_PHASE                  13:13
- #define CRT_DISPLAY_CTRL_VSYNC_PHASE_ACTIVE_HIGH      0
- #define CRT_DISPLAY_CTRL_VSYNC_PHASE_ACTIVE_LOW       1
- #define CRT_DISPLAY_CTRL_HSYNC_PHASE                  12:12
- #define CRT_DISPLAY_CTRL_HSYNC_PHASE_ACTIVE_HIGH      0
- #define CRT_DISPLAY_CTRL_HSYNC_PHASE_ACTIVE_LOW       1
- #define CRT_DISPLAY_CTRL_BLANK                        10:10
- #define CRT_DISPLAY_CTRL_BLANK_OFF                    0
- #define CRT_DISPLAY_CTRL_BLANK_ON                     1
- #define CRT_DISPLAY_CTRL_TIMING                       8:8
- #define CRT_DISPLAY_CTRL_TIMING_DISABLE               0
- #define CRT_DISPLAY_CTRL_TIMING_ENABLE                1
- #define CRT_DISPLAY_CTRL_PIXEL                        7:4
- #define CRT_DISPLAY_CTRL_GAMMA                        3:3
- #define CRT_DISPLAY_CTRL_GAMMA_DISABLE                0
- #define CRT_DISPLAY_CTRL_GAMMA_ENABLE                 1
- #define CRT_DISPLAY_CTRL_PLANE                        2:2
- #define CRT_DISPLAY_CTRL_PLANE_DISABLE                0
- #define CRT_DISPLAY_CTRL_PLANE_ENABLE                 1
- #define CRT_DISPLAY_CTRL_FORMAT                       1:0
- #define CRT_DISPLAY_CTRL_FORMAT_8                     0
- #define CRT_DISPLAY_CTRL_FORMAT_16                    1
- #define CRT_DISPLAY_CTRL_FORMAT_32                    2
- #define CRT_DISPLAY_CTRL_RESERVED_BITS_MASK           0xFF000200
- 
- #define CRT_FB_ADDRESS                                0x080204
- #define CRT_FB_ADDRESS_STATUS                         31:31
- #define CRT_FB_ADDRESS_STATUS_CURRENT                 0
- #define CRT_FB_ADDRESS_STATUS_PENDING                 1
- #define CRT_FB_ADDRESS_EXT                            27:27
- #define CRT_FB_ADDRESS_EXT_LOCAL                      0
- #define CRT_FB_ADDRESS_EXT_EXTERNAL                   1
- #define CRT_FB_ADDRESS_ADDRESS                        25:0
- 
- #define CRT_FB_WIDTH                                  0x080208
- #define CRT_FB_WIDTH_WIDTH                            29:16
- #define CRT_FB_WIDTH_OFFSET                           13:0
- 
- #define CRT_HORIZONTAL_TOTAL                          0x08020C
- #define CRT_HORIZONTAL_TOTAL_TOTAL                    27:16
- #define CRT_HORIZONTAL_TOTAL_DISPLAY_END              11:0
- 
- #define CRT_HORIZONTAL_SYNC                           0x080210
- #define CRT_HORIZONTAL_SYNC_WIDTH                     23:16
- #define CRT_HORIZONTAL_SYNC_START                     11:0
- 
- #define CRT_VERTICAL_TOTAL                            0x080214
- #define CRT_VERTICAL_TOTAL_TOTAL                      26:16
- #define CRT_VERTICAL_TOTAL_DISPLAY_END                10:0
- 
- #define CRT_VERTICAL_SYNC                             0x080218
- #define CRT_VERTICAL_SYNC_HEIGHT                      21:16
- #define CRT_VERTICAL_SYNC_START                       10:0
- 
- #define CRT_SIGNATURE_ANALYZER                        0x08021C
- #define CRT_SIGNATURE_ANALYZER_STATUS                 31:16
- #define CRT_SIGNATURE_ANALYZER_ENABLE                 3:3
- #define CRT_SIGNATURE_ANALYZER_ENABLE_DISABLE         0
- #define CRT_SIGNATURE_ANALYZER_ENABLE_ENABLE          1
- #define CRT_SIGNATURE_ANALYZER_RESET                  2:2
- #define CRT_SIGNATURE_ANALYZER_RESET_NORMAL           0
- #define CRT_SIGNATURE_ANALYZER_RESET_RESET            1
- #define CRT_SIGNATURE_ANALYZER_SOURCE                 1:0
- #define CRT_SIGNATURE_ANALYZER_SOURCE_RED             0
- #define CRT_SIGNATURE_ANALYZER_SOURCE_GREEN           1
- #define CRT_SIGNATURE_ANALYZER_SOURCE_BLUE            2
- 
- #define CRT_CURRENT_LINE                              0x080220
- #define CRT_CURRENT_LINE_LINE                         10:0
- 
- #define CRT_MONITOR_DETECT                            0x080224
- #define CRT_MONITOR_DETECT_VALUE                      25:25
- #define CRT_MONITOR_DETECT_VALUE_DISABLE              0
- #define CRT_MONITOR_DETECT_VALUE_ENABLE               1
- #define CRT_MONITOR_DETECT_ENABLE                     24:24
- #define CRT_MONITOR_DETECT_ENABLE_DISABLE             0
- #define CRT_MONITOR_DETECT_ENABLE_ENABLE              1
- #define CRT_MONITOR_DETECT_RED                        23:16
- #define CRT_MONITOR_DETECT_GREEN                      15:8
- #define CRT_MONITOR_DETECT_BLUE                       7:0
- 
- #define CRT_SCALE                                     0x080228
- #define CRT_SCALE_VERTICAL_MODE                       31:31
- #define CRT_SCALE_VERTICAL_MODE_EXPAND                0
- #define CRT_SCALE_VERTICAL_MODE_SHRINK                1
- #define CRT_SCALE_VERTICAL_SCALE                      27:16
- #define CRT_SCALE_HORIZONTAL_MODE                     15:15
- #define CRT_SCALE_HORIZONTAL_MODE_EXPAND              0
- #define CRT_SCALE_HORIZONTAL_MODE_SHRINK              1
- #define CRT_SCALE_HORIZONTAL_SCALE                    11:0
- 
- /* CRT Cursor Control */
- 
- #define CRT_HWC_ADDRESS                               0x080230
- #define CRT_HWC_ADDRESS_ENABLE                        31:31
- #define CRT_HWC_ADDRESS_ENABLE_DISABLE                0
- #define CRT_HWC_ADDRESS_ENABLE_ENABLE                 1
- #define CRT_HWC_ADDRESS_EXT                           27:27
- #define CRT_HWC_ADDRESS_EXT_LOCAL                     0
- #define CRT_HWC_ADDRESS_EXT_EXTERNAL                  1
- #define CRT_HWC_ADDRESS_ADDRESS                       25:0
- 
- #define CRT_HWC_LOCATION                              0x080234
- #define CRT_HWC_LOCATION_TOP                          27:27
- #define CRT_HWC_LOCATION_TOP_INSIDE                   0
- #define CRT_HWC_LOCATION_TOP_OUTSIDE                  1
- #define CRT_HWC_LOCATION_Y                            26:16
- #define CRT_HWC_LOCATION_LEFT                         11:11
- #define CRT_HWC_LOCATION_LEFT_INSIDE                  0
- #define CRT_HWC_LOCATION_LEFT_OUTSIDE                 1
- #define CRT_HWC_LOCATION_X                            10:0
- 
- #define CRT_HWC_COLOR_12                              0x080238
- #define CRT_HWC_COLOR_12_2_RGB565                     31:16
- #define CRT_HWC_COLOR_12_1_RGB565                     15:0
- 
- #define CRT_HWC_COLOR_3                               0x08023C
- #define CRT_HWC_COLOR_3_RGB565                        15:0
- 
- /* This vertical expansion below start at 0x080240 ~ 0x080264 */
- #define CRT_VERTICAL_EXPANSION                        0x080240
- #ifndef VALIDATION_CHIP
-     #define CRT_VERTICAL_CENTERING_VALUE              31:24
- #endif
- #define CRT_VERTICAL_EXPANSION_COMPARE_VALUE          23:16
- #define CRT_VERTICAL_EXPANSION_LINE_BUFFER            15:12
- #define CRT_VERTICAL_EXPANSION_SCALE_FACTOR           11:0
- 
- /* This horizontal expansion below start at 0x080268 ~ 0x08027C */
- #define CRT_HORIZONTAL_EXPANSION                      0x080268
- #ifndef VALIDATION_CHIP
-     #define CRT_HORIZONTAL_CENTERING_VALUE            31:24
- #endif
- #define CRT_HORIZONTAL_EXPANSION_COMPARE_VALUE        23:16
- #define CRT_HORIZONTAL_EXPANSION_SCALE_FACTOR         11:0
- 
- #ifndef VALIDATION_CHIP
-     /* Auto Centering */
-     #define CRT_AUTO_CENTERING_TL                     0x080280
-     #define CRT_AUTO_CENTERING_TL_TOP                 26:16
-     #define CRT_AUTO_CENTERING_TL_LEFT                10:0
- 
-     #define CRT_AUTO_CENTERING_BR                     0x080284
-     #define CRT_AUTO_CENTERING_BR_BOTTOM              26:16
-     #define CRT_AUTO_CENTERING_BR_RIGHT               10:0
- #endif
- 
- /* sm750le new register to control panel output */
- #define DISPLAY_CONTROL_750LE			      0x80288
- /* Palette RAM */
- 
- /* Panel Palette register starts at 0x080400 ~ 0x0807FC */
- #define PANEL_PALETTE_RAM                             0x080400
- 
- /* Panel Palette register starts at 0x080C00 ~ 0x080FFC */
- #define CRT_PALETTE_RAM                               0x080C00
- 
- /* Color Space Conversion registers. */
- 
- #define CSC_Y_SOURCE_BASE                               0x1000C8
- #define CSC_Y_SOURCE_BASE_EXT                           27:27
- #define CSC_Y_SOURCE_BASE_EXT_LOCAL                     0
- #define CSC_Y_SOURCE_BASE_EXT_EXTERNAL                  1
- #define CSC_Y_SOURCE_BASE_CS                            26:26
- #define CSC_Y_SOURCE_BASE_CS_0                          0
- #define CSC_Y_SOURCE_BASE_CS_1                          1
- #define CSC_Y_SOURCE_BASE_ADDRESS                       25:0
- 
- #define CSC_CONSTANTS                                   0x1000CC
- #define CSC_CONSTANTS_Y                                 31:24
- #define CSC_CONSTANTS_R                                 23:16
- #define CSC_CONSTANTS_G                                 15:8
- #define CSC_CONSTANTS_B                                 7:0
- 
- #define CSC_Y_SOURCE_X                                  0x1000D0
- #define CSC_Y_SOURCE_X_INTEGER                          26:16
- #define CSC_Y_SOURCE_X_FRACTION                         15:3
- 
- #define CSC_Y_SOURCE_Y                                  0x1000D4
- #define CSC_Y_SOURCE_Y_INTEGER                          27:16
- #define CSC_Y_SOURCE_Y_FRACTION                         15:3
- 
- #define CSC_U_SOURCE_BASE                               0x1000D8
- #define CSC_U_SOURCE_BASE_EXT                           27:27
- #define CSC_U_SOURCE_BASE_EXT_LOCAL                     0
- #define CSC_U_SOURCE_BASE_EXT_EXTERNAL                  1
- #define CSC_U_SOURCE_BASE_CS                            26:26
- #define CSC_U_SOURCE_BASE_CS_0                          0
- #define CSC_U_SOURCE_BASE_CS_1                          1
- #define CSC_U_SOURCE_BASE_ADDRESS                       25:0
- 
- #define CSC_V_SOURCE_BASE                               0x1000DC
- #define CSC_V_SOURCE_BASE_EXT                           27:27
- #define CSC_V_SOURCE_BASE_EXT_LOCAL                     0
- #define CSC_V_SOURCE_BASE_EXT_EXTERNAL                  1
- #define CSC_V_SOURCE_BASE_CS                            26:26
- #define CSC_V_SOURCE_BASE_CS_0                          0
- #define CSC_V_SOURCE_BASE_CS_1                          1
- #define CSC_V_SOURCE_BASE_ADDRESS                       25:0
- 
- #define CSC_SOURCE_DIMENSION                            0x1000E0
- #define CSC_SOURCE_DIMENSION_X                          31:16
- #define CSC_SOURCE_DIMENSION_Y                          15:0
- 
- #define CSC_SOURCE_PITCH                                0x1000E4
- #define CSC_SOURCE_PITCH_Y                              31:16
- #define CSC_SOURCE_PITCH_UV                             15:0
- 
- #define CSC_DESTINATION                                 0x1000E8
- #define CSC_DESTINATION_WRAP                            31:31
- #define CSC_DESTINATION_WRAP_DISABLE                    0
- #define CSC_DESTINATION_WRAP_ENABLE                     1
- #define CSC_DESTINATION_X                               27:16
- #define CSC_DESTINATION_Y                               11:0
- 
- #define CSC_DESTINATION_DIMENSION                       0x1000EC
- #define CSC_DESTINATION_DIMENSION_X                     31:16
- #define CSC_DESTINATION_DIMENSION_Y                     15:0
- 
- #define CSC_DESTINATION_PITCH                           0x1000F0
- #define CSC_DESTINATION_PITCH_X                         31:16
- #define CSC_DESTINATION_PITCH_Y                         15:0
- 
- #define CSC_SCALE_FACTOR                                0x1000F4
- #define CSC_SCALE_FACTOR_HORIZONTAL                     31:16
- #define CSC_SCALE_FACTOR_VERTICAL                       15:0
- 
- #define CSC_DESTINATION_BASE                            0x1000F8
- #define CSC_DESTINATION_BASE_EXT                        27:27
- #define CSC_DESTINATION_BASE_EXT_LOCAL                  0
- #define CSC_DESTINATION_BASE_EXT_EXTERNAL               1
- #define CSC_DESTINATION_BASE_CS                         26:26
- #define CSC_DESTINATION_BASE_CS_0                       0
- #define CSC_DESTINATION_BASE_CS_1                       1
- #define CSC_DESTINATION_BASE_ADDRESS                    25:0
- 
- #define CSC_CONTROL                                     0x1000FC
- #define CSC_CONTROL_STATUS                              31:31
- #define CSC_CONTROL_STATUS_STOP                         0
- #define CSC_CONTROL_STATUS_START                        1
- #define CSC_CONTROL_SOURCE_FORMAT                       30:28
- #define CSC_CONTROL_SOURCE_FORMAT_YUV422                0
- #define CSC_CONTROL_SOURCE_FORMAT_YUV420I               1
- #define CSC_CONTROL_SOURCE_FORMAT_YUV420                2
- #define CSC_CONTROL_SOURCE_FORMAT_YVU9                  3
- #define CSC_CONTROL_SOURCE_FORMAT_IYU1                  4
- #define CSC_CONTROL_SOURCE_FORMAT_IYU2                  5
- #define CSC_CONTROL_SOURCE_FORMAT_RGB565                6
- #define CSC_CONTROL_SOURCE_FORMAT_RGB8888               7
- #define CSC_CONTROL_DESTINATION_FORMAT                  27:26
- #define CSC_CONTROL_DESTINATION_FORMAT_RGB565           0
- #define CSC_CONTROL_DESTINATION_FORMAT_RGB8888          1
- #define CSC_CONTROL_HORIZONTAL_FILTER                   25:25
- #define CSC_CONTROL_HORIZONTAL_FILTER_DISABLE           0
- #define CSC_CONTROL_HORIZONTAL_FILTER_ENABLE            1
- #define CSC_CONTROL_VERTICAL_FILTER                     24:24
- #define CSC_CONTROL_VERTICAL_FILTER_DISABLE             0
- #define CSC_CONTROL_VERTICAL_FILTER_ENABLE              1
- #define CSC_CONTROL_BYTE_ORDER                          23:23
- #define CSC_CONTROL_BYTE_ORDER_YUYV                     0
- #define CSC_CONTROL_BYTE_ORDER_UYVY                     1
- 
- #define DE_DATA_PORT                                    0x110000
- 
- #define I2C_BYTE_COUNT                                  0x010040
- #define I2C_BYTE_COUNT_COUNT                            3:0
- 
- #define I2C_CTRL                                        0x010041
- #define I2C_CTRL_INT                                    4:4
- #define I2C_CTRL_INT_DISABLE                            0
- #define I2C_CTRL_INT_ENABLE                             1
- #define I2C_CTRL_DIR                                    3:3
- #define I2C_CTRL_DIR_WR                                 0
- #define I2C_CTRL_DIR_RD                                 1
- #define I2C_CTRL_CTRL                                   2:2
- #define I2C_CTRL_CTRL_STOP                              0
- #define I2C_CTRL_CTRL_START                             1
- #define I2C_CTRL_MODE                                   1:1
- #define I2C_CTRL_MODE_STANDARD                          0
- #define I2C_CTRL_MODE_FAST                              1
- #define I2C_CTRL_EN                                     0:0
- #define I2C_CTRL_EN_DISABLE                             0
- #define I2C_CTRL_EN_ENABLE                              1
- 
- #define I2C_STATUS                                      0x010042
- #define I2C_STATUS_TX                                   3:3
- #define I2C_STATUS_TX_PROGRESS                          0
- #define I2C_STATUS_TX_COMPLETED                         1
- #define I2C_TX_DONE                                     0x08
- #define I2C_STATUS_ERR                                  2:2
- #define I2C_STATUS_ERR_NORMAL                           0
- #define I2C_STATUS_ERR_ERROR                            1
- #define I2C_STATUS_ERR_CLEAR                            0
- #define I2C_STATUS_ACK                                  1:1
- #define I2C_STATUS_ACK_RECEIVED                         0
- #define I2C_STATUS_ACK_NOT                              1
- #define I2C_STATUS_BSY                                  0:0
- #define I2C_STATUS_BSY_IDLE                             0
- #define I2C_STATUS_BSY_BUSY                             1
- 
- #define I2C_RESET                                       0x010042
- #define I2C_RESET_BUS_ERROR                             2:2
- #define I2C_RESET_BUS_ERROR_CLEAR                       0
- 
- #define I2C_SLAVE_ADDRESS                               0x010043
- #define I2C_SLAVE_ADDRESS_ADDRESS                       7:1
- #define I2C_SLAVE_ADDRESS_RW                            0:0
- #define I2C_SLAVE_ADDRESS_RW_W                          0
- #define I2C_SLAVE_ADDRESS_RW_R                          1
- 
- #define I2C_DATA0                                       0x010044
- #define I2C_DATA1                                       0x010045
- #define I2C_DATA2                                       0x010046
- #define I2C_DATA3                                       0x010047
- #define I2C_DATA4                                       0x010048
- #define I2C_DATA5                                       0x010049
- #define I2C_DATA6                                       0x01004A
- #define I2C_DATA7                                       0x01004B
- #define I2C_DATA8                                       0x01004C
- #define I2C_DATA9                                       0x01004D
- #define I2C_DATA10                                      0x01004E
- #define I2C_DATA11                                      0x01004F
- #define I2C_DATA12                                      0x010050
- #define I2C_DATA13                                      0x010051
- #define I2C_DATA14                                      0x010052
- #define I2C_DATA15                                      0x010053
- 
- 
- #define ZV0_CAPTURE_CTRL                                0x090000
- #define ZV0_CAPTURE_CTRL_FIELD_INPUT                    27:27
- #define ZV0_CAPTURE_CTRL_FIELD_INPUT_EVEN_FIELD         0
- #define ZV0_CAPTURE_CTRL_FIELD_INPUT_ODD_FIELD          1
- #define ZV0_CAPTURE_CTRL_SCAN                           26:26
- #define ZV0_CAPTURE_CTRL_SCAN_PROGRESSIVE               0
- #define ZV0_CAPTURE_CTRL_SCAN_INTERLACE                 1
- #define ZV0_CAPTURE_CTRL_CURRENT_BUFFER                 25:25
- #define ZV0_CAPTURE_CTRL_CURRENT_BUFFER_0               0
- #define ZV0_CAPTURE_CTRL_CURRENT_BUFFER_1               1
- #define ZV0_CAPTURE_CTRL_VERTICAL_SYNC                  24:24
- #define ZV0_CAPTURE_CTRL_VERTICAL_SYNC_INACTIVE         0
- #define ZV0_CAPTURE_CTRL_VERTICAL_SYNC_ACTIVE           1
- #define ZV0_CAPTURE_CTRL_ADJ                            19:19
- #define ZV0_CAPTURE_CTRL_ADJ_NORMAL                     0
- #define ZV0_CAPTURE_CTRL_ADJ_DELAY                      1
- #define ZV0_CAPTURE_CTRL_HA                             18:18
- #define ZV0_CAPTURE_CTRL_HA_DISABLE                     0
- #define ZV0_CAPTURE_CTRL_HA_ENABLE                      1
- #define ZV0_CAPTURE_CTRL_VSK                            17:17
- #define ZV0_CAPTURE_CTRL_VSK_DISABLE                    0
- #define ZV0_CAPTURE_CTRL_VSK_ENABLE                     1
- #define ZV0_CAPTURE_CTRL_HSK                            16:16
- #define ZV0_CAPTURE_CTRL_HSK_DISABLE                    0
- #define ZV0_CAPTURE_CTRL_HSK_ENABLE                     1
- #define ZV0_CAPTURE_CTRL_FD                             15:15
- #define ZV0_CAPTURE_CTRL_FD_RISING                      0
- #define ZV0_CAPTURE_CTRL_FD_FALLING                     1
- #define ZV0_CAPTURE_CTRL_VP                             14:14
- #define ZV0_CAPTURE_CTRL_VP_HIGH                        0
- #define ZV0_CAPTURE_CTRL_VP_LOW                         1
- #define ZV0_CAPTURE_CTRL_HP                             13:13
- #define ZV0_CAPTURE_CTRL_HP_HIGH                        0
- #define ZV0_CAPTURE_CTRL_HP_LOW                         1
- #define ZV0_CAPTURE_CTRL_CP                             12:12
- #define ZV0_CAPTURE_CTRL_CP_HIGH                        0
- #define ZV0_CAPTURE_CTRL_CP_LOW                         1
- #define ZV0_CAPTURE_CTRL_UVS                            11:11
- #define ZV0_CAPTURE_CTRL_UVS_DISABLE                    0
- #define ZV0_CAPTURE_CTRL_UVS_ENABLE                     1
- #define ZV0_CAPTURE_CTRL_BS                             10:10
- #define ZV0_CAPTURE_CTRL_BS_DISABLE                     0
- #define ZV0_CAPTURE_CTRL_BS_ENABLE                      1
- #define ZV0_CAPTURE_CTRL_CS                             9:9
- #define ZV0_CAPTURE_CTRL_CS_16                          0
- #define ZV0_CAPTURE_CTRL_CS_8                           1
- #define ZV0_CAPTURE_CTRL_CF                             8:8
- #define ZV0_CAPTURE_CTRL_CF_YUV                         0
- #define ZV0_CAPTURE_CTRL_CF_RGB                         1
- #define ZV0_CAPTURE_CTRL_FS                             7:7
- #define ZV0_CAPTURE_CTRL_FS_DISABLE                     0
- #define ZV0_CAPTURE_CTRL_FS_ENABLE                      1
- #define ZV0_CAPTURE_CTRL_WEAVE                          6:6
- #define ZV0_CAPTURE_CTRL_WEAVE_DISABLE                  0
- #define ZV0_CAPTURE_CTRL_WEAVE_ENABLE                   1
- #define ZV0_CAPTURE_CTRL_BOB                            5:5
- #define ZV0_CAPTURE_CTRL_BOB_DISABLE                    0
- #define ZV0_CAPTURE_CTRL_BOB_ENABLE                     1
- #define ZV0_CAPTURE_CTRL_DB                             4:4
- #define ZV0_CAPTURE_CTRL_DB_DISABLE                     0
- #define ZV0_CAPTURE_CTRL_DB_ENABLE                      1
- #define ZV0_CAPTURE_CTRL_CC                             3:3
- #define ZV0_CAPTURE_CTRL_CC_CONTINUE                    0
- #define ZV0_CAPTURE_CTRL_CC_CONDITION                   1
- #define ZV0_CAPTURE_CTRL_RGB                            2:2
- #define ZV0_CAPTURE_CTRL_RGB_DISABLE                    0
- #define ZV0_CAPTURE_CTRL_RGB_ENABLE                     1
- #define ZV0_CAPTURE_CTRL_656                            1:1
- #define ZV0_CAPTURE_CTRL_656_DISABLE                    0
- #define ZV0_CAPTURE_CTRL_656_ENABLE                     1
- #define ZV0_CAPTURE_CTRL_CAP                            0:0
- #define ZV0_CAPTURE_CTRL_CAP_DISABLE                    0
- #define ZV0_CAPTURE_CTRL_CAP_ENABLE                     1
- 
- #define ZV0_CAPTURE_CLIP                                0x090004
- #define ZV0_CAPTURE_CLIP_YCLIP_EVEN_FIELD                25:16
- #define ZV0_CAPTURE_CLIP_YCLIP                          25:16
- #define ZV0_CAPTURE_CLIP_XCLIP                          9:0
- 
- #define ZV0_CAPTURE_SIZE                                0x090008
- #define ZV0_CAPTURE_SIZE_HEIGHT                         26:16
- #define ZV0_CAPTURE_SIZE_WIDTH                          10:0
- 
- #define ZV0_CAPTURE_BUF0_ADDRESS                        0x09000C
- #define ZV0_CAPTURE_BUF0_ADDRESS_STATUS                 31:31
- #define ZV0_CAPTURE_BUF0_ADDRESS_STATUS_CURRENT         0
- #define ZV0_CAPTURE_BUF0_ADDRESS_STATUS_PENDING         1
- #define ZV0_CAPTURE_BUF0_ADDRESS_EXT                    27:27
- #define ZV0_CAPTURE_BUF0_ADDRESS_EXT_LOCAL              0
- #define ZV0_CAPTURE_BUF0_ADDRESS_EXT_EXTERNAL           1
- #define ZV0_CAPTURE_BUF0_ADDRESS_CS                     26:26
- #define ZV0_CAPTURE_BUF0_ADDRESS_CS_0                   0
- #define ZV0_CAPTURE_BUF0_ADDRESS_CS_1                   1
- #define ZV0_CAPTURE_BUF0_ADDRESS_ADDRESS                25:0
- 
- #define ZV0_CAPTURE_BUF1_ADDRESS                        0x090010
- #define ZV0_CAPTURE_BUF1_ADDRESS_STATUS                 31:31
- #define ZV0_CAPTURE_BUF1_ADDRESS_STATUS_CURRENT         0
- #define ZV0_CAPTURE_BUF1_ADDRESS_STATUS_PENDING         1
- #define ZV0_CAPTURE_BUF1_ADDRESS_EXT                    27:27
- #define ZV0_CAPTURE_BUF1_ADDRESS_EXT_LOCAL              0
- #define ZV0_CAPTURE_BUF1_ADDRESS_EXT_EXTERNAL           1
- #define ZV0_CAPTURE_BUF1_ADDRESS_CS                     26:26
- #define ZV0_CAPTURE_BUF1_ADDRESS_CS_0                   0
- #define ZV0_CAPTURE_BUF1_ADDRESS_CS_1                   1
- #define ZV0_CAPTURE_BUF1_ADDRESS_ADDRESS                25:0
- 
- #define ZV0_CAPTURE_BUF_OFFSET                          0x090014
- #ifndef VALIDATION_CHIP
-     #define ZV0_CAPTURE_BUF_OFFSET_YCLIP_ODD_FIELD      25:16
- #endif
- #define ZV0_CAPTURE_BUF_OFFSET_OFFSET                   15:0
- 
- #define ZV0_CAPTURE_FIFO_CTRL                           0x090018
- #define ZV0_CAPTURE_FIFO_CTRL_FIFO                      2:0
- #define ZV0_CAPTURE_FIFO_CTRL_FIFO_0                    0
- #define ZV0_CAPTURE_FIFO_CTRL_FIFO_1                    1
- #define ZV0_CAPTURE_FIFO_CTRL_FIFO_2                    2
- #define ZV0_CAPTURE_FIFO_CTRL_FIFO_3                    3
- #define ZV0_CAPTURE_FIFO_CTRL_FIFO_4                    4
- #define ZV0_CAPTURE_FIFO_CTRL_FIFO_5                    5
- #define ZV0_CAPTURE_FIFO_CTRL_FIFO_6                    6
- #define ZV0_CAPTURE_FIFO_CTRL_FIFO_7                    7
- 
- #define ZV0_CAPTURE_YRGB_CONST                          0x09001C
- #define ZV0_CAPTURE_YRGB_CONST_Y                        31:24
- #define ZV0_CAPTURE_YRGB_CONST_R                        23:16
- #define ZV0_CAPTURE_YRGB_CONST_G                        15:8
- #define ZV0_CAPTURE_YRGB_CONST_B                        7:0
- 
- #define ZV0_CAPTURE_LINE_COMP                           0x090020
- #define ZV0_CAPTURE_LINE_COMP_LC                        10:0
- 
- /* ZV1 */
- 
- #define ZV1_CAPTURE_CTRL                                0x098000
- #define ZV1_CAPTURE_CTRL_FIELD_INPUT                    27:27
- #define ZV1_CAPTURE_CTRL_FIELD_INPUT_EVEN_FIELD         0
- #define ZV1_CAPTURE_CTRL_FIELD_INPUT_ODD_FIELD          0
- #define ZV1_CAPTURE_CTRL_SCAN                           26:26
- #define ZV1_CAPTURE_CTRL_SCAN_PROGRESSIVE               0
- #define ZV1_CAPTURE_CTRL_SCAN_INTERLACE                 1
- #define ZV1_CAPTURE_CTRL_CURRENT_BUFFER                 25:25
- #define ZV1_CAPTURE_CTRL_CURRENT_BUFFER_0               0
- #define ZV1_CAPTURE_CTRL_CURRENT_BUFFER_1               1
- #define ZV1_CAPTURE_CTRL_VERTICAL_SYNC                  24:24
- #define ZV1_CAPTURE_CTRL_VERTICAL_SYNC_INACTIVE         0
- #define ZV1_CAPTURE_CTRL_VERTICAL_SYNC_ACTIVE           1
- #define ZV1_CAPTURE_CTRL_PANEL                          20:20
- #define ZV1_CAPTURE_CTRL_PANEL_DISABLE                  0
- #define ZV1_CAPTURE_CTRL_PANEL_ENABLE                   1
- #define ZV1_CAPTURE_CTRL_ADJ                            19:19
- #define ZV1_CAPTURE_CTRL_ADJ_NORMAL                     0
- #define ZV1_CAPTURE_CTRL_ADJ_DELAY                      1
- #define ZV1_CAPTURE_CTRL_HA                             18:18
- #define ZV1_CAPTURE_CTRL_HA_DISABLE                     0
- #define ZV1_CAPTURE_CTRL_HA_ENABLE                      1
- #define ZV1_CAPTURE_CTRL_VSK                            17:17
- #define ZV1_CAPTURE_CTRL_VSK_DISABLE                    0
- #define ZV1_CAPTURE_CTRL_VSK_ENABLE                     1
- #define ZV1_CAPTURE_CTRL_HSK                            16:16
- #define ZV1_CAPTURE_CTRL_HSK_DISABLE                    0
- #define ZV1_CAPTURE_CTRL_HSK_ENABLE                     1
- #define ZV1_CAPTURE_CTRL_FD                             15:15
- #define ZV1_CAPTURE_CTRL_FD_RISING                      0
- #define ZV1_CAPTURE_CTRL_FD_FALLING                     1
- #define ZV1_CAPTURE_CTRL_VP                             14:14
- #define ZV1_CAPTURE_CTRL_VP_HIGH                        0
- #define ZV1_CAPTURE_CTRL_VP_LOW                         1
- #define ZV1_CAPTURE_CTRL_HP                             13:13
- #define ZV1_CAPTURE_CTRL_HP_HIGH                        0
- #define ZV1_CAPTURE_CTRL_HP_LOW                         1
- #define ZV1_CAPTURE_CTRL_CP                             12:12
- #define ZV1_CAPTURE_CTRL_CP_HIGH                        0
- #define ZV1_CAPTURE_CTRL_CP_LOW                         1
- #define ZV1_CAPTURE_CTRL_UVS                            11:11
- #define ZV1_CAPTURE_CTRL_UVS_DISABLE                    0
- #define ZV1_CAPTURE_CTRL_UVS_ENABLE                     1
- #define ZV1_CAPTURE_CTRL_BS                             10:10
- #define ZV1_CAPTURE_CTRL_BS_DISABLE                     0
- #define ZV1_CAPTURE_CTRL_BS_ENABLE                      1
- #define ZV1_CAPTURE_CTRL_CS                             9:9
- #define ZV1_CAPTURE_CTRL_CS_16                          0
- #define ZV1_CAPTURE_CTRL_CS_8                           1
- #define ZV1_CAPTURE_CTRL_CF                             8:8
- #define ZV1_CAPTURE_CTRL_CF_YUV                         0
- #define ZV1_CAPTURE_CTRL_CF_RGB                         1
- #define ZV1_CAPTURE_CTRL_FS                             7:7
- #define ZV1_CAPTURE_CTRL_FS_DISABLE                     0
- #define ZV1_CAPTURE_CTRL_FS_ENABLE                      1
- #define ZV1_CAPTURE_CTRL_WEAVE                          6:6
- #define ZV1_CAPTURE_CTRL_WEAVE_DISABLE                  0
- #define ZV1_CAPTURE_CTRL_WEAVE_ENABLE                   1
- #define ZV1_CAPTURE_CTRL_BOB                            5:5
- #define ZV1_CAPTURE_CTRL_BOB_DISABLE                    0
- #define ZV1_CAPTURE_CTRL_BOB_ENABLE                     1
- #define ZV1_CAPTURE_CTRL_DB                             4:4
- #define ZV1_CAPTURE_CTRL_DB_DISABLE                     0
- #define ZV1_CAPTURE_CTRL_DB_ENABLE                      1
- #define ZV1_CAPTURE_CTRL_CC                             3:3
- #define ZV1_CAPTURE_CTRL_CC_CONTINUE                    0
- #define ZV1_CAPTURE_CTRL_CC_CONDITION                   1
- #define ZV1_CAPTURE_CTRL_RGB                            2:2
- #define ZV1_CAPTURE_CTRL_RGB_DISABLE                    0
- #define ZV1_CAPTURE_CTRL_RGB_ENABLE                     1
- #define ZV1_CAPTURE_CTRL_656                            1:1
- #define ZV1_CAPTURE_CTRL_656_DISABLE                    0
- #define ZV1_CAPTURE_CTRL_656_ENABLE                     1
- #define ZV1_CAPTURE_CTRL_CAP                            0:0
- #define ZV1_CAPTURE_CTRL_CAP_DISABLE                    0
- #define ZV1_CAPTURE_CTRL_CAP_ENABLE                     1
- 
- #define ZV1_CAPTURE_CLIP                                0x098004
- #define ZV1_CAPTURE_CLIP_YCLIP                          25:16
- #define ZV1_CAPTURE_CLIP_XCLIP                          9:0
- 
- #define ZV1_CAPTURE_SIZE                                0x098008
- #define ZV1_CAPTURE_SIZE_HEIGHT                         26:16
- #define ZV1_CAPTURE_SIZE_WIDTH                          10:0
- 
- #define ZV1_CAPTURE_BUF0_ADDRESS                        0x09800C
- #define ZV1_CAPTURE_BUF0_ADDRESS_STATUS                 31:31
- #define ZV1_CAPTURE_BUF0_ADDRESS_STATUS_CURRENT         0
- #define ZV1_CAPTURE_BUF0_ADDRESS_STATUS_PENDING         1
- #define ZV1_CAPTURE_BUF0_ADDRESS_EXT                    27:27
- #define ZV1_CAPTURE_BUF0_ADDRESS_EXT_LOCAL              0
- #define ZV1_CAPTURE_BUF0_ADDRESS_EXT_EXTERNAL           1
- #define ZV1_CAPTURE_BUF0_ADDRESS_CS                     26:26
- #define ZV1_CAPTURE_BUF0_ADDRESS_CS_0                   0
- #define ZV1_CAPTURE_BUF0_ADDRESS_CS_1                   1
- #define ZV1_CAPTURE_BUF0_ADDRESS_ADDRESS                25:0
- 
- #define ZV1_CAPTURE_BUF1_ADDRESS                        0x098010
- #define ZV1_CAPTURE_BUF1_ADDRESS_STATUS                 31:31
- #define ZV1_CAPTURE_BUF1_ADDRESS_STATUS_CURRENT         0
- #define ZV1_CAPTURE_BUF1_ADDRESS_STATUS_PENDING         1
- #define ZV1_CAPTURE_BUF1_ADDRESS_EXT                    27:27
- #define ZV1_CAPTURE_BUF1_ADDRESS_EXT_LOCAL              0
- #define ZV1_CAPTURE_BUF1_ADDRESS_EXT_EXTERNAL           1
- #define ZV1_CAPTURE_BUF1_ADDRESS_CS                     26:26
- #define ZV1_CAPTURE_BUF1_ADDRESS_CS_0                   0
- #define ZV1_CAPTURE_BUF1_ADDRESS_CS_1                   1
- #define ZV1_CAPTURE_BUF1_ADDRESS_ADDRESS                25:0
- 
- #define ZV1_CAPTURE_BUF_OFFSET                          0x098014
- #define ZV1_CAPTURE_BUF_OFFSET_OFFSET                   15:0
- 
- #define ZV1_CAPTURE_FIFO_CTRL                           0x098018
- #define ZV1_CAPTURE_FIFO_CTRL_FIFO                      2:0
- #define ZV1_CAPTURE_FIFO_CTRL_FIFO_0                    0
- #define ZV1_CAPTURE_FIFO_CTRL_FIFO_1                    1
- #define ZV1_CAPTURE_FIFO_CTRL_FIFO_2                    2
- #define ZV1_CAPTURE_FIFO_CTRL_FIFO_3                    3
- #define ZV1_CAPTURE_FIFO_CTRL_FIFO_4                    4
- #define ZV1_CAPTURE_FIFO_CTRL_FIFO_5                    5
- #define ZV1_CAPTURE_FIFO_CTRL_FIFO_6                    6
- #define ZV1_CAPTURE_FIFO_CTRL_FIFO_7                    7
- 
- #define ZV1_CAPTURE_YRGB_CONST                          0x09801C
- #define ZV1_CAPTURE_YRGB_CONST_Y                        31:24
- #define ZV1_CAPTURE_YRGB_CONST_R                        23:16
- #define ZV1_CAPTURE_YRGB_CONST_G                        15:8
- #define ZV1_CAPTURE_YRGB_CONST_B                        7:0
- 
- #define DMA_1_SOURCE                                    0x0D0010
- #define DMA_1_SOURCE_ADDRESS_EXT                        27:27
- #define DMA_1_SOURCE_ADDRESS_EXT_LOCAL                  0
- #define DMA_1_SOURCE_ADDRESS_EXT_EXTERNAL               1
- #define DMA_1_SOURCE_ADDRESS_CS                         26:26
- #define DMA_1_SOURCE_ADDRESS_CS_0                       0
- #define DMA_1_SOURCE_ADDRESS_CS_1                       1
- #define DMA_1_SOURCE_ADDRESS                            25:0
- 
- #define DMA_1_DESTINATION                               0x0D0014
- #define DMA_1_DESTINATION_ADDRESS_EXT                   27:27
- #define DMA_1_DESTINATION_ADDRESS_EXT_LOCAL             0
- #define DMA_1_DESTINATION_ADDRESS_EXT_EXTERNAL          1
- #define DMA_1_DESTINATION_ADDRESS_CS                    26:26
- #define DMA_1_DESTINATION_ADDRESS_CS_0                  0
- #define DMA_1_DESTINATION_ADDRESS_CS_1                  1
- #define DMA_1_DESTINATION_ADDRESS                       25:0
- 
- #define DMA_1_SIZE_CONTROL                              0x0D0018
- #define DMA_1_SIZE_CONTROL_STATUS                       31:31
- #define DMA_1_SIZE_CONTROL_STATUS_IDLE                  0
- #define DMA_1_SIZE_CONTROL_STATUS_ACTIVE                1
- #define DMA_1_SIZE_CONTROL_SIZE                         23:0
- 
- #define DMA_ABORT_INTERRUPT                             0x0D0020
- #define DMA_ABORT_INTERRUPT_ABORT_1                     5:5
- #define DMA_ABORT_INTERRUPT_ABORT_1_ENABLE              0
- #define DMA_ABORT_INTERRUPT_ABORT_1_ABORT               1
- #define DMA_ABORT_INTERRUPT_ABORT_0                     4:4
- #define DMA_ABORT_INTERRUPT_ABORT_0_ENABLE              0
- #define DMA_ABORT_INTERRUPT_ABORT_0_ABORT               1
- #define DMA_ABORT_INTERRUPT_INT_1                       1:1
- #define DMA_ABORT_INTERRUPT_INT_1_CLEAR                 0
- #define DMA_ABORT_INTERRUPT_INT_1_FINISHED              1
- #define DMA_ABORT_INTERRUPT_INT_0                       0:0
- #define DMA_ABORT_INTERRUPT_INT_0_CLEAR                 0
- #define DMA_ABORT_INTERRUPT_INT_0_FINISHED              1
- 
- 
- 
- 
- 
- /* Default i2c CLK and Data GPIO. These are the default i2c pins */
- #define DEFAULT_I2C_SCL                     30
- #define DEFAULT_I2C_SDA                     31
- 
- 
- #define GPIO_DATA_SM750LE                               0x020018
- #define GPIO_DATA_SM750LE_1                             1:1
- #define GPIO_DATA_SM750LE_0                             0:0
- 
- #define GPIO_DATA_DIRECTION_SM750LE                     0x02001C
- #define GPIO_DATA_DIRECTION_SM750LE_1                   1:1
- #define GPIO_DATA_DIRECTION_SM750LE_1_INPUT             0
- #define GPIO_DATA_DIRECTION_SM750LE_1_OUTPUT            1
- #define GPIO_DATA_DIRECTION_SM750LE_0                   0:0
- #define GPIO_DATA_DIRECTION_SM750LE_0_INPUT             0
- #define GPIO_DATA_DIRECTION_SM750LE_0_OUTPUT            1
- 
- 
- #endif
--- 0 ----
diff -rcNP linux-4.4.24/drivers/staging/sm750fb/ddk750_sii164.c linux-4.4.24-baikal/drivers/staging/sm750fb/ddk750_sii164.c
*** linux-4.4.24/drivers/staging/sm750fb/ddk750_sii164.c	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/staging/sm750fb/ddk750_sii164.c	1970-01-01 03:00:00.000000000 +0300
***************
*** 1,409 ****
- #define USE_DVICHIP
- #ifdef USE_DVICHIP
- 
- #include "ddk750_sii164.h"
- #include "ddk750_hwi2c.h"
- 
- /* I2C Address of each SII164 chip */
- #define SII164_I2C_ADDRESS                  0x70
- 
- /* Define this definition to use hardware i2c. */
- #define USE_HW_I2C
- 
- #ifdef USE_HW_I2C
-     #define i2cWriteReg sm750_hw_i2c_write_reg
-     #define i2cReadReg  sm750_hw_i2c_read_reg
- #else
-     #define i2cWriteReg swI2CWriteReg
-     #define i2cReadReg  swI2CReadReg
- #endif
- 
- /* SII164 Vendor and Device ID */
- #define SII164_VENDOR_ID                    0x0001
- #define SII164_DEVICE_ID                    0x0006
- 
- #ifdef SII164_FULL_FUNCTIONS
- /* Name of the DVI Controller chip */
- static char *gDviCtrlChipName = "Silicon Image SiI 164";
- #endif
- 
- /*
-  *  sii164GetVendorID
-  *      This function gets the vendor ID of the DVI controller chip.
-  *
-  *  Output:
-  *      Vendor ID
-  */
- unsigned short sii164GetVendorID(void)
- {
- 	unsigned short vendorID;
- 
- 	vendorID = ((unsigned short) i2cReadReg(SII164_I2C_ADDRESS, SII164_VENDOR_ID_HIGH) << 8) |
- 		    (unsigned short) i2cReadReg(SII164_I2C_ADDRESS, SII164_VENDOR_ID_LOW);
- 
- 	return vendorID;
- }
- 
- /*
-  *  sii164GetDeviceID
-  *      This function gets the device ID of the DVI controller chip.
-  *
-  *  Output:
-  *      Device ID
-  */
- unsigned short sii164GetDeviceID(void)
- {
- 	unsigned short deviceID;
- 
- 	deviceID = ((unsigned short) i2cReadReg(SII164_I2C_ADDRESS, SII164_DEVICE_ID_HIGH) << 8) |
- 		    (unsigned short) i2cReadReg(SII164_I2C_ADDRESS, SII164_DEVICE_ID_LOW);
- 
- 	return deviceID;
- }
- 
- 
- 
- /* DVI.C will handle all SiI164 chip stuffs and try it best to make code minimal and useful */
- 
- /*
-  *  sii164InitChip
-  *      This function initialize and detect the DVI controller chip.
-  *
-  *  Input:
-  *      edgeSelect          - Edge Select:
-  *                              0 = Input data is falling edge latched (falling edge
-  *                                  latched first in dual edge mode)
-  *                              1 = Input data is rising edge latched (rising edge
-  *                                  latched first in dual edge mode)
-  *      busSelect           - Input Bus Select:
-  *                              0 = Input data bus is 12-bits wide
-  *                              1 = Input data bus is 24-bits wide
-  *      dualEdgeClkSelect   - Dual Edge Clock Select
-  *                              0 = Input data is single edge latched
-  *                              1 = Input data is dual edge latched
-  *      hsyncEnable         - Horizontal Sync Enable:
-  *                              0 = HSYNC input is transmitted as fixed LOW
-  *                              1 = HSYNC input is transmitted as is
-  *      vsyncEnable         - Vertical Sync Enable:
-  *                              0 = VSYNC input is transmitted as fixed LOW
-  *                              1 = VSYNC input is transmitted as is
-  *      deskewEnable        - De-skewing Enable:
-  *                              0 = De-skew disabled
-  *                              1 = De-skew enabled
-  *      deskewSetting       - De-skewing Setting (increment of 260psec)
-  *                              0 = 1 step --> minimum setup / maximum hold
-  *                              1 = 2 step
-  *                              2 = 3 step
-  *                              3 = 4 step
-  *                              4 = 5 step
-  *                              5 = 6 step
-  *                              6 = 7 step
-  *                              7 = 8 step --> maximum setup / minimum hold
-  *      continuousSyncEnable- SYNC Continuous:
-  *                              0 = Disable
-  *                              1 = Enable
-  *      pllFilterEnable     - PLL Filter Enable
-  *                              0 = Disable PLL Filter
-  *                              1 = Enable PLL Filter
-  *      pllFilterValue      - PLL Filter characteristics:
-  *                              0~7 (recommended value is 4)
-  *
-  *  Output:
-  *      0   - Success
-  *     -1   - Fail.
-  */
- long sii164InitChip(
- 	unsigned char edgeSelect,
- 	unsigned char busSelect,
- 	unsigned char dualEdgeClkSelect,
- 	unsigned char hsyncEnable,
- 	unsigned char vsyncEnable,
- 	unsigned char deskewEnable,
- 	unsigned char deskewSetting,
- 	unsigned char continuousSyncEnable,
- 	unsigned char pllFilterEnable,
- 	unsigned char pllFilterValue
- )
- {
- 	unsigned char config;
- 
- 	/* Initialize the i2c bus */
- #ifdef USE_HW_I2C
- 	/* Use fast mode. */
- 	sm750_hw_i2c_init(1);
- #else
- 	sm750_sw_i2c_init(DEFAULT_I2C_SCL, DEFAULT_I2C_SDA);
- #endif
- 
- 	/* Check if SII164 Chip exists */
- 	if ((sii164GetVendorID() == SII164_VENDOR_ID) && (sii164GetDeviceID() == SII164_DEVICE_ID)) {
- 		/*
- 		 *  Initialize SII164 controller chip.
- 		 */
- 
- 		/* Select the edge */
- 		if (edgeSelect == 0)
- 			config = SII164_CONFIGURATION_LATCH_FALLING;
- 		else
- 			config = SII164_CONFIGURATION_LATCH_RISING;
- 
- 		/* Select bus wide */
- 		if (busSelect == 0)
- 			config |= SII164_CONFIGURATION_BUS_12BITS;
- 		else
- 			config |= SII164_CONFIGURATION_BUS_24BITS;
- 
- 		/* Select Dual/Single Edge Clock */
- 		if (dualEdgeClkSelect == 0)
- 			config |= SII164_CONFIGURATION_CLOCK_SINGLE;
- 		else
- 			config |= SII164_CONFIGURATION_CLOCK_DUAL;
- 
- 		/* Select HSync Enable */
- 		if (hsyncEnable == 0)
- 			config |= SII164_CONFIGURATION_HSYNC_FORCE_LOW;
- 		else
- 			config |= SII164_CONFIGURATION_HSYNC_AS_IS;
- 
- 		/* Select VSync Enable */
- 		if (vsyncEnable == 0)
- 			config |= SII164_CONFIGURATION_VSYNC_FORCE_LOW;
- 		else
- 			config |= SII164_CONFIGURATION_VSYNC_AS_IS;
- 
- 		i2cWriteReg(SII164_I2C_ADDRESS, SII164_CONFIGURATION, config);
- 
- 		/* De-skew enabled with default 111b value.
- 		   This will fix some artifacts problem in some mode on board 2.2.
- 		   Somehow this fix does not affect board 2.1.
- 		 */
- 		if (deskewEnable == 0)
- 			config = SII164_DESKEW_DISABLE;
- 		else
- 			config = SII164_DESKEW_ENABLE;
- 
- 		switch (deskewSetting) {
- 		case 0:
- 			config |= SII164_DESKEW_1_STEP;
- 			break;
- 		case 1:
- 			config |= SII164_DESKEW_2_STEP;
- 			break;
- 		case 2:
- 			config |= SII164_DESKEW_3_STEP;
- 			break;
- 		case 3:
- 			config |= SII164_DESKEW_4_STEP;
- 			break;
- 		case 4:
- 			config |= SII164_DESKEW_5_STEP;
- 			break;
- 		case 5:
- 			config |= SII164_DESKEW_6_STEP;
- 			break;
- 		case 6:
- 			config |= SII164_DESKEW_7_STEP;
- 			break;
- 		case 7:
- 			config |= SII164_DESKEW_8_STEP;
- 			break;
- 		}
- 		i2cWriteReg(SII164_I2C_ADDRESS, SII164_DESKEW, config);
- 
- 		/* Enable/Disable Continuous Sync. */
- 		if (continuousSyncEnable == 0)
- 			config = SII164_PLL_FILTER_SYNC_CONTINUOUS_DISABLE;
- 		else
- 			config = SII164_PLL_FILTER_SYNC_CONTINUOUS_ENABLE;
- 
- 		/* Enable/Disable PLL Filter */
- 		if (pllFilterEnable == 0)
- 			config |= SII164_PLL_FILTER_DISABLE;
- 		else
- 			config |= SII164_PLL_FILTER_ENABLE;
- 
- 		/* Set the PLL Filter value */
- 		config |= ((pllFilterValue & 0x07) << 1);
- 
- 		i2cWriteReg(SII164_I2C_ADDRESS, SII164_PLL, config);
- 
- 		/* Recover from Power Down and enable output. */
- 		config = i2cReadReg(SII164_I2C_ADDRESS, SII164_CONFIGURATION);
- 		config |= SII164_CONFIGURATION_POWER_NORMAL;
- 		i2cWriteReg(SII164_I2C_ADDRESS, SII164_CONFIGURATION, config);
- 
- 		return 0;
- 	}
- 
- 	/* Return -1 if initialization fails. */
- 	return (-1);
- }
- 
- 
- 
- 
- 
- /* below sii164 function is not necessary */
- 
- #ifdef SII164_FULL_FUNCTIONS
- 
- /*
-  *  sii164ResetChip
-  *      This function resets the DVI Controller Chip.
-  */
- void sii164ResetChip(void)
- {
- 	/* Power down */
- 	sii164SetPower(0);
- 	sii164SetPower(1);
- }
- 
- 
- /*
-  * sii164GetChipString
-  *      This function returns a char string name of the current DVI Controller chip.
-  *      It's convenient for application need to display the chip name.
-  */
- char *sii164GetChipString(void)
- {
- 	return gDviCtrlChipName;
- }
- 
- 
- /*
-  *  sii164SetPower
-  *      This function sets the power configuration of the DVI Controller Chip.
-  *
-  *  Input:
-  *      powerUp - Flag to set the power down or up
-  */
- void sii164SetPower(
- 	unsigned char powerUp
- )
- {
- 	unsigned char config;
- 
- 	config = i2cReadReg(SII164_I2C_ADDRESS, SII164_CONFIGURATION);
- 	if (powerUp == 1) {
- 		/* Power up the chip */
- 		config &= ~SII164_CONFIGURATION_POWER_MASK;
- 		config |= SII164_CONFIGURATION_POWER_NORMAL;
- 		i2cWriteReg(SII164_I2C_ADDRESS, SII164_CONFIGURATION, config);
- 	} else {
- 		/* Power down the chip */
- 		config &= ~SII164_CONFIGURATION_POWER_MASK;
- 		config |= SII164_CONFIGURATION_POWER_DOWN;
- 		i2cWriteReg(SII164_I2C_ADDRESS, SII164_CONFIGURATION, config);
- 	}
- }
- 
- 
- /*
-  *  sii164SelectHotPlugDetectionMode
-  *      This function selects the mode of the hot plug detection.
-  */
- static void sii164SelectHotPlugDetectionMode(
- 	sii164_hot_plug_mode_t hotPlugMode
- )
- {
- 	unsigned char detectReg;
- 
- 	detectReg = i2cReadReg(SII164_I2C_ADDRESS, SII164_DETECT) & ~SII164_DETECT_MONITOR_SENSE_OUTPUT_FLAG;
- 	switch (hotPlugMode) {
- 	case SII164_HOTPLUG_DISABLE:
- 		detectReg |= SII164_DETECT_MONITOR_SENSE_OUTPUT_HIGH;
- 		break;
- 	case SII164_HOTPLUG_USE_MDI:
- 		detectReg &= ~SII164_DETECT_INTERRUPT_MASK;
- 		detectReg |= SII164_DETECT_INTERRUPT_BY_HTPLG_PIN;
- 		detectReg |= SII164_DETECT_MONITOR_SENSE_OUTPUT_MDI;
- 		break;
- 	case SII164_HOTPLUG_USE_RSEN:
- 		detectReg |= SII164_DETECT_MONITOR_SENSE_OUTPUT_RSEN;
- 		break;
- 	case SII164_HOTPLUG_USE_HTPLG:
- 		detectReg |= SII164_DETECT_MONITOR_SENSE_OUTPUT_HTPLG;
- 		break;
- 	}
- 
- 	i2cWriteReg(SII164_I2C_ADDRESS, SII164_DETECT, detectReg);
- }
- 
- /*
-  *  sii164EnableHotPlugDetection
-  *      This function enables the Hot Plug detection.
-  *
-  *  enableHotPlug   - Enable (=1) / disable (=0) Hot Plug detection
-  */
- void sii164EnableHotPlugDetection(
- 	unsigned char enableHotPlug
- )
- {
- 	unsigned char detectReg;
- 
- 	detectReg = i2cReadReg(SII164_I2C_ADDRESS, SII164_DETECT);
- 
- 	/* Depending on each DVI controller, need to enable the hot plug based on each
- 	   individual chip design. */
- 	if (enableHotPlug != 0)
- 		sii164SelectHotPlugDetectionMode(SII164_HOTPLUG_USE_MDI);
- 	else
- 		sii164SelectHotPlugDetectionMode(SII164_HOTPLUG_DISABLE);
- }
- 
- /*
-  *  sii164IsConnected
-  *      Check if the DVI Monitor is connected.
-  *
-  *  Output:
-  *      0   - Not Connected
-  *      1   - Connected
-  */
- unsigned char sii164IsConnected(void)
- {
- 	unsigned char hotPlugValue;
- 
- 	hotPlugValue = i2cReadReg(SII164_I2C_ADDRESS, SII164_DETECT) & SII164_DETECT_HOT_PLUG_STATUS_MASK;
- 	if (hotPlugValue == SII164_DETECT_HOT_PLUG_STATUS_ON)
- 		return 1;
- 	else
- 		return 0;
- }
- 
- /*
-  *  sii164CheckInterrupt
-  *      Checks if interrupt has occurred.
-  *
-  *  Output:
-  *      0   - No interrupt
-  *      1   - Interrupt occurs
-  */
- unsigned char sii164CheckInterrupt(void)
- {
- 	unsigned char detectReg;
- 
- 	detectReg = i2cReadReg(SII164_I2C_ADDRESS, SII164_DETECT) & SII164_DETECT_MONITOR_STATE_MASK;
- 	if (detectReg == SII164_DETECT_MONITOR_STATE_CHANGE)
- 		return 1;
- 	else
- 		return 0;
- }
- 
- /*
-  *  sii164ClearInterrupt
-  *      Clear the hot plug interrupt.
-  */
- void sii164ClearInterrupt(void)
- {
- 	unsigned char detectReg;
- 
- 	/* Clear the MDI interrupt */
- 	detectReg = i2cReadReg(SII164_I2C_ADDRESS, SII164_DETECT);
- 	i2cWriteReg(SII164_I2C_ADDRESS, SII164_DETECT, detectReg | SII164_DETECT_MONITOR_STATE_CLEAR);
- }
- 
- #endif
- 
- #endif
- 
- 
--- 0 ----
diff -rcNP linux-4.4.24/drivers/staging/sm750fb/ddk750_sii164.h linux-4.4.24-baikal/drivers/staging/sm750fb/ddk750_sii164.h
*** linux-4.4.24/drivers/staging/sm750fb/ddk750_sii164.h	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/staging/sm750fb/ddk750_sii164.h	1970-01-01 03:00:00.000000000 +0300
***************
*** 1,171 ****
- #ifndef DDK750_SII164_H__
- #define DDK750_SII164_H__
- 
- #define USE_DVICHIP
- 
- /* Hot Plug detection mode structure */
- typedef enum _sii164_hot_plug_mode_t {
- 	SII164_HOTPLUG_DISABLE = 0,         /* Disable Hot Plug output bit (always high). */
- 	SII164_HOTPLUG_USE_MDI,             /* Use Monitor Detect Interrupt bit. */
- 	SII164_HOTPLUG_USE_RSEN,            /* Use Receiver Sense detect bit. */
- 	SII164_HOTPLUG_USE_HTPLG            /* Use Hot Plug detect bit. */
- } sii164_hot_plug_mode_t;
- 
- 
- /* Silicon Image SiI164 chip prototype */
- long sii164InitChip(
- 	unsigned char edgeSelect,
- 	unsigned char busSelect,
- 	unsigned char dualEdgeClkSelect,
- 	unsigned char hsyncEnable,
- 	unsigned char vsyncEnable,
- 	unsigned char deskewEnable,
- 	unsigned char deskewSetting,
- 	unsigned char continuousSyncEnable,
- 	unsigned char pllFilterEnable,
- 	unsigned char pllFilterValue
- );
- 
- unsigned short sii164GetVendorID(void);
- unsigned short sii164GetDeviceID(void);
- 
- 
- #ifdef SII164_FULL_FUNCTIONS
- void sii164ResetChip(void);
- char *sii164GetChipString(void);
- void sii164SetPower(unsigned char powerUp);
- void sii164EnableHotPlugDetection(unsigned char enableHotPlug);
- unsigned char sii164IsConnected(void);
- unsigned char sii164CheckInterrupt(void);
- void sii164ClearInterrupt(void);
- #endif
- /* below register definination is used for Silicon Image SiI164 DVI controller chip */
- /*
-  * Vendor ID registers
-  */
- #define SII164_VENDOR_ID_LOW                        0x00
- #define SII164_VENDOR_ID_HIGH                       0x01
- 
- /*
-  * Device ID registers
-  */
- #define SII164_DEVICE_ID_LOW                        0x02
- #define SII164_DEVICE_ID_HIGH                       0x03
- 
- /*
-  * Device Revision
-  */
- #define SII164_DEVICE_REVISION                      0x04
- 
- /*
-  * Frequency Limitation registers
-  */
- #define SII164_FREQUENCY_LIMIT_LOW                  0x06
- #define SII164_FREQUENCY_LIMIT_HIGH                 0x07
- 
- /*
-  * Power Down and Input Signal Configuration registers
-  */
- #define SII164_CONFIGURATION                        0x08
- 
- /* Power down (PD) */
- #define SII164_CONFIGURATION_POWER_DOWN             0x00
- #define SII164_CONFIGURATION_POWER_NORMAL           0x01
- #define SII164_CONFIGURATION_POWER_MASK             0x01
- 
- /* Input Edge Latch Select (EDGE) */
- #define SII164_CONFIGURATION_LATCH_FALLING          0x00
- #define SII164_CONFIGURATION_LATCH_RISING           0x02
- 
- /* Bus Select (BSEL) */
- #define SII164_CONFIGURATION_BUS_12BITS             0x00
- #define SII164_CONFIGURATION_BUS_24BITS             0x04
- 
- /* Dual Edge Clock Select (DSEL) */
- #define SII164_CONFIGURATION_CLOCK_SINGLE           0x00
- #define SII164_CONFIGURATION_CLOCK_DUAL             0x08
- 
- /* Horizontal Sync Enable (HEN) */
- #define SII164_CONFIGURATION_HSYNC_FORCE_LOW        0x00
- #define SII164_CONFIGURATION_HSYNC_AS_IS            0x10
- 
- /* Vertical Sync Enable (VEN) */
- #define SII164_CONFIGURATION_VSYNC_FORCE_LOW        0x00
- #define SII164_CONFIGURATION_VSYNC_AS_IS            0x20
- 
- /*
-  * Detection registers
-  */
- #define SII164_DETECT                               0x09
- 
- /* Monitor Detect Interrupt (MDI) */
- #define SII164_DETECT_MONITOR_STATE_CHANGE          0x00
- #define SII164_DETECT_MONITOR_STATE_NO_CHANGE       0x01
- #define SII164_DETECT_MONITOR_STATE_CLEAR           0x01
- #define SII164_DETECT_MONITOR_STATE_MASK            0x01
- 
- /* Hot Plug detect Input (HTPLG) */
- #define SII164_DETECT_HOT_PLUG_STATUS_OFF           0x00
- #define SII164_DETECT_HOT_PLUG_STATUS_ON            0x02
- #define SII164_DETECT_HOT_PLUG_STATUS_MASK          0x02
- 
- /* Receiver Sense (RSEN) */
- #define SII164_DETECT_RECEIVER_SENSE_NOT_DETECTED   0x00
- #define SII164_DETECT_RECEIVER_SENSE_DETECTED       0x04
- 
- /* Interrupt Generation Method (TSEL) */
- #define SII164_DETECT_INTERRUPT_BY_RSEN_PIN         0x00
- #define SII164_DETECT_INTERRUPT_BY_HTPLG_PIN        0x08
- #define SII164_DETECT_INTERRUPT_MASK                0x08
- 
- /* Monitor Sense Output (MSEN) */
- #define SII164_DETECT_MONITOR_SENSE_OUTPUT_HIGH     0x00
- #define SII164_DETECT_MONITOR_SENSE_OUTPUT_MDI      0x10
- #define SII164_DETECT_MONITOR_SENSE_OUTPUT_RSEN     0x20
- #define SII164_DETECT_MONITOR_SENSE_OUTPUT_HTPLG    0x30
- #define SII164_DETECT_MONITOR_SENSE_OUTPUT_FLAG     0x30
- 
- /*
-  * Skewing registers
-  */
- #define SII164_DESKEW                               0x0A
- 
- /* General Purpose Input (CTL[3:1]) */
- #define SII164_DESKEW_GENERAL_PURPOSE_INPUT_MASK    0x0E
- 
- /* De-skewing Enable bit (DKEN) */
- #define SII164_DESKEW_DISABLE                       0x00
- #define SII164_DESKEW_ENABLE                        0x10
- 
- /* De-skewing Setting (DK[3:1])*/
- #define SII164_DESKEW_1_STEP                        0x00
- #define SII164_DESKEW_2_STEP                        0x20
- #define SII164_DESKEW_3_STEP                        0x40
- #define SII164_DESKEW_4_STEP                        0x60
- #define SII164_DESKEW_5_STEP                        0x80
- #define SII164_DESKEW_6_STEP                        0xA0
- #define SII164_DESKEW_7_STEP                        0xC0
- #define SII164_DESKEW_8_STEP                        0xE0
- 
- /*
-  * User Configuration Data registers (CFG 7:0)
-  */
- #define SII164_USER_CONFIGURATION                   0x0B
- 
- /*
-  * PLL registers
-  */
- #define SII164_PLL                                  0x0C
- 
- /* PLL Filter Value (PLLF) */
- #define SII164_PLL_FILTER_VALUE_MASK                0x0E
- 
- /* PLL Filter Enable (PFEN) */
- #define SII164_PLL_FILTER_DISABLE                   0x00
- #define SII164_PLL_FILTER_ENABLE                    0x01
- 
- /* Sync Continuous (SCNT) */
- #define SII164_PLL_FILTER_SYNC_CONTINUOUS_DISABLE   0x00
- #define SII164_PLL_FILTER_SYNC_CONTINUOUS_ENABLE    0x80
- 
- #endif
--- 0 ----
diff -rcNP linux-4.4.24/drivers/staging/sm750fb/ddk750_swi2c.c linux-4.4.24-baikal/drivers/staging/sm750fb/ddk750_swi2c.c
*** linux-4.4.24/drivers/staging/sm750fb/ddk750_swi2c.c	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/staging/sm750fb/ddk750_swi2c.c	1970-01-01 03:00:00.000000000 +0300
***************
*** 1,516 ****
- /*******************************************************************
- *
- *         Copyright (c) 2007 by Silicon Motion, Inc. (SMI)
- *
- *  All rights are reserved. Reproduction or in part is prohibited
- *  without the written consent of the copyright owner.
- *
- *  swi2c.c --- SM750/SM718 DDK
- *  This file contains the source code for I2C using software
- *  implementation.
- *
- *******************************************************************/
- #include "ddk750_help.h"
- #include "ddk750_reg.h"
- #include "ddk750_swi2c.h"
- #include "ddk750_power.h"
- 
- /*******************************************************************
-  * I2C Software Master Driver:
-  * ===========================
-  * Each i2c cycle is split into 4 sections. Each of these section marks
-  * a point in time where the SCL or SDA may be changed.
-  *
-  * 1 Cycle == |  Section I. |  Section 2. |  Section 3. |  Section 4. |
-  *            +-------------+-------------+-------------+-------------+
-  *            | SCL set LOW |SCL no change| SCL set HIGH|SCL no change|
-  *
-  *                                          ____________ _____________
-  * SCL == XXXX _____________ ____________ /
-  *
-  * I.e. the SCL may only be changed in section 1. and section 3. while
-  * the SDA may only be changed in section 2. and section 4. The table
-  * below gives the changes for these 2 lines in the varios sections.
-  *
-  * Section changes Table:
-  * ======================
-  * blank = no change, L = set bit LOW, H = set bit HIGH
-  *
-  *                                | 1.| 2.| 3.| 4.|
-  *                 ---------------+---+---+---+---+
-  *                 Tx Start   SDA |   | H |   | L |
-  *                            SCL | L |   | H |   |
-  *                 ---------------+---+---+---+---+
-  *                 Tx Stop    SDA |   | L |   | H |
-  *                            SCL | L |   | H |   |
-  *                 ---------------+---+---+---+---+
-  *                 Tx bit H   SDA |   | H |   |   |
-  *                            SCL | L |   | H |   |
-  *                 ---------------+---+---+---+---+
-  *                 Tx bit L   SDA |   | L |   |   |
-  *                            SCL | L |   | H |   |
-  *                 ---------------+---+---+---+---+
-  *
-  ******************************************************************/
- 
- /* GPIO pins used for this I2C. It ranges from 0 to 63. */
- static unsigned char sw_i2c_clk_gpio = DEFAULT_I2C_SCL;
- static unsigned char sw_i2c_data_gpio = DEFAULT_I2C_SDA;
- 
- /*
-  *  Below is the variable declaration for the GPIO pin register usage
-  *  for the i2c Clock and i2c Data.
-  *
-  *  Note:
-  *      Notice that the GPIO usage for the i2c clock and i2c Data are
-  *      separated. This is to make this code flexible enough when
-  *      two separate GPIO pins for the clock and data are located
-  *      in two different GPIO register set (worst case).
-  */
- 
- /* i2c Clock GPIO Register usage */
- static unsigned long sw_i2c_clk_gpio_mux_reg = GPIO_MUX;
- static unsigned long sw_i2c_clk_gpio_data_reg = GPIO_DATA;
- static unsigned long sw_i2c_clk_gpio_data_dir_reg = GPIO_DATA_DIRECTION;
- 
- /* i2c Data GPIO Register usage */
- static unsigned long sw_i2c_data_gpio_mux_reg = GPIO_MUX;
- static unsigned long sw_i2c_data_gpio_data_reg = GPIO_DATA;
- static unsigned long sw_i2c_data_gpio_data_dir_reg = GPIO_DATA_DIRECTION;
- 
- /*
-  *  This function puts a delay between command
-  */
- static void sw_i2c_wait(void)
- {
- 	/* find a bug:
- 	 * peekIO method works well before suspend/resume
- 	 * but after suspend, peekIO(0x3ce,0x61) & 0x10
- 	 * always be non-zero,which makes the while loop
- 	 * never finish.
- 	 * use non-ultimate for loop below is safe
- 	 * */
- 
-     /* Change wait algorithm to use PCI bus clock,
-        it's more reliable than counter loop ..
-        write 0x61 to 0x3ce and read from 0x3cf
-        */
- 	int i, tmp;
- 
- 	for (i = 0; i < 600; i++) {
- 		tmp = i;
- 		tmp += i;
- 	}
- }
- 
- /*
-  *  This function set/reset the SCL GPIO pin
-  *
-  *  Parameters:
-  *      value    - Bit value to set to the SCL or SDA (0 = low, 1 = high)
-  *
-  *  Notes:
-  *      When setting SCL to high, just set the GPIO as input where the pull up
-  *      resistor will pull the signal up. Do not use software to pull up the
-  *      signal because the i2c will fail when other device try to drive the
-  *      signal due to SM50x will drive the signal to always high.
-  */
- static void sw_i2c_scl(unsigned char value)
- {
- 	unsigned long gpio_data;
- 	unsigned long gpio_dir;
- 
- 	gpio_dir = PEEK32(sw_i2c_clk_gpio_data_dir_reg);
- 	if (value) {    /* High */
- 		/*
- 		 * Set direction as input. This will automatically
- 		 * pull the signal up.
- 		 */
- 		gpio_dir &= ~(1 << sw_i2c_clk_gpio);
- 		POKE32(sw_i2c_clk_gpio_data_dir_reg, gpio_dir);
- 	} else {        /* Low */
- 		/* Set the signal down */
- 		gpio_data = PEEK32(sw_i2c_clk_gpio_data_reg);
- 		gpio_data &= ~(1 << sw_i2c_clk_gpio);
- 		POKE32(sw_i2c_clk_gpio_data_reg, gpio_data);
- 
- 		/* Set direction as output */
- 		gpio_dir |= (1 << sw_i2c_clk_gpio);
- 		POKE32(sw_i2c_clk_gpio_data_dir_reg, gpio_dir);
- 	}
- }
- 
- /*
-  *  This function set/reset the SDA GPIO pin
-  *
-  *  Parameters:
-  *      value    - Bit value to set to the SCL or SDA (0 = low, 1 = high)
-  *
-  *  Notes:
-  *      When setting SCL to high, just set the GPIO as input where the pull up
-  *      resistor will pull the signal up. Do not use software to pull up the
-  *      signal because the i2c will fail when other device try to drive the
-  *      signal due to SM50x will drive the signal to always high.
-  */
- static void sw_i2c_sda(unsigned char value)
- {
- 	unsigned long gpio_data;
- 	unsigned long gpio_dir;
- 
- 	gpio_dir = PEEK32(sw_i2c_data_gpio_data_dir_reg);
- 	if (value) {    /* High */
- 		/*
- 		 * Set direction as input. This will automatically
- 		 * pull the signal up.
- 		 */
- 		gpio_dir &= ~(1 << sw_i2c_data_gpio);
- 		POKE32(sw_i2c_data_gpio_data_dir_reg, gpio_dir);
- 	} else {        /* Low */
- 		/* Set the signal down */
- 		gpio_data = PEEK32(sw_i2c_data_gpio_data_reg);
- 		gpio_data &= ~(1 << sw_i2c_data_gpio);
- 		POKE32(sw_i2c_data_gpio_data_reg, gpio_data);
- 
- 		/* Set direction as output */
- 		gpio_dir |= (1 << sw_i2c_data_gpio);
- 		POKE32(sw_i2c_data_gpio_data_dir_reg, gpio_dir);
- 	}
- }
- 
- /*
-  *  This function read the data from the SDA GPIO pin
-  *
-  *  Return Value:
-  *      The SDA data bit sent by the Slave
-  */
- static unsigned char sw_i2c_read_sda(void)
- {
- 	unsigned long gpio_dir;
- 	unsigned long gpio_data;
- 	unsigned long dir_mask = 1 << sw_i2c_data_gpio;
- 
- 	/* Make sure that the direction is input (High) */
- 	gpio_dir = PEEK32(sw_i2c_data_gpio_data_dir_reg);
- 	if ((gpio_dir & dir_mask) != ~dir_mask) {
- 		gpio_dir &= ~(1 << sw_i2c_data_gpio);
- 		POKE32(sw_i2c_data_gpio_data_dir_reg, gpio_dir);
- 	}
- 
- 	/* Now read the SDA line */
- 	gpio_data = PEEK32(sw_i2c_data_gpio_data_reg);
- 	if (gpio_data & (1 << sw_i2c_data_gpio))
- 		return 1;
- 	else
- 		return 0;
- }
- 
- /*
-  *  This function sends ACK signal
-  */
- static void sw_i2c_ack(void)
- {
- 	return;  /* Single byte read is ok without it. */
- }
- 
- /*
-  *  This function sends the start command to the slave device
-  */
- static void sw_i2c_start(void)
- {
- 	/* Start I2C */
- 	sw_i2c_sda(1);
- 	sw_i2c_scl(1);
- 	sw_i2c_sda(0);
- }
- 
- /*
-  *  This function sends the stop command to the slave device
-  */
- static void sw_i2c_stop(void)
- {
- 	/* Stop the I2C */
- 	sw_i2c_scl(1);
- 	sw_i2c_sda(0);
- 	sw_i2c_sda(1);
- }
- 
- /*
-  *  This function writes one byte to the slave device
-  *
-  *  Parameters:
-  *      data    - Data to be write to the slave device
-  *
-  *  Return Value:
-  *       0   - Success
-  *      -1   - Fail to write byte
-  */
- static long sw_i2c_write_byte(unsigned char data)
- {
- 	unsigned char value = data;
- 	int i;
- 
- 	/* Sending the data bit by bit */
- 	for (i = 0; i < 8; i++) {
- 		/* Set SCL to low */
- 		sw_i2c_scl(0);
- 
- 		/* Send data bit */
- 		if ((value & 0x80) != 0)
- 			sw_i2c_sda(1);
- 		else
- 			sw_i2c_sda(0);
- 
- 		sw_i2c_wait();
- 
- 		/* Toggle clk line to one */
- 		sw_i2c_scl(1);
- 		sw_i2c_wait();
- 
- 		/* Shift byte to be sent */
- 		value = value << 1;
- 	}
- 
- 	/* Set the SCL Low and SDA High (prepare to get input) */
- 	sw_i2c_scl(0);
- 	sw_i2c_sda(1);
- 
- 	/* Set the SCL High for ack */
- 	sw_i2c_wait();
- 	sw_i2c_scl(1);
- 	sw_i2c_wait();
- 
- 	/* Read SDA, until SDA==0 */
- 	for (i = 0; i < 0xff; i++) {
- 		if (!sw_i2c_read_sda())
- 			break;
- 
- 		sw_i2c_scl(0);
- 		sw_i2c_wait();
- 		sw_i2c_scl(1);
- 		sw_i2c_wait();
- 	}
- 
- 	/* Set the SCL Low and SDA High */
- 	sw_i2c_scl(0);
- 	sw_i2c_sda(1);
- 
- 	if (i < 0xff)
- 		return 0;
- 	else
- 		return -1;
- }
- 
- /*
-  *  This function reads one byte from the slave device
-  *
-  *  Parameters:
-  *      ack    - Flag to indicate either to send the acknowledge
-  *            message to the slave device or not
-  *
-  *  Return Value:
-  *      One byte data read from the Slave device
-  */
- static unsigned char sw_i2c_read_byte(unsigned char ack)
- {
- 	int i;
- 	unsigned char data = 0;
- 
- 	for (i = 7; i >= 0; i--) {
- 		/* Set the SCL to Low and SDA to High (Input) */
- 		sw_i2c_scl(0);
- 		sw_i2c_sda(1);
- 		sw_i2c_wait();
- 
- 		/* Set the SCL High */
- 		sw_i2c_scl(1);
- 		sw_i2c_wait();
- 
- 		/* Read data bits from SDA */
- 		data |= (sw_i2c_read_sda() << i);
- 	}
- 
- 	if (ack)
- 		sw_i2c_ack();
- 
- 	/* Set the SCL Low and SDA High */
- 	sw_i2c_scl(0);
- 	sw_i2c_sda(1);
- 
- 	return data;
- }
- 
- /*
-  * This function initializes GPIO port for SW I2C communication.
-  *
-  * Parameters:
-  *      clk_gpio      - The GPIO pin to be used as i2c SCL
-  *      data_gpio     - The GPIO pin to be used as i2c SDA
-  *
-  * Return Value:
-  *      -1   - Fail to initialize the i2c
-  *       0   - Success
-  */
- static long sm750le_i2c_init(unsigned char clk_gpio,
- 			     unsigned char data_gpio)
- {
- 	int i;
- 
- 	/* Initialize the GPIO pin for the i2c Clock Register */
- 	sw_i2c_clk_gpio_data_reg = GPIO_DATA_SM750LE;
- 	sw_i2c_clk_gpio_data_dir_reg = GPIO_DATA_DIRECTION_SM750LE;
- 
- 	/* Initialize the Clock GPIO Offset */
- 	sw_i2c_clk_gpio = clk_gpio;
- 
- 	/* Initialize the GPIO pin for the i2c Data Register */
- 	sw_i2c_data_gpio_data_reg = GPIO_DATA_SM750LE;
- 	sw_i2c_data_gpio_data_dir_reg = GPIO_DATA_DIRECTION_SM750LE;
- 
- 	/* Initialize the Data GPIO Offset */
- 	sw_i2c_data_gpio = data_gpio;
- 
- 	/* Note that SM750LE don't have GPIO MUX and power is always on */
- 
- 	/* Clear the i2c lines. */
- 	for (i = 0; i < 9; i++)
- 		sw_i2c_stop();
- 
- 	return 0;
- }
- 
- /*
-  * This function initializes the i2c attributes and bus
-  *
-  * Parameters:
-  *      clk_gpio      - The GPIO pin to be used as i2c SCL
-  *      data_gpio     - The GPIO pin to be used as i2c SDA
-  *
-  * Return Value:
-  *      -1   - Fail to initialize the i2c
-  *       0   - Success
-  */
- long sm750_sw_i2c_init(
- 	unsigned char clk_gpio,
- 	unsigned char data_gpio
- )
- {
- 	int i;
- 
- 	/*
- 	 * Return 0 if the GPIO pins to be used is out of range. The
- 	 * range is only from [0..63]
- 	 */
- 	if ((clk_gpio > 31) || (data_gpio > 31))
- 		return -1;
- 
- 	if (getChipType() == SM750LE)
- 		return sm750le_i2c_init(clk_gpio, data_gpio);
- 
- 	/* Initialize the GPIO pin for the i2c Clock Register */
- 	sw_i2c_clk_gpio_mux_reg = GPIO_MUX;
- 	sw_i2c_clk_gpio_data_reg = GPIO_DATA;
- 	sw_i2c_clk_gpio_data_dir_reg = GPIO_DATA_DIRECTION;
- 
- 	/* Initialize the Clock GPIO Offset */
- 	sw_i2c_clk_gpio = clk_gpio;
- 
- 	/* Initialize the GPIO pin for the i2c Data Register */
- 	sw_i2c_data_gpio_mux_reg = GPIO_MUX;
- 	sw_i2c_data_gpio_data_reg = GPIO_DATA;
- 	sw_i2c_data_gpio_data_dir_reg = GPIO_DATA_DIRECTION;
- 
- 	/* Initialize the Data GPIO Offset */
- 	sw_i2c_data_gpio = data_gpio;
- 
- 	/* Enable the GPIO pins for the i2c Clock and Data (GPIO MUX) */
- 	POKE32(sw_i2c_clk_gpio_mux_reg,
- 	       PEEK32(sw_i2c_clk_gpio_mux_reg) & ~(1 << sw_i2c_clk_gpio));
- 	POKE32(sw_i2c_data_gpio_mux_reg,
- 	       PEEK32(sw_i2c_data_gpio_mux_reg) & ~(1 << sw_i2c_data_gpio));
- 
- 	/* Enable GPIO power */
- 	enableGPIO(1);
- 
- 	/* Clear the i2c lines. */
- 	for (i = 0; i < 9; i++)
- 		sw_i2c_stop();
- 
- 	return 0;
- }
- 
- /*
-  *  This function reads the slave device's register
-  *
-  *  Parameters:
-  *      addr   - i2c Slave device address which register
-  *                        to be read from
-  *      reg    - Slave device's register to be read
-  *
-  *  Return Value:
-  *      Register value
-  */
- unsigned char sm750_sw_i2c_read_reg(
- 	unsigned char addr,
- 	unsigned char reg
- )
- {
- 	unsigned char data;
- 
- 	/* Send the Start signal */
- 	sw_i2c_start();
- 
- 	/* Send the device address */
- 	sw_i2c_write_byte(addr);
- 
- 	/* Send the register index */
- 	sw_i2c_write_byte(reg);
- 
- 	/* Get the bus again and get the data from the device read address */
- 	sw_i2c_start();
- 	sw_i2c_write_byte(addr + 1);
- 	data = sw_i2c_read_byte(1);
- 
- 	/* Stop swI2C and release the bus */
- 	sw_i2c_stop();
- 
- 	return data;
- }
- 
- /*
-  *  This function writes a value to the slave device's register
-  *
-  *  Parameters:
-  *      addr            - i2c Slave device address which register
-  *                        to be written
-  *      reg             - Slave device's register to be written
-  *      data            - Data to be written to the register
-  *
-  *  Result:
-  *          0   - Success
-  *         -1   - Fail
-  */
- long sm750_sw_i2c_write_reg(
- 	unsigned char addr,
- 	unsigned char reg,
- 	unsigned char data
- )
- {
- 	long ret = 0;
- 
- 	/* Send the Start signal */
- 	sw_i2c_start();
- 
- 	/* Send the device address and read the data. All should return success
- 	   in order for the writing processed to be successful
- 	*/
- 	if ((sw_i2c_write_byte(addr) != 0) ||
- 	    (sw_i2c_write_byte(reg) != 0) ||
- 	    (sw_i2c_write_byte(data) != 0)) {
- 		ret = -1;
- 	}
- 
- 	/* Stop i2c and release the bus */
- 	sw_i2c_stop();
- 
- 	return ret;
- }
--- 0 ----
diff -rcNP linux-4.4.24/drivers/staging/sm750fb/ddk750_swi2c.h linux-4.4.24-baikal/drivers/staging/sm750fb/ddk750_swi2c.h
*** linux-4.4.24/drivers/staging/sm750fb/ddk750_swi2c.h	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/staging/sm750fb/ddk750_swi2c.h	1970-01-01 03:00:00.000000000 +0300
***************
*** 1,71 ****
- /*******************************************************************
- *
- *         Copyright (c) 2007 by Silicon Motion, Inc. (SMI)
- *
- *  All rights are reserved. Reproduction or in part is prohibited
- *  without the written consent of the copyright owner.
- *
- *  swi2c.h --- SM750/SM718 DDK
- *  This file contains the definitions for i2c using software
- *  implementation.
- *
- *******************************************************************/
- #ifndef _SWI2C_H_
- #define _SWI2C_H_
- 
- /* Default i2c CLK and Data GPIO. These are the default i2c pins */
- #define DEFAULT_I2C_SCL                     30
- #define DEFAULT_I2C_SDA                     31
- 
- /*
-  * This function initializes the i2c attributes and bus
-  *
-  * Parameters:
-  *      i2cClkGPIO  - The GPIO pin to be used as i2c SCL
-  *      i2cDataGPIO - The GPIO pin to be used as i2c SDA
-  *
-  * Return Value:
-  *      -1   - Fail to initialize the i2c
-  *       0   - Success
-  */
- long sm750_sw_i2c_init(
- 	unsigned char clk_gpio,
- 	unsigned char data_gpio
- );
- 
- /*
-  *  This function reads the slave device's register
-  *
-  *  Parameters:
-  *      addr   - i2c Slave device address which register
-  *                        to be read from
-  *      reg    - Slave device's register to be read
-  *
-  *  Return Value:
-  *      Register value
-  */
- unsigned char sm750_sw_i2c_read_reg(
- 	unsigned char addr,
- 	unsigned char reg
- );
- 
- /*
-  *  This function writes a value to the slave device's register
-  *
-  *  Parameters:
-  *      addr            - i2c Slave device address which register
-  *                        to be written
-  *      reg             - Slave device's register to be written
-  *      data            - Data to be written to the register
-  *
-  *  Result:
-  *          0   - Success
-  *         -1   - Fail
-  */
- long sm750_sw_i2c_write_reg(
- 	unsigned char addr,
- 	unsigned char reg,
- 	unsigned char data
- );
- 
- #endif  /* _SWI2C_H_ */
--- 0 ----
diff -rcNP linux-4.4.24/drivers/staging/sm750fb/display.c linux-4.4.24-baikal/drivers/staging/sm750fb/display.c
*** linux-4.4.24/drivers/staging/sm750fb/display.c	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/drivers/staging/sm750fb/display.c	2016-11-11 14:49:54.000000000 +0300
***************
*** 0 ****
--- 1,208 ----
+ #include "reg.h"
+ #include "help.h"
+ #include "display.h"
+ #include "power.h"
+ #include "dvi.h"
+ 
+ #define primaryWaitVerticalSync(delay) waitNextVerticalSync(0, delay)
+ 
+ static void setDisplayControl(int ctrl, int disp_state)
+ {
+     /* state != 0 means turn on both timing&plane en_bit */
+     unsigned long reg, val, reserved;
+     int cnt = 0;
+ 
+     if (!ctrl) {
+ 	reg = PANEL_DISPLAY_CTRL;
+ 	reserved = PANEL_DISPLAY_CTRL_RESERVED_MASK;
+     } else {
+ 	reg = CRT_DISPLAY_CTRL;
+ 	reserved = CRT_DISPLAY_CTRL_RESERVED_MASK;
+     }
+ 
+     val = PEEK32(reg);
+     if (disp_state) {
+ 	/*
+ 	 * Timing should be enabled first before enabling the
+ 	 * plane because changing at the same time does not
+ 	 * guarantee that the plane will also enabled or
+ 	 * disabled.
+ 	 */
+ 	val |= DISPLAY_CTRL_TIMING;
+ 	POKE32(reg, val);
+ 
+ 	val |= DISPLAY_CTRL_PLANE;
+ 
+ 	/*
+ 	 * Somehow the register value on the plane is not set
+ 	 * until a few delay. Need to write and read it a
+ 	 * couple times
+ 	 */
+ 	do {
+ 		cnt++;
+ 		POKE32(reg, val);
+ 	} while ((PEEK32(reg)&~reserved) != (val&~reserved));
+ 	pr_info("Set Plane enbit:after tried %d times\n", cnt);
+     } else {
+ 	/*
+ 	 * When turning off, there is no rule on the
+ 	 * programming sequence since whenever the clock is
+ 	 * off, then it does not matter whether the plane is
+ 	 * enabled or disabled.  Note: Modifying the plane bit
+ 	 * will take effect on the next vertical sync. Need to
+ 	 * find out if it is necessary to wait for 1 vsync
+ 	 * before modifying the timing enable bit.
+ 	 */
+ 	val &= ~DISPLAY_CTRL_PLANE;
+ 	POKE32(reg, val);
+ 
+ 	val &= ~DISPLAY_CTRL_TIMING;
+ 	POKE32(reg, val);
+     }
+ }
+ 
+ static void waitNextVerticalSync(int ctrl, int delay) {
+     unsigned int status;
+ 
+     if (!ctrl) {
+ 	/* primary controller */
+ 
+ 	/* Do not wait when the Primary PLL is off or display control is already off. This will prevent the software to wait forever. */
+ 	if (!(PEEK32(PANEL_PLL_CTRL)&PLL_CTRL_POWER) || !(PEEK32(PANEL_DISPLAY_CTRL)&DISPLAY_CTRL_TIMING)) {
+ 	    return;
+ 	}
+ 
+ 	while (delay-- > 0) {
+ 	    /* Wait for end of vsync. */
+ 	    do {
+ 		status = PEEK32(SYSTEM_CTRL);
+ 	    } while (status&SYSTEM_CTRL_PANEL_VSYNC_ACTIVE);
+ 
+ 	    /* Wait for start of vsync. */
+ 	    do {
+ 		status = PEEK32(SYSTEM_CTRL);
+ 	    } while (!(status&SYSTEM_CTRL_PANEL_VSYNC_ACTIVE));
+ 	}
+ 
+     } else {
+ 
+ 	/* Do not wait when the Primary PLL is off or display control is already off. This will prevent the software to wait forever. */
+ 	if (!(PEEK32(CRT_PLL_CTRL)&PLL_CTRL_POWER) || !(PEEK32(CRT_DISPLAY_CTRL)&DISPLAY_CTRL_TIMING)) {
+ 	    return;
+ 	}
+ 
+ 	while (delay-- > 0) {
+ 	    /* Wait for end of vsync. */
+ 	    do {
+ 		status = PEEK32(SYSTEM_CTRL);
+ 	    } while (status&SYSTEM_CTRL_PANEL_VSYNC_ACTIVE);
+ 
+ 	    /* Wait for start of vsync. */
+ 	    do {
+ 		status = PEEK32(SYSTEM_CTRL);
+ 	    } while (!(status&SYSTEM_CTRL_PANEL_VSYNC_ACTIVE));
+ 	}
+     }
+ }
+ 
+ static void swPanelPowerSequence(int disp, int delay)
+ {
+     unsigned int reg;
+ 
+     /* disp should be 1 to open sequence */
+     reg = PEEK32(PANEL_DISPLAY_CTRL);
+     reg |= (disp?PANEL_DISPLAY_CTRL_FPEN:0);
+     POKE32(PANEL_DISPLAY_CTRL, reg);
+     primaryWaitVerticalSync(delay);
+ 
+     reg = PEEK32(PANEL_DISPLAY_CTRL);
+     reg |= (disp?PANEL_DISPLAY_CTRL_DATA:0);
+     POKE32(PANEL_DISPLAY_CTRL, reg);
+     primaryWaitVerticalSync(delay);
+ 
+     reg = PEEK32(PANEL_DISPLAY_CTRL);
+     reg |= (disp?PANEL_DISPLAY_CTRL_VBIASEN:0);
+     POKE32(PANEL_DISPLAY_CTRL, reg);
+     primaryWaitVerticalSync(delay);
+ 
+     reg = PEEK32(PANEL_DISPLAY_CTRL);
+     reg |= (disp?PANEL_DISPLAY_CTRL_FPEN:0);
+     POKE32(PANEL_DISPLAY_CTRL, reg);
+     primaryWaitVerticalSync(delay);
+ 
+     reg = PEEK32(PANEL_DISPLAY_CTRL);
+     reg |= (disp?PANEL_DISPLAY_CTRL_FPVDDEN:0);
+     //reg = FIELD_VALUE(reg, PANEL_DISPLAY_CTRL, FPVDDEN, disp);
+     POKE32(PANEL_DISPLAY_CTRL, reg);
+     primaryWaitVerticalSync(delay);
+ 
+ //ddk750_reg.h defines do not match the sm750 documentation, these defines are following the documentation.
+ #define BACKLIGHT_PIN 17
+ #define DOC_GPIO_DATA      0x010000
+ #define DOC_GPIO_DATA_HIGH 0x010004
+ #define DOC_GPIO_DIRECTION 0x010008
+ 
+    reg = PEEK32(DOC_GPIO_DIRECTION);
+    reg |= (1<<BACKLIGHT_PIN);
+    POKE32(DOC_GPIO_DIRECTION, reg);
+ 
+    reg = PEEK32(DOC_GPIO_DATA_HIGH);
+    reg |= (1<<BACKLIGHT_PIN);
+    POKE32(DOC_GPIO_DATA_HIGH, reg);
+ 
+    reg = PEEK32(DOC_GPIO_DATA);
+    reg |= (1<<BACKLIGHT_PIN);
+    POKE32(DOC_GPIO_DATA, reg);
+ }
+ 
+ void setLogicalDispOut(disp_output_t output)
+ {
+     unsigned int reg;
+ 
+     if (output&PNL_2_USAGE) {
+ 	/* set panel path controller select */
+ 	reg = PEEK32(PANEL_DISPLAY_CTRL);
+ 	reg &= ~PANEL_DISPLAY_CTRL_SELECT_MASK;
+ 	reg |= (((output&PNL_2_MASK)>>PNL_2_OFFSET)<<PANEL_DISPLAY_CTRL_SELECT_SHIFT);
+ 	POKE32(PANEL_DISPLAY_CTRL, reg);
+     }
+ 
+     if (output&CRT_2_USAGE) {
+ 	/* set crt path controller select */
+ 	reg = PEEK32(CRT_DISPLAY_CTRL);
+ 	reg &= ~CRT_DISPLAY_CTRL_SELECT_MASK;
+ 	reg |= (((output&CRT_2_MASK)>>CRT_2_OFFSET)<<CRT_DISPLAY_CTRL_SELECT_SHIFT);
+ 	/*se blank off */
+ 	reg &= ~CRT_DISPLAY_CTRL_BLANK;
+ 	POKE32(CRT_DISPLAY_CTRL, reg);
+ 
+     }
+ 
+     if (output&PRI_TP_USAGE) {
+ 	/* set primary timing and plane en_bit */
+ 	setDisplayControl(0, (output&PRI_TP_MASK)>>PRI_TP_OFFSET);
+     }
+ 
+     if (output&SEC_TP_USAGE) {
+ 	/* set secondary timing and plane en_bit*/
+ 	setDisplayControl(1, (output&SEC_TP_MASK)>>SEC_TP_OFFSET);
+     }
+ 
+     if (output&PNL_SEQ_USAGE) {
+ 	/* set  panel sequence */
+ 	swPanelPowerSequence((output&PNL_SEQ_MASK)>>PNL_SEQ_OFFSET, 4);
+     }
+ 
+     if (output&DAC_USAGE)
+ 	setDAC((output&DAC_MASK)>>DAC_OFFSET);
+ 
+     if (output&DPMS_USAGE)
+ 	setDPMS((output&DPMS_MASK)>>DPMS_OFFSET);
+ }
+ 
+ /*#ifdef USE_DVICHIP
+ long initDisplay() {
+     if ((dviInit(1, 1, 0, 1, 1, 1, 7, 1, 1, 4) != 0) && (dviGetVendorID() != 0x0000) && (dviGetDeviceID() != 0x0000)) return -1;
+     return 0;
+ }
+ #endif*/
diff -rcNP linux-4.4.24/drivers/staging/sm750fb/display.h linux-4.4.24-baikal/drivers/staging/sm750fb/display.h
*** linux-4.4.24/drivers/staging/sm750fb/display.h	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/drivers/staging/sm750fb/display.h	2016-11-11 14:49:54.000000000 +0300
***************
*** 0 ****
--- 1,103 ----
+ #ifndef DISPLAY_H__
+ #define DISPLAY_H__
+ 
+ /* panel path select
+ 	80000[29:28]
+ */
+ 
+ #define PNL_2_OFFSET 0
+ #define PNL_2_MASK (3<<PNL_2_OFFSET)
+ #define PNL_2_USAGE	(PNL_2_MASK<<16)
+ #define PNL_2_PRI	((0<<PNL_2_OFFSET)|PNL_2_USAGE)
+ #define PNL_2_SEC	((2<<PNL_2_OFFSET)|PNL_2_USAGE)
+ 
+ 
+ /* primary timing&plane enable bit
+ 	1: 80000[8]&80000[2] on
+ 	0: both off
+ */
+ #define PRI_TP_OFFSET 4
+ #define PRI_TP_MASK BIT(PRI_TP_OFFSET)
+ #define PRI_TP_USAGE (PRI_TP_MASK<<16)
+ #define PRI_TP_ON ((0x1<<PRI_TP_OFFSET)|PRI_TP_USAGE)
+ #define PRI_TP_OFF ((0x0<<PRI_TP_OFFSET)|PRI_TP_USAGE)
+ 
+ 
+ /* panel sequency status
+ 	80000[27:24]
+ */
+ #define PNL_SEQ_OFFSET 6
+ #define PNL_SEQ_MASK BIT(PNL_SEQ_OFFSET)
+ #define PNL_SEQ_USAGE (PNL_SEQ_MASK<<16)
+ #define PNL_SEQ_ON (BIT(PNL_SEQ_OFFSET)|PNL_SEQ_USAGE)
+ #define PNL_SEQ_OFF ((0<<PNL_SEQ_OFFSET)|PNL_SEQ_USAGE)
+ 
+ /* dual digital output
+ 	80000[19]
+ */
+ #define DUAL_TFT_OFFSET 8
+ #define DUAL_TFT_MASK BIT(DUAL_TFT_OFFSET)
+ #define DUAL_TFT_USAGE (DUAL_TFT_MASK<<16)
+ #define DUAL_TFT_ON (BIT(DUAL_TFT_OFFSET)|DUAL_TFT_USAGE)
+ #define DUAL_TFT_OFF ((0<<DUAL_TFT_OFFSET)|DUAL_TFT_USAGE)
+ 
+ /* secondary timing&plane enable bit
+ 	1:80200[8]&80200[2] on
+ 	0: both off
+ */
+ #define SEC_TP_OFFSET 5
+ #define SEC_TP_MASK BIT(SEC_TP_OFFSET)
+ #define SEC_TP_USAGE (SEC_TP_MASK<<16)
+ #define SEC_TP_ON  ((0x1<<SEC_TP_OFFSET)|SEC_TP_USAGE)
+ #define SEC_TP_OFF ((0x0<<SEC_TP_OFFSET)|SEC_TP_USAGE)
+ 
+ /* crt path select
+ 	80200[19:18]
+ */
+ #define CRT_2_OFFSET 2
+ #define CRT_2_MASK (3<<CRT_2_OFFSET)
+ #define CRT_2_USAGE (CRT_2_MASK<<16)
+ #define CRT_2_PRI ((0x0<<CRT_2_OFFSET)|CRT_2_USAGE)
+ #define CRT_2_SEC ((0x2<<CRT_2_OFFSET)|CRT_2_USAGE)
+ 
+ 
+ /* DAC affect both DVI and DSUB
+ 	4[20]
+ */
+ #define DAC_OFFSET 7
+ #define DAC_MASK BIT(DAC_OFFSET)
+ #define DAC_USAGE (DAC_MASK<<16)
+ #define DAC_ON ((0x0<<DAC_OFFSET)|DAC_USAGE)
+ #define DAC_OFF ((0x1<<DAC_OFFSET)|DAC_USAGE)
+ 
+ /* DPMS only affect D-SUB head
+ 	0[31:30]
+ */
+ #define DPMS_OFFSET 9
+ #define DPMS_MASK (3<<DPMS_OFFSET)
+ #define DPMS_USAGE (DPMS_MASK<<16)
+ #define DPMS_OFF ((3<<DPMS_OFFSET)|DPMS_USAGE)
+ #define DPMS_ON ((0<<DPMS_OFFSET)|DPMS_USAGE)
+ 
+ 
+ 
+ /*
+ 	LCD1 means panel path TFT1&panel path DVI (so enable DAC)
+ 	CRT means crt path DSUB
+ */
+ typedef enum _disp_output_t {
+     do_LCD1_PRI = PNL_2_PRI|PRI_TP_ON|PNL_SEQ_ON|DAC_ON,
+     do_LCD1_SEC = PNL_2_SEC|SEC_TP_ON|PNL_SEQ_ON|DAC_ON,
+     do_LCD2_PRI = CRT_2_PRI|PRI_TP_ON|DUAL_TFT_ON,
+     do_LCD2_SEC = CRT_2_SEC|SEC_TP_ON|DUAL_TFT_ON,
+     /*
+     do_DSUB_PRI = CRT_2_PRI|PRI_TP_ON|DPMS_ON|DAC_ON,
+     do_DSUB_SEC = CRT_2_SEC|SEC_TP_ON|DPMS_ON|DAC_ON,
+     */
+     do_CRT_PRI = CRT_2_PRI|PRI_TP_ON|DPMS_ON|DAC_ON,
+     do_CRT_SEC = CRT_2_SEC|SEC_TP_ON|DPMS_ON|DAC_ON,
+ } disp_output_t;
+ 
+ void setLogicalDispOut(disp_output_t);
+ 
+ #endif
diff -rcNP linux-4.4.24/drivers/staging/sm750fb/drv.c linux-4.4.24-baikal/drivers/staging/sm750fb/drv.c
*** linux-4.4.24/drivers/staging/sm750fb/drv.c	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/drivers/staging/sm750fb/drv.c	2016-11-11 14:49:54.000000000 +0300
***************
*** 0 ****
--- 1,1114 ----
+ #include <linux/kernel.h>
+ #include <linux/module.h>
+ #include <linux/errno.h>
+ #include <linux/string.h>
+ #include <linux/mm.h>
+ #include <linux/slab.h>
+ #include <linux/delay.h>
+ #include <linux/fb.h>
+ #include <linux/ioport.h>
+ #include <linux/init.h>
+ #include <linux/pci.h>
+ #include <linux/mm_types.h>
+ #include <linux/vmalloc.h>
+ #include <linux/pagemap.h>
+ #include <linux/screen_info.h>
+ #include <linux/console.h>
+ #include <asm/fb.h>
+ #include "drv.h"
+ #include "accel.h"
+ #include "cursor.h"
+ 
+ /*
+  * #ifdef __BIG_ENDIAN
+  * ssize_t lynxfb_write(struct fb_info *info, const char __user *buf, size_t count, loff_t *ppos);
+  * ssize_t lynxfb_read(struct fb_info *info, char __user *buf, size_t count, loff_t *ppos);
+  * #endif
+  */
+ 
+ /* common var for all device */
+ static int g_hwcursor = 1;
+ static int g_noaccel;
+ static int g_nomtrr;
+ static const char *g_fbmode[] = {NULL, NULL};
+ static const char *g_def_fbmode = "800x600-16@60";
+ static char *g_settings;
+ static int g_dualview;
+ static char *g_option;
+ 
+ static const struct fb_videomode lynx750_ext[] = {
+ 	/*	1024x600-60 VESA	[1.71:1] */
+ 	{NULL,  60, 1024, 600, 20423, 144,  40, 18, 1, 104, 3, FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED},
+ 	/*	1024x600-70 VESA */
+ 	{NULL,  70, 1024, 600, 17211, 152,  48, 21, 1, 104, 3, FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED},
+ 	/*	1024x600-75 VESA */
+ 	{NULL,  75, 1024, 600, 15822, 160,  56, 23, 1, 104, 3, FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED},
+ 	/*	1024x600-85 VESA */
+ 	{NULL,  85, 1024, 600, 13730, 168,  56, 26, 1, 112, 3, FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED},
+ 	/*	720x480	*/
+ 	{NULL, 60,  720,  480,  37427, 88,   16, 13, 1,   72,  3, FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED},
+ 	/*	1280x720		[1.78:1]	*/
+ 	{NULL, 60,  1280,  720,  13426, 162, 86, 22, 1,  136, 3, FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED},
+ 	/*	1280x768@60 */
+ 	{NULL, 60, 1280, 768, 12579, 192, 64, 20, 3, 128, 7, FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED},
+ 	/*	1360 x 768	[1.77083:1]	*/
+ 	{NULL,  60, 1360, 768, 11804, 208,  64, 23, 1, 144, 3, FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED},
+ 	/*	1368 x 768      [1.78:1]	*/
+ 	{NULL, 60,  1368,  768,  11647, 216, 72, 23, 1,  144, 3, FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED},
+ 	/*	1440 x 900		[16:10]	*/
+ 	{NULL, 60, 1440, 900, 9392, 232, 80, 28, 1, 152, 3, FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED},
+ 	/*	1440x960		[15:10]	*/
+ 	{NULL, 60, 1440, 960, 8733, 240, 88, 30, 1, 152, 3, FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED},
+ 	/*	1920x1080	[16:9]	*/
+ 	{NULL, 60, 1920, 1080, 6734, 148, 88, 41, 1, 44, 3, FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED},
+ };
+ 
+ 
+ static int lynxfb_cursor(struct fb_info *info, struct fb_cursor *fbcursor) {	/* no hardware cursor supported under version 2.6.10, kernel bug */
+ 	struct lynxfb_par *par;
+ 	struct lynxfb_crtc *crtc;
+ 	struct lynx_cursor *cursor;
+ 
+ 	par = info->par;
+ 	crtc = &par->crtc;
+ 	cursor = &crtc->cursor;
+ 
+ 	if (fbcursor->image.width > cursor->maxW || fbcursor->image.height > cursor->maxH || fbcursor->image.depth > 1) {
+ 		return -ENXIO;
+ 	}
+ 
+ 	hw_cursor_disable(cursor);
+ 	if (fbcursor->set&FB_CUR_SETSIZE)
+ 		hw_cursor_setSize(cursor, fbcursor->image.width, fbcursor->image.height);
+ 
+ 	if (fbcursor->set&FB_CUR_SETPOS)
+ 		hw_cursor_setPos(cursor, fbcursor->image.dx - info->var.xoffset, fbcursor->image.dy - info->var.yoffset);
+ 
+ 	if (fbcursor->set&FB_CUR_SETCMAP) {
+ 		/* get the 16bit color of kernel means */
+ 		u16 fg, bg;
+ 
+ 		fg = ((info->cmap.red[fbcursor->image.fg_color]&0xf800))|((info->cmap.green[fbcursor->image.fg_color]&0xfc00)>>5)|((info->cmap.blue[fbcursor->image.fg_color]&0xf800)>>11);
+ 		bg = ((info->cmap.red[fbcursor->image.bg_color]&0xf800))|((info->cmap.green[fbcursor->image.bg_color]&0xfc00)>>5)|((info->cmap.blue[fbcursor->image.bg_color]&0xf800)>>11);
+ 
+ 		hw_cursor_setColor(cursor, fg, bg);
+ 	}
+ 
+ 	if (fbcursor->set&(FB_CUR_SETSHAPE|FB_CUR_SETIMAGE)) {
+ 		hw_cursor_setData(cursor, fbcursor->rop, fbcursor->image.data, fbcursor->mask);
+ 	}
+ 
+ 	if (fbcursor->enable)
+ 		hw_cursor_enable(cursor);
+ 
+ 	return 0;
+ }
+ 
+ static void lynxfb_fillrect(struct fb_info *info, const struct fb_fillrect *region)
+ {
+ 	struct lynxfb_par *par;
+ 	struct sm750_dev *sm750_dev;
+ 	unsigned int base, pitch, Bpp, rop;
+ 	u32 color;
+ 
+ 	if (info->state != FBINFO_STATE_RUNNING)
+ 		return;
+ 
+ 	par = info->par;
+ 	sm750_dev = par->dev;
+ 
+ 	/*
+ 	 * each time 2d function begin to work,below three variable always need
+ 	 * be set, seems we can put them together in some place
+ 	 */
+ 	base = par->crtc.oScreen;
+ 	pitch = info->fix.line_length;
+ 	Bpp = info->var.bits_per_pixel>>3;
+ 
+ 	color = (Bpp == 1)?region->color:((u32 *)info->pseudo_palette)[region->color];
+ 	rop = (region->rop != ROP_COPY)?HW_ROP2_XOR:HW_ROP2_COPY;
+ 
+ 	/*
+ 	 * If not use spin_lock,system will die if user load driver
+ 	 * and immediately unload driver frequently (dual)
+ 	 */
+ 	if (sm750_dev->fb_count > 1)
+ 		spin_lock(&sm750_dev->slock);
+ 
+ 	sm750_dev->accel.de_fillrect(&sm750_dev->accel, base, pitch, Bpp, region->dx, region->dy, region->width, region->height, color, rop);
+ 	if (sm750_dev->fb_count > 1)
+ 		spin_unlock(&sm750_dev->slock);
+ }
+ 
+ static void lynxfb_copyarea(struct fb_info *info, const struct fb_copyarea *region)
+ {
+ 	struct lynxfb_par *par;
+ 	struct sm750_dev *sm750_dev;
+ 	unsigned int base, pitch, Bpp;
+ 
+ 	par = info->par;
+ 	sm750_dev = par->dev;
+ 
+ 	/*
+ 	 * each time 2d function begin to work,below three variable always need
+ 	 * be set, seems we can put them together in some place
+ 	 */
+ 	base = par->crtc.oScreen;
+ 	pitch = info->fix.line_length;
+ 	Bpp = info->var.bits_per_pixel>>3;
+ 
+ 	/*
+ 	 * If not use spin_lock, system will die if user load driver
+ 	 * and immediately unload driver frequently (dual)
+ 	 */
+ 	if (sm750_dev->fb_count > 1)
+ 		spin_lock(&sm750_dev->slock);
+ 
+ 	sm750_dev->accel.de_copyarea(&sm750_dev->accel, base, pitch, region->sx, region->sy, base, pitch, Bpp, region->dx, region->dy, region->width, region->height, HW_ROP2_COPY);
+ 	if (sm750_dev->fb_count > 1)
+ 		spin_unlock(&sm750_dev->slock);
+ }
+ 
+ static void lynxfb_imageblit(struct fb_info *info, const struct fb_image *image)
+ {
+ 	unsigned int base, pitch, Bpp;
+ 	unsigned int fgcol, bgcol;
+ 	struct lynxfb_par *par;
+ 	struct sm750_dev *sm750_dev;
+ 
+ 	par = info->par;
+ 	sm750_dev = par->dev;
+ 	/* each time 2d function begin to work, below three variable always need be set, seems we can put them together in some place */
+ 	base = par->crtc.oScreen;
+ 	pitch = info->fix.line_length;
+ 	Bpp = info->var.bits_per_pixel>>3;
+ 
+ 	/* TODO: Implement hardware acceleration for image->depth > 1 */
+ 	if (image->depth != 1) {
+ 		cfb_imageblit(info, image);
+ 		return;
+ 	}
+ 
+ 	if (info->fix.visual == FB_VISUAL_TRUECOLOR || info->fix.visual == FB_VISUAL_DIRECTCOLOR) {
+ 		fgcol = ((u32 *)info->pseudo_palette)[image->fg_color];
+ 		bgcol = ((u32 *)info->pseudo_palette)[image->bg_color];
+ 	} else {
+ 		fgcol = image->fg_color;
+ 		bgcol = image->bg_color;
+ 	}
+ 
+ 	/* If not use spin_lock, system will die if user load driver and immediately unload driver frequently (dual) */
+ 	if (sm750_dev->fb_count > 1)
+ 		spin_lock(&sm750_dev->slock);
+ 
+ 	sm750_dev->accel.de_imageblit(&sm750_dev->accel, image->data, image->width>>3, 0, base, pitch, Bpp, image->dx, image->dy, image->width, image->height, fgcol, bgcol, HW_ROP2_COPY);
+ 	if (sm750_dev->fb_count > 1)
+ 		spin_unlock(&sm750_dev->slock);
+ }
+ 
+ static int lynxfb_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)
+ {
+ 	struct lynxfb_par *par;
+ 	struct lynxfb_crtc *crtc;
+ 
+ 	if (!info)
+ 		return -EINVAL;
+ 
+ 	par = info->par;
+ 	crtc = &par->crtc;
+ 	return hw_pan_display(crtc, var, info);
+ }
+ 
+ static int lynxfb_set_par(struct fb_info *info)
+ {
+ 	struct lynxfb_par *par;
+ 	struct lynxfb_crtc *crtc;
+ 	struct lynxfb_output *output;
+ 	struct fb_var_screeninfo *var;
+ 	struct fb_fix_screeninfo *fix;
+ 	int ret;
+ 	unsigned int line_length;
+ 
+ 	if (!info)
+ 		return -EINVAL;
+ 
+ 	ret = 0;
+ 	par = info->par;
+ 	crtc = &par->crtc;
+ 	output = &par->output;
+ 	var = &info->var;
+ 	fix = &info->fix;
+ 
+ 	/* fix structure is not so FIX ... */
+ 	line_length = var->xres_virtual * var->bits_per_pixel/8;
+ 	line_length = ALIGN(line_length, crtc->line_pad);
+ 	fix->line_length = line_length;
+ 	pr_info("fix->line_length = %d\n", fix->line_length);
+ 
+ 	/*
+ 	 * var->red,green,blue,transp are need to be set by driver
+ 	 * and these data should be set before setcolreg routine
+ 	 */
+ 
+ 	switch (var->bits_per_pixel) {
+ 	case 8:
+ 		fix->visual = FB_VISUAL_PSEUDOCOLOR;
+ 		var->red.offset = 0;
+ 		var->red.length = 8;
+ 		var->green.offset = 0;
+ 		var->green.length = 8;
+ 		var->blue.offset = 0;
+ 		var->blue.length = 8;
+ 		var->transp.length = 0;
+ 		var->transp.offset = 0;
+ 		break;
+ 	case 16:
+ 		var->red.offset = 11;
+ 		var->red.length = 5;
+ 		var->green.offset = 5;
+ 		var->green.length = 6;
+ 		var->blue.offset = 0;
+ 		var->blue.length = 5;
+ 		var->transp.length = 0;
+ 		var->transp.offset = 0;
+ 		fix->visual = FB_VISUAL_TRUECOLOR;
+ 		break;
+ 	case 24:
+ 	case 32:
+ 		var->red.offset = 16;
+ 		var->red.length = 8;
+ 		var->green.offset = 8;
+ 		var->green.length = 8;
+ 		var->blue.offset = 0;
+ 		var->blue.length = 8;
+ 		fix->visual = FB_VISUAL_TRUECOLOR;
+ 		break;
+ 	default:
+ 		ret = -EINVAL;
+ 		break;
+ 	}
+ 	var->height = var->width = -1;
+ 	var->accel_flags = 0;/*FB_ACCELF_TEXT;*/
+ 
+ 	if (ret) {
+ 		pr_err("pixel bpp format not satisfied\n.");
+ 		return ret;
+ 	}
+ 	ret = hw_crtc_setMode(crtc, var, fix);
+ 	if (!ret)
+ 		ret = hw_output_setMode(output, var, fix);
+ 	return ret;
+ }
+ 
+ #ifdef CONFIG_PM
+ static int lynxfb_suspend(struct pci_dev *pdev, pm_message_t mesg)
+ {
+ 	struct fb_info *info;
+ 	struct sm750_dev *sm750_dev;
+ 	int ret;
+ 
+ 	if (mesg.event == pdev->dev.power.power_state.event)
+ 		return 0;
+ 
+ 	ret = 0;
+ 	sm750_dev = pci_get_drvdata(pdev);
+ 	switch (mesg.event) {
+ 	case PM_EVENT_FREEZE:
+ 	case PM_EVENT_PRETHAW:
+ 		pdev->dev.power.power_state = mesg;
+ 		return 0;
+ 	}
+ 
+ 	console_lock();
+ 	if (mesg.event&PM_EVENT_SLEEP) {
+ 		info = sm750_dev->fbinfo[0];
+ 		if (info)
+ 			/* 1 means do suspend */
+ 			fb_set_suspend(info, 1);
+ 		info = sm750_dev->fbinfo[1];
+ 		if (info)
+ 			/* 1 means do suspend */
+ 			fb_set_suspend(info, 1);
+ 
+ 		ret = pci_save_state(pdev);
+ 		if (ret) {
+ 			dev_err(&pdev->dev, "error:%d occurred in pci_save_state\n", ret);
+ 			return ret;
+ 		}
+ 
+ 		ret = pci_set_power_state(pdev, pci_choose_state(pdev, mesg));
+ 		if (ret) {
+ 			dev_err(&pdev->dev, "error:%d occurred in pci_set_power_state\n", ret);
+ 			return ret;
+ 		}
+ 	}
+ 
+ 	pdev->dev.power.power_state = mesg;
+ 	console_unlock();
+ 	return ret;
+ }
+ 
+ static int lynxfb_resume(struct pci_dev *pdev)
+ {
+     struct fb_info *info;
+     struct sm750_dev *sm750_dev;
+ 
+     struct lynxfb_par *par;
+     struct lynxfb_crtc *crtc;
+     struct lynx_cursor *cursor;
+ 
+     int ret;
+ 
+     ret = 0;
+     sm750_dev = pci_get_drvdata(pdev);
+ 
+     console_lock();
+ 
+     ret = pci_set_power_state(pdev, PCI_D0);
+     if (ret) {
+ 	dev_err(&pdev->dev, "error:%d occurred in pci_set_power_state\n", ret);
+ 	return ret;
+     }
+ 
+     if (pdev->dev.power.power_state.event != PM_EVENT_FREEZE) {
+ 	pci_restore_state(pdev);
+ 	ret = pci_enable_device(pdev);
+ 	if (ret) {
+ 	    dev_err(&pdev->dev, "error:%d occurred in pci_enable_device\n", ret);
+ 	    return ret;
+ 	}
+ 	pci_set_master(pdev);
+     }
+ 
+     hw_init_chip(sm750_dev, pdev);
+ 
+     info = sm750_dev->fbinfo[0];
+ 
+     if (info) {
+ 	par = info->par;
+ 	crtc = &par->crtc;
+ 	cursor = &crtc->cursor;
+ 	memset_io(cursor->vstart, 0x0, cursor->size);
+ 	memset_io(crtc->vScreen, 0x0, crtc->vidmem_size);
+ 	lynxfb_set_par(info);
+ 	fb_set_suspend(info, 0);
+     }
+ 
+     info = sm750_dev->fbinfo[1];
+ 
+     if (info) {
+ 	par = info->par;
+ 	crtc = &par->crtc;
+ 	cursor = &crtc->cursor;
+ 	memset_io(cursor->vstart, 0x0, cursor->size);
+ 	memset_io(crtc->vScreen, 0x0, crtc->vidmem_size);
+ 	lynxfb_set_par(info);
+ 	fb_set_suspend(info, 0);
+     }
+ 
+     pdev->dev.power.power_state.event = PM_EVENT_RESUME;
+     console_unlock();
+     return ret;
+ }
+ #endif
+ 
+ static int lynxfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
+ {
+ 	struct lynxfb_par *par;
+ 	struct lynxfb_crtc *crtc;
+ 	struct lynxfb_output *output;
+ 	resource_size_t request;
+ 
+ 	par = info->par;
+ 	crtc = &par->crtc;
+ 	output = &par->output;
+ 
+ 	pr_info("check var:%dx%d-%d\n", var->xres, var->yres, var->bits_per_pixel);
+ 
+ 	switch (var->bits_per_pixel) {
+ 	case 8:
+ 		info->fix.visual = FB_VISUAL_PSEUDOCOLOR;
+ 		var->red.offset = 0;
+ 		var->red.length = 8;
+ 		var->green.offset = 0;
+ 		var->green.length = 8;
+ 		var->blue.offset = 0;
+ 		var->blue.length = 8;
+ 		var->transp.length = 0;
+ 		var->transp.offset = 0;
+ 		break;
+ 	case 16:
+ 		var->red.offset = 11;
+ 		var->red.length = 5;
+ 		var->green.offset = 5;
+ 		var->green.length = 6;
+ 		var->blue.offset = 0;
+ 		var->blue.length = 5;
+ 		var->transp.length = 0;
+ 		var->transp.offset = 0;
+ 		info->fix.visual = FB_VISUAL_TRUECOLOR;
+ 		break;
+ 	case 24:
+ 	case 32:
+ 		var->red.offset = 16;
+ 		var->red.length = 8;
+ 		var->green.offset = 8;
+ 		var->green.length = 8;
+ 		var->blue.offset = 0;
+ 		var->blue.length = 8;
+ 		info->fix.visual = FB_VISUAL_TRUECOLOR;
+ 		break;
+ 	default:
+ 		pr_err("bpp %d not supported\n", var->bits_per_pixel);
+ 		return -EINVAL;
+ 	}
+ 	var->height = var->width = -1;
+ 	var->accel_flags = 0;/* FB_ACCELF_TEXT; */
+ 
+ 	/* check if current fb's video memory big enought to hold the onscreen*/
+ 	request = var->xres_virtual * (var->bits_per_pixel>>3);
+ 	/* defaulty crtc->channel go with par->index */
+ 
+ 	request = ALIGN(request, crtc->line_pad);
+ 	request = request * var->yres_virtual;
+ 	if (crtc->vidmem_size < request) {
+ 		pr_err("not enough video memory for mode\n");
+ 		return -ENOMEM;
+ 	}
+ 
+ 	return hw_crtc_checkMode(crtc, var);
+ }
+ 
+ static inline unsigned int chan_to_field(unsigned int chan, struct fb_bitfield *bf) { // TODO: used only in function below
+ 	chan &= 0xffff;
+ 	chan >>= 16 - bf->length;
+ 	return chan<<bf->offset;
+ }
+ static int lynxfb_setcolreg(unsigned regno, unsigned red, unsigned green, unsigned blue, unsigned transp, struct fb_info *info)
+ {
+ 	struct lynxfb_par *par;
+ 	struct lynxfb_crtc *crtc;
+ 	struct fb_var_screeninfo *var;
+ 	int ret;
+ 
+ 	par = info->par;
+ 	crtc = &par->crtc;
+ 	var = &info->var;
+ 	ret = 0;
+ 
+ 	if (regno > 256) {
+ 		pr_err("regno = %d\n", regno);
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (info->var.grayscale)
+ 		red = green = blue = (red * 77 + green * 151 + blue * 28)>>8;
+ 
+ 	if (var->bits_per_pixel == 8 && info->fix.visual == FB_VISUAL_PSEUDOCOLOR) {
+ 		red >>= 8;
+ 		green >>= 8;
+ 		blue >>= 8;
+ 		ret = hw_setColReg(crtc, regno, red, green, blue);
+ 		goto exit;
+ 	}
+ 
+ 	if (info->fix.visual == FB_VISUAL_TRUECOLOR && regno < 256) {
+ 		u32 val;
+ 
+ 		if (var->bits_per_pixel == 16 || var->bits_per_pixel == 32 || var->bits_per_pixel == 24) {
+ 			val = chan_to_field(red, &var->red);
+ 			val |= chan_to_field(green, &var->green);
+ 			val |= chan_to_field(blue, &var->blue);
+ 			par->pseudo_palette[regno] = val;
+ 			goto exit;
+ 		}
+ 	}
+ 
+ 	ret = -EINVAL;
+ 
+ exit:
+ 	return ret;
+ }
+ 
+ static int lynxfb_blank(int blank, struct fb_info *info)
+ {
+     struct lynxfb_par *par;
+     struct lynxfb_output *output;
+ 
+     par = info->par;
+     output = &par->output;
+     return output->proc_setBLANK(output, blank);
+ }
+ 
+ static int sm750fb_set_drv(struct lynxfb_par *par)
+ {
+ 	int ret;
+ 	struct sm750_dev *sm750_dev;
+ 	struct lynxfb_output *output;
+ 	struct lynxfb_crtc *crtc;
+ 
+ 	ret = 0;
+ 
+ 	sm750_dev = par->dev;
+ 	output = &par->output;
+ 	crtc = &par->crtc;
+ 
+ 	crtc->vidmem_size = sm750_dev->vidmem_size;
+ 	if (sm750_dev->fb_count > 1)
+ 		crtc->vidmem_size >>= 1;
+ 
+ 	/* setup crtc and output member */
+ 	sm750_dev->hwCursor = g_hwcursor;
+ 
+ 	crtc->line_pad = 16;
+ 	crtc->xpanstep = 8;
+ 	crtc->ypanstep = 1;
+ 	crtc->ywrapstep = 0;
+ 
+ 	output->proc_setBLANK = (sm750_dev->revid == SM750LE_REVISION_ID)?hw_le_setBLANK:hw_setBLANK;
+ 	/* chip specific phase */
+ 	sm750_dev->accel.de_wait = (sm750_dev->revid == SM750LE_REVISION_ID)?hw_le_deWait:hw_deWait;
+ 	switch (sm750_dev->dataflow) {
+ 	case sm750_simul_pri:
+ 		output->paths = sm750_pnc;
+ 		crtc->channel = sm750_primary;
+ 		crtc->oScreen = 0;
+ 		crtc->vScreen = sm750_dev->pvMem;
+ 		pr_info("use simul primary mode\n");
+ 		break;
+ 	case sm750_simul_sec:
+ 		output->paths = sm750_pnc;
+ 		crtc->channel = sm750_secondary;
+ 		crtc->oScreen = 0;
+ 		crtc->vScreen = sm750_dev->pvMem;
+ 		break;
+ 	case sm750_dual_normal:
+ 		if (par->index == 0) {
+ 			output->paths = sm750_panel;
+ 			crtc->channel = sm750_primary;
+ 			crtc->oScreen = 0;
+ 			crtc->vScreen = sm750_dev->pvMem;
+ 		} else {
+ 			output->paths = sm750_crt;
+ 			crtc->channel = sm750_secondary;
+ 			/* not consider of padding stuffs for oScreen,need fix */
+ 			crtc->oScreen = (sm750_dev->vidmem_size>>1);
+ 			crtc->vScreen = sm750_dev->pvMem + crtc->oScreen;
+ 		}
+ 		break;
+ 	case sm750_dual_swap:
+ 		if (par->index == 0) {
+ 			output->paths = sm750_panel;
+ 			crtc->channel = sm750_secondary;
+ 			crtc->oScreen = 0;
+ 			crtc->vScreen = sm750_dev->pvMem;
+ 		} else {
+ 			output->paths = sm750_crt;
+ 			crtc->channel = sm750_primary;
+ 			/* not consider of padding stuffs for oScreen,need fix */
+ 			crtc->oScreen = (sm750_dev->vidmem_size>>1);
+ 			crtc->vScreen = sm750_dev->pvMem + crtc->oScreen;
+ 		}
+ 		break;
+ 	default:
+ 		ret = -EINVAL;
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ static struct fb_ops lynxfb_ops = {
+ 	.owner = THIS_MODULE,
+ 	.fb_check_var =  lynxfb_check_var,
+ 	.fb_set_par = lynxfb_set_par,
+ 	.fb_setcolreg = lynxfb_setcolreg,
+ 	.fb_blank = lynxfb_blank,
+ 	.fb_fillrect = cfb_fillrect,
+ 	.fb_imageblit = cfb_imageblit,
+ 	.fb_copyarea = cfb_copyarea,
+ 	/* cursor */
+ 	.fb_cursor = lynxfb_cursor,
+ };
+ 
+ static int lynxfb_set_fbinfo(struct fb_info *info, int index)
+ {
+ 	int i;
+ 	struct lynxfb_par *par;
+ 	struct sm750_dev *sm750_dev;
+ 	struct lynxfb_crtc *crtc;
+ 	struct lynxfb_output *output;
+ 	struct fb_var_screeninfo *var;
+ 	struct fb_fix_screeninfo *fix;
+ 
+ 	const struct fb_videomode *pdb[] = {
+ 		lynx750_ext, NULL, vesa_modes,
+ 	};
+ 	int cdb[] = {ARRAY_SIZE(lynx750_ext), 0, VESA_MODEDB_SIZE};
+ 	static const char *mdb_desc[] = {
+ 		"driver prepared modes",
+ 		"kernel prepared default modedb",
+ 		"kernel HELPERS prepared vesa_modes",
+ 	};
+ 
+ 	static const char *fixId[2] = {
+ 		"sm750_fb1", "sm750_fb2",
+ 	};
+ 
+ 	int ret, line_length;
+ 
+ 	ret = 0;
+ 	par = (struct lynxfb_par *)info->par;
+ 	sm750_dev = par->dev;
+ 	crtc = &par->crtc;
+ 	output = &par->output;
+ 	var = &info->var;
+ 	fix = &info->fix;
+ 
+ 	/* set index */
+ 	par->index = index;
+ 	output->channel = &crtc->channel;
+ 	sm750fb_set_drv(par);
+ 	lynxfb_ops.fb_pan_display = lynxfb_pan_display;
+ 
+ 	/*
+ 	 * set current cursor variable and proc pointer,
+ 	 * must be set after crtc member initialized
+ 	 */
+ 	crtc->cursor.offset = crtc->oScreen + crtc->vidmem_size - 1024;
+ 	crtc->cursor.mmio = sm750_dev->pvReg + 0x800f0 + (int)crtc->channel * 0x140;
+ 
+ 	pr_info("crtc->cursor.mmio = %p\n", crtc->cursor.mmio);
+ 	crtc->cursor.maxH = crtc->cursor.maxW = 64;
+ 	crtc->cursor.size = crtc->cursor.maxH * crtc->cursor.maxW * 2/8;
+ 	crtc->cursor.vstart = sm750_dev->pvMem + crtc->cursor.offset;
+ 
+ 	memset_io(crtc->cursor.vstart, 0, crtc->cursor.size);
+ 	if (!g_hwcursor) {
+ 		lynxfb_ops.fb_cursor = NULL;
+ 		hw_cursor_disable(&crtc->cursor);
+ 	}
+ 
+ 	/* set info->fbops, must be set before fb_find_mode */
+ 	if (!sm750_dev->accel_off) {
+ 		/* use 2d acceleration */
+ 		lynxfb_ops.fb_fillrect = lynxfb_fillrect;
+ 		lynxfb_ops.fb_copyarea = lynxfb_copyarea;
+ 		lynxfb_ops.fb_imageblit = lynxfb_imageblit;
+ 	}
+ 	info->fbops = &lynxfb_ops;
+ 
+ 	if (!g_fbmode[index]) {
+ 		g_fbmode[index] = g_def_fbmode;
+ 		if (index)
+ 			g_fbmode[index] = g_fbmode[0];
+ 	}
+ 
+ 	for (i = 0; i < 3; i++) {
+ 
+ 		ret = fb_find_mode(var, info, g_fbmode[index], pdb[i], cdb[i], NULL, 8);
+ 
+ 		if (ret == 1) {
+ 			pr_info("success! use specified mode:%s in %s\n", g_fbmode[index], mdb_desc[i]);
+ 			break;
+ 		} else if (ret == 2) {
+ 			pr_warn("use specified mode:%s in %s,with an ignored refresh rate\n", g_fbmode[index], mdb_desc[i]);
+ 			break;
+ 		} else if (ret == 3) {
+ 			pr_warn("wanna use default mode\n");
+ 			/*break;*/
+ 		} else if (ret == 4) {
+ 			pr_warn("fall back to any valid mode\n");
+ 		} else {
+ 			pr_warn("ret = %d,fb_find_mode failed,with %s\n", ret, mdb_desc[i]);
+ 		}
+ 	}
+ 
+ 	/* some member of info->var had been set by fb_find_mode */
+ 
+ 	pr_info("Member of info->var is :\n\
+ 		xres=%d\n\
+ 		yres=%d\n\
+ 		xres_virtual=%d\n\
+ 		yres_virtual=%d\n\
+ 		xoffset=%d\n\
+ 		yoffset=%d\n\
+ 		bits_per_pixel=%d\n \
+ 		...\n",
+ 		var->xres,
+ 		var->yres,
+ 		var->xres_virtual,
+ 		var->yres_virtual,
+ 		var->xoffset,
+ 		var->yoffset,
+ 		var->bits_per_pixel);
+ 
+ 	/* set par */
+ 	par->info = info;
+ 
+ 	/* set info */
+ 	line_length = ALIGN((var->xres_virtual * var->bits_per_pixel/8), crtc->line_pad);
+ 
+ 	info->pseudo_palette = &par->pseudo_palette[0];
+ 	info->screen_base = crtc->vScreen;
+ 	pr_info("screen_base vaddr = %p\n", info->screen_base);
+ 	info->screen_size = line_length * var->yres_virtual;
+ 	info->flags = FBINFO_FLAG_DEFAULT|0;
+ 
+ 	/* set info->fix */
+ 	fix->type = FB_TYPE_PACKED_PIXELS;
+ 	fix->type_aux = 0;
+ 	fix->xpanstep = crtc->xpanstep;
+ 	fix->ypanstep = crtc->ypanstep;
+ 	fix->ywrapstep = crtc->ywrapstep;
+ 	fix->accel = FB_ACCEL_SMI;
+ 
+ 	strlcpy(fix->id, fixId[index], sizeof(fix->id));
+ 
+ 	fix->smem_start = crtc->oScreen + sm750_dev->vidmem_start;
+ 	pr_info("fix->smem_start = %lx\n", fix->smem_start);
+ 	/*
+ 	 * according to mmap experiment from user space application,
+ 	 * fix->mmio_len should not larger than virtual size
+ 	 * (xres_virtual x yres_virtual x ByPP)
+ 	 * Below line maybe buggy when user mmap fb dev node and write
+ 	 * data into the bound over virtual size
+ 	 */
+ 	fix->smem_len = crtc->vidmem_size;
+ 	pr_info("fix->smem_len = %x\n", fix->smem_len);
+ 	info->screen_size = fix->smem_len;
+ 	fix->line_length = line_length;
+ 	fix->mmio_start = sm750_dev->vidreg_start;
+ 	pr_info("fix->mmio_start = %lx\n", fix->mmio_start);
+ 	fix->mmio_len = sm750_dev->vidreg_size;
+ 	pr_info("fix->mmio_len = %x\n", fix->mmio_len);
+ 	switch (var->bits_per_pixel) {
+ 	case 8:
+ 		fix->visual = FB_VISUAL_PSEUDOCOLOR;
+ 		break;
+ 	case 16:
+ 	case 32:
+ 		fix->visual = FB_VISUAL_TRUECOLOR;
+ 		break;
+ 	}
+ 
+ 	/* set var */
+ 	var->activate = FB_ACTIVATE_NOW;
+ 	var->accel_flags = 0;
+ 	var->vmode = FB_VMODE_NONINTERLACED;
+ 
+ 	pr_info("#1 show info->cmap :\nstart=%d,len=%d,red=%p,green=%p,blue=%p,transp=%p\n", info->cmap.start, info->cmap.len, info->cmap.red, info->cmap.green, info->cmap.blue, info->cmap.transp);
+ 
+ 	ret = fb_alloc_cmap(&info->cmap, 256, 0);
+ 	if (ret < 0) {
+ 		pr_err("Could not allocate memory for cmap.\n");
+ 		goto exit;
+ 	}
+ 
+ 	pr_info("#2 show info->cmap :\nstart=%d,len=%d,red=%p,green=%p,blue=%p,transp=%p\n", info->cmap.start, info->cmap.len, info->cmap.red, info->cmap.green, info->cmap.blue, info->cmap.transp);
+ 
+ exit:
+ 	lynxfb_check_var(var, info);
+ 	return ret;
+ }
+ 
+ /* chip specific g_option configuration routine */
+ static void sm750fb_setup(struct sm750_dev *sm750_dev, char *src)
+ {
+ 	char *opt;
+ 	int swap;
+ 
+ 	swap = 0;
+ 
+ 	sm750_dev->initParm.chip_clk = 0;
+ 	sm750_dev->initParm.mem_clk = 0;
+ 	sm750_dev->initParm.master_clk = 0;
+ 	sm750_dev->initParm.powerMode = 0;
+ 	sm750_dev->initParm.setAllEngOff = 0;
+ 	sm750_dev->initParm.resetMemory = 1;
+ 
+ 	/* defaultly turn g_hwcursor on for both view */
+ 	g_hwcursor = 3;
+ 
+ 	if (!src || !*src) {
+ 		pr_warn("no specific g_option.\n");
+ 		goto NO_PARAM;
+ 	}
+ 
+ 	while ((opt = strsep(&src, ":")) != NULL && *opt != 0) {
+ 		pr_info("opt=%s\n", opt);
+ 		pr_info("src=%s\n", src);
+ 
+ 		if (!strncmp(opt, "swap", strlen("swap")))
+ 			swap = 1;
+ 		else if (!strncmp(opt, "nocrt", strlen("nocrt")))
+ 			sm750_dev->nocrt = 1;
+ 		else if (!strncmp(opt, "36bit", strlen("36bit")))
+ 			sm750_dev->pnltype = sm750_doubleTFT;
+ 		else if (!strncmp(opt, "18bit", strlen("18bit")))
+ 			sm750_dev->pnltype = sm750_dualTFT;
+ 		else if (!strncmp(opt, "24bit", strlen("24bit")))
+ 			sm750_dev->pnltype = sm750_24TFT;
+ 		else if (!strncmp(opt, "nohwc0", strlen("nohwc0")))
+ 			g_hwcursor &= ~0x1;
+ 		else if (!strncmp(opt, "nohwc1", strlen("nohwc1")))
+ 			g_hwcursor &= ~0x2;
+ 		else if (!strncmp(opt, "nohwc", strlen("nohwc")))
+ 			g_hwcursor = 0;
+ 		else {
+ 			if (!g_fbmode[0]) {
+ 				g_fbmode[0] = opt;
+ 				//pr_info("find fbmode0:%s\n", g_fbmode[0]);
+ 			} else if (!g_fbmode[1]) {
+ 				g_fbmode[1] = opt;
+ 				//pr_info("find fbmode1:%s\n", g_fbmode[1]);
+ 			} else {
+ 				pr_warn("How many view you wann set?\n");
+ 			}
+ 		}
+ 	}
+ 
+ NO_PARAM:
+ 	if (sm750_dev->revid != SM750LE_REVISION_ID) {
+ 		if (sm750_dev->fb_count > 1) {
+ 			if (swap)
+ 				sm750_dev->dataflow = sm750_dual_swap;
+ 			else
+ 				sm750_dev->dataflow = sm750_dual_normal;
+ 		} else {
+ 			if (swap)
+ 				sm750_dev->dataflow = sm750_simul_sec;
+ 			else
+ 				sm750_dev->dataflow = sm750_simul_pri;
+ 		}
+ 	} else {
+ 		sm750_dev->dataflow = sm750_simul_sec;	/* SM750LE only have one crt channel */
+ 		sm750_dev->nocrt = 0;			/* sm750le do not have complex attributes */
+ 	}
+ }
+ 
+ static void sm750fb_frambuffer_release(struct sm750_dev *sm750_dev)
+ {
+ 	struct fb_info *fb_info;
+ 
+ 	while (sm750_dev->fb_count) {
+ 		fb_info = sm750_dev->fbinfo[sm750_dev->fb_count - 1];
+ 		unregister_framebuffer(fb_info);
+ 		framebuffer_release(fb_info);
+ 		sm750_dev->fb_count--;
+ 	}
+ }
+ 
+ static int sm750fb_frambuffer_alloc(struct sm750_dev *sm750_dev, int fbidx)
+ {
+ 	struct fb_info *fb_info;
+ 	struct lynxfb_par *par;
+ 	int err;
+ 
+ 	fb_info = framebuffer_alloc(sizeof(struct lynxfb_par), &sm750_dev->pdev->dev);
+ 	if (!fb_info)
+ 		return -ENOMEM;
+ 
+ 	sm750_dev->fbinfo[fbidx] = fb_info;
+ 	par = fb_info->par;
+ 	par->dev = sm750_dev;
+ 
+ 	err = lynxfb_set_fbinfo(fb_info, fbidx);
+ 	if (err)
+ 		goto release_fb;
+ 
+ 	err = register_framebuffer(fb_info);
+ 	if (err < 0)
+ 		goto release_fb;
+ 
+ 	sm750_dev->fb_count++;
+ 
+ 	return 0;
+ 
+ release_fb:
+ 	framebuffer_release(fb_info);
+ 	return err;
+ }
+ 
+ static int lynxfb_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
+ {
+     struct sm750_dev *sm750_dev = NULL;
+     int max_fb;
+     int fbidx;
+     int err;
+ 
+     /* enable device */
+     err = pcim_enable_device(pdev);
+     if (err)
+ 	return err;
+ 
+     err = -ENOMEM;
+     sm750_dev = devm_kzalloc(&pdev->dev, sizeof(*sm750_dev), GFP_KERNEL);
+     if (!sm750_dev)
+ 	return err;
+ 
+     sm750_dev->fbinfo[0] = sm750_dev->fbinfo[1] = NULL;
+     sm750_dev->devid = pdev->device;
+     sm750_dev->revid = pdev->revision;
+     sm750_dev->pdev = pdev;
+     sm750_dev->mtrr_off = g_nomtrr;
+     sm750_dev->mtrr.vram = 0;
+     sm750_dev->accel_off = g_noaccel;
+     spin_lock_init(&sm750_dev->slock);
+ 
+     if (!sm750_dev->accel_off) {
+ 	/* hook deInit and 2d routines, notes that below hw_xxx routine can work on most of lynx chips. if some chip need specific function, please hook it in smXXX_set_drv routine */
+ 	sm750_dev->accel.de_init = hw_de_init;
+ 	sm750_dev->accel.de_fillrect = hw_fillrect;
+ 	sm750_dev->accel.de_copyarea = hw_copyarea;
+ 	sm750_dev->accel.de_imageblit = hw_imageblit;
+     }
+ 
+     sm750fb_setup(sm750_dev, g_settings);	/* call chip specific setup routine  */
+     err = hw_map(sm750_dev, pdev);		/* call chip specific mmap routine */
+     if (err)
+ 	return err;
+ 
+     if (!sm750_dev->mtrr_off)
+ 	sm750_dev->mtrr.vram = arch_phys_wc_add(sm750_dev->vidmem_start, sm750_dev->vidmem_size);
+ 
+     memset_io(sm750_dev->pvMem, 0, sm750_dev->vidmem_size);
+ 
+     pci_set_drvdata(pdev, sm750_dev);
+ 
+     hw_init_chip(sm750_dev, pdev);	/* call chipInit routine */
+ 
+     /* allocate frame buffer info structures according to g_dualview */
+     max_fb = g_dualview?2:1;
+     for (fbidx = 0; fbidx < max_fb; fbidx++) {
+ 	err = sm750fb_frambuffer_alloc(sm750_dev, fbidx);
+ 	if (err)
+ 	    goto release_fb;
+     }
+ 
+     return 0;
+ 
+ release_fb:
+     sm750fb_frambuffer_release(sm750_dev);
+     return err;
+ }
+ 
+ static void lynxfb_pci_remove(struct pci_dev *pdev)
+ {
+ 	struct sm750_dev *sm750_dev;
+ 
+ 	sm750_dev = pci_get_drvdata(pdev);
+ 
+ 	sm750fb_frambuffer_release(sm750_dev);
+ 	arch_phys_wc_del(sm750_dev->mtrr.vram);
+ 
+ 	iounmap(sm750_dev->pvReg);
+ 	iounmap(sm750_dev->pvMem);
+ 	kfree(g_settings);
+ }
+ 
+ static int __init lynxfb_setup(char *options)
+ {
+ 	int len;
+ 	char *opt, *tmp;
+ 
+ 	if (!options || !*options) {
+ 		pr_warn("no options.\n");
+ 		return 0;
+ 	}
+ 
+ 	//pr_info("options:%s\n", options);
+ 
+ 	len = strlen(options) + 1;
+ 	g_settings = kzalloc(len, GFP_KERNEL);
+ 	if (!g_settings)
+ 		return -ENOMEM;
+ 
+ 	tmp = g_settings;
+ 
+ 	/*
+ 	 * Notes:
+ 	 * char * strsep(char **s,const char * ct);
+ 	 * @s: the string to be searched
+ 	 * @ct :the characters to search for
+ 	 *
+ 	 * strsep() updates @options to pointer after the first found token
+ 	 * it also returns the pointer ahead the token.
+ 	 */
+ 	while ((opt = strsep(&options, ":")) != NULL) {
+ 		/* options that mean for any lynx chips are configured here */
+ 		if (!strncmp(opt, "noaccel", strlen("noaccel")))
+ 			g_noaccel = 1;
+ 		else if (!strncmp(opt, "nomtrr", strlen("nomtrr")))
+ 			g_nomtrr = 1;
+ 		else if (!strncmp(opt, "dual", strlen("dual")))
+ 			g_dualview = 1;
+ 		else {
+ 			strcat(tmp, opt);
+ 			tmp += strlen(opt);
+ 			if (options != NULL)
+ 				*tmp++ = ':';
+ 			else
+ 				*tmp++ = 0;
+ 		}
+ 	}
+ 
+ 	//pr_info("parameter left for chip specific analysis:%s\n", g_settings);	/* misc g_settings are transport to chip specific routines */
+ 	return 0;
+ }
+ 
+ static struct pci_device_id smi_pci_table[] = {
+ 	{ PCI_DEVICE(0x126f, 0x0750), },
+ 	{0,}
+ };
+ 
+ MODULE_DEVICE_TABLE(pci, smi_pci_table);
+ 
+ static struct pci_driver lynxfb_driver = {
+ 	.name =		"sm750fb",
+ 	.id_table =	smi_pci_table,
+ 	.probe =	lynxfb_pci_probe,
+ 	.remove =	lynxfb_pci_remove,
+ #ifdef CONFIG_PM
+ 	.suspend = lynxfb_suspend,
+ 	.resume = lynxfb_resume,
+ #endif
+ };
+ 
+ static int __init lynxfb_init(void)
+ {
+ 	char *option;
+ 	int ret;
+ 
+ #ifdef MODULE
+ 	option = g_option;
+ #else
+ 	if (fb_get_options("sm750fb", &option))
+ 		return -ENODEV;
+ #endif
+ 
+ 	lynxfb_setup(option);
+ 	ret = pci_register_driver(&lynxfb_driver);
+ 	return ret;
+ }
+ module_init(lynxfb_init);
+ 
+ static void __exit lynxfb_exit(void) {pci_unregister_driver(&lynxfb_driver);}
+ 
+ module_exit(lynxfb_exit);
+ 
+ module_param(g_option, charp, S_IRUGO);
+ 
+ MODULE_PARM_DESC(g_option,
+     "\n\t\tCommon options:\n"
+     "\t\tnoaccel:disable 2d capabilities\n"
+     "\t\tnomtrr:disable MTRR attribute for video memory\n"
+     "\t\tdualview:dual frame buffer feature enabled\n"
+     "\t\tnohwc:disable hardware cursor\n"
+     "\t\tUsual example:\n"
+     "\t\tinsmod ./sm750fb.ko g_option=\"noaccel,nohwc,1280x1024-8@60\"\n"
+ );
+ 
+ MODULE_AUTHOR("monk liu <monk.liu@siliconmotion.com>");
+ MODULE_AUTHOR("Sudip Mukherjee <sudip@vectorindia.org>");
+ MODULE_DESCRIPTION("Frame buffer driver for SM750 chipset");
+ MODULE_LICENSE("GPL v2");
diff -rcNP linux-4.4.24/drivers/staging/sm750fb/drv.h linux-4.4.24-baikal/drivers/staging/sm750fb/drv.h
*** linux-4.4.24/drivers/staging/sm750fb/drv.h	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/drivers/staging/sm750fb/drv.h	2016-11-11 14:49:54.000000000 +0300
***************
*** 0 ****
--- 1,183 ----
+ #ifndef LYNXDRV_H_
+ #define LYNXDRV_H_
+ 
+ #define FB_ACCEL_SMI 0xab
+ 
+ #define MHZ(x) ((x) * 1000000)
+ 
+ #define DEFAULT_SM750_CHIP_CLOCK	290
+ #define DEFAULT_SM750LE_CHIP_CLOCK	333
+ #ifndef SM750LE_REVISION_ID
+ #define SM750LE_REVISION_ID ((unsigned char)0xfe)
+ #endif
+ 
+ enum sm750_pnltype {
+ 	sm750_24TFT = 0,	/* 24bit tft */
+ 	sm750_dualTFT = 2,	/* dual 18 bit tft */
+ 	sm750_doubleTFT = 1,	/* 36 bit double pixel tft */
+ };
+ 
+ /* vga channel is not concerned  */
+ enum sm750_dataflow {
+ 	sm750_simul_pri,	/* primary => all head */
+ 	sm750_simul_sec,	/* secondary => all head */
+ 	sm750_dual_normal,	/* primary => panel head and secondary => crt */
+ 	sm750_dual_swap,	/* primary => crt head and secondary => panel */
+ };
+ 
+ enum sm750_channel {
+ 	sm750_primary = 0,
+ 	/* enum value equal to the register filed data */
+ 	sm750_secondary = 1,
+ };
+ 
+ enum sm750_path {
+ 	sm750_panel = 1,
+ 	sm750_crt = 2,
+ 	sm750_pnc = 3,	/* panel and crt */
+ };
+ 
+ struct init_status {
+ 	ushort powerMode;
+ 	/* below three clocks are in unit of MHZ*/
+ 	ushort chip_clk;
+ 	ushort mem_clk;
+ 	ushort master_clk;
+ 	ushort setAllEngOff;
+ 	ushort resetMemory;
+ };
+ 
+ struct lynx_accel {
+     volatile unsigned char __iomem *dprBase;	/* base virtual address of DPR registers */
+     volatile unsigned char __iomem *dpPortBase;	/* base virtual address of de data port */
+     void (*de_init)(struct lynx_accel *);	/* function pointers */
+     int (*de_wait)(void);			/* see if hardware ready to work */
+     int (*de_fillrect)(struct lynx_accel *, u32, u32, u32, u32, u32, u32, u32, u32, u32);
+     int (*de_copyarea)(struct lynx_accel *, u32, u32, u32, u32, u32, u32, u32, u32, u32, u32, u32, u32);
+     int (*de_imageblit)(struct lynx_accel *, const char *, u32, u32, u32, u32, u32, u32, u32, u32, u32, u32, u32, u32);
+ };
+ 
+ struct sm750_dev {
+ 	/* common members */
+ 	u16 devid;
+ 	u8 revid;
+ 	struct pci_dev *pdev;
+ 	struct fb_info *fbinfo[2];
+ 	struct lynx_accel accel;
+ 	int accel_off;
+ 	int fb_count;
+ 	int mtrr_off;
+ 	struct{
+ 		int vram;
+ 	} mtrr;
+ 	/* all smi graphic adaptor got below attributes */
+ 	unsigned long vidmem_start;
+ 	unsigned long vidreg_start;
+ 	__u32 vidmem_size;
+ 	__u32 vidreg_size;
+ 	void __iomem *pvReg;
+ 	unsigned char __iomem *pvMem;
+ 	/* locks*/
+ 	spinlock_t slock;
+ 
+ 	struct init_status initParm;
+ 	enum sm750_pnltype pnltype;
+ 	enum sm750_dataflow dataflow;
+ 	int nocrt;
+ 
+ 	/*
+ 	 * 0: no hardware cursor
+ 	 * 1: primary crtc hw cursor enabled,
+ 	 * 2: secondary crtc hw cursor enabled
+ 	 * 3: both ctrc hw cursor enabled
+ 	 */
+ 	int hwCursor;
+ };
+ 
+ struct lynx_cursor {
+ 	/* cursor width ,height and size */
+ 	int w;
+ 	int h;
+ 	int size;
+ 	/* hardware limitation */
+ 	int maxW;
+ 	int maxH;
+ 	/* base virtual address and offset  of cursor image */
+ 	char __iomem *vstart;
+ 	int offset;
+ 
+ 	volatile char __iomem *mmio;	/* mmio addr of hw cursor */
+ };
+ 
+ struct lynxfb_crtc {
+ 	unsigned char __iomem *vCursor; /* virtual address of cursor */
+ 	unsigned char __iomem *vScreen; /* virtual address of on_screen */
+ 	int oCursor; /* cursor address offset in vidmem */
+ 	int oScreen; /* onscreen address offset in vidmem */
+ 	int channel;/* which channel this crtc stands for*/
+ 	resource_size_t vidmem_size;/* this view's video memory max size */
+ 
+ 	/* below attributes belong to info->fix, their value depends on specific adaptor*/
+ 	u16 line_pad;/* padding information:0,1,2,4,8,16,... */
+ 	u16 xpanstep;
+ 	u16 ypanstep;
+ 	u16 ywrapstep;
+ 
+ 	void *priv;
+ 
+ 	struct lynx_cursor cursor;	/* cursor information */
+ };
+ 
+ struct lynxfb_output {
+     int dpms;
+     int paths;
+     /* which paths(s) this output stands for,for sm750:
+     paths=1:means output for panel paths
+     paths=2:means output for crt paths
+     paths=3:means output for both panel and crt paths
+     */
+ 
+     int *channel;
+     /* which channel these outputs linked with,for sm750:
+     channel=0 means primary channel
+     channel=1 means secondary channel
+     output->channel ==> &crtc->channel
+     */
+     void *priv;
+ 
+     int (*proc_setBLANK)(struct lynxfb_output*, int);
+ };
+ 
+ struct lynxfb_par {
+     /* either 0 or 1 for dual head adaptor,0 is the older one registered */
+     int index;
+     unsigned int pseudo_palette[256];
+     struct lynxfb_crtc crtc;
+     struct lynxfb_output output;
+     struct fb_info *info;
+     struct sm750_dev *dev;
+ };
+ 
+ static inline unsigned long ps_to_hz(unsigned int psvalue)
+ {
+     unsigned long long numerator = 1000*1000*1000*1000ULL;
+     /* 10^12/picosecond period gives frequency in Hz */
+     do_div(numerator, psvalue);
+     return (unsigned long)numerator;
+ }
+ 
+ int hw_map(struct sm750_dev *sm750_dev, struct pci_dev *pdev);
+ int hw_init_chip(struct sm750_dev*, struct pci_dev *);
+ void hw_init_accel(struct sm750_dev *);
+ int hw_deWait(void);
+ int hw_le_deWait(void);
+ 
+ int hw_output_setMode(struct lynxfb_output*, struct fb_var_screeninfo*, struct fb_fix_screeninfo*);
+ int hw_crtc_checkMode(struct lynxfb_crtc*, struct fb_var_screeninfo*);
+ int hw_crtc_setMode(struct lynxfb_crtc*, struct fb_var_screeninfo*, struct fb_fix_screeninfo*);
+ int hw_setColReg(struct lynxfb_crtc*, ushort, ushort, ushort, ushort);
+ int hw_setBLANK(struct lynxfb_output*, int);
+ int hw_le_setBLANK(struct lynxfb_output*, int);
+ int hw_pan_display(struct lynxfb_crtc *crtc, const struct fb_var_screeninfo *var, const struct fb_info *info);
+ 
+ #endif
diff -rcNP linux-4.4.24/drivers/staging/sm750fb/dvi.c linux-4.4.24-baikal/drivers/staging/sm750fb/dvi.c
*** linux-4.4.24/drivers/staging/sm750fb/dvi.c	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/drivers/staging/sm750fb/dvi.c	2016-11-11 14:49:54.000000000 +0300
***************
*** 0 ****
--- 1,36 ----
+ #include "help.h"
+ #include "reg.h"
+ #include "dvi.h"
+ #include "sii164.h"
+ 
+ /* This global variable contains all the supported driver and its corresponding function API. Please set the function pointer to NULL whenever the function is not supported. */
+ static dvi_ctrl_device_t g_dcftSupportedDviController[] = {
+ #ifdef DVI_CTRL_SII164
+     {
+     .pfnInit = sii164InitChip,
+     .pfnGetVendorId = sii164GetVendorID,
+     .pfnGetDeviceId = sii164GetDeviceID,
+ #ifdef SII164_FULL_FUNCTIONS
+     .pfnResetChip = sii164ResetChip,
+     .pfnGetChipString = sii164GetChipString,
+     .pfnSetPower = sii164SetPower,
+     .pfnEnableHotPlugDetection = sii164EnableHotPlugDetection,
+     .pfnIsConnected = sii164IsConnected,
+     .pfnCheckInterrupt = sii164CheckInterrupt,
+     .pfnClearInterrupt = sii164ClearInterrupt,
+ #endif
+     },
+ #endif
+ };
+ 
+ int dviInit(unsigned char edgeSelect, unsigned char busSelect, unsigned char dualEdgeClkSelect, unsigned char hsyncEnable, unsigned char vsyncEnable, unsigned char deskewEnable, unsigned char deskewSetting, unsigned char continuousSyncEnable, unsigned char pllFilterEnable, unsigned char pllFilterValue) {
+     dvi_ctrl_device_t *pCurrentDviCtrl;
+ 
+     pCurrentDviCtrl = g_dcftSupportedDviController;
+     if (pCurrentDviCtrl->pfnInit != NULL) {
+ 	return pCurrentDviCtrl->pfnInit(edgeSelect, busSelect, dualEdgeClkSelect, hsyncEnable, vsyncEnable, deskewEnable, deskewSetting, continuousSyncEnable, pllFilterEnable, pllFilterValue);
+     }
+     return -1;
+ }
+ 
+ 
diff -rcNP linux-4.4.24/drivers/staging/sm750fb/dvi.h linux-4.4.24-baikal/drivers/staging/sm750fb/dvi.h
*** linux-4.4.24/drivers/staging/sm750fb/dvi.h	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/drivers/staging/sm750fb/dvi.h	2016-11-11 14:49:54.000000000 +0300
***************
*** 0 ****
--- 1,48 ----
+ #ifndef DVI_H__
+ #define DVI_H__
+ 
+ /* dvi chip stuffs structros */
+ 
+ typedef long (*PFN_DVICTRL_INIT)(
+     unsigned char edgeSelect,
+     unsigned char busSelect,
+     unsigned char dualEdgeClkSelect,
+     unsigned char hsyncEnable,
+     unsigned char vsyncEnable,
+     unsigned char deskewEnable,
+     unsigned char deskewSetting,
+     unsigned char continuousSyncEnable,
+     unsigned char pllFilterEnable,
+     unsigned char pllFilterValue
+ );
+ 
+ typedef void (*PFN_DVICTRL_RESETCHIP)(void);
+ typedef char* (*PFN_DVICTRL_GETCHIPSTRING)(void);
+ typedef unsigned short (*PFN_DVICTRL_GETVENDORID)(void);
+ typedef unsigned short (*PFN_DVICTRL_GETDEVICEID)(void);
+ typedef void (*PFN_DVICTRL_SETPOWER)(unsigned char powerUp);
+ typedef void (*PFN_DVICTRL_HOTPLUGDETECTION)(unsigned char enableHotPlug);
+ typedef unsigned char (*PFN_DVICTRL_ISCONNECTED)(void);
+ typedef unsigned char (*PFN_DVICTRL_CHECKINTERRUPT)(void);
+ typedef void (*PFN_DVICTRL_CLEARINTERRUPT)(void);
+ 
+ /* Structure to hold all the function pointer to the DVI Controller. */
+ typedef struct _dvi_ctrl_device_t {
+     PFN_DVICTRL_INIT		pfnInit;
+     PFN_DVICTRL_RESETCHIP		pfnResetChip;
+     PFN_DVICTRL_GETCHIPSTRING	pfnGetChipString;
+     PFN_DVICTRL_GETVENDORID		pfnGetVendorId;
+     PFN_DVICTRL_GETDEVICEID		pfnGetDeviceId;
+     PFN_DVICTRL_SETPOWER		pfnSetPower;
+     PFN_DVICTRL_HOTPLUGDETECTION	pfnEnableHotPlugDetection;
+     PFN_DVICTRL_ISCONNECTED		pfnIsConnected;
+     PFN_DVICTRL_CHECKINTERRUPT	pfnCheckInterrupt;
+     PFN_DVICTRL_CLEARINTERRUPT	pfnClearInterrupt;
+ } dvi_ctrl_device_t;
+ 
+ /* dvi functions prototype */
+ int dviInit(unsigned char edgeSelect, unsigned char busSelect, unsigned char dualEdgeClkSelect, unsigned char hsyncEnable, unsigned char vsyncEnable, unsigned char deskewEnable, unsigned char deskewSetting, unsigned char continuousSyncEnable, unsigned char pllFilterEnable, unsigned char pllFilterValue
+ );
+ 
+ #endif
+ 
diff -rcNP linux-4.4.24/drivers/staging/sm750fb/help.c linux-4.4.24-baikal/drivers/staging/sm750fb/help.c
*** linux-4.4.24/drivers/staging/sm750fb/help.c	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/drivers/staging/sm750fb/help.c	2016-11-11 14:49:54.000000000 +0300
***************
*** 0 ****
--- 1,17 ----
+ #include "help.h"
+ 
+ void __iomem *mmio750;
+ char revId750;
+ unsigned short devId750;
+ 
+ /* after driver mapped io registers, use this function first */
+ void set_mmio(void __iomem *addr, unsigned short devId, char revId)
+ {
+     mmio750 = addr;
+     devId750 = devId;
+     revId750 = revId;
+     if (revId == 0xfe)
+ 	printk("found sm750le\n");
+ }
+ 
+ 
diff -rcNP linux-4.4.24/drivers/staging/sm750fb/help.h linux-4.4.24-baikal/drivers/staging/sm750fb/help.h
*** linux-4.4.24/drivers/staging/sm750fb/help.h	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/drivers/staging/sm750fb/help.h	2016-11-11 14:49:54.000000000 +0300
***************
*** 0 ****
--- 1,24 ----
+ #ifndef HELP_H__
+ #define HELP_H__
+ 
+ #include "chip.h"
+ 
+ #ifndef USE_INTERNAL_REGISTER_ACCESS
+ 
+ #include <linux/ioport.h>
+ #include <linux/io.h>
+ #include <linux/uaccess.h>
+ 
+ /* software control endianness */
+ #define PEEK32(addr) readl(addr + mmio750)
+ #define POKE32(addr, data) writel(data, addr + mmio750)
+ 
+ extern void __iomem *mmio750;
+ extern char revId750;
+ extern unsigned short devId750;
+ 
+ #else
+ /* implement if you want use it*/
+ #endif
+ 
+ #endif
diff -rcNP linux-4.4.24/drivers/staging/sm750fb/hw.c linux-4.4.24-baikal/drivers/staging/sm750fb/hw.c
*** linux-4.4.24/drivers/staging/sm750fb/hw.c	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/drivers/staging/sm750fb/hw.c	2016-11-11 14:49:54.000000000 +0300
***************
*** 0 ****
--- 1,505 ----
+ #include <linux/module.h>
+ #include <linux/kernel.h>
+ #include <linux/errno.h>
+ #include <linux/string.h>
+ #include <linux/mm.h>
+ #include <linux/slab.h>
+ #include <linux/delay.h>
+ #include <linux/fb.h>
+ #include <linux/ioport.h>
+ #include <linux/init.h>
+ #include <linux/pci.h>
+ #include <linux/vmalloc.h>
+ #include <linux/pagemap.h>
+ #include <linux/console.h>
+ #ifdef CONFIG_MTRR
+ #include <asm/mtrr.h>
+ #endif
+ #include <linux/platform_device.h>
+ #include <linux/screen_info.h>
+ #include <linux/sizes.h>
+ 
+ #include "drv.h"
+ #include "accel.h"
+ #include "reg.h"
+ #include "chip.h"
+ #include "mode.h"
+ #include "help.h"
+ #include "swi2c.h"
+ #include "display.h"
+ #include "power.h"
+ #ifdef USE_DVICHIP
+ #include "dvi.h"
+ #endif
+ 
+ int hw_map(struct sm750_dev *sm750_dev, struct pci_dev *pdev)
+ {
+ 	int ret;
+ 
+ 	ret = 0;
+ 
+ 	sm750_dev->vidreg_start  = pci_resource_start(pdev, 1);
+ 	sm750_dev->vidreg_size = SZ_2M;
+ 
+ 	pr_info("mmio phyAddr = %lx\n", sm750_dev->vidreg_start);
+ 
+ 	/* reserve the vidreg space of smi adaptor if you do this, u need to add release region code in lynxfb_remove, or memory will not be mapped again successfully */
+ 	ret = pci_request_region(pdev, 1, "sm750fb");
+ 	if (ret) {
+ 		pr_err("Can not request PCI regions.\n");
+ 		goto exit;
+ 	}
+ 
+ 	/* now map mmio and vidmem*/
+ 	sm750_dev->pvReg = ioremap_nocache(sm750_dev->vidreg_start, sm750_dev->vidreg_size);
+ 	if (!sm750_dev->pvReg) {
+ 		pr_err("mmio failed\n");
+ 		ret = -EFAULT;
+ 		goto exit;
+ 	} else {
+ 		pr_info("mmio virtual addr = %p\n", sm750_dev->pvReg);
+ 	}
+ 
+ 
+ 	sm750_dev->accel.dprBase = sm750_dev->pvReg + DE_BASE_ADDR_TYPE1;
+ 	sm750_dev->accel.dpPortBase = sm750_dev->pvReg + DE_PORT_ADDR_TYPE1;
+ 
+ 	set_mmio(sm750_dev->pvReg, sm750_dev->devid, sm750_dev->revid);
+ 
+ 	sm750_dev->vidmem_start = pci_resource_start(pdev, 0);
+ 	/* don't use pdev_resource[x].end - resource[x].start to calculate the resource size,its only the maximum available size but not the actual size, use @getVMSize function can be safe. */
+ 	sm750_dev->vidmem_size = getVMSize();
+ 	pr_info("video memory phyAddr = %lx, size = %u bytes\n", sm750_dev->vidmem_start, sm750_dev->vidmem_size);
+ 
+ 	/* reserve the vidmem space of smi adaptor */
+ 	sm750_dev->pvMem = ioremap_wc(sm750_dev->vidmem_start, sm750_dev->vidmem_size);
+ 	if (!sm750_dev->pvMem) {
+ 		pr_err("Map video memory failed\n");
+ 		ret = -EFAULT;
+ 		goto exit;
+ 	} else {
+ 		pr_info("video memory vaddr = %p\n", sm750_dev->pvMem);
+ 	}
+ exit:
+ 	return ret;
+ }
+ 
+ 
+ 
+ int hw_init_chip(struct sm750_dev *sm750_dev, struct pci_dev *pdev)
+ {
+     struct init_status *parm;
+ 
+     parm = &sm750_dev->initParm;
+     if (parm->chip_clk == 0)
+ 	parm->chip_clk = (getChipType() == SM750LE)?DEFAULT_SM750LE_CHIP_CLOCK:DEFAULT_SM750_CHIP_CLOCK;
+     if (parm->mem_clk == 0)
+ 	parm->mem_clk = parm->chip_clk;
+     if (parm->master_clk == 0)
+ 	parm->master_clk = parm->chip_clk/3;
+ 
+     initChipParm((initchip_param_t *)&sm750_dev->initParm);
+ /*#ifdef USE_DVICHIP
+     if(dviInit(1, 1, 0, 1, 1, 1, 7, 1, 1, 4)) pr_info("Init Display failed\n");
+ #endif*/
+     if (sm750_dev->devid == 0x718) POKE32(SYSTEM_CTRL, PEEK32(SYSTEM_CTRL)|SYSTEM_CTRL_PCI_BURST);	/* for sm718, open pci burst */
+     if (getChipType() != SM750LE) {
+ 	unsigned int val;
+ 	/* does user need CRT ?*/
+ 	if (sm750_dev->nocrt) {
+ 	    POKE32(MISC_CTRL, PEEK32(MISC_CTRL)|MISC_CTRL_DAC_POWER_OFF);		// dac turn off
+ 	    /* shut off dpms */
+ 	    val = PEEK32(SYSTEM_CTRL)&~SYSTEM_CTRL_DPMS_MASK;
+ 	    val |= SYSTEM_CTRL_DPMS_VPHN;
+ 	    POKE32(SYSTEM_CTRL, val);
+ 	} else {
+ 	    POKE32(MISC_CTRL, PEEK32(MISC_CTRL)&~MISC_CTRL_DAC_POWER_OFF);	// dac turn on
+ 	    /* turn on dpms */
+ 	    val = PEEK32(SYSTEM_CTRL)&~SYSTEM_CTRL_DPMS_MASK;
+ 	    val |= SYSTEM_CTRL_DPMS_VPHP;
+ 	    POKE32(SYSTEM_CTRL, val);
+ 	}
+ 	// setPanelType
+ 	val = PEEK32(PANEL_DISPLAY_CTRL)&~(PANEL_DISPLAY_CTRL_DUAL_DISPLAY|PANEL_DISPLAY_CTRL_DOUBLE_PIXEL);
+ 	switch (sm750_dev->pnltype) {
+ 	case sm750_24TFT:
+ 	    break;
+ 	case sm750_doubleTFT:
+ 	    val |= PANEL_DISPLAY_CTRL_DOUBLE_PIXEL;
+ 	    break;
+ 	case sm750_dualTFT:
+ 	    val |= PANEL_DISPLAY_CTRL_DUAL_DISPLAY;
+ 	    break;
+ 	}
+ 	POKE32(PANEL_DISPLAY_CTRL, val);
+     } else {
+ 	/* for 750LE , no DVI chip initialization makes Monitor no signal */
+ 	sw_i2c_init(0, 1);	/* Set up GPIO for software I2C to program DVI chip in the Xilinx SP605 board, in order to have video signal. */
+ 
+ 	/* Customer may NOT use CH7301 DVI chip, which has to be initialized differently. */
+ 	if (sw_i2c_read_reg(0xec, 0x4a) == 0x95) {
+ 	    /* The following register values for CH7301 are from Chrontel app note and our experiment. */
+ 	    pr_info("yes,CH7301 DVI chip found\n");
+ 	    sw_i2c_write_reg(0xec, 0x1d, 0x16);
+ 	    sw_i2c_write_reg(0xec, 0x21, 0x9);
+ 	    sw_i2c_write_reg(0xec, 0x49, 0xC0);
+ 	    pr_info("okay,CH7301 DVI chip setup done\n");
+ 	}
+     }
+ 
+     if (!sm750_dev->accel_off)	/* init 2d engine */
+ 	hw_init_accel(sm750_dev);
+ 
+ #ifdef USE_DVICHIP
+     if(dviInit(1, 1, 0, 1, 1, 1, 7, 1, 1, 4)) pr_info("Init Display failed\n");
+ #endif
+ 
+     return 0;
+ }
+ 
+ int hw_output_setMode(struct lynxfb_output *output, struct fb_var_screeninfo *var, struct fb_fix_screeninfo *fix)
+ {
+ 	int ret;
+ 	disp_output_t dispSet;
+ 	int channel;
+ 
+ 	ret = 0;
+ 	dispSet = 0;
+ 	channel = *output->channel;
+ 
+ 
+ 	if (getChipType() != SM750LE) {
+ 		if (channel == sm750_primary) {
+ 			pr_info("primary channel\n");
+ 			if (output->paths&sm750_panel)
+ 				dispSet |= do_LCD1_PRI;
+ 			if (output->paths&sm750_crt)
+ 				dispSet |= do_CRT_PRI;
+ 
+ 		} else {
+ 			pr_info("secondary channel\n");
+ 			if (output->paths&sm750_panel)
+ 				dispSet |= do_LCD1_SEC;
+ 			if (output->paths&sm750_crt)
+ 				dispSet |= do_CRT_SEC;
+ 
+ 		}
+ 		setLogicalDispOut(dispSet);
+ 	} else {
+ 		/* just open DISPLAY_CONTROL_750LE register bit 3:0*/
+ 		u32 reg;
+ 
+ 		reg = PEEK32(DISPLAY_CONTROL_750LE);
+ 		reg |= 0xf;
+ 		POKE32(DISPLAY_CONTROL_750LE, reg);
+ 	}
+ 
+ 	pr_info("ddk setlogicdispout done\n");
+ 	return ret;
+ }
+ 
+ int hw_crtc_checkMode(struct lynxfb_crtc *crtc, struct fb_var_screeninfo *var)
+ {
+ 	struct sm750_dev *sm750_dev;
+ 	struct lynxfb_par *par = container_of(crtc, struct lynxfb_par, crtc);
+ 
+ 	sm750_dev = par->dev;
+ 
+ 	switch (var->bits_per_pixel) {
+ 	case 8:
+ 	case 16:
+ 		break;
+ 	case 32:
+ 		if (sm750_dev->revid == SM750LE_REVISION_ID) {
+ 			pr_info("750le do not support 32bpp\n");
+ 			return -EINVAL;
+ 		}
+ 		break;
+ 	default:
+ 		return -EINVAL;
+ 
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ 
+ /*
+ 	set the controller's mode for @crtc charged with @var and @fix parameters
+ */
+ int hw_crtc_setMode(struct lynxfb_crtc *crtc, struct fb_var_screeninfo *var, struct fb_fix_screeninfo *fix)
+ {
+ 	int ret, fmt;
+ 	u32 reg;
+ 	mode_parameter_t modparm;
+ 	clock_type_t clock;
+ 	struct sm750_dev *sm750_dev;
+ 	struct lynxfb_par *par;
+ 
+ 
+ 	ret = 0;
+ 	par = container_of(crtc, struct lynxfb_par, crtc);
+ 	sm750_dev = par->dev;
+ 
+ 	if (!sm750_dev->accel_off) {
+ 		/* set 2d engine pixel format according to mode bpp */
+ 		switch (var->bits_per_pixel) {
+ 		case 8:
+ 			fmt = 0;
+ 			break;
+ 		case 16:
+ 			fmt = 1;
+ 			break;
+ 		case 32:
+ 		default:
+ 			fmt = 2;
+ 			break;
+ 		}
+ 		hw_set2dformat(&sm750_dev->accel, fmt);
+ 	}
+ 
+ 	/* set timing */
+ 	modparm.pixel_clock = ps_to_hz(var->pixclock);
+ 	modparm.vertical_sync_polarity = (var->sync&FB_SYNC_HOR_HIGH_ACT)?POS:NEG;
+ 	modparm.horizontal_sync_polarity = (var->sync&FB_SYNC_VERT_HIGH_ACT)?POS:NEG;
+ 	modparm.clock_phase_polarity = (var->sync&FB_SYNC_COMP_HIGH_ACT)?POS:NEG;
+ 	modparm.horizontal_display_end = var->xres;
+ 	modparm.horizontal_sync_width = var->hsync_len;
+ 	modparm.horizontal_sync_start = var->xres + var->right_margin;
+ 	modparm.horizontal_total = var->xres + var->left_margin + var->right_margin + var->hsync_len;
+ 	modparm.vertical_display_end = var->yres;
+ 	modparm.vertical_sync_height = var->vsync_len;
+ 	modparm.vertical_sync_start = var->yres + var->lower_margin;
+ 	modparm.vertical_total = var->yres + var->upper_margin + var->lower_margin + var->vsync_len;
+ 
+ 	/* choose pll */
+ 	if (crtc->channel != sm750_secondary)
+ 		clock = PRIMARY_PLL;
+ 	else
+ 		clock = SECONDARY_PLL;
+ 
+ 	pr_info("Request pixel clock = %lu\n", modparm.pixel_clock);
+ 	ret = setModeTiming(&modparm, clock);
+ 	if (ret) {
+ 		pr_err("Set mode timing failed\n");
+ 		goto exit;
+ 	}
+ 
+ 	if (crtc->channel != sm750_secondary) {
+ 		/* set pitch, offset ,width,start address ,etc... */
+ 		POKE32(PANEL_FB_ADDRESS, crtc->oScreen&PANEL_FB_ADDRESS_ADDRESS_MASK);
+ 
+ 		reg = var->xres * (var->bits_per_pixel>>3);
+ 		/* crtc->channel is not equal to par->index on numeric,be aware of that */
+ 		reg = ALIGN(reg, crtc->line_pad);
+ 		reg = (reg<<PANEL_FB_WIDTH_WIDTH_SHIFT)&PANEL_FB_WIDTH_WIDTH_MASK;
+ 		reg |= (fix->line_length&PANEL_FB_WIDTH_OFFSET_MASK);
+ 		POKE32(PANEL_FB_WIDTH, reg);
+ 
+ 		reg = ((var->xres - 1)<<PANEL_WINDOW_WIDTH_WIDTH_SHIFT)&PANEL_WINDOW_WIDTH_WIDTH_MASK;
+ 		reg |= (var->xoffset&PANEL_WINDOW_WIDTH_X_MASK);
+ 		POKE32(PANEL_WINDOW_WIDTH, reg);
+ 
+ 		reg = ((var->yres_virtual - 1) <<
+ 		       PANEL_WINDOW_HEIGHT_HEIGHT_SHIFT);
+ 		reg &= PANEL_WINDOW_HEIGHT_HEIGHT_MASK;
+ 		reg |= (var->yoffset&PANEL_WINDOW_HEIGHT_Y_MASK);
+ 		POKE32(PANEL_WINDOW_HEIGHT, reg);
+ 
+ 		POKE32(PANEL_PLANE_TL, 0);
+ 
+ 		reg = ((var->yres - 1)<<PANEL_PLANE_BR_BOTTOM_SHIFT)&PANEL_PLANE_BR_BOTTOM_MASK;
+ 		reg |= ((var->xres - 1)&PANEL_PLANE_BR_RIGHT_MASK);
+ 		POKE32(PANEL_PLANE_BR, reg);
+ 
+ 		/* set pixel format */
+ 		reg = PEEK32(PANEL_DISPLAY_CTRL);
+ 		POKE32(PANEL_DISPLAY_CTRL, reg|(var->bits_per_pixel>>4));
+ 	} else {
+ 		/* not implemented now */
+ 		POKE32(CRT_FB_ADDRESS, crtc->oScreen);
+ 		reg = var->xres * (var->bits_per_pixel>>3);
+ 		/* crtc->channel is not equal to par->index on numeric,be aware of that */
+ 		reg = ALIGN(reg, crtc->line_pad)<<CRT_FB_WIDTH_WIDTH_SHIFT;
+ 		reg &= CRT_FB_WIDTH_WIDTH_MASK;
+ 		reg |= (fix->line_length&CRT_FB_WIDTH_OFFSET_MASK);
+ 		POKE32(CRT_FB_WIDTH, reg);
+ 
+ 		/* SET PIXEL FORMAT */
+ 		reg = PEEK32(CRT_DISPLAY_CTRL);
+ 		reg |= ((var->bits_per_pixel>>4)&CRT_DISPLAY_CTRL_FORMAT_MASK);
+ 		POKE32(CRT_DISPLAY_CTRL, reg);
+ 
+ 	}
+ 
+ 
+ exit:
+ 	return ret;
+ }
+ 
+ int hw_setColReg(struct lynxfb_crtc *crtc, ushort index, ushort red, ushort green, ushort blue)
+ {
+     static unsigned int add[] = {PANEL_PALETTE_RAM, CRT_PALETTE_RAM};
+ 
+     POKE32(add[crtc->channel] + index*4, (red<<16)|(green<<8)|blue);
+     return 0;
+ }
+ 
+ int hw_le_setBLANK(struct lynxfb_output *output, int blank)
+ {
+ 	int dpms, crtdb;
+ 
+ 	switch (blank) {
+ 	case FB_BLANK_UNBLANK:
+ 		dpms = CRT_DISPLAY_CTRL_DPMS_0;
+ 		crtdb = 0;
+ 		break;
+ 	case FB_BLANK_NORMAL:
+ 		dpms = CRT_DISPLAY_CTRL_DPMS_0;
+ 		crtdb = CRT_DISPLAY_CTRL_BLANK;
+ 		break;
+ 	case FB_BLANK_VSYNC_SUSPEND:
+ 		dpms = CRT_DISPLAY_CTRL_DPMS_2;
+ 		crtdb = CRT_DISPLAY_CTRL_BLANK;
+ 		break;
+ 	case FB_BLANK_HSYNC_SUSPEND:
+ 		dpms = CRT_DISPLAY_CTRL_DPMS_1;
+ 		crtdb = CRT_DISPLAY_CTRL_BLANK;
+ 		break;
+ 	case FB_BLANK_POWERDOWN:
+ 		dpms = CRT_DISPLAY_CTRL_DPMS_3;
+ 		crtdb = CRT_DISPLAY_CTRL_BLANK;
+ 		break;
+ 	default:
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (output->paths&sm750_crt) {
+ 		unsigned int val;
+ 
+ 		val = PEEK32(CRT_DISPLAY_CTRL)&~CRT_DISPLAY_CTRL_DPMS_MASK;
+ 		POKE32(CRT_DISPLAY_CTRL, val|dpms);
+ 
+ 		val = PEEK32(CRT_DISPLAY_CTRL)&~CRT_DISPLAY_CTRL_BLANK;
+ 		POKE32(CRT_DISPLAY_CTRL, val|crtdb);
+ 	}
+ 	return 0;
+ }
+ 
+ int hw_setBLANK(struct lynxfb_output *output, int blank)
+ {
+     unsigned int dpms, pps, crtdb;
+ 
+     dpms = pps = crtdb = 0;
+ 
+     switch (blank) {
+     case FB_BLANK_UNBLANK:
+ 	pr_info("flag = FB_BLANK_UNBLANK\n");
+ 	dpms = SYSTEM_CTRL_DPMS_VPHP;
+ 	pps = PANEL_DISPLAY_CTRL_DATA;
+ 	break;
+     case FB_BLANK_NORMAL:
+ 	pr_info("flag = FB_BLANK_NORMAL\n");
+ 	dpms = SYSTEM_CTRL_DPMS_VPHP;
+ 	crtdb = CRT_DISPLAY_CTRL_BLANK;
+ 	break;
+     case FB_BLANK_VSYNC_SUSPEND:
+ 	dpms = SYSTEM_CTRL_DPMS_VNHP;
+ 	crtdb = CRT_DISPLAY_CTRL_BLANK;
+ 	break;
+     case FB_BLANK_HSYNC_SUSPEND:
+ 	dpms = SYSTEM_CTRL_DPMS_VPHN;
+ 	crtdb = CRT_DISPLAY_CTRL_BLANK;
+ 	break;
+     case FB_BLANK_POWERDOWN:
+ 	dpms = SYSTEM_CTRL_DPMS_VNHN;
+ 	crtdb = CRT_DISPLAY_CTRL_BLANK;
+ 	break;
+     }
+     if (output->paths&sm750_crt) {
+ 	POKE32(SYSTEM_CTRL, (PEEK32(SYSTEM_CTRL)&~SYSTEM_CTRL_DPMS_MASK)|dpms);
+ 	POKE32(CRT_DISPLAY_CTRL, (PEEK32(CRT_DISPLAY_CTRL)&~CRT_DISPLAY_CTRL_BLANK)|crtdb);
+     }
+     if (output->paths&sm750_panel) {
+ 	//POKE32(SYSTEM_CTRL, (PEEK32(SYSTEM_CTRL)&~SYSTEM_CTRL_DPMS_MASK)|dpms);???
+ 	POKE32(PANEL_DISPLAY_CTRL, (PEEK32(PANEL_DISPLAY_CTRL)&~PANEL_DISPLAY_CTRL_DATA)|pps);
+     }
+     return 0;
+ }
+ 
+ 
+ void hw_init_accel(struct sm750_dev *sm750_dev)
+ {
+     u32 reg;
+ 
+     enable2DEngine(1);
+ 
+     if (getChipType() == SM750LE) {
+ 	reg = PEEK32(DE_STATE1);
+ 	reg |= DE_STATE1_DE_ABORT;
+ 	POKE32(DE_STATE1, reg);
+ 
+ 	reg = PEEK32(DE_STATE1);
+ 	reg &= ~DE_STATE1_DE_ABORT;
+ 	POKE32(DE_STATE1, reg);
+     } else {
+ 	/* engine reset */
+ 	reg = PEEK32(SYSTEM_CTRL);
+ 	reg |= SYSTEM_CTRL_DE_ABORT;
+ 	POKE32(SYSTEM_CTRL, reg);
+ 
+ 	reg = PEEK32(SYSTEM_CTRL);
+ 	reg &= ~SYSTEM_CTRL_DE_ABORT;
+ 	POKE32(SYSTEM_CTRL, reg);
+     }
+     sm750_dev->accel.de_init(&sm750_dev->accel);	/* call 2d init */
+ }
+ 
+ int hw_le_deWait(void)
+ {
+     int i = 0x10000000;
+ 
+     unsigned int mask = DE_STATE2_DE_STATUS_BUSY|DE_STATE2_DE_FIFO_EMPTY|DE_STATE2_DE_MEM_FIFO_EMPTY;
+ 
+     while (i--) {
+ 	unsigned int val = PEEK32(DE_STATE2);
+ 
+ 	if ((val&mask) == (DE_STATE2_DE_FIFO_EMPTY|DE_STATE2_DE_MEM_FIFO_EMPTY))
+ 	    return 0;
+     }
+     return -1;	/* timeout error */
+ }
+ 
+ 
+ int hw_deWait(void)
+ {
+     int i = 0x10000000;
+ 
+     unsigned int mask = SYSTEM_CTRL_DE_STATUS_BUSY|SYSTEM_CTRL_DE_FIFO_EMPTY|SYSTEM_CTRL_DE_MEM_FIFO_EMPTY;
+ 
+     while (i--) {
+ 	unsigned int val = PEEK32(SYSTEM_CTRL);
+ 
+ 	if ((val&mask) == (SYSTEM_CTRL_DE_FIFO_EMPTY|SYSTEM_CTRL_DE_MEM_FIFO_EMPTY)) return 0;
+     }
+ 
+     return -1;	/* timeout error */
+ }
+ 
+ int hw_pan_display(struct lynxfb_crtc *crtc, const struct fb_var_screeninfo *var, const struct fb_info *info) {
+     uint32_t total;
+ 
+     /* check params */
+     if ((var->xoffset + var->xres > var->xres_virtual) || (var->yoffset + var->yres > var->yres_virtual)) {
+ 	return -EINVAL;
+     }
+ 
+     total = var->yoffset * info->fix.line_length + ((var->xoffset * var->bits_per_pixel)>>3);
+     total += crtc->oScreen;
+     if (crtc->channel == sm750_primary) {
+ 	POKE32(PANEL_FB_ADDRESS, PEEK32(PANEL_FB_ADDRESS)|(total&PANEL_FB_ADDRESS_ADDRESS_MASK));
+     } else {
+ 	POKE32(CRT_FB_ADDRESS, PEEK32(CRT_FB_ADDRESS)|(total&CRT_FB_ADDRESS_ADDRESS_MASK));
+     }
+     return 0;
+ }
diff -rcNP linux-4.4.24/drivers/staging/sm750fb/hwi2c.c linux-4.4.24-baikal/drivers/staging/sm750fb/hwi2c.c
*** linux-4.4.24/drivers/staging/sm750fb/hwi2c.c	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/drivers/staging/sm750fb/hwi2c.c	2016-11-11 14:49:54.000000000 +0300
***************
*** 0 ****
--- 1,235 ----
+ #define USE_HW_I2C
+ #ifdef USE_HW_I2C
+ #include "help.h"
+ #include "reg.h"
+ #include "hwi2c.h"
+ #include "power.h"
+ 
+ #define MAX_HWI2C_FIFO                  16
+ #define HWI2C_WAIT_TIMEOUT              0xF0000
+ 
+ int hw_i2c_init(unsigned char bus_speed_mode)
+ {
+     unsigned int value;
+ 
+     /* Enable GPIO 30&31 as IIC clock&data */
+     value = PEEK32(GPIO_MUX);
+ 
+     value |= (GPIO_MUX_30|GPIO_MUX_31);
+     POKE32(GPIO_MUX, value);
+ 
+     /* Enable Hardware I2C power. TODO: Check if we need to enable GPIO power? */
+     enableI2C(1);
+ 
+     /* Enable the I2C Controller and set the bus speed mode */
+     value = PEEK32(I2C_CTRL)&~(I2C_CTRL_MODE|I2C_CTRL_EN);
+     if (bus_speed_mode)
+ 	value |= I2C_CTRL_MODE;
+     value |= I2C_CTRL_EN;
+     POKE32(I2C_CTRL, value);
+ 
+     return 0;
+ }
+ 
+ void hw_i2c_close(void)
+ {
+     unsigned int value;
+ 
+     /* Disable I2C controller */
+     value = PEEK32(I2C_CTRL)&~I2C_CTRL_EN;
+     POKE32(I2C_CTRL, value);
+ 
+     /* Disable I2C Power */
+     enableI2C(0);
+ 
+     /* Set GPIO 30&31 back as GPIO pins */
+     value = PEEK32(GPIO_MUX);
+     value &= ~GPIO_MUX_30;
+     value &= ~GPIO_MUX_31;
+     POKE32(GPIO_MUX, value);
+ }
+ 
+ static long hw_i2c_wait_tx_done(void)
+ {
+     unsigned int timeout;
+ 
+     /* Wait until the transfer is completed. */
+     timeout = HWI2C_WAIT_TIMEOUT;
+     while (!(PEEK32(I2C_STATUS)&I2C_STATUS_TX) && (timeout != 0))
+ 	timeout--;
+ 
+     if (timeout == 0)
+ 	return -1;
+ 
+ return 0;
+ }
+ 
+ /*
+  *  This function writes data to the i2c slave device registers.
+  *
+  *  Parameters:
+  *      addr            - i2c Slave device address
+  *      length          - Total number of bytes to be written to the device
+  *      buf             - The buffer that contains the data to be written to the
+  *                     i2c device.
+  *
+  *  Return Value:
+  *      Total number of bytes those are actually written.
+  */
+ static unsigned int hw_i2c_write_data(unsigned char addr, unsigned int length, unsigned char *buf)
+ {
+     unsigned char count, i;
+     unsigned int total_bytes = 0;
+ 
+     /* Set the Device Address */
+     POKE32(I2C_SLAVE_ADDRESS, addr&~0x01);
+ 
+     /* Write data.
+      * Note:
+      *      Only 16 byte can be accessed per i2c start instruction.
+      */
+     do {
+ 	/*
+ 	 * Reset I2C by writing 0 to I2C_RESET register to
+ 	 * clear the previous status.
+ 	 */
+ 	POKE32(I2C_RESET, 0);
+ 
+ 	/* Set the number of bytes to be written */
+ 	if (length < MAX_HWI2C_FIFO)
+ 	    count = length - 1;
+ 	else
+ 	    count = MAX_HWI2C_FIFO - 1;
+ 	POKE32(I2C_BYTE_COUNT, count);
+ 
+ 	/* Move the data to the I2C data register */
+ 	for (i = 0; i <= count; i++)
+ 	    POKE32(I2C_DATA0 + i, *buf++);
+ 
+ 	/* Start the I2C */
+ 	POKE32(I2C_CTRL, PEEK32(I2C_CTRL)|I2C_CTRL_CTRL);
+ 
+ 	/* Wait until the transfer is completed. */
+ 	if (hw_i2c_wait_tx_done() != 0)
+ 	    break;
+ 
+ 	/* Subtract length */
+ 	length -= (count + 1);
+ 
+ 	/* Total byte written */
+ 	total_bytes += (count + 1);
+ 
+     } while (length > 0);
+ 
+     return total_bytes;
+ }
+ 
+ /*
+  *  This function reads data from the slave device and stores them
+  *  in the given buffer
+  *
+  *  Parameters:
+  *      addr            - i2c Slave device address
+  *      length          - Total number of bytes to be read
+  *      buf             - Pointer to a buffer to be filled with the data read
+  *                     from the slave device. It has to be the same size as the
+  *                     length to make sure that it can keep all the data read.
+  *
+  *  Return Value:
+  *      Total number of actual bytes read from the slave device
+  */
+ static unsigned int hw_i2c_read_data(unsigned char addr, unsigned int length, unsigned char *buf)
+ {
+     unsigned char count, i;
+     unsigned int total_bytes = 0;
+ 
+     /* Set the Device Address */
+     POKE32(I2C_SLAVE_ADDRESS, addr|0x01);
+ 
+     /* Read data and save them to the buffer.
+      * Note:
+      *      Only 16 byte can be accessed per i2c start instruction.
+      */
+     do {
+ 	/*
+ 	 * Reset I2C by writing 0 to I2C_RESET register to
+ 	 * clear all the status.
+ 	 */
+ 	POKE32(I2C_RESET, 0);
+ 
+ 	/* Set the number of bytes to be read */
+ 	if (length <= MAX_HWI2C_FIFO)
+ 	    count = length - 1;
+ 	else
+ 	    count = MAX_HWI2C_FIFO - 1;
+ 	POKE32(I2C_BYTE_COUNT, count);
+ 
+ 	/* Start the I2C */
+ 	POKE32(I2C_CTRL, PEEK32(I2C_CTRL)|I2C_CTRL_CTRL);
+ 
+ 	/* Wait until transaction done. */
+ 	if (hw_i2c_wait_tx_done() != 0)
+ 	    break;
+ 
+ 	/* Save the data to the given buffer */
+ 	for (i = 0; i <= count; i++)
+ 	    *buf++ = PEEK32(I2C_DATA0 + i);
+ 
+ 	/* Subtract length by 16 */
+ 	length -= (count + 1);
+ 
+ 	/* Number of bytes read. */
+ 	total_bytes += (count + 1);
+ 
+     } while (length > 0);
+ 
+     return total_bytes;
+ }
+ 
+ /*
+  *  This function reads the slave device's register
+  *
+  *  Parameters:
+  *      deviceAddress   - i2c Slave device address which register
+  *                        to be read from
+  *      registerIndex   - Slave device's register to be read
+  *
+  *  Return Value:
+  *      Register value
+  */
+ unsigned char hw_i2c_read_reg(unsigned char addr, unsigned char reg)
+ {
+     unsigned char value = (0xFF);
+ 
+     if (hw_i2c_write_data(addr, 1, &reg) == 1)
+ 	hw_i2c_read_data(addr, 1, &value);
+ 
+     return value;
+ }
+ 
+ /*
+  *  This function writes a value to the slave device's register
+  *
+  *  Parameters:
+  *      deviceAddress   - i2c Slave device address which register
+  *                        to be written
+  *      registerIndex   - Slave device's register to be written
+  *      data            - Data to be written to the register
+  *
+  *  Result:
+  *          0   - Success
+  *         -1   - Fail
+  */
+ int hw_i2c_write_reg(unsigned char addr, unsigned char reg, unsigned char data)
+ {
+     unsigned char value[2];
+ 
+     value[0] = reg;
+     value[1] = data;
+     if (hw_i2c_write_data(addr, 2, value) == 2)
+ 	return 0;
+ 
+     return -1;
+ }
+ 
+ #endif
diff -rcNP linux-4.4.24/drivers/staging/sm750fb/hwi2c.h linux-4.4.24-baikal/drivers/staging/sm750fb/hwi2c.h
*** linux-4.4.24/drivers/staging/sm750fb/hwi2c.h	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/drivers/staging/sm750fb/hwi2c.h	2016-11-11 14:49:54.000000000 +0300
***************
*** 0 ****
--- 1,10 ----
+ #ifndef HWI2C_H__
+ #define HWI2C_H__
+ 
+ /* hwi2c functions */
+ int hw_i2c_init(unsigned char bus_speed_mode);
+ void hw_i2c_close(void);
+ 
+ unsigned char hw_i2c_read_reg(unsigned char addr, unsigned char reg);
+ int hw_i2c_write_reg(unsigned char addr, unsigned char reg, unsigned char data);
+ #endif
diff -rcNP linux-4.4.24/drivers/staging/sm750fb/Makefile linux-4.4.24-baikal/drivers/staging/sm750fb/Makefile
*** linux-4.4.24/drivers/staging/sm750fb/Makefile	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/staging/sm750fb/Makefile	2016-11-11 14:49:54.000000000 +0300
***************
*** 1,4 ****
  obj-$(CONFIG_FB_SM750)	+= sm750fb.o
  
! sm750fb-objs		:= sm750.o sm750_hw.o sm750_accel.o sm750_cursor.o ddk750_chip.o ddk750_power.o ddk750_mode.o
! sm750fb-objs		+= ddk750_display.o ddk750_help.o ddk750_swi2c.o ddk750_sii164.o ddk750_dvi.o ddk750_hwi2c.o
--- 1,6 ----
  obj-$(CONFIG_FB_SM750)	+= sm750fb.o
  
! sm750fb-objs		:= drv.o hw.o accel.o cursor.o chip.o power.o mode.o
! sm750fb-objs		+= display.o help.o swi2c.o sii164.o dvi.o hwi2c.o
! 
! ccflags-y += -DUSE_DVICHIP -DDVI_CTRL_SII164
diff -rcNP linux-4.4.24/drivers/staging/sm750fb/mode.c linux-4.4.24-baikal/drivers/staging/sm750fb/mode.c
*** linux-4.4.24/drivers/staging/sm750fb/mode.c	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/drivers/staging/sm750fb/mode.c	2016-11-11 14:49:54.000000000 +0300
***************
*** 0 ****
--- 1,172 ----
+ #include "help.h"
+ #include "reg.h"
+ #include "mode.h"
+ #include "chip.h"
+ 
+ /*
+ 	SM750LE only:
+     This function takes care extra registers and bit fields required to set
+     up a mode in SM750LE
+ 
+ 	Explanation about Display Control register:
+     HW only supports 7 predefined pixel clocks, and clock select is
+     in bit 29:27 of	Display Control register.
+ */
+ static unsigned long displayControlAdjust_SM750LE(mode_parameter_t *pModeParam, unsigned long dispControl)
+ {
+ 	unsigned long x, y;
+ 
+ 	x = pModeParam->horizontal_display_end;
+ 	y = pModeParam->vertical_display_end;
+ 
+ 	/* SM750LE has to set up the top-left and bottom-right
+ 	   registers as well.
+ 	   Note that normal SM750/SM718 only use those two register for
+ 	   auto-centering mode.
+ 	 */
+ 	POKE32(CRT_AUTO_CENTERING_TL, 0);
+ 
+ 	POKE32(CRT_AUTO_CENTERING_BR, (((y - 1)<<CRT_AUTO_CENTERING_BR_BOTTOM_SHIFT)&CRT_AUTO_CENTERING_BR_BOTTOM_MASK)|((x - 1)&CRT_AUTO_CENTERING_BR_RIGHT_MASK));
+ 
+ 	/* Assume common fields in dispControl have been properly set before
+ 	   calling this function.
+ 	   This function only sets the extra fields in dispControl.
+ 	 */
+ 
+ 	/* Clear bit 29:27 of display control register */
+ 	dispControl &= ~CRT_DISPLAY_CTRL_CLK_MASK;
+ 
+ 	/* Set bit 29:27 of display control register for the right clock */
+ 	/* Note that SM750LE only need to supported 7 resolutions. */
+ 	if (x == 800 && y == 600)
+ 		dispControl |= CRT_DISPLAY_CTRL_CLK_PLL41;
+ 	else if (x == 1024 && y == 768)
+ 		dispControl |= CRT_DISPLAY_CTRL_CLK_PLL65;
+ 	else if (x == 1152 && y == 864)
+ 		dispControl |= CRT_DISPLAY_CTRL_CLK_PLL80;
+ 	else if (x == 1280 && y == 768)
+ 		dispControl |= CRT_DISPLAY_CTRL_CLK_PLL80;
+ 	else if (x == 1280 && y == 720)
+ 		dispControl |= CRT_DISPLAY_CTRL_CLK_PLL74;
+ 	else if (x == 1280 && y == 960)
+ 		dispControl |= CRT_DISPLAY_CTRL_CLK_PLL108;
+ 	else if (x == 1280 && y == 1024)
+ 		dispControl |= CRT_DISPLAY_CTRL_CLK_PLL108;
+ 	else /* default to VGA clock */
+ 		dispControl |= CRT_DISPLAY_CTRL_CLK_PLL25;
+ 
+ 	/* Set bit 25:24 of display controller */
+ 	dispControl |= (CRT_DISPLAY_CTRL_CRTSELECT|CRT_DISPLAY_CTRL_RGBBIT);
+ 
+ 	/* Set bit 14 of display controller */
+ 	dispControl = DISPLAY_CTRL_CLOCK_PHASE;
+ 
+ 	POKE32(CRT_DISPLAY_CTRL, dispControl);
+ 
+ 	return dispControl;
+ }
+ 
+ 
+ 
+ /* only timing related registers will be  programed */
+ static int programModeRegisters(mode_parameter_t *pModeParam, pll_value_t *pll)
+ {
+ 	int ret = 0;
+ 	int cnt = 0;
+ 	unsigned int tmp, reg;
+ 
+ 	if (pll->clockType == SECONDARY_PLL) {
+ 		/* programe secondary pixel clock */
+ 		POKE32(CRT_PLL_CTRL, formatPllReg(pll));
+ 		POKE32(CRT_HORIZONTAL_TOTAL, (((pModeParam->horizontal_total - 1)<<CRT_HORIZONTAL_TOTAL_TOTAL_SHIFT)&CRT_HORIZONTAL_TOTAL_TOTAL_MASK)|((pModeParam->horizontal_display_end - 1)&CRT_HORIZONTAL_TOTAL_DISPLAY_END_MASK));
+ 
+ 		POKE32(CRT_HORIZONTAL_SYNC, ((pModeParam->horizontal_sync_width<<CRT_HORIZONTAL_SYNC_WIDTH_SHIFT)&CRT_HORIZONTAL_SYNC_WIDTH_MASK)|((pModeParam->horizontal_sync_start - 1)&CRT_HORIZONTAL_SYNC_START_MASK));
+ 
+ 		POKE32(CRT_VERTICAL_TOTAL, (((pModeParam->vertical_total - 1)<<CRT_VERTICAL_TOTAL_TOTAL_SHIFT)&CRT_VERTICAL_TOTAL_TOTAL_MASK)|((pModeParam->vertical_display_end - 1)&CRT_VERTICAL_TOTAL_DISPLAY_END_MASK));
+ 
+ 		POKE32(CRT_VERTICAL_SYNC, ((pModeParam->vertical_sync_height<<CRT_VERTICAL_SYNC_HEIGHT_SHIFT)&CRT_VERTICAL_SYNC_HEIGHT_MASK)|((pModeParam->vertical_sync_start - 1)&CRT_VERTICAL_SYNC_START_MASK));
+ 
+ 
+ 		tmp = DISPLAY_CTRL_TIMING|DISPLAY_CTRL_PLANE;
+ 		if (pModeParam->vertical_sync_polarity)
+ 			tmp |= DISPLAY_CTRL_VSYNC_PHASE;
+ 		if (pModeParam->horizontal_sync_polarity)
+ 			tmp |= DISPLAY_CTRL_HSYNC_PHASE;
+ 
+ 		if (getChipType() == SM750LE) {
+ 			displayControlAdjust_SM750LE(pModeParam, tmp);
+ 		} else {
+ 			reg = PEEK32(CRT_DISPLAY_CTRL)&~(DISPLAY_CTRL_VSYNC_PHASE|DISPLAY_CTRL_HSYNC_PHASE|DISPLAY_CTRL_TIMING|DISPLAY_CTRL_PLANE);
+ 
+ 			 POKE32(CRT_DISPLAY_CTRL, tmp|reg);
+ 		}
+ 
+ 	} else if (pll->clockType == PRIMARY_PLL) {
+ 		unsigned int reserved;
+ 
+ 		POKE32(PANEL_PLL_CTRL, formatPllReg(pll));
+ 
+ 		reg = ((pModeParam->horizontal_total - 1)<<PANEL_HORIZONTAL_TOTAL_TOTAL_SHIFT)&PANEL_HORIZONTAL_TOTAL_TOTAL_MASK;
+ 		reg |= ((pModeParam->horizontal_display_end - 1)&PANEL_HORIZONTAL_TOTAL_DISPLAY_END_MASK);
+ 		POKE32(PANEL_HORIZONTAL_TOTAL, reg);
+ 
+ 		POKE32(PANEL_HORIZONTAL_SYNC, ((pModeParam->horizontal_sync_width<<PANEL_HORIZONTAL_SYNC_WIDTH_SHIFT)&PANEL_HORIZONTAL_SYNC_WIDTH_MASK)|((pModeParam->horizontal_sync_start - 1)&PANEL_HORIZONTAL_SYNC_START_MASK));
+ 
+ 		POKE32(PANEL_VERTICAL_TOTAL, (((pModeParam->vertical_total - 1)<<PANEL_VERTICAL_TOTAL_TOTAL_SHIFT)&PANEL_VERTICAL_TOTAL_TOTAL_MASK)|((pModeParam->vertical_display_end - 1)&PANEL_VERTICAL_TOTAL_DISPLAY_END_MASK));
+ 
+ 		POKE32(PANEL_VERTICAL_SYNC, ((pModeParam->vertical_sync_height<<PANEL_VERTICAL_SYNC_HEIGHT_SHIFT)&PANEL_VERTICAL_SYNC_HEIGHT_MASK)|((pModeParam->vertical_sync_start - 1)&PANEL_VERTICAL_SYNC_START_MASK));
+ 
+ 		tmp = DISPLAY_CTRL_TIMING|DISPLAY_CTRL_PLANE;
+ 		if (pModeParam->vertical_sync_polarity)
+ 			tmp |= DISPLAY_CTRL_VSYNC_PHASE;
+ 		if (pModeParam->horizontal_sync_polarity)
+ 			tmp |= DISPLAY_CTRL_HSYNC_PHASE;
+ 		if (pModeParam->clock_phase_polarity)
+ 			tmp |= DISPLAY_CTRL_CLOCK_PHASE;
+ 
+ 		reserved = PANEL_DISPLAY_CTRL_RESERVED_MASK|PANEL_DISPLAY_CTRL_VSYNC;
+ 
+ 		reg = (PEEK32(PANEL_DISPLAY_CTRL)&~reserved)&~(DISPLAY_CTRL_CLOCK_PHASE|DISPLAY_CTRL_VSYNC_PHASE|DISPLAY_CTRL_HSYNC_PHASE|DISPLAY_CTRL_TIMING|DISPLAY_CTRL_PLANE);
+ 
+ 		/* May a hardware bug or just my test chip (not confirmed).
+ 		* PANEL_DISPLAY_CTRL register seems requiring few writes
+ 		* before a value can be successfully written in.
+ 		* Added some masks to mask out the reserved bits.
+ 		* Note: This problem happens by design. The hardware will wait for the
+ 		*       next vertical sync to turn on/off the plane.
+ 		*/
+ 
+ 		POKE32(PANEL_DISPLAY_CTRL, tmp|reg);
+ 
+ 		while ((PEEK32(PANEL_DISPLAY_CTRL)&~reserved) !=
+ 			(tmp|reg)) {
+ 			cnt++;
+ 			if (cnt > 1000)
+ 				break;
+ 			POKE32(PANEL_DISPLAY_CTRL, tmp|reg);
+ 		}
+ 	} else {
+ 		ret = -1;
+ 	}
+ 	return ret;
+ }
+ 
+ int setModeTiming(mode_parameter_t *parm, clock_type_t clock)
+ {
+ 	pll_value_t pll;
+ 	unsigned int uiActualPixelClk;
+ 
+ 	pll.inputFreq = DEFAULT_INPUT_CLOCK;
+ 	pll.clockType = clock;
+ 
+ 	uiActualPixelClk = calcPllValue(parm->pixel_clock, &pll);
+ 	if (getChipType() == SM750LE) {
+ 		/* set graphic mode via IO method */
+ 		outb_p(0x88, 0x3d4);
+ 		outb_p(0x06, 0x3d5);
+ 	}
+ 	programModeRegisters(parm, &pll);
+ 	return 0;
+ }
+ 
+ 
diff -rcNP linux-4.4.24/drivers/staging/sm750fb/modedb.h linux-4.4.24-baikal/drivers/staging/sm750fb/modedb.h
*** linux-4.4.24/drivers/staging/sm750fb/modedb.h	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/staging/sm750fb/modedb.h	1970-01-01 03:00:00.000000000 +0300
***************
*** 1,233 ****
- 
- static const struct fb_videomode modedb2[] = {
- 	{
- 		/* 640x400 @ 70 Hz, 31.5 kHz hsync */
- 		NULL, 70, 640, 400, 39721, 40, 24, 39, 9, 96, 2,
- 		0, FB_VMODE_NONINTERLACED
- 	}, {
- 		/* 640x480 @ 60 Hz, 31.5 kHz hsync */
- 		NULL, 60, 640, 480, 39721, 40, 24, 32, 11, 96, 2,
- 		0, FB_VMODE_NONINTERLACED
- 	}, {
- 		/* 800x600 @ 56 Hz, 35.15 kHz hsync */
- 		NULL, 56, 800, 600, 27777, 128, 24, 22, 1, 72, 2,
- 		0, FB_VMODE_NONINTERLACED
- 	}, {
- 		/* 1024x768 @ 87 Hz interlaced, 35.5 kHz hsync */
- 		NULL, 87, 1024, 768, 22271, 56, 24, 33, 8, 160, 8,
- 		0, FB_VMODE_INTERLACED
- 	}, {
- 		/* 640x400 @ 85 Hz, 37.86 kHz hsync */
- 		NULL, 85, 640, 400, 31746, 96, 32, 41, 1, 64, 3,
- 		FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED
- 	}, {
- 		/* 640x480 @ 72 Hz, 36.5 kHz hsync */
- 		NULL, 72, 640, 480, 31746, 144, 40, 30, 8, 40, 3,
- 		0, FB_VMODE_NONINTERLACED
- 	}, {
- 		/* 640x480 @ 75 Hz, 37.50 kHz hsync */
- 		NULL, 75, 640, 480, 31746, 120, 16, 16, 1, 64, 3,
- 		0, FB_VMODE_NONINTERLACED
- 	}, {
- 		/* 800x600 @ 60 Hz, 37.8 kHz hsync */
- 		NULL, 60, 800, 600, 25000, 88, 40, 23, 1, 128, 4,
- 		FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT,
- 		FB_VMODE_NONINTERLACED
- 	}, {
- 		/* 640x480 @ 85 Hz, 43.27 kHz hsync */
- 		NULL, 85, 640, 480, 27777, 80, 56, 25, 1, 56, 3,
- 		0, FB_VMODE_NONINTERLACED
- 	}, {
- 		/* 1152x864 @ 89 Hz interlaced, 44 kHz hsync */
- 		NULL, 69, 1152, 864, 15384, 96, 16, 110, 1, 216, 10,
- 		0, FB_VMODE_INTERLACED
- 	}, {
- 		/* 800x600 @ 72 Hz, 48.0 kHz hsync */
- 		NULL, 72, 800, 600, 20000, 64, 56, 23, 37, 120, 6,
- 		FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT,
- 		FB_VMODE_NONINTERLACED
- 	}, {
- 		/* 1024x768 @ 60 Hz, 48.4 kHz hsync */
- 		NULL, 60, 1024, 768, 15384, 168, 8, 29, 3, 144, 6,
- 		0, FB_VMODE_NONINTERLACED
- 	}, {
- 		/* 640x480 @ 100 Hz, 53.01 kHz hsync */
- 		NULL, 100, 640, 480, 21834, 96, 32, 36, 8, 96, 6,
- 		0, FB_VMODE_NONINTERLACED
- 	}, {
- 		/* 1152x864 @ 60 Hz, 53.5 kHz hsync */
- 		NULL, 60, 1152, 864, 11123, 208, 64, 16, 4, 256, 8,
- 		0, FB_VMODE_NONINTERLACED
- 	}, {
- 		/* 800x600 @ 85 Hz, 55.84 kHz hsync */
- 		NULL, 85, 800, 600, 16460, 160, 64, 36, 16, 64, 5,
- 		0, FB_VMODE_NONINTERLACED
- 	}, {
- 		/* 1024x768 @ 70 Hz, 56.5 kHz hsync */
- 		NULL, 70, 1024, 768, 13333, 144, 24, 29, 3, 136, 6,
- 		0, FB_VMODE_NONINTERLACED
- 	}, {
- 		/*  1280x960-60 VESA */
- 		NULL, 60, 1280, 960, 9259, 312, 96, 36, 1, 112, 3,
- 		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
- 		FB_VMODE_NONINTERLACED, FB_MODE_IS_VESA
- 	}, {
- 		/*  1280x1024-60 VESA */
- 		NULL, 60, 1280, 1024, 9259, 248, 48, 38, 1, 112, 3,
- 		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
- 		FB_VMODE_NONINTERLACED, FB_MODE_IS_VESA
- 	}, {
- 		/* 1280x1024 @ 87 Hz interlaced, 51 kHz hsync */
- 		NULL, 87, 1280, 1024, 12500, 56, 16, 128, 1, 216, 12,
- 		0, FB_VMODE_INTERLACED
- 	}, {
- 		/* 800x600 @ 100 Hz, 64.02 kHz hsync */
- 		NULL, 100, 800, 600, 14357, 160, 64, 30, 4, 64, 6,
- 		0, FB_VMODE_NONINTERLACED
- 	}, {
- 		/* 1024x768 @ 76 Hz, 62.5 kHz hsync */
- 		NULL, 76, 1024, 768, 11764, 208, 8, 36, 16, 120, 3,
- 		0, FB_VMODE_NONINTERLACED
- 	}, {
- 		/* 1152x864 @ 70 Hz, 62.4 kHz hsync */
- 		NULL, 70, 1152, 864, 10869, 106, 56, 20, 1, 160, 10,
- 		0, FB_VMODE_NONINTERLACED
- 	}, {
- 		/* 1280x1024 @ 61 Hz, 64.2 kHz hsync */
- 		NULL, 61, 1280, 1024, 9090, 200, 48, 26, 1, 184, 3,
- 		0, FB_VMODE_NONINTERLACED
- 	}, {
- 		/* 1400x1050 @ 60Hz, 63.9 kHz hsync */
- 		NULL, 68, 1400, 1050, 9259, 136, 40, 13, 1, 112, 3,
- 		0, FB_VMODE_NONINTERLACED
- 	}, {
- 		/* 1400x1050 @ 75,107 Hz, 82,392 kHz +hsync +vsync*/
- 		NULL, 75, 1400, 1050, 9271, 120, 56, 13, 0, 112, 3,
- 		FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT,
- 		FB_VMODE_NONINTERLACED
- 	}, {
- 		/* 1400x1050 @ 60 Hz, ? kHz +hsync +vsync*/
- 		NULL, 60, 1400, 1050, 9259, 128, 40, 12, 0, 112, 3,
- 		FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT,
- 		FB_VMODE_NONINTERLACED
- 	}, {
- 		/* 1024x768 @ 85 Hz, 70.24 kHz hsync */
- 		NULL, 85, 1024, 768, 10111, 192, 32, 34, 14, 160, 6,
- 		0, FB_VMODE_NONINTERLACED
- 	}, {
- 		/* 1152x864 @ 78 Hz, 70.8 kHz hsync */
- 		NULL, 78, 1152, 864, 9090, 228, 88, 32, 0, 84, 12,
- 		0, FB_VMODE_NONINTERLACED
- 	}, {
- 		/* 1280x1024 @ 70 Hz, 74.59 kHz hsync */
- 		NULL, 70, 1280, 1024, 7905, 224, 32, 28, 8, 160, 8,
- 		0, FB_VMODE_NONINTERLACED
- 	}, {
- 		/* 1600x1200 @ 60Hz, 75.00 kHz hsync */
- 		NULL, 60, 1600, 1200, 6172, 304, 64, 46, 1, 192, 3,
- 		FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT,
- 		FB_VMODE_NONINTERLACED
- 	}, {
- 		/* 1152x864 @ 84 Hz, 76.0 kHz hsync */
- 		NULL, 84, 1152, 864, 7407, 184, 312, 32, 0, 128, 12,
- 		0, FB_VMODE_NONINTERLACED
- 	}, {
- 		/* 1280x1024 @ 74 Hz, 78.85 kHz hsync */
- 		NULL, 74, 1280, 1024, 7407, 256, 32, 34, 3, 144, 3,
- 		0, FB_VMODE_NONINTERLACED
- 	}, {
- 		/* 1024x768 @ 100Hz, 80.21 kHz hsync */
- 		NULL, 100, 1024, 768, 8658, 192, 32, 21, 3, 192, 10,
- 		0, FB_VMODE_NONINTERLACED
- 	}, {
- 		/* 1280x1024 @ 76 Hz, 81.13 kHz hsync */
- 		NULL, 76, 1280, 1024, 7407, 248, 32, 34, 3, 104, 3,
- 		0, FB_VMODE_NONINTERLACED
- 	}, {
- 		/* 1600x1200 @ 70 Hz, 87.50 kHz hsync */
- 		NULL, 70, 1600, 1200, 5291, 304, 64, 46, 1, 192, 3,
- 		0, FB_VMODE_NONINTERLACED
- 	}, {
- 		/* 1152x864 @ 100 Hz, 89.62 kHz hsync */
- 		NULL, 100, 1152, 864, 7264, 224, 32, 17, 2, 128, 19,
- 		0, FB_VMODE_NONINTERLACED
- 	}, {
- 		/* 1280x1024 @ 85 Hz, 91.15 kHz hsync */
- 		NULL, 85, 1280, 1024, 6349, 224, 64, 44, 1, 160, 3,
- 		FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT,
- 		FB_VMODE_NONINTERLACED
- 	}, {
- 		/* 1600x1200 @ 75 Hz, 93.75 kHz hsync */
- 		NULL, 75, 1600, 1200, 4938, 304, 64, 46, 1, 192, 3,
- 		FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT,
- 		FB_VMODE_NONINTERLACED
- 	}, {
- 		/* 1600x1200 @ 85 Hz, 105.77 kHz hsync */
- 		NULL, 85, 1600, 1200, 4545, 272, 16, 37, 4, 192, 3,
- 		FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT,
- 		FB_VMODE_NONINTERLACED
- 	}, {
- 		/* 1280x1024 @ 100 Hz, 107.16 kHz hsync */
- 		NULL, 100, 1280, 1024, 5502, 256, 32, 26, 7, 128, 15,
- 		0, FB_VMODE_NONINTERLACED
- 	}, {
- 		/* 1800x1440 @ 64Hz, 96.15 kHz hsync  */
- 		NULL, 64, 1800, 1440, 4347, 304, 96, 46, 1, 192, 3,
- 		FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT,
- 		FB_VMODE_NONINTERLACED
- 	}, {
- 		/* 1800x1440 @ 70Hz, 104.52 kHz hsync  */
- 		NULL, 70, 1800, 1440, 4000, 304, 96, 46, 1, 192, 3,
- 		FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT,
- 		FB_VMODE_NONINTERLACED
- 	}, {
- 		/* 512x384 @ 78 Hz, 31.50 kHz hsync */
- 		NULL, 78, 512, 384, 49603, 48, 16, 16, 1, 64, 3,
- 		0, FB_VMODE_NONINTERLACED
- 	}, {
- 		/* 512x384 @ 85 Hz, 34.38 kHz hsync */
- 		NULL, 85, 512, 384, 45454, 48, 16, 16, 1, 64, 3,
- 		0, FB_VMODE_NONINTERLACED
- 	}, {
- 		/* 320x200 @ 70 Hz, 31.5 kHz hsync, 8:5 aspect ratio */
- 		NULL, 70, 320, 200, 79440, 16, 16, 20, 4, 48, 1,
- 		0, FB_VMODE_DOUBLE
- 	}, {
- 		/* 320x240 @ 60 Hz, 31.5 kHz hsync, 4:3 aspect ratio */
- 		NULL, 60, 320, 240, 79440, 16, 16, 16, 5, 48, 1,
- 		0, FB_VMODE_DOUBLE
- 	}, {
- 		/* 320x240 @ 72 Hz, 36.5 kHz hsync */
- 		NULL, 72, 320, 240, 63492, 16, 16, 16, 4, 48, 2,
- 		0, FB_VMODE_DOUBLE
- 	}, {
- 		/* 400x300 @ 56 Hz, 35.2 kHz hsync, 4:3 aspect ratio */
- 		NULL, 56, 400, 300, 55555, 64, 16, 10, 1, 32, 1,
- 		0, FB_VMODE_DOUBLE
- 	}, {
- 		/* 400x300 @ 60 Hz, 37.8 kHz hsync */
- 		NULL, 60, 400, 300, 50000, 48, 16, 11, 1, 64, 2,
- 		0, FB_VMODE_DOUBLE
- 	}, {
- 		/* 400x300 @ 72 Hz, 48.0 kHz hsync */
- 		NULL, 72, 400, 300, 40000, 32, 24, 11, 19, 64, 3,
- 		0, FB_VMODE_DOUBLE
- 	}, {
- 		/* 480x300 @ 56 Hz, 35.2 kHz hsync, 8:5 aspect ratio */
- 		NULL, 56, 480, 300, 46176, 80, 16, 10, 1, 40, 1,
- 		0, FB_VMODE_DOUBLE
- 	}, {
- 		/* 480x300 @ 60 Hz, 37.8 kHz hsync */
- 		NULL, 60, 480, 300, 41858, 56, 16, 11, 1, 80, 2,
- 		0, FB_VMODE_DOUBLE
- 	}, {
- 		/* 480x300 @ 63 Hz, 39.6 kHz hsync */
- 		NULL, 63, 480, 300, 40000, 56, 16, 11, 1, 80, 2,
- 		0, FB_VMODE_DOUBLE
- 	}, {
- 		/* 480x300 @ 72 Hz, 48.0 kHz hsync */
- 		NULL, 72, 480, 300, 33386, 40, 24, 11, 19, 80, 3,
- 		0, FB_VMODE_DOUBLE
- 	},
- };
- static const int nmodedb2 = sizeof(modedb2);
--- 0 ----
diff -rcNP linux-4.4.24/drivers/staging/sm750fb/mode.h linux-4.4.24-baikal/drivers/staging/sm750fb/mode.h
*** linux-4.4.24/drivers/staging/sm750fb/mode.h	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/drivers/staging/sm750fb/mode.h	2016-11-11 14:49:54.000000000 +0300
***************
*** 0 ****
--- 1,40 ----
+ #ifndef MODE_H__
+ #define MODE_H__
+ 
+ #include "chip.h"
+ 
+ typedef enum _spolarity_t {
+     POS = 0, /* positive */
+     NEG, /* negative */
+ }
+ spolarity_t;
+ 
+ 
+ typedef struct _mode_parameter_t {
+     /* Horizontal timing. */
+     unsigned long horizontal_total;
+     unsigned long horizontal_display_end;
+     unsigned long horizontal_sync_start;
+     unsigned long horizontal_sync_width;
+     spolarity_t horizontal_sync_polarity;
+ 
+     /* Vertical timing. */
+     unsigned long vertical_total;
+     unsigned long vertical_display_end;
+     unsigned long vertical_sync_start;
+     unsigned long vertical_sync_height;
+     spolarity_t vertical_sync_polarity;
+ 
+     /* Refresh timing. */
+     unsigned long pixel_clock;
+     unsigned long horizontal_frequency;
+     unsigned long vertical_frequency;
+ 
+     /* Clock Phase. This clock phase only applies to Panel. */
+     spolarity_t clock_phase_polarity;
+ } mode_parameter_t;
+ 
+ int setModeTiming(mode_parameter_t *, clock_type_t);
+ 
+ 
+ #endif
diff -rcNP linux-4.4.24/drivers/staging/sm750fb/power.c linux-4.4.24-baikal/drivers/staging/sm750fb/power.c
*** linux-4.4.24/drivers/staging/sm750fb/power.c	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/drivers/staging/sm750fb/power.c	2016-11-11 14:49:54.000000000 +0300
***************
*** 0 ****
--- 1,160 ----
+ #include "help.h"
+ #include "reg.h"
+ #include "power.h"
+ 
+ void setDPMS(DPMS_t state) { /* Set DPMS state. DPMS is used for CRT head */
+     unsigned int value;
+ 
+     if (getChipType() == SM750LE) {
+ 	value = PEEK32(CRT_DISPLAY_CTRL)&~CRT_DISPLAY_CTRL_DPMS_MASK;
+ 	value |= (state<<CRT_DISPLAY_CTRL_DPMS_SHIFT);
+ 	POKE32(CRT_DISPLAY_CTRL, value);
+     } else {
+ 	value = PEEK32(SYSTEM_CTRL);
+ 	value = (value&~SYSTEM_CTRL_DPMS_MASK)|state;
+ 	POKE32(SYSTEM_CTRL, value);
+     }
+ }
+ 
+ static unsigned int getPowerMode(void)
+ {
+     if (getChipType() == SM750LE)
+ 	return 0;
+     return PEEK32(POWER_MODE_CTRL)&POWER_MODE_CTRL_MODE_MASK;
+ }
+ 
+ 
+ /*
+  * SM50x can operate in one of three modes: 0, 1 or Sleep.
+  * On hardware reset, power mode 0 is default.
+  */
+ void setPowerMode(unsigned int powerMode)
+ {
+     unsigned int control_value = 0;
+ 
+     control_value = PEEK32(POWER_MODE_CTRL)&~POWER_MODE_CTRL_MODE_MASK;
+ 
+     if (getChipType() == SM750LE)
+ 	return;
+ 
+     switch (powerMode) {
+     case POWER_MODE_CTRL_MODE_MODE0:
+ 	control_value |= POWER_MODE_CTRL_MODE_MODE0;
+ 	break;
+ 
+     case POWER_MODE_CTRL_MODE_MODE1:
+ 	control_value |= POWER_MODE_CTRL_MODE_MODE1;
+ 	break;
+ 
+     case POWER_MODE_CTRL_MODE_SLEEP:
+ 	control_value |= POWER_MODE_CTRL_MODE_SLEEP;
+ 	break;
+ 
+     default:
+ 	break;
+     }
+ 
+ /* Set up other fields in Power Control Register */
+     if (powerMode == POWER_MODE_CTRL_MODE_SLEEP) {
+ 	control_value &= ~POWER_MODE_CTRL_OSC_INPUT;
+ #ifdef VALIDATION_CHIP
+ 	control_value &= ~POWER_MODE_CTRL_336CLK;
+ #endif
+     } else {
+ 	control_value |= POWER_MODE_CTRL_OSC_INPUT;
+ #ifdef VALIDATION_CHIP
+ 	control_value |= POWER_MODE_CTRL_336CLK;
+ #endif
+     }
+ 
+     POKE32(POWER_MODE_CTRL, control_value);	/* Program new power mode. */
+ }
+ 
+ void setCurrentGate(unsigned int gate)
+ {
+     unsigned int gate_reg;
+     unsigned int mode;
+ 
+     /* Get current power mode. */
+     mode = getPowerMode();
+ 
+     switch (mode) {
+     case POWER_MODE_CTRL_MODE_MODE0:
+ 	gate_reg = MODE0_GATE;
+ 	break;
+ 
+     case POWER_MODE_CTRL_MODE_MODE1:
+ 	gate_reg = MODE1_GATE;
+ 	break;
+ 
+     default:
+ 	gate_reg = MODE0_GATE;
+ 	break;
+     }
+     POKE32(gate_reg, gate);
+ }
+ 
+ /*
+  * This function enable/disable the 2D engine.
+  */
+ void enable2DEngine(unsigned int enable)
+ {
+     u32 gate;
+ 
+     gate = PEEK32(CURRENT_GATE);
+     if (enable)
+ 	gate |= (CURRENT_GATE_DE|CURRENT_GATE_CSC);
+     else
+ 	gate &= ~(CURRENT_GATE_DE|CURRENT_GATE_CSC);
+ 
+     setCurrentGate(gate);
+ }
+ 
+ /*
+  * This function enable/disable the GPIO Engine
+  */
+ void enableGPIO(unsigned int enable)
+ {
+     u32 gate;
+ 
+     /* Enable GPIO Gate */
+     gate = PEEK32(CURRENT_GATE);
+     if (enable)
+ 	gate |= CURRENT_GATE_GPIO;
+     else
+ 	gate &= ~CURRENT_GATE_GPIO;
+ 
+     setCurrentGate(gate);
+ }
+ 
+ /*
+  * This function enable/disable the I2C Engine
+  */
+ void enableI2C(unsigned int enable)
+ {
+     u32 gate;
+ 
+     /* Enable I2C Gate */
+     gate = PEEK32(CURRENT_GATE);
+     if (enable)
+ 	gate |= CURRENT_GATE_I2C;
+     else
+ 	gate &= ~CURRENT_GATE_I2C;
+ 
+     setCurrentGate(gate);
+ }
+ 
+ void enableDMA(unsigned int enable)
+ {
+     u32 gate;
+ 
+     /* Enable DMA Gate */
+     gate = PEEK32(CURRENT_GATE);
+     if (enable)
+ 	gate |= CURRENT_GATE_DMA;
+     else
+ 	gate &= ~CURRENT_GATE_DMA;
+ 
+     setCurrentGate(gate);
+ }
+ 
diff -rcNP linux-4.4.24/drivers/staging/sm750fb/power.h linux-4.4.24-baikal/drivers/staging/sm750fb/power.h
*** linux-4.4.24/drivers/staging/sm750fb/power.h	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/drivers/staging/sm750fb/power.h	2016-11-11 14:49:54.000000000 +0300
***************
*** 0 ****
--- 1,48 ----
+ #ifndef POWER_H__
+ #define POWER_H__
+ 
+ typedef enum _DPMS_t {
+     crtDPMS_ON = 0x0,
+     crtDPMS_STANDBY = 0x1,
+     crtDPMS_SUSPEND = 0x2,
+     crtDPMS_OFF = 0x3,
+ } DPMS_t;
+ 
+ #define setDAC(off) {							\
+ 	POKE32(MISC_CTRL, (PEEK32(MISC_CTRL)&~MISC_CTRL_DAC_POWER_OFF)|(off)); \
+ }
+ 
+ void setDPMS(DPMS_t);
+ 
+ /*
+  * This function sets the current power mode
+  */
+ void setPowerMode(unsigned int powerMode);
+ 
+ /*
+  * This function sets current gate
+  */
+ void setCurrentGate(unsigned int gate);
+ 
+ /*
+  * This function enable/disable the 2D engine.
+  */
+ void enable2DEngine(unsigned int enable);
+ 
+ /*
+  * This function enable/disable the DMA Engine
+  */
+ void enableDMA(unsigned int enable);
+ 
+ /*
+  * This function enable/disable the GPIO Engine
+  */
+ void enableGPIO(unsigned int enable);
+ 
+ /*
+  * This function enable/disable the I2C Engine
+  */
+ void enableI2C(unsigned int enable);
+ 
+ 
+ #endif
diff -rcNP linux-4.4.24/drivers/staging/sm750fb/reg.h linux-4.4.24-baikal/drivers/staging/sm750fb/reg.h
*** linux-4.4.24/drivers/staging/sm750fb/reg.h	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/drivers/staging/sm750fb/reg.h	2016-11-11 14:49:54.000000000 +0300
***************
*** 0 ****
--- 1,1458 ----
+ #ifndef REG_H__
+ #define REG_H__
+ 
+ /* New register for SM750LE */
+ #define DE_STATE1                                        0x100054
+ #define DE_STATE1_DE_ABORT                               BIT(0)
+ 
+ #define DE_STATE2                                        0x100058
+ #define DE_STATE2_DE_FIFO_EMPTY                          BIT(3)
+ #define DE_STATE2_DE_STATUS_BUSY                         BIT(2)
+ #define DE_STATE2_DE_MEM_FIFO_EMPTY                      BIT(1)
+ 
+ #define SYSTEM_CTRL                                   0x000000
+ #define SYSTEM_CTRL_DPMS_MASK                         (0x3<<30)
+ #define SYSTEM_CTRL_DPMS_VPHP                         (0x0<<30)
+ #define SYSTEM_CTRL_DPMS_VPHN                         (0x1<<30)
+ #define SYSTEM_CTRL_DPMS_VNHP                         (0x2<<30)
+ #define SYSTEM_CTRL_DPMS_VNHN                         (0x3<<30)
+ #define SYSTEM_CTRL_PCI_BURST                         BIT(29)
+ #define SYSTEM_CTRL_PCI_MASTER                        BIT(25)
+ #define SYSTEM_CTRL_LATENCY_TIMER_OFF                 BIT(24)
+ #define SYSTEM_CTRL_DE_FIFO_EMPTY                     BIT(23)
+ #define SYSTEM_CTRL_DE_STATUS_BUSY                    BIT(22)
+ #define SYSTEM_CTRL_DE_MEM_FIFO_EMPTY                 BIT(21)
+ #define SYSTEM_CTRL_CSC_STATUS_BUSY                   BIT(20)
+ #define SYSTEM_CTRL_CRT_VSYNC_ACTIVE                  BIT(19)
+ #define SYSTEM_CTRL_PANEL_VSYNC_ACTIVE                BIT(18)
+ #define SYSTEM_CTRL_CURRENT_BUFFER_FLIP_PENDING       BIT(17)
+ #define SYSTEM_CTRL_DMA_STATUS_BUSY                   BIT(16)
+ #define SYSTEM_CTRL_PCI_BURST_READ                    BIT(15)
+ #define SYSTEM_CTRL_DE_ABORT                          BIT(13)
+ #define SYSTEM_CTRL_PCI_SUBSYS_ID_LOCK                BIT(11)
+ #define SYSTEM_CTRL_PCI_RETRY_OFF                     BIT(7)
+ #define SYSTEM_CTRL_PCI_SLAVE_BURST_READ_SIZE_MASK    (0x3<<4)
+ #define SYSTEM_CTRL_PCI_SLAVE_BURST_READ_SIZE_1       (0x0<<4)
+ #define SYSTEM_CTRL_PCI_SLAVE_BURST_READ_SIZE_2       (0x1<<4)
+ #define SYSTEM_CTRL_PCI_SLAVE_BURST_READ_SIZE_4       (0x2<<4)
+ #define SYSTEM_CTRL_PCI_SLAVE_BURST_READ_SIZE_8       (0x3<<4)
+ #define SYSTEM_CTRL_CRT_TRISTATE                      BIT(3)
+ #define SYSTEM_CTRL_PCIMEM_TRISTATE                   BIT(2)
+ #define SYSTEM_CTRL_LOCALMEM_TRISTATE                 BIT(1)
+ #define SYSTEM_CTRL_PANEL_TRISTATE                    BIT(0)
+ 
+ #define MISC_CTRL                                     0x000004
+ #define MISC_CTRL_DRAM_RERESH_COUNT                   BIT(27)
+ #define MISC_CTRL_DRAM_REFRESH_TIME_MASK              (0x3<<25)
+ #define MISC_CTRL_DRAM_REFRESH_TIME_8                 (0x0<<25)
+ #define MISC_CTRL_DRAM_REFRESH_TIME_16                (0x1<<25)
+ #define MISC_CTRL_DRAM_REFRESH_TIME_32                (0x2<<25)
+ #define MISC_CTRL_DRAM_REFRESH_TIME_64                (0x3<<25)
+ #define MISC_CTRL_INT_OUTPUT_INVERT                   BIT(24)
+ #define MISC_CTRL_PLL_CLK_COUNT                       BIT(23)
+ #define MISC_CTRL_DAC_POWER_OFF                       BIT(20)
+ #define MISC_CTRL_CLK_SELECT_TESTCLK                  BIT(16)
+ #define MISC_CTRL_DRAM_COLUMN_SIZE_MASK               (0x3<<14)
+ #define MISC_CTRL_DRAM_COLUMN_SIZE_256                (0x0<<14)
+ #define MISC_CTRL_DRAM_COLUMN_SIZE_512                (0x1<<14)
+ #define MISC_CTRL_DRAM_COLUMN_SIZE_1024               (0x2<<14)
+ #define MISC_CTRL_LOCALMEM_SIZE_MASK                  (0x3<<12)
+ #define MISC_CTRL_LOCALMEM_SIZE_8M                    (0x3<<12)
+ #define MISC_CTRL_LOCALMEM_SIZE_16M                   (0x0<<12)
+ #define MISC_CTRL_LOCALMEM_SIZE_32M                   (0x1<<12)
+ #define MISC_CTRL_LOCALMEM_SIZE_64M                   (0x2<<12)
+ #define MISC_CTRL_DRAM_TWTR                           BIT(11)
+ #define MISC_CTRL_DRAM_TWR                            BIT(10)
+ #define MISC_CTRL_DRAM_TRP                            BIT(9)
+ #define MISC_CTRL_DRAM_TRFC                           BIT(8)
+ #define MISC_CTRL_DRAM_TRAS                           BIT(7)
+ #define MISC_CTRL_LOCALMEM_RESET                      BIT(6)
+ #define MISC_CTRL_LOCALMEM_STATE_INACTIVE             BIT(5)
+ #define MISC_CTRL_CPU_CAS_LATENCY                     BIT(4)
+ #define MISC_CTRL_DLL_OFF                             BIT(3)
+ #define MISC_CTRL_DRAM_OUTPUT_HIGH                    BIT(2)
+ #define MISC_CTRL_LOCALMEM_BUS_SIZE                   BIT(1)
+ #define MISC_CTRL_EMBEDDED_LOCALMEM_OFF               BIT(0)
+ 
+ #define GPIO_MUX                                      0x000008
+ #define GPIO_MUX_31                                   BIT(31)
+ #define GPIO_MUX_30                                   BIT(30)
+ #define GPIO_MUX_29                                   BIT(29)
+ #define GPIO_MUX_28                                   BIT(28)
+ #define GPIO_MUX_27                                   BIT(27)
+ #define GPIO_MUX_26                                   BIT(26)
+ #define GPIO_MUX_25                                   BIT(25)
+ #define GPIO_MUX_24                                   BIT(24)
+ #define GPIO_MUX_23                                   BIT(23)
+ #define GPIO_MUX_22                                   BIT(22)
+ #define GPIO_MUX_21                                   BIT(21)
+ #define GPIO_MUX_20                                   BIT(20)
+ #define GPIO_MUX_19                                   BIT(19)
+ #define GPIO_MUX_18                                   BIT(18)
+ #define GPIO_MUX_17                                   BIT(17)
+ #define GPIO_MUX_16                                   BIT(16)
+ #define GPIO_MUX_15                                   BIT(15)
+ #define GPIO_MUX_14                                   BIT(14)
+ #define GPIO_MUX_13                                   BIT(13)
+ #define GPIO_MUX_12                                   BIT(12)
+ #define GPIO_MUX_11                                   BIT(11)
+ #define GPIO_MUX_10                                   BIT(10)
+ #define GPIO_MUX_9                                    BIT(9)
+ #define GPIO_MUX_8                                    BIT(8)
+ #define GPIO_MUX_7                                    BIT(7)
+ #define GPIO_MUX_6                                    BIT(6)
+ #define GPIO_MUX_5                                    BIT(5)
+ #define GPIO_MUX_4                                    BIT(4)
+ #define GPIO_MUX_3                                    BIT(3)
+ #define GPIO_MUX_2                                    BIT(2)
+ #define GPIO_MUX_1                                    BIT(1)
+ #define GPIO_MUX_0                                    BIT(0)
+ 
+ #define LOCALMEM_ARBITRATION                          0x00000C
+ #define LOCALMEM_ARBITRATION_ROTATE                   BIT(28)
+ #define LOCALMEM_ARBITRATION_VGA_MASK                 (0x7<<24)
+ #define LOCALMEM_ARBITRATION_VGA_OFF                  (0x0<<24)
+ #define LOCALMEM_ARBITRATION_VGA_PRIORITY_1           (0x1<<24)
+ #define LOCALMEM_ARBITRATION_VGA_PRIORITY_2           (0x2<<24)
+ #define LOCALMEM_ARBITRATION_VGA_PRIORITY_3           (0x3<<24)
+ #define LOCALMEM_ARBITRATION_VGA_PRIORITY_4           (0x4<<24)
+ #define LOCALMEM_ARBITRATION_VGA_PRIORITY_5           (0x5<<24)
+ #define LOCALMEM_ARBITRATION_VGA_PRIORITY_6           (0x6<<24)
+ #define LOCALMEM_ARBITRATION_VGA_PRIORITY_7           (0x7<<24)
+ #define LOCALMEM_ARBITRATION_DMA_MASK                 (0x7<<20)
+ #define LOCALMEM_ARBITRATION_DMA_OFF                  (0x0<<20)
+ #define LOCALMEM_ARBITRATION_DMA_PRIORITY_1           (0x1<<20)
+ #define LOCALMEM_ARBITRATION_DMA_PRIORITY_2           (0x2<<20)
+ #define LOCALMEM_ARBITRATION_DMA_PRIORITY_3           (0x3<<20)
+ #define LOCALMEM_ARBITRATION_DMA_PRIORITY_4           (0x4<<20)
+ #define LOCALMEM_ARBITRATION_DMA_PRIORITY_5           (0x5<<20)
+ #define LOCALMEM_ARBITRATION_DMA_PRIORITY_6           (0x6<<20)
+ #define LOCALMEM_ARBITRATION_DMA_PRIORITY_7           (0x7<<20)
+ #define LOCALMEM_ARBITRATION_ZVPORT1_MASK             (0x7<<16)
+ #define LOCALMEM_ARBITRATION_ZVPORT1_OFF              (0x0<<16)
+ #define LOCALMEM_ARBITRATION_ZVPORT1_PRIORITY_1       (0x1<<16)
+ #define LOCALMEM_ARBITRATION_ZVPORT1_PRIORITY_2       (0x2<<16)
+ #define LOCALMEM_ARBITRATION_ZVPORT1_PRIORITY_3       (0x3<<16)
+ #define LOCALMEM_ARBITRATION_ZVPORT1_PRIORITY_4       (0x4<<16)
+ #define LOCALMEM_ARBITRATION_ZVPORT1_PRIORITY_5       (0x5<<16)
+ #define LOCALMEM_ARBITRATION_ZVPORT1_PRIORITY_6       (0x6<<16)
+ #define LOCALMEM_ARBITRATION_ZVPORT1_PRIORITY_7       (0x7<<16)
+ #define LOCALMEM_ARBITRATION_ZVPORT0_MASK             (0x7<<12)
+ #define LOCALMEM_ARBITRATION_ZVPORT0_OFF              (0x0<<12)
+ #define LOCALMEM_ARBITRATION_ZVPORT0_PRIORITY_1       (0x1<<12)
+ #define LOCALMEM_ARBITRATION_ZVPORT0_PRIORITY_2       (0x2<<12)
+ #define LOCALMEM_ARBITRATION_ZVPORT0_PRIORITY_3       (0x3<<12)
+ #define LOCALMEM_ARBITRATION_ZVPORT0_PRIORITY_4       (0x4<<12)
+ #define LOCALMEM_ARBITRATION_ZVPORT0_PRIORITY_5       (0x5<<12)
+ #define LOCALMEM_ARBITRATION_ZVPORT0_PRIORITY_6       (0x6<<12)
+ #define LOCALMEM_ARBITRATION_ZVPORT0_PRIORITY_7       (0x7<<12)
+ #define LOCALMEM_ARBITRATION_VIDEO_MASK               (0x7<<8)
+ #define LOCALMEM_ARBITRATION_VIDEO_OFF                (0x0<<8)
+ #define LOCALMEM_ARBITRATION_VIDEO_PRIORITY_1         (0x1<<8)
+ #define LOCALMEM_ARBITRATION_VIDEO_PRIORITY_2         (0x2<<8)
+ #define LOCALMEM_ARBITRATION_VIDEO_PRIORITY_3         (0x3<<8)
+ #define LOCALMEM_ARBITRATION_VIDEO_PRIORITY_4         (0x4<<8)
+ #define LOCALMEM_ARBITRATION_VIDEO_PRIORITY_5         (0x5<<8)
+ #define LOCALMEM_ARBITRATION_VIDEO_PRIORITY_6         (0x6<<8)
+ #define LOCALMEM_ARBITRATION_VIDEO_PRIORITY_7         (0x7<<8)
+ #define LOCALMEM_ARBITRATION_PANEL_MASK               (0x7<<4)
+ #define LOCALMEM_ARBITRATION_PANEL_OFF                (0x0<<4)
+ #define LOCALMEM_ARBITRATION_PANEL_PRIORITY_1         (0x1<<4)
+ #define LOCALMEM_ARBITRATION_PANEL_PRIORITY_2         (0x2<<4)
+ #define LOCALMEM_ARBITRATION_PANEL_PRIORITY_3         (0x3<<4)
+ #define LOCALMEM_ARBITRATION_PANEL_PRIORITY_4         (0x4<<4)
+ #define LOCALMEM_ARBITRATION_PANEL_PRIORITY_5         (0x5<<4)
+ #define LOCALMEM_ARBITRATION_PANEL_PRIORITY_6         (0x6<<4)
+ #define LOCALMEM_ARBITRATION_PANEL_PRIORITY_7         (0x7<<4)
+ #define LOCALMEM_ARBITRATION_CRT_MASK                 0x7
+ #define LOCALMEM_ARBITRATION_CRT_OFF                  0x0
+ #define LOCALMEM_ARBITRATION_CRT_PRIORITY_1           0x1
+ #define LOCALMEM_ARBITRATION_CRT_PRIORITY_2           0x2
+ #define LOCALMEM_ARBITRATION_CRT_PRIORITY_3           0x3
+ #define LOCALMEM_ARBITRATION_CRT_PRIORITY_4           0x4
+ #define LOCALMEM_ARBITRATION_CRT_PRIORITY_5           0x5
+ #define LOCALMEM_ARBITRATION_CRT_PRIORITY_6           0x6
+ #define LOCALMEM_ARBITRATION_CRT_PRIORITY_7           0x7
+ 
+ #define PCIMEM_ARBITRATION                            0x000010
+ #define PCIMEM_ARBITRATION_ROTATE                     BIT(28)
+ #define PCIMEM_ARBITRATION_VGA_MASK                   (0x7<<24)
+ #define PCIMEM_ARBITRATION_VGA_OFF                    (0x0<<24)
+ #define PCIMEM_ARBITRATION_VGA_PRIORITY_1             (0x1<<24)
+ #define PCIMEM_ARBITRATION_VGA_PRIORITY_2             (0x2<<24)
+ #define PCIMEM_ARBITRATION_VGA_PRIORITY_3             (0x3<<24)
+ #define PCIMEM_ARBITRATION_VGA_PRIORITY_4             (0x4<<24)
+ #define PCIMEM_ARBITRATION_VGA_PRIORITY_5             (0x5<<24)
+ #define PCIMEM_ARBITRATION_VGA_PRIORITY_6             (0x6<<24)
+ #define PCIMEM_ARBITRATION_VGA_PRIORITY_7             (0x7<<24)
+ #define PCIMEM_ARBITRATION_DMA_MASK                   (0x7<<20)
+ #define PCIMEM_ARBITRATION_DMA_OFF                    (0x0<<20)
+ #define PCIMEM_ARBITRATION_DMA_PRIORITY_1             (0x1<<20)
+ #define PCIMEM_ARBITRATION_DMA_PRIORITY_2             (0x2<<20)
+ #define PCIMEM_ARBITRATION_DMA_PRIORITY_3             (0x3<<20)
+ #define PCIMEM_ARBITRATION_DMA_PRIORITY_4             (0x4<<20)
+ #define PCIMEM_ARBITRATION_DMA_PRIORITY_5             (0x5<<20)
+ #define PCIMEM_ARBITRATION_DMA_PRIORITY_6             (0x6<<20)
+ #define PCIMEM_ARBITRATION_DMA_PRIORITY_7             (0x7<<20)
+ #define PCIMEM_ARBITRATION_ZVPORT1_MASK               (0x7<<16)
+ #define PCIMEM_ARBITRATION_ZVPORT1_OFF                (0x0<<16)
+ #define PCIMEM_ARBITRATION_ZVPORT1_PRIORITY_1         (0x1<<16)
+ #define PCIMEM_ARBITRATION_ZVPORT1_PRIORITY_2         (0x2<<16)
+ #define PCIMEM_ARBITRATION_ZVPORT1_PRIORITY_3         (0x3<<16)
+ #define PCIMEM_ARBITRATION_ZVPORT1_PRIORITY_4         (0x4<<16)
+ #define PCIMEM_ARBITRATION_ZVPORT1_PRIORITY_5         (0x5<<16)
+ #define PCIMEM_ARBITRATION_ZVPORT1_PRIORITY_6         (0x6<<16)
+ #define PCIMEM_ARBITRATION_ZVPORT1_PRIORITY_7         (0x7<<16)
+ #define PCIMEM_ARBITRATION_ZVPORT0_MASK               (0x7<<12)
+ #define PCIMEM_ARBITRATION_ZVPORT0_OFF                (0x0<<12)
+ #define PCIMEM_ARBITRATION_ZVPORT0_PRIORITY_1         (0x1<<12)
+ #define PCIMEM_ARBITRATION_ZVPORT0_PRIORITY_2         (0x2<<12)
+ #define PCIMEM_ARBITRATION_ZVPORT0_PRIORITY_3         (0x3<<12)
+ #define PCIMEM_ARBITRATION_ZVPORT0_PRIORITY_4         (0x4<<12)
+ #define PCIMEM_ARBITRATION_ZVPORT0_PRIORITY_5         (0x5<<12)
+ #define PCIMEM_ARBITRATION_ZVPORT0_PRIORITY_6         (0x6<<12)
+ #define PCIMEM_ARBITRATION_ZVPORT0_PRIORITY_7         (0x7<<12)
+ #define PCIMEM_ARBITRATION_VIDEO_MASK                 (0x7<<8)
+ #define PCIMEM_ARBITRATION_VIDEO_OFF                  (0x0<<8)
+ #define PCIMEM_ARBITRATION_VIDEO_PRIORITY_1           (0x1<<8)
+ #define PCIMEM_ARBITRATION_VIDEO_PRIORITY_2           (0x2<<8)
+ #define PCIMEM_ARBITRATION_VIDEO_PRIORITY_3           (0x3<<8)
+ #define PCIMEM_ARBITRATION_VIDEO_PRIORITY_4           (0x4<<8)
+ #define PCIMEM_ARBITRATION_VIDEO_PRIORITY_5           (0x5<<8)
+ #define PCIMEM_ARBITRATION_VIDEO_PRIORITY_6           (0x6<<8)
+ #define PCIMEM_ARBITRATION_VIDEO_PRIORITY_7           (0x7<<8)
+ #define PCIMEM_ARBITRATION_PANEL_MASK                 (0x7<<4)
+ #define PCIMEM_ARBITRATION_PANEL_OFF                  (0x0<<4)
+ #define PCIMEM_ARBITRATION_PANEL_PRIORITY_1           (0x1<<4)
+ #define PCIMEM_ARBITRATION_PANEL_PRIORITY_2           (0x2<<4)
+ #define PCIMEM_ARBITRATION_PANEL_PRIORITY_3           (0x3<<4)
+ #define PCIMEM_ARBITRATION_PANEL_PRIORITY_4           (0x4<<4)
+ #define PCIMEM_ARBITRATION_PANEL_PRIORITY_5           (0x5<<4)
+ #define PCIMEM_ARBITRATION_PANEL_PRIORITY_6           (0x6<<4)
+ #define PCIMEM_ARBITRATION_PANEL_PRIORITY_7           (0x7<<4)
+ #define PCIMEM_ARBITRATION_CRT_MASK                   0x7
+ #define PCIMEM_ARBITRATION_CRT_OFF                    0x0
+ #define PCIMEM_ARBITRATION_CRT_PRIORITY_1             0x1
+ #define PCIMEM_ARBITRATION_CRT_PRIORITY_2             0x2
+ #define PCIMEM_ARBITRATION_CRT_PRIORITY_3             0x3
+ #define PCIMEM_ARBITRATION_CRT_PRIORITY_4             0x4
+ #define PCIMEM_ARBITRATION_CRT_PRIORITY_5             0x5
+ #define PCIMEM_ARBITRATION_CRT_PRIORITY_6             0x6
+ #define PCIMEM_ARBITRATION_CRT_PRIORITY_7             0x7
+ 
+ #define RAW_INT                                       0x000020
+ #define RAW_INT_ZVPORT1_VSYNC                         BIT(4)
+ #define RAW_INT_ZVPORT0_VSYNC                         BIT(3)
+ #define RAW_INT_CRT_VSYNC                             BIT(2)
+ #define RAW_INT_PANEL_VSYNC                           BIT(1)
+ #define RAW_INT_VGA_VSYNC                             BIT(0)
+ 
+ #define INT_STATUS                                    0x000024
+ #define INT_STATUS_GPIO31                             BIT(31)
+ #define INT_STATUS_GPIO30                             BIT(30)
+ #define INT_STATUS_GPIO29                             BIT(29)
+ #define INT_STATUS_GPIO28                             BIT(28)
+ #define INT_STATUS_GPIO27                             BIT(27)
+ #define INT_STATUS_GPIO26                             BIT(26)
+ #define INT_STATUS_GPIO25                             BIT(25)
+ #define INT_STATUS_I2C                                BIT(12)
+ #define INT_STATUS_PWM                                BIT(11)
+ #define INT_STATUS_DMA1                               BIT(10)
+ #define INT_STATUS_DMA0                               BIT(9)
+ #define INT_STATUS_PCI                                BIT(8)
+ #define INT_STATUS_SSP1                               BIT(7)
+ #define INT_STATUS_SSP0                               BIT(6)
+ #define INT_STATUS_DE                                 BIT(5)
+ #define INT_STATUS_ZVPORT1_VSYNC                      BIT(4)
+ #define INT_STATUS_ZVPORT0_VSYNC                      BIT(3)
+ #define INT_STATUS_CRT_VSYNC                          BIT(2)
+ #define INT_STATUS_PANEL_VSYNC                        BIT(1)
+ #define INT_STATUS_VGA_VSYNC                          BIT(0)
+ 
+ #define INT_MASK                                      0x000028
+ #define INT_MASK_GPIO31                               BIT(31)
+ #define INT_MASK_GPIO30                               BIT(30)
+ #define INT_MASK_GPIO29                               BIT(29)
+ #define INT_MASK_GPIO28                               BIT(28)
+ #define INT_MASK_GPIO27                               BIT(27)
+ #define INT_MASK_GPIO26                               BIT(26)
+ #define INT_MASK_GPIO25                               BIT(25)
+ #define INT_MASK_I2C                                  BIT(12)
+ #define INT_MASK_PWM                                  BIT(11)
+ #define INT_MASK_DMA1                                 BIT(10)
+ #define INT_MASK_DMA                                  BIT(9)
+ #define INT_MASK_PCI                                  BIT(8)
+ #define INT_MASK_SSP1                                 BIT(7)
+ #define INT_MASK_SSP0                                 BIT(6)
+ #define INT_MASK_DE                                   BIT(5)
+ #define INT_MASK_ZVPORT1_VSYNC                        BIT(4)
+ #define INT_MASK_ZVPORT0_VSYNC                        BIT(3)
+ #define INT_MASK_CRT_VSYNC                            BIT(2)
+ #define INT_MASK_PANEL_VSYNC                          BIT(1)
+ #define INT_MASK_VGA_VSYNC                            BIT(0)
+ 
+ #define CURRENT_GATE                                  0x000040
+ #define CURRENT_GATE_MCLK_MASK                        (0x3<<14)
+ #ifdef VALIDATION_CHIP
+     #define CURRENT_GATE_MCLK_112MHZ                  (0x0<<14)
+     #define CURRENT_GATE_MCLK_84MHZ                   (0x1<<14)
+     #define CURRENT_GATE_MCLK_56MHZ                   (0x2<<14)
+     #define CURRENT_GATE_MCLK_42MHZ                   (0x3<<14)
+ #else
+     #define CURRENT_GATE_MCLK_DIV_3                   (0x0<<14)
+     #define CURRENT_GATE_MCLK_DIV_4                   (0x1<<14)
+     #define CURRENT_GATE_MCLK_DIV_6                   (0x2<<14)
+     #define CURRENT_GATE_MCLK_DIV_8                   (0x3<<14)
+ #endif
+ #define CURRENT_GATE_M2XCLK_MASK                      (0x3<<12)
+ #ifdef VALIDATION_CHIP
+     #define CURRENT_GATE_M2XCLK_336MHZ                (0x0<<12)
+     #define CURRENT_GATE_M2XCLK_168MHZ                (0x1<<12)
+     #define CURRENT_GATE_M2XCLK_112MHZ                (0x2<<12)
+     #define CURRENT_GATE_M2XCLK_84MHZ                 (0x3<<12)
+ #else
+     #define CURRENT_GATE_M2XCLK_DIV_1                 (0x0<<12)
+     #define CURRENT_GATE_M2XCLK_DIV_2                 (0x1<<12)
+     #define CURRENT_GATE_M2XCLK_DIV_3                 (0x2<<12)
+     #define CURRENT_GATE_M2XCLK_DIV_4                 (0x3<<12)
+ #endif
+ #define CURRENT_GATE_VGA                              BIT(10)
+ #define CURRENT_GATE_PWM                              BIT(9)
+ #define CURRENT_GATE_I2C                              BIT(8)
+ #define CURRENT_GATE_SSP                              BIT(7)
+ #define CURRENT_GATE_GPIO                             BIT(6)
+ #define CURRENT_GATE_ZVPORT                           BIT(5)
+ #define CURRENT_GATE_CSC                              BIT(4)
+ #define CURRENT_GATE_DE                               BIT(3)
+ #define CURRENT_GATE_DISPLAY                          BIT(2)
+ #define CURRENT_GATE_LOCALMEM                         BIT(1)
+ #define CURRENT_GATE_DMA                              BIT(0)
+ 
+ #define MODE0_GATE                                    0x000044
+ #define MODE0_GATE_MCLK_MASK                          (0x3<<14)
+ #define MODE0_GATE_MCLK_112MHZ                        (0x0<<14)
+ #define MODE0_GATE_MCLK_84MHZ                         (0x1<<14)
+ #define MODE0_GATE_MCLK_56MHZ                         (0x2<<14)
+ #define MODE0_GATE_MCLK_42MHZ                         (0x3<<14)
+ #define MODE0_GATE_M2XCLK_MASK                        (0x3<<12)
+ #define MODE0_GATE_M2XCLK_336MHZ                      (0x0<<12)
+ #define MODE0_GATE_M2XCLK_168MHZ                      (0x1<<12)
+ #define MODE0_GATE_M2XCLK_112MHZ                      (0x2<<12)
+ #define MODE0_GATE_M2XCLK_84MHZ                       (0x3<<12)
+ #define MODE0_GATE_VGA                                BIT(10)
+ #define MODE0_GATE_PWM                                BIT(9)
+ #define MODE0_GATE_I2C                                BIT(8)
+ #define MODE0_GATE_SSP                                BIT(7)
+ #define MODE0_GATE_GPIO                               BIT(6)
+ #define MODE0_GATE_ZVPORT                             BIT(5)
+ #define MODE0_GATE_CSC                                BIT(4)
+ #define MODE0_GATE_DE                                 BIT(3)
+ #define MODE0_GATE_DISPLAY                            BIT(2)
+ #define MODE0_GATE_LOCALMEM                           BIT(1)
+ #define MODE0_GATE_DMA                                BIT(0)
+ 
+ #define MODE1_GATE                                    0x000048
+ #define MODE1_GATE_MCLK_MASK                          (0x3<<14)
+ #define MODE1_GATE_MCLK_112MHZ                        (0x0<<14)
+ #define MODE1_GATE_MCLK_84MHZ                         (0x1<<14)
+ #define MODE1_GATE_MCLK_56MHZ                         (0x2<<14)
+ #define MODE1_GATE_MCLK_42MHZ                         (0x3<<14)
+ #define MODE1_GATE_M2XCLK_MASK                        (0x3<<12)
+ #define MODE1_GATE_M2XCLK_336MHZ                      (0x0<<12)
+ #define MODE1_GATE_M2XCLK_168MHZ                      (0x1<<12)
+ #define MODE1_GATE_M2XCLK_112MHZ                      (0x2<<12)
+ #define MODE1_GATE_M2XCLK_84MHZ                       (0x3<<12)
+ #define MODE1_GATE_VGA                                BIT(10)
+ #define MODE1_GATE_PWM                                BIT(9)
+ #define MODE1_GATE_I2C                                BIT(8)
+ #define MODE1_GATE_SSP                                BIT(7)
+ #define MODE1_GATE_GPIO                               BIT(6)
+ #define MODE1_GATE_ZVPORT                             BIT(5)
+ #define MODE1_GATE_CSC                                BIT(4)
+ #define MODE1_GATE_DE                                 BIT(3)
+ #define MODE1_GATE_DISPLAY                            BIT(2)
+ #define MODE1_GATE_LOCALMEM                           BIT(1)
+ #define MODE1_GATE_DMA                                BIT(0)
+ 
+ #define POWER_MODE_CTRL                               0x00004C
+ #ifdef VALIDATION_CHIP
+     #define POWER_MODE_CTRL_336CLK                    BIT(4)
+ #endif
+ #define POWER_MODE_CTRL_OSC_INPUT                     BIT(3)
+ #define POWER_MODE_CTRL_ACPI                          BIT(2)
+ #define POWER_MODE_CTRL_MODE_MASK                     (0x3<<0)
+ #define POWER_MODE_CTRL_MODE_MODE0                    (0x0<<0)
+ #define POWER_MODE_CTRL_MODE_MODE1                    (0x1<<0)
+ #define POWER_MODE_CTRL_MODE_SLEEP                    (0x2<<0)
+ 
+ #define PCI_MASTER_BASE                               0x000050
+ #define PCI_MASTER_BASE_ADDRESS_MASK                  0xff
+ 
+ #define DEVICE_ID                                     0x000054
+ #define DEVICE_ID_DEVICE_ID_MASK                      (0xffff<<16)
+ #define DEVICE_ID_REVISION_ID_MASK                    0xff
+ 
+ #define PLL_CLK_COUNT                                 0x000058
+ #define PLL_CLK_COUNT_COUNTER_MASK                    0xffff
+ 
+ #define PANEL_PLL_CTRL                                0x00005C
+ #define PLL_CTRL_BYPASS                               BIT(18)
+ #define PLL_CTRL_POWER                                BIT(17)
+ #define PLL_CTRL_INPUT                                BIT(16)
+ #ifdef VALIDATION_CHIP
+     #define PLL_CTRL_OD_SHIFT                         14
+     #define PLL_CTRL_OD_MASK                          (0x3<<14)
+ #else
+     #define PLL_CTRL_POD_SHIFT                        14
+     #define PLL_CTRL_POD_MASK                         (0x3<<14)
+     #define PLL_CTRL_OD_SHIFT                         12
+     #define PLL_CTRL_OD_MASK                          (0x3<<12)
+ #endif
+ #define PLL_CTRL_N_SHIFT                              8
+ #define PLL_CTRL_N_MASK                               (0xf<<8)
+ #define PLL_CTRL_M_SHIFT                              0
+ #define PLL_CTRL_M_MASK                               0xff
+ 
+ #define CRT_PLL_CTRL                                  0x000060
+ 
+ #define VGA_PLL0_CTRL                                 0x000064
+ 
+ #define VGA_PLL1_CTRL                                 0x000068
+ 
+ #define SCRATCH_DATA                                  0x00006c
+ 
+ #ifndef VALIDATION_CHIP
+ 
+ #define MXCLK_PLL_CTRL                                0x000070
+ 
+ #define VGA_CONFIGURATION                             0x000088
+ #define VGA_CONFIGURATION_USER_DEFINE_MASK            (0x3<<4)
+ #define VGA_CONFIGURATION_PLL                         BIT(2)
+ #define VGA_CONFIGURATION_MODE                        BIT(1)
+ 
+ #endif
+ 
+ #define GPIO_DATA                                       0x010000
+ #define GPIO_DATA_31                                    BIT(31)
+ #define GPIO_DATA_30                                    BIT(30)
+ #define GPIO_DATA_29                                    BIT(29)
+ #define GPIO_DATA_28                                    BIT(28)
+ #define GPIO_DATA_27                                    BIT(27)
+ #define GPIO_DATA_26                                    BIT(26)
+ #define GPIO_DATA_25                                    BIT(25)
+ #define GPIO_DATA_24                                    BIT(24)
+ #define GPIO_DATA_23                                    BIT(23)
+ #define GPIO_DATA_22                                    BIT(22)
+ #define GPIO_DATA_21                                    BIT(21)
+ #define GPIO_DATA_20                                    BIT(20)
+ #define GPIO_DATA_19                                    BIT(19)
+ #define GPIO_DATA_18                                    BIT(18)
+ #define GPIO_DATA_17                                    BIT(17)
+ #define GPIO_DATA_16                                    BIT(16)
+ #define GPIO_DATA_15                                    BIT(15)
+ #define GPIO_DATA_14                                    BIT(14)
+ #define GPIO_DATA_13                                    BIT(13)
+ #define GPIO_DATA_12                                    BIT(12)
+ #define GPIO_DATA_11                                    BIT(11)
+ #define GPIO_DATA_10                                    BIT(10)
+ #define GPIO_DATA_9                                     BIT(9)
+ #define GPIO_DATA_8                                     BIT(8)
+ #define GPIO_DATA_7                                     BIT(7)
+ #define GPIO_DATA_6                                     BIT(6)
+ #define GPIO_DATA_5                                     BIT(5)
+ #define GPIO_DATA_4                                     BIT(4)
+ #define GPIO_DATA_3                                     BIT(3)
+ #define GPIO_DATA_2                                     BIT(2)
+ #define GPIO_DATA_1                                     BIT(1)
+ #define GPIO_DATA_0                                     BIT(0)
+ 
+ #define GPIO_DATA_DIRECTION                             0x010004
+ #define GPIO_DATA_DIRECTION_31                          BIT(31)
+ #define GPIO_DATA_DIRECTION_30                          BIT(30)
+ #define GPIO_DATA_DIRECTION_29                          BIT(29)
+ #define GPIO_DATA_DIRECTION_28                          BIT(28)
+ #define GPIO_DATA_DIRECTION_27                          BIT(27)
+ #define GPIO_DATA_DIRECTION_26                          BIT(26)
+ #define GPIO_DATA_DIRECTION_25                          BIT(25)
+ #define GPIO_DATA_DIRECTION_24                          BIT(24)
+ #define GPIO_DATA_DIRECTION_23                          BIT(23)
+ #define GPIO_DATA_DIRECTION_22                          BIT(22)
+ #define GPIO_DATA_DIRECTION_21                          BIT(21)
+ #define GPIO_DATA_DIRECTION_20                          BIT(20)
+ #define GPIO_DATA_DIRECTION_19                          BIT(19)
+ #define GPIO_DATA_DIRECTION_18                          BIT(18)
+ #define GPIO_DATA_DIRECTION_17                          BIT(17)
+ #define GPIO_DATA_DIRECTION_16                          BIT(16)
+ #define GPIO_DATA_DIRECTION_15                          BIT(15)
+ #define GPIO_DATA_DIRECTION_14                          BIT(14)
+ #define GPIO_DATA_DIRECTION_13                          BIT(13)
+ #define GPIO_DATA_DIRECTION_12                          BIT(12)
+ #define GPIO_DATA_DIRECTION_11                          BIT(11)
+ #define GPIO_DATA_DIRECTION_10                          BIT(10)
+ #define GPIO_DATA_DIRECTION_9                           BIT(9)
+ #define GPIO_DATA_DIRECTION_8                           BIT(8)
+ #define GPIO_DATA_DIRECTION_7                           BIT(7)
+ #define GPIO_DATA_DIRECTION_6                           BIT(6)
+ #define GPIO_DATA_DIRECTION_5                           BIT(5)
+ #define GPIO_DATA_DIRECTION_4                           BIT(4)
+ #define GPIO_DATA_DIRECTION_3                           BIT(3)
+ #define GPIO_DATA_DIRECTION_2                           BIT(2)
+ #define GPIO_DATA_DIRECTION_1                           BIT(1)
+ #define GPIO_DATA_DIRECTION_0                           BIT(0)
+ 
+ #define GPIO_INTERRUPT_SETUP                            0x010008
+ #define GPIO_INTERRUPT_SETUP_TRIGGER_31                 BIT(22)
+ #define GPIO_INTERRUPT_SETUP_TRIGGER_30                 BIT(21)
+ #define GPIO_INTERRUPT_SETUP_TRIGGER_29                 BIT(20)
+ #define GPIO_INTERRUPT_SETUP_TRIGGER_28                 BIT(19)
+ #define GPIO_INTERRUPT_SETUP_TRIGGER_27                 BIT(18)
+ #define GPIO_INTERRUPT_SETUP_TRIGGER_26                 BIT(17)
+ #define GPIO_INTERRUPT_SETUP_TRIGGER_25                 BIT(16)
+ #define GPIO_INTERRUPT_SETUP_ACTIVE_31                  BIT(14)
+ #define GPIO_INTERRUPT_SETUP_ACTIVE_30                  BIT(13)
+ #define GPIO_INTERRUPT_SETUP_ACTIVE_29                  BIT(12)
+ #define GPIO_INTERRUPT_SETUP_ACTIVE_28                  BIT(11)
+ #define GPIO_INTERRUPT_SETUP_ACTIVE_27                  BIT(10)
+ #define GPIO_INTERRUPT_SETUP_ACTIVE_26                  BIT(9)
+ #define GPIO_INTERRUPT_SETUP_ACTIVE_25                  BIT(8)
+ #define GPIO_INTERRUPT_SETUP_ENABLE_31                  BIT(6)
+ #define GPIO_INTERRUPT_SETUP_ENABLE_30                  BIT(5)
+ #define GPIO_INTERRUPT_SETUP_ENABLE_29                  BIT(4)
+ #define GPIO_INTERRUPT_SETUP_ENABLE_28                  BIT(3)
+ #define GPIO_INTERRUPT_SETUP_ENABLE_27                  BIT(2)
+ #define GPIO_INTERRUPT_SETUP_ENABLE_26                  BIT(1)
+ #define GPIO_INTERRUPT_SETUP_ENABLE_25                  BIT(0)
+ 
+ #define GPIO_INTERRUPT_STATUS                           0x01000C
+ #define GPIO_INTERRUPT_STATUS_31                        BIT(22)
+ #define GPIO_INTERRUPT_STATUS_30                        BIT(21)
+ #define GPIO_INTERRUPT_STATUS_29                        BIT(20)
+ #define GPIO_INTERRUPT_STATUS_28                        BIT(19)
+ #define GPIO_INTERRUPT_STATUS_27                        BIT(18)
+ #define GPIO_INTERRUPT_STATUS_26                        BIT(17)
+ #define GPIO_INTERRUPT_STATUS_25                        BIT(16)
+ 
+ 
+ #define PANEL_DISPLAY_CTRL                            0x080000
+ #define PANEL_DISPLAY_CTRL_RESERVED_MASK              0xc0f08000
+ #define PANEL_DISPLAY_CTRL_SELECT_SHIFT               28
+ #define PANEL_DISPLAY_CTRL_SELECT_MASK                (0x3<<28)
+ #define PANEL_DISPLAY_CTRL_SELECT_PANEL               (0x0<<28)
+ #define PANEL_DISPLAY_CTRL_SELECT_VGA                 (0x1<<28)
+ #define PANEL_DISPLAY_CTRL_SELECT_CRT                 (0x2<<28)
+ #define PANEL_DISPLAY_CTRL_FPEN                       BIT(27)
+ #define PANEL_DISPLAY_CTRL_VBIASEN                    BIT(26)
+ #define PANEL_DISPLAY_CTRL_DATA                       BIT(25)
+ #define PANEL_DISPLAY_CTRL_FPVDDEN                    BIT(24)
+ #define PANEL_DISPLAY_CTRL_DUAL_DISPLAY               BIT(19)
+ #define PANEL_DISPLAY_CTRL_DOUBLE_PIXEL               BIT(18)
+ #define PANEL_DISPLAY_CTRL_FIFO                       (0x3<<16)
+ #define PANEL_DISPLAY_CTRL_FIFO_1                     (0x0<<16)
+ #define PANEL_DISPLAY_CTRL_FIFO_3                     (0x1<<16)
+ #define PANEL_DISPLAY_CTRL_FIFO_7                     (0x2<<16)
+ #define PANEL_DISPLAY_CTRL_FIFO_11                    (0x3<<16)
+ #define DISPLAY_CTRL_CLOCK_PHASE                      BIT(14)
+ #define DISPLAY_CTRL_VSYNC_PHASE                      BIT(13)
+ #define DISPLAY_CTRL_HSYNC_PHASE                      BIT(12)
+ #define PANEL_DISPLAY_CTRL_VSYNC                      BIT(11)
+ #define PANEL_DISPLAY_CTRL_CAPTURE_TIMING             BIT(10)
+ #define PANEL_DISPLAY_CTRL_COLOR_KEY                  BIT(9)
+ #define DISPLAY_CTRL_TIMING                           BIT(8)
+ #define PANEL_DISPLAY_CTRL_VERTICAL_PAN_DIR           BIT(7)
+ #define PANEL_DISPLAY_CTRL_VERTICAL_PAN               BIT(6)
+ #define PANEL_DISPLAY_CTRL_HORIZONTAL_PAN_DIR         BIT(5)
+ #define PANEL_DISPLAY_CTRL_HORIZONTAL_PAN             BIT(4)
+ #define DISPLAY_CTRL_GAMMA                            BIT(3)
+ #define DISPLAY_CTRL_PLANE                            BIT(2)
+ #define PANEL_DISPLAY_CTRL_FORMAT                     (0x3<<0)
+ #define PANEL_DISPLAY_CTRL_FORMAT_8                   (0x0<<0)
+ #define PANEL_DISPLAY_CTRL_FORMAT_16                  (0x1<<0)
+ #define PANEL_DISPLAY_CTRL_FORMAT_32                  (0x2<<0)
+ 
+ #define PANEL_PAN_CTRL                                0x080004
+ #define PANEL_PAN_CTRL_VERTICAL_PAN_MASK              (0xff<<24)
+ #define PANEL_PAN_CTRL_VERTICAL_VSYNC_MASK            (0x3f<<16)
+ #define PANEL_PAN_CTRL_HORIZONTAL_PAN_MASK            (0xff<<8)
+ #define PANEL_PAN_CTRL_HORIZONTAL_VSYNC_MASK          0x3f
+ 
+ #define PANEL_COLOR_KEY                               0x080008
+ #define PANEL_COLOR_KEY_MASK_MASK                     (0xffff<<16)
+ #define PANEL_COLOR_KEY_VALUE_MASK                    0xffff
+ 
+ #define PANEL_FB_ADDRESS                              0x08000C
+ #define PANEL_FB_ADDRESS_STATUS                       BIT(31)
+ #define PANEL_FB_ADDRESS_EXT                          BIT(27)
+ #define PANEL_FB_ADDRESS_ADDRESS_MASK                 0x1ffffff
+ 
+ #define PANEL_FB_WIDTH                                0x080010
+ #define PANEL_FB_WIDTH_WIDTH_SHIFT                    16
+ #define PANEL_FB_WIDTH_WIDTH_MASK                     (0x3fff<<16)
+ #define PANEL_FB_WIDTH_OFFSET_MASK                    0x3fff
+ 
+ #define PANEL_WINDOW_WIDTH                            0x080014
+ #define PANEL_WINDOW_WIDTH_WIDTH_SHIFT                16
+ #define PANEL_WINDOW_WIDTH_WIDTH_MASK                 (0xfff<<16)
+ #define PANEL_WINDOW_WIDTH_X_MASK                     0xfff
+ 
+ #define PANEL_WINDOW_HEIGHT                           0x080018
+ #define PANEL_WINDOW_HEIGHT_HEIGHT_SHIFT              16
+ #define PANEL_WINDOW_HEIGHT_HEIGHT_MASK               (0xfff<<16)
+ #define PANEL_WINDOW_HEIGHT_Y_MASK                    0xfff
+ 
+ #define PANEL_PLANE_TL                                0x08001C
+ #define PANEL_PLANE_TL_TOP_SHIFT                      16
+ #define PANEL_PLANE_TL_TOP_MASK                       (0xeff<<16)
+ #define PANEL_PLANE_TL_LEFT_MASK                      0xeff
+ 
+ #define PANEL_PLANE_BR                                0x080020
+ #define PANEL_PLANE_BR_BOTTOM_SHIFT                   16
+ #define PANEL_PLANE_BR_BOTTOM_MASK                    (0xeff<<16)
+ #define PANEL_PLANE_BR_RIGHT_MASK                     0xeff
+ 
+ #define PANEL_HORIZONTAL_TOTAL                        0x080024
+ #define PANEL_HORIZONTAL_TOTAL_TOTAL_SHIFT            16
+ #define PANEL_HORIZONTAL_TOTAL_TOTAL_MASK             (0xfff<<16)
+ #define PANEL_HORIZONTAL_TOTAL_DISPLAY_END_MASK       0xfff
+ 
+ #define PANEL_HORIZONTAL_SYNC                         0x080028
+ #define PANEL_HORIZONTAL_SYNC_WIDTH_SHIFT             16
+ #define PANEL_HORIZONTAL_SYNC_WIDTH_MASK              (0xff<<16)
+ #define PANEL_HORIZONTAL_SYNC_START_MASK              0xfff
+ 
+ #define PANEL_VERTICAL_TOTAL                          0x08002C
+ #define PANEL_VERTICAL_TOTAL_TOTAL_SHIFT              16
+ #define PANEL_VERTICAL_TOTAL_TOTAL_MASK               (0x7ff<<16)
+ #define PANEL_VERTICAL_TOTAL_DISPLAY_END_MASK         0x7ff
+ 
+ #define PANEL_VERTICAL_SYNC                           0x080030
+ #define PANEL_VERTICAL_SYNC_HEIGHT_SHIFT              16
+ #define PANEL_VERTICAL_SYNC_HEIGHT_MASK               (0x3f<<16)
+ #define PANEL_VERTICAL_SYNC_START_MASK                0x7ff
+ 
+ #define PANEL_CURRENT_LINE                            0x080034
+ #define PANEL_CURRENT_LINE_LINE_MASK                  0x7ff
+ 
+ /* Video Control */
+ 
+ #define VIDEO_DISPLAY_CTRL                              0x080040
+ #define VIDEO_DISPLAY_CTRL_LINE_BUFFER                  BIT(18)
+ #define VIDEO_DISPLAY_CTRL_FIFO_MASK                    (0x3<<16)
+ #define VIDEO_DISPLAY_CTRL_FIFO_1                       (0x0<<16)
+ #define VIDEO_DISPLAY_CTRL_FIFO_3                       (0x1<<16)
+ #define VIDEO_DISPLAY_CTRL_FIFO_7                       (0x2<<16)
+ #define VIDEO_DISPLAY_CTRL_FIFO_11                      (0x3<<16)
+ #define VIDEO_DISPLAY_CTRL_BUFFER                       BIT(15)
+ #define VIDEO_DISPLAY_CTRL_CAPTURE                      BIT(14)
+ #define VIDEO_DISPLAY_CTRL_DOUBLE_BUFFER                BIT(13)
+ #define VIDEO_DISPLAY_CTRL_BYTE_SWAP                    BIT(12)
+ #define VIDEO_DISPLAY_CTRL_VERTICAL_SCALE               BIT(11)
+ #define VIDEO_DISPLAY_CTRL_HORIZONTAL_SCALE             BIT(10)
+ #define VIDEO_DISPLAY_CTRL_VERTICAL_MODE                BIT(9)
+ #define VIDEO_DISPLAY_CTRL_HORIZONTAL_MODE              BIT(8)
+ #define VIDEO_DISPLAY_CTRL_PIXEL_MASK                   (0xf<<4)
+ #define VIDEO_DISPLAY_CTRL_GAMMA                        BIT(3)
+ #define VIDEO_DISPLAY_CTRL_FORMAT_MASK                  0x3
+ #define VIDEO_DISPLAY_CTRL_FORMAT_8                     0x0
+ #define VIDEO_DISPLAY_CTRL_FORMAT_16                    0x1
+ #define VIDEO_DISPLAY_CTRL_FORMAT_32                    0x2
+ #define VIDEO_DISPLAY_CTRL_FORMAT_YUV                   0x3
+ 
+ #define VIDEO_FB_0_ADDRESS                            0x080044
+ #define VIDEO_FB_0_ADDRESS_STATUS                     BIT(31)
+ #define VIDEO_FB_0_ADDRESS_EXT                        BIT(27)
+ #define VIDEO_FB_0_ADDRESS_ADDRESS_MASK               0x3ffffff
+ 
+ #define VIDEO_FB_WIDTH                                0x080048
+ #define VIDEO_FB_WIDTH_WIDTH_MASK                     (0x3fff<<16)
+ #define VIDEO_FB_WIDTH_OFFSET_MASK                    0x3fff
+ 
+ #define VIDEO_FB_0_LAST_ADDRESS                       0x08004C
+ #define VIDEO_FB_0_LAST_ADDRESS_EXT                   BIT(27)
+ #define VIDEO_FB_0_LAST_ADDRESS_ADDRESS_MASK          0x3ffffff
+ 
+ #define VIDEO_PLANE_TL                                0x080050
+ #define VIDEO_PLANE_TL_TOP_MASK                       (0x7ff<<16)
+ #define VIDEO_PLANE_TL_LEFT_MASK                      0x7ff
+ 
+ #define VIDEO_PLANE_BR                                0x080054
+ #define VIDEO_PLANE_BR_BOTTOM_MASK                    (0x7ff<<16)
+ #define VIDEO_PLANE_BR_RIGHT_MASK                     0x7ff
+ 
+ #define VIDEO_SCALE                                   0x080058
+ #define VIDEO_SCALE_VERTICAL_MODE                     BIT(31)
+ #define VIDEO_SCALE_VERTICAL_SCALE_MASK               (0xfff<<16)
+ #define VIDEO_SCALE_HORIZONTAL_MODE                   BIT(15)
+ #define VIDEO_SCALE_HORIZONTAL_SCALE_MASK             0xfff
+ 
+ #define VIDEO_INITIAL_SCALE                           0x08005C
+ #define VIDEO_INITIAL_SCALE_FB_1_MASK                 (0xfff<<16)
+ #define VIDEO_INITIAL_SCALE_FB_0_MASK                 0xfff
+ 
+ #define VIDEO_YUV_CONSTANTS                           0x080060
+ #define VIDEO_YUV_CONSTANTS_Y_MASK                    (0xff<<24)
+ #define VIDEO_YUV_CONSTANTS_R_MASK                    (0xff<<16)
+ #define VIDEO_YUV_CONSTANTS_G_MASK                    (0xff<<8)
+ #define VIDEO_YUV_CONSTANTS_B_MASK                    0xff
+ 
+ #define VIDEO_FB_1_ADDRESS                            0x080064
+ #define VIDEO_FB_1_ADDRESS_STATUS                     BIT(31)
+ #define VIDEO_FB_1_ADDRESS_EXT                        BIT(27)
+ #define VIDEO_FB_1_ADDRESS_ADDRESS_MASK               0x3ffffff
+ 
+ #define VIDEO_FB_1_LAST_ADDRESS                       0x080068
+ #define VIDEO_FB_1_LAST_ADDRESS_EXT                   BIT(27)
+ #define VIDEO_FB_1_LAST_ADDRESS_ADDRESS_MASK          0x3ffffff
+ 
+ /* Video Alpha Control */
+ 
+ #define VIDEO_ALPHA_DISPLAY_CTRL                        0x080080
+ #define VIDEO_ALPHA_DISPLAY_CTRL_SELECT                 BIT(28)
+ #define VIDEO_ALPHA_DISPLAY_CTRL_ALPHA_MASK             (0xf<<24)
+ #define VIDEO_ALPHA_DISPLAY_CTRL_FIFO_MASK              (0x3<<16)
+ #define VIDEO_ALPHA_DISPLAY_CTRL_FIFO_1                 (0x0<<16)
+ #define VIDEO_ALPHA_DISPLAY_CTRL_FIFO_3                 (0x1<<16)
+ #define VIDEO_ALPHA_DISPLAY_CTRL_FIFO_7                 (0x2<<16)
+ #define VIDEO_ALPHA_DISPLAY_CTRL_FIFO_11                (0x3<<16)
+ #define VIDEO_ALPHA_DISPLAY_CTRL_VERT_SCALE             BIT(11)
+ #define VIDEO_ALPHA_DISPLAY_CTRL_HORZ_SCALE             BIT(10)
+ #define VIDEO_ALPHA_DISPLAY_CTRL_VERT_MODE              BIT(9)
+ #define VIDEO_ALPHA_DISPLAY_CTRL_HORZ_MODE              BIT(8)
+ #define VIDEO_ALPHA_DISPLAY_CTRL_PIXEL_MASK             (0xf<<4)
+ #define VIDEO_ALPHA_DISPLAY_CTRL_CHROMA_KEY             BIT(3)
+ #define VIDEO_ALPHA_DISPLAY_CTRL_FORMAT_MASK            0x3
+ #define VIDEO_ALPHA_DISPLAY_CTRL_FORMAT_8               0x0
+ #define VIDEO_ALPHA_DISPLAY_CTRL_FORMAT_16              0x1
+ #define VIDEO_ALPHA_DISPLAY_CTRL_FORMAT_ALPHA_4_4       0x2
+ #define VIDEO_ALPHA_DISPLAY_CTRL_FORMAT_ALPHA_4_4_4_4   0x3
+ 
+ #define VIDEO_ALPHA_FB_ADDRESS                        0x080084
+ #define VIDEO_ALPHA_FB_ADDRESS_STATUS                 BIT(31)
+ #define VIDEO_ALPHA_FB_ADDRESS_EXT                    BIT(27)
+ #define VIDEO_ALPHA_FB_ADDRESS_ADDRESS_MASK           0x3ffffff
+ 
+ #define VIDEO_ALPHA_FB_WIDTH                          0x080088
+ #define VIDEO_ALPHA_FB_WIDTH_WIDTH_MASK               (0x3fff<<16)
+ #define VIDEO_ALPHA_FB_WIDTH_OFFSET_MASK              0x3fff
+ 
+ #define VIDEO_ALPHA_FB_LAST_ADDRESS                   0x08008C
+ #define VIDEO_ALPHA_FB_LAST_ADDRESS_EXT               BIT(27)
+ #define VIDEO_ALPHA_FB_LAST_ADDRESS_ADDRESS_MASK      0x3ffffff
+ 
+ #define VIDEO_ALPHA_PLANE_TL                          0x080090
+ #define VIDEO_ALPHA_PLANE_TL_TOP_MASK                 (0x7ff<<16)
+ #define VIDEO_ALPHA_PLANE_TL_LEFT_MASK                0x7ff
+ 
+ #define VIDEO_ALPHA_PLANE_BR                          0x080094
+ #define VIDEO_ALPHA_PLANE_BR_BOTTOM_MASK              (0x7ff<<16)
+ #define VIDEO_ALPHA_PLANE_BR_RIGHT_MASK               0x7ff
+ 
+ #define VIDEO_ALPHA_SCALE                             0x080098
+ #define VIDEO_ALPHA_SCALE_VERTICAL_MODE               BIT(31)
+ #define VIDEO_ALPHA_SCALE_VERTICAL_SCALE_MASK         (0xfff<<16)
+ #define VIDEO_ALPHA_SCALE_HORIZONTAL_MODE             BIT(15)
+ #define VIDEO_ALPHA_SCALE_HORIZONTAL_SCALE_MASK       0xfff
+ 
+ #define VIDEO_ALPHA_INITIAL_SCALE                     0x08009C
+ #define VIDEO_ALPHA_INITIAL_SCALE_VERTICAL_MASK       (0xfff<<16)
+ #define VIDEO_ALPHA_INITIAL_SCALE_HORIZONTAL_MASK     0xfff
+ 
+ #define VIDEO_ALPHA_CHROMA_KEY                        0x0800A0
+ #define VIDEO_ALPHA_CHROMA_KEY_MASK_MASK              (0xffff<<16)
+ #define VIDEO_ALPHA_CHROMA_KEY_VALUE_MASK             0xffff
+ 
+ #define VIDEO_ALPHA_COLOR_LOOKUP_01                   0x0800A4
+ #define VIDEO_ALPHA_COLOR_LOOKUP_01_1_MASK            (0xffff<<16)
+ #define VIDEO_ALPHA_COLOR_LOOKUP_01_1_RED_MASK        (0x1f<<27)
+ #define VIDEO_ALPHA_COLOR_LOOKUP_01_1_GREEN_MASK      (0x3f<<21)
+ #define VIDEO_ALPHA_COLOR_LOOKUP_01_1_BLUE_MASK       (0x1f<<16)
+ #define VIDEO_ALPHA_COLOR_LOOKUP_01_0_MASK            0xffff
+ #define VIDEO_ALPHA_COLOR_LOOKUP_01_0_RED_MASK        (0x1f<<11)
+ #define VIDEO_ALPHA_COLOR_LOOKUP_01_0_GREEN_MASK      (0x3f<<5)
+ #define VIDEO_ALPHA_COLOR_LOOKUP_01_0_BLUE_MASK       0x1f
+ 
+ #define VIDEO_ALPHA_COLOR_LOOKUP_23                   0x0800A8
+ #define VIDEO_ALPHA_COLOR_LOOKUP_23_3_MASK            (0xffff<<16)
+ #define VIDEO_ALPHA_COLOR_LOOKUP_23_3_RED_MASK        (0x1f<<27)
+ #define VIDEO_ALPHA_COLOR_LOOKUP_23_3_GREEN_MASK      (0x3f<<21)
+ #define VIDEO_ALPHA_COLOR_LOOKUP_23_3_BLUE_MASK       (0x1f<<16)
+ #define VIDEO_ALPHA_COLOR_LOOKUP_23_2_MASK            0xffff
+ #define VIDEO_ALPHA_COLOR_LOOKUP_23_2_RED_MASK        (0x1f<<11)
+ #define VIDEO_ALPHA_COLOR_LOOKUP_23_2_GREEN_MASK      (0x3f<<5)
+ #define VIDEO_ALPHA_COLOR_LOOKUP_23_2_BLUE_MASK       0x1f
+ 
+ #define VIDEO_ALPHA_COLOR_LOOKUP_45                   0x0800AC
+ #define VIDEO_ALPHA_COLOR_LOOKUP_45_5_MASK            (0xffff<<16)
+ #define VIDEO_ALPHA_COLOR_LOOKUP_45_5_RED_MASK        (0x1f<<27)
+ #define VIDEO_ALPHA_COLOR_LOOKUP_45_5_GREEN_MASK      (0x3f<<21)
+ #define VIDEO_ALPHA_COLOR_LOOKUP_45_5_BLUE_MASK       (0x1f<<16)
+ #define VIDEO_ALPHA_COLOR_LOOKUP_45_4_MASK            0xffff
+ #define VIDEO_ALPHA_COLOR_LOOKUP_45_4_RED_MASK        (0x1f<<11)
+ #define VIDEO_ALPHA_COLOR_LOOKUP_45_4_GREEN_MASK      (0x3f<<5)
+ #define VIDEO_ALPHA_COLOR_LOOKUP_45_4_BLUE_MASK       0x1f
+ 
+ #define VIDEO_ALPHA_COLOR_LOOKUP_67                   0x0800B0
+ #define VIDEO_ALPHA_COLOR_LOOKUP_67_7_MASK            (0xffff<<16)
+ #define VIDEO_ALPHA_COLOR_LOOKUP_67_7_RED_MASK        (0x1f<<27)
+ #define VIDEO_ALPHA_COLOR_LOOKUP_67_7_GREEN_MASK      (0x3f<<21)
+ #define VIDEO_ALPHA_COLOR_LOOKUP_67_7_BLUE_MASK       (0x1f<<16)
+ #define VIDEO_ALPHA_COLOR_LOOKUP_67_6_MASK            0xffff
+ #define VIDEO_ALPHA_COLOR_LOOKUP_67_6_RED_MASK        (0x1f<<11)
+ #define VIDEO_ALPHA_COLOR_LOOKUP_67_6_GREEN_MASK      (0x3f<<5)
+ #define VIDEO_ALPHA_COLOR_LOOKUP_67_6_BLUE_MASK       0x1f
+ 
+ #define VIDEO_ALPHA_COLOR_LOOKUP_89                   0x0800B4
+ #define VIDEO_ALPHA_COLOR_LOOKUP_89_9_MASK            (0xffff<<16)
+ #define VIDEO_ALPHA_COLOR_LOOKUP_89_9_RED_MASK        (0x1f<<27)
+ #define VIDEO_ALPHA_COLOR_LOOKUP_89_9_GREEN_MASK      (0x3f<<21)
+ #define VIDEO_ALPHA_COLOR_LOOKUP_89_9_BLUE_MASK       (0x1f<<16)
+ #define VIDEO_ALPHA_COLOR_LOOKUP_89_8_MASK            0xffff
+ #define VIDEO_ALPHA_COLOR_LOOKUP_89_8_RED_MASK        (0x1f<<11)
+ #define VIDEO_ALPHA_COLOR_LOOKUP_89_8_GREEN_MASK      (0x3f<<5)
+ #define VIDEO_ALPHA_COLOR_LOOKUP_89_8_BLUE_MASK       0x1f
+ 
+ #define VIDEO_ALPHA_COLOR_LOOKUP_AB                   0x0800B8
+ #define VIDEO_ALPHA_COLOR_LOOKUP_AB_B_MASK            (0xffff<<16)
+ #define VIDEO_ALPHA_COLOR_LOOKUP_AB_B_RED_MASK        (0x1f<<27)
+ #define VIDEO_ALPHA_COLOR_LOOKUP_AB_B_GREEN_MASK      (0x3f<<21)
+ #define VIDEO_ALPHA_COLOR_LOOKUP_AB_B_BLUE_MASK       (0x1f<<16)
+ #define VIDEO_ALPHA_COLOR_LOOKUP_AB_A_MASK            0xffff
+ #define VIDEO_ALPHA_COLOR_LOOKUP_AB_A_RED_MASK        (0x1f<<11)
+ #define VIDEO_ALPHA_COLOR_LOOKUP_AB_A_GREEN_MASK      (0x3f<<5)
+ #define VIDEO_ALPHA_COLOR_LOOKUP_AB_A_BLUE_MASK       0x1f
+ 
+ #define VIDEO_ALPHA_COLOR_LOOKUP_CD                   0x0800BC
+ #define VIDEO_ALPHA_COLOR_LOOKUP_CD_D_MASK            (0xffff<<16)
+ #define VIDEO_ALPHA_COLOR_LOOKUP_CD_D_RED_MASK        (0x1f<<27)
+ #define VIDEO_ALPHA_COLOR_LOOKUP_CD_D_GREEN_MASK      (0x3f<<21)
+ #define VIDEO_ALPHA_COLOR_LOOKUP_CD_D_BLUE_MASK       (0x1f<<16)
+ #define VIDEO_ALPHA_COLOR_LOOKUP_CD_C_MASK            0xffff
+ #define VIDEO_ALPHA_COLOR_LOOKUP_CD_C_RED_MASK        (0x1f<<11)
+ #define VIDEO_ALPHA_COLOR_LOOKUP_CD_C_GREEN_MASK      (0x3f<<5)
+ #define VIDEO_ALPHA_COLOR_LOOKUP_CD_C_BLUE_MASK       0x1f
+ 
+ #define VIDEO_ALPHA_COLOR_LOOKUP_EF                   0x0800C0
+ #define VIDEO_ALPHA_COLOR_LOOKUP_EF_F_MASK            (0xffff<<16)
+ #define VIDEO_ALPHA_COLOR_LOOKUP_EF_F_RED_MASK        (0x1f<<27)
+ #define VIDEO_ALPHA_COLOR_LOOKUP_EF_F_GREEN_MASK      (0x3f<<21)
+ #define VIDEO_ALPHA_COLOR_LOOKUP_EF_F_BLUE_MASK       (0x1f<<16)
+ #define VIDEO_ALPHA_COLOR_LOOKUP_EF_E_MASK            0xffff
+ #define VIDEO_ALPHA_COLOR_LOOKUP_EF_E_RED_MASK        (0x1f<<11)
+ #define VIDEO_ALPHA_COLOR_LOOKUP_EF_E_GREEN_MASK      (0x3f<<5)
+ #define VIDEO_ALPHA_COLOR_LOOKUP_EF_E_BLUE_MASK       0x1f
+ 
+ /* Panel Cursor Control */
+ 
+ #define PANEL_HWC_ADDRESS                             0x0800F0
+ #define PANEL_HWC_ADDRESS_ENABLE                      BIT(31)
+ #define PANEL_HWC_ADDRESS_EXT                         BIT(27)
+ #define PANEL_HWC_ADDRESS_ADDRESS_MASK                0x3ffffff
+ 
+ #define PANEL_HWC_LOCATION                            0x0800F4
+ #define PANEL_HWC_LOCATION_TOP                        BIT(27)
+ #define PANEL_HWC_LOCATION_Y_MASK                     (0x7ff<<16)
+ #define PANEL_HWC_LOCATION_LEFT                       BIT(11)
+ #define PANEL_HWC_LOCATION_X_MASK                     0x7ff
+ 
+ #define PANEL_HWC_COLOR_12                            0x0800F8
+ #define PANEL_HWC_COLOR_12_2_RGB565_MASK              (0xffff<<16)
+ #define PANEL_HWC_COLOR_12_1_RGB565_MASK              0xffff
+ 
+ #define PANEL_HWC_COLOR_3                             0x0800FC
+ #define PANEL_HWC_COLOR_3_RGB565_MASK                 0xffff
+ 
+ /* Old Definitions +++ */
+ #define PANEL_HWC_COLOR_01                            0x0800F8
+ #define PANEL_HWC_COLOR_01_1_RED_MASK                 (0x1f<<27)
+ #define PANEL_HWC_COLOR_01_1_GREEN_MASK               (0x3f<<21)
+ #define PANEL_HWC_COLOR_01_1_BLUE_MASK                (0x1f<<16)
+ #define PANEL_HWC_COLOR_01_0_RED_MASK                 (0x1f<<11)
+ #define PANEL_HWC_COLOR_01_0_GREEN_MASK               (0x3f<<5)
+ #define PANEL_HWC_COLOR_01_0_BLUE_MASK                0x1f
+ 
+ #define PANEL_HWC_COLOR_2                             0x0800FC
+ #define PANEL_HWC_COLOR_2_RED_MASK                    (0x1f<<11)
+ #define PANEL_HWC_COLOR_2_GREEN_MASK                  (0x3f<<5)
+ #define PANEL_HWC_COLOR_2_BLUE_MASK                   0x1f
+ /* Old Definitions --- */
+ 
+ /* Alpha Control */
+ 
+ #define ALPHA_DISPLAY_CTRL                            0x080100
+ #define ALPHA_DISPLAY_CTRL_SELECT                     BIT(28)
+ #define ALPHA_DISPLAY_CTRL_ALPHA_MASK                 (0xf<<24)
+ #define ALPHA_DISPLAY_CTRL_FIFO_MASK                  (0x3<<16)
+ #define ALPHA_DISPLAY_CTRL_FIFO_1                     (0x0<<16)
+ #define ALPHA_DISPLAY_CTRL_FIFO_3                     (0x1<<16)
+ #define ALPHA_DISPLAY_CTRL_FIFO_7                     (0x2<<16)
+ #define ALPHA_DISPLAY_CTRL_FIFO_11                    (0x3<<16)
+ #define ALPHA_DISPLAY_CTRL_PIXEL_MASK                 (0xf<<4)
+ #define ALPHA_DISPLAY_CTRL_CHROMA_KEY                 BIT(3)
+ #define ALPHA_DISPLAY_CTRL_FORMAT_MASK                0x3
+ #define ALPHA_DISPLAY_CTRL_FORMAT_16                  0x1
+ #define ALPHA_DISPLAY_CTRL_FORMAT_ALPHA_4_4           0x2
+ #define ALPHA_DISPLAY_CTRL_FORMAT_ALPHA_4_4_4_4       0x3
+ 
+ #define ALPHA_FB_ADDRESS                              0x080104
+ #define ALPHA_FB_ADDRESS_STATUS                       BIT(31)
+ #define ALPHA_FB_ADDRESS_EXT                          BIT(27)
+ #define ALPHA_FB_ADDRESS_ADDRESS_MASK                 0x3ffffff
+ 
+ #define ALPHA_FB_WIDTH                                0x080108
+ #define ALPHA_FB_WIDTH_WIDTH_MASK                     (0x3fff<<16)
+ #define ALPHA_FB_WIDTH_OFFSET_MASK                    0x3fff
+ 
+ #define ALPHA_PLANE_TL                                0x08010C
+ #define ALPHA_PLANE_TL_TOP_MASK                       (0x7ff<<16)
+ #define ALPHA_PLANE_TL_LEFT_MASK                      0x7ff
+ 
+ #define ALPHA_PLANE_BR                                0x080110
+ #define ALPHA_PLANE_BR_BOTTOM_MASK                    (0x7ff<<16)
+ #define ALPHA_PLANE_BR_RIGHT_MASK                     0x7ff
+ 
+ #define ALPHA_CHROMA_KEY                              0x080114
+ #define ALPHA_CHROMA_KEY_MASK_MASK                    (0xffff<<16)
+ #define ALPHA_CHROMA_KEY_VALUE_MASK                   0xffff
+ 
+ #define ALPHA_COLOR_LOOKUP_01                         0x080118
+ #define ALPHA_COLOR_LOOKUP_01_1_MASK                  (0xffff<<16)
+ #define ALPHA_COLOR_LOOKUP_01_1_RED_MASK              (0x1f<<27)
+ #define ALPHA_COLOR_LOOKUP_01_1_GREEN_MASK            (0x3f<<21)
+ #define ALPHA_COLOR_LOOKUP_01_1_BLUE_MASK             (0x1f<<16)
+ #define ALPHA_COLOR_LOOKUP_01_0_MASK                  0xffff
+ #define ALPHA_COLOR_LOOKUP_01_0_RED_MASK              (0x1f<<11)
+ #define ALPHA_COLOR_LOOKUP_01_0_GREEN_MASK            (0x3f<<5)
+ #define ALPHA_COLOR_LOOKUP_01_0_BLUE_MASK             0x1f
+ 
+ #define ALPHA_COLOR_LOOKUP_23                         0x08011C
+ #define ALPHA_COLOR_LOOKUP_23_3_MASK                  (0xffff<<16)
+ #define ALPHA_COLOR_LOOKUP_23_3_RED_MASK              (0x1f<<27)
+ #define ALPHA_COLOR_LOOKUP_23_3_GREEN_MASK            (0x3f<<21)
+ #define ALPHA_COLOR_LOOKUP_23_3_BLUE_MASK             (0x1f<<16)
+ #define ALPHA_COLOR_LOOKUP_23_2_MASK                  0xffff
+ #define ALPHA_COLOR_LOOKUP_23_2_RED_MASK              (0x1f<<11)
+ #define ALPHA_COLOR_LOOKUP_23_2_GREEN_MASK            (0x3f<<5)
+ #define ALPHA_COLOR_LOOKUP_23_2_BLUE_MASK             0x1f
+ 
+ #define ALPHA_COLOR_LOOKUP_45                         0x080120
+ #define ALPHA_COLOR_LOOKUP_45_5_MASK                  (0xffff<<16)
+ #define ALPHA_COLOR_LOOKUP_45_5_RED_MASK              (0x1f<<27)
+ #define ALPHA_COLOR_LOOKUP_45_5_GREEN_MASK            (0x3f<<21)
+ #define ALPHA_COLOR_LOOKUP_45_5_BLUE_MASK             (0x1f<<16)
+ #define ALPHA_COLOR_LOOKUP_45_4_MASK                  0xffff
+ #define ALPHA_COLOR_LOOKUP_45_4_RED_MASK              (0x1f<<11)
+ #define ALPHA_COLOR_LOOKUP_45_4_GREEN_MASK            (0x3f<<5)
+ #define ALPHA_COLOR_LOOKUP_45_4_BLUE_MASK             0x1f
+ 
+ #define ALPHA_COLOR_LOOKUP_67                         0x080124
+ #define ALPHA_COLOR_LOOKUP_67_7_MASK                  (0xffff<<16)
+ #define ALPHA_COLOR_LOOKUP_67_7_RED_MASK              (0x1f<<27)
+ #define ALPHA_COLOR_LOOKUP_67_7_GREEN_MASK            (0x3f<<21)
+ #define ALPHA_COLOR_LOOKUP_67_7_BLUE_MASK             (0x1f<<16)
+ #define ALPHA_COLOR_LOOKUP_67_6_MASK                  0xffff
+ #define ALPHA_COLOR_LOOKUP_67_6_RED_MASK              (0x1f<<11)
+ #define ALPHA_COLOR_LOOKUP_67_6_GREEN_MASK            (0x3f<<5)
+ #define ALPHA_COLOR_LOOKUP_67_6_BLUE_MASK             0x1f
+ 
+ #define ALPHA_COLOR_LOOKUP_89                         0x080128
+ #define ALPHA_COLOR_LOOKUP_89_9_MASK                  (0xffff<<16)
+ #define ALPHA_COLOR_LOOKUP_89_9_RED_MASK              (0x1f<<27)
+ #define ALPHA_COLOR_LOOKUP_89_9_GREEN_MASK            (0x3f<<21)
+ #define ALPHA_COLOR_LOOKUP_89_9_BLUE_MASK             (0x1f<<16)
+ #define ALPHA_COLOR_LOOKUP_89_8_MASK                  0xffff
+ #define ALPHA_COLOR_LOOKUP_89_8_RED_MASK              (0x1f<<11)
+ #define ALPHA_COLOR_LOOKUP_89_8_GREEN_MASK            (0x3f<<5)
+ #define ALPHA_COLOR_LOOKUP_89_8_BLUE_MASK             0x1f
+ 
+ #define ALPHA_COLOR_LOOKUP_AB                         0x08012C
+ #define ALPHA_COLOR_LOOKUP_AB_B_MASK                  (0xffff<<16)
+ #define ALPHA_COLOR_LOOKUP_AB_B_RED_MASK              (0x1f<<27)
+ #define ALPHA_COLOR_LOOKUP_AB_B_GREEN_MASK            (0x3f<<21)
+ #define ALPHA_COLOR_LOOKUP_AB_B_BLUE_MASK             (0x1f<<16)
+ #define ALPHA_COLOR_LOOKUP_AB_A_MASK                  0xffff
+ #define ALPHA_COLOR_LOOKUP_AB_A_RED_MASK              (0x1f<<11)
+ #define ALPHA_COLOR_LOOKUP_AB_A_GREEN_MASK            (0x3f<<5)
+ #define ALPHA_COLOR_LOOKUP_AB_A_BLUE_MASK             0x1f
+ 
+ #define ALPHA_COLOR_LOOKUP_CD                         0x080130
+ #define ALPHA_COLOR_LOOKUP_CD_D_MASK                  (0xffff<<16)
+ #define ALPHA_COLOR_LOOKUP_CD_D_RED_MASK              (0x1f<<27)
+ #define ALPHA_COLOR_LOOKUP_CD_D_GREEN_MASK            (0x3f<<21)
+ #define ALPHA_COLOR_LOOKUP_CD_D_BLUE_MASK             (0x1f<<16)
+ #define ALPHA_COLOR_LOOKUP_CD_C_MASK                  0xffff
+ #define ALPHA_COLOR_LOOKUP_CD_C_RED_MASK              (0x1f<<11)
+ #define ALPHA_COLOR_LOOKUP_CD_C_GREEN_MASK            (0x3f<<5)
+ #define ALPHA_COLOR_LOOKUP_CD_C_BLUE_MASK             0x1f
+ 
+ #define ALPHA_COLOR_LOOKUP_EF                         0x080134
+ #define ALPHA_COLOR_LOOKUP_EF_F_MASK                  (0xffff<<16)
+ #define ALPHA_COLOR_LOOKUP_EF_F_RED_MASK              (0x1f<<27)
+ #define ALPHA_COLOR_LOOKUP_EF_F_GREEN_MASK            (0x3f<<21)
+ #define ALPHA_COLOR_LOOKUP_EF_F_BLUE_MASK             (0x1f<<16)
+ #define ALPHA_COLOR_LOOKUP_EF_E_MASK                  0xffff
+ #define ALPHA_COLOR_LOOKUP_EF_E_RED_MASK              (0x1f<<11)
+ #define ALPHA_COLOR_LOOKUP_EF_E_GREEN_MASK            (0x3f<<5)
+ #define ALPHA_COLOR_LOOKUP_EF_E_BLUE_MASK             0x1f
+ 
+ /* CRT Graphics Control */
+ 
+ #define CRT_DISPLAY_CTRL                              0x080200
+ #define CRT_DISPLAY_CTRL_RESERVED_MASK                0xfb008200
+ 
+ /* SM750LE definition */
+ #define CRT_DISPLAY_CTRL_DPMS_SHIFT                   30
+ #define CRT_DISPLAY_CTRL_DPMS_MASK                    (0x3<<30)
+ #define CRT_DISPLAY_CTRL_DPMS_0                       (0x0<<30)
+ #define CRT_DISPLAY_CTRL_DPMS_1                       (0x1<<30)
+ #define CRT_DISPLAY_CTRL_DPMS_2                       (0x2<<30)
+ #define CRT_DISPLAY_CTRL_DPMS_3                       (0x3<<30)
+ #define CRT_DISPLAY_CTRL_CLK_MASK                     (0x7<<27)
+ #define CRT_DISPLAY_CTRL_CLK_PLL25                    (0x0<<27)
+ #define CRT_DISPLAY_CTRL_CLK_PLL41                    (0x1<<27)
+ #define CRT_DISPLAY_CTRL_CLK_PLL62                    (0x2<<27)
+ #define CRT_DISPLAY_CTRL_CLK_PLL65                    (0x3<<27)
+ #define CRT_DISPLAY_CTRL_CLK_PLL74                    (0x4<<27)
+ #define CRT_DISPLAY_CTRL_CLK_PLL80                    (0x5<<27)
+ #define CRT_DISPLAY_CTRL_CLK_PLL108                   (0x6<<27)
+ #define CRT_DISPLAY_CTRL_CLK_RESERVED                 (0x7<<27)
+ #define CRT_DISPLAY_CTRL_SHIFT_VGA_DAC                BIT(26)
+ 
+ /* SM750LE definition */
+ #define CRT_DISPLAY_CTRL_CRTSELECT                    BIT(25)
+ #define CRT_DISPLAY_CTRL_RGBBIT                       BIT(24)
+ 
+ #ifndef VALIDATION_CHIP
+     #define CRT_DISPLAY_CTRL_CENTERING                BIT(24)
+ #endif
+ #define CRT_DISPLAY_CTRL_LOCK_TIMING                  BIT(23)
+ #define CRT_DISPLAY_CTRL_EXPANSION                    BIT(22)
+ #define CRT_DISPLAY_CTRL_VERTICAL_MODE                BIT(21)
+ #define CRT_DISPLAY_CTRL_HORIZONTAL_MODE              BIT(20)
+ #define CRT_DISPLAY_CTRL_SELECT_SHIFT                 18
+ #define CRT_DISPLAY_CTRL_SELECT_MASK                  (0x3<<18)
+ #define CRT_DISPLAY_CTRL_SELECT_PANEL                 (0x0<<18)
+ #define CRT_DISPLAY_CTRL_SELECT_VGA                   (0x1<<18)
+ #define CRT_DISPLAY_CTRL_SELECT_CRT                   (0x2<<18)
+ #define CRT_DISPLAY_CTRL_FIFO_MASK                    (0x3<<16)
+ #define CRT_DISPLAY_CTRL_FIFO_1                       (0x0<<16)
+ #define CRT_DISPLAY_CTRL_FIFO_3                       (0x1<<16)
+ #define CRT_DISPLAY_CTRL_FIFO_7                       (0x2<<16)
+ #define CRT_DISPLAY_CTRL_FIFO_11                      (0x3<<16)
+ #define CRT_DISPLAY_CTRL_BLANK                        BIT(10)
+ #define CRT_DISPLAY_CTRL_PIXEL_MASK                   (0xf<<4)
+ #define CRT_DISPLAY_CTRL_FORMAT_MASK                  (0x3<<0)
+ #define CRT_DISPLAY_CTRL_FORMAT_8                     (0x0<<0)
+ #define CRT_DISPLAY_CTRL_FORMAT_16                    (0x1<<0)
+ #define CRT_DISPLAY_CTRL_FORMAT_32                    (0x2<<0)
+ 
+ #define CRT_FB_ADDRESS                                0x080204
+ #define CRT_FB_ADDRESS_STATUS                         BIT(31)
+ #define CRT_FB_ADDRESS_EXT                            BIT(27)
+ #define CRT_FB_ADDRESS_ADDRESS_MASK                   0x3ffffff
+ 
+ #define CRT_FB_WIDTH                                  0x080208
+ #define CRT_FB_WIDTH_WIDTH_SHIFT                      16
+ #define CRT_FB_WIDTH_WIDTH_MASK                       (0x3fff<<16)
+ #define CRT_FB_WIDTH_OFFSET_MASK                      0x3fff
+ 
+ #define CRT_HORIZONTAL_TOTAL                          0x08020C
+ #define CRT_HORIZONTAL_TOTAL_TOTAL_SHIFT              16
+ #define CRT_HORIZONTAL_TOTAL_TOTAL_MASK               (0xfff<<16)
+ #define CRT_HORIZONTAL_TOTAL_DISPLAY_END_MASK         0xfff
+ 
+ #define CRT_HORIZONTAL_SYNC                           0x080210
+ #define CRT_HORIZONTAL_SYNC_WIDTH_SHIFT               16
+ #define CRT_HORIZONTAL_SYNC_WIDTH_MASK                (0xff<<16)
+ #define CRT_HORIZONTAL_SYNC_START_MASK                0xfff
+ 
+ #define CRT_VERTICAL_TOTAL                            0x080214
+ #define CRT_VERTICAL_TOTAL_TOTAL_SHIFT                16
+ #define CRT_VERTICAL_TOTAL_TOTAL_MASK                 (0x7ff<<16)
+ #define CRT_VERTICAL_TOTAL_DISPLAY_END_MASK           (0x7ff)
+ 
+ #define CRT_VERTICAL_SYNC                             0x080218
+ #define CRT_VERTICAL_SYNC_HEIGHT_SHIFT                16
+ #define CRT_VERTICAL_SYNC_HEIGHT_MASK                 (0x3f<<16)
+ #define CRT_VERTICAL_SYNC_START_MASK                  0x7ff
+ 
+ #define CRT_SIGNATURE_ANALYZER                        0x08021C
+ #define CRT_SIGNATURE_ANALYZER_STATUS_MASK            (0xffff<<16)
+ #define CRT_SIGNATURE_ANALYZER_ENABLE                 BIT(3)
+ #define CRT_SIGNATURE_ANALYZER_RESET                  BIT(2)
+ #define CRT_SIGNATURE_ANALYZER_SOURCE_MASK            0x3
+ #define CRT_SIGNATURE_ANALYZER_SOURCE_RED             0
+ #define CRT_SIGNATURE_ANALYZER_SOURCE_GREEN           1
+ #define CRT_SIGNATURE_ANALYZER_SOURCE_BLUE            2
+ 
+ #define CRT_CURRENT_LINE                              0x080220
+ #define CRT_CURRENT_LINE_LINE_MASK                    0x7ff
+ 
+ #define CRT_MONITOR_DETECT                            0x080224
+ #define CRT_MONITOR_DETECT_VALUE                      BIT(25)
+ #define CRT_MONITOR_DETECT_ENABLE                     BIT(24)
+ #define CRT_MONITOR_DETECT_RED_MASK                   (0xff<<16)
+ #define CRT_MONITOR_DETECT_GREEN_MASK                 (0xff<<8)
+ #define CRT_MONITOR_DETECT_BLUE_MASK                  0xff
+ 
+ #define CRT_SCALE                                     0x080228
+ #define CRT_SCALE_VERTICAL_MODE                       BIT(31)
+ #define CRT_SCALE_VERTICAL_SCALE_MASK                 (0xfff<<16)
+ #define CRT_SCALE_HORIZONTAL_MODE                     BIT(15)
+ #define CRT_SCALE_HORIZONTAL_SCALE_MASK               0xfff
+ 
+ /* CRT Cursor Control */
+ 
+ #define CRT_HWC_ADDRESS                               0x080230
+ #define CRT_HWC_ADDRESS_ENABLE                        BIT(31)
+ #define CRT_HWC_ADDRESS_EXT                           BIT(27)
+ #define CRT_HWC_ADDRESS_ADDRESS_MASK                  0x3ffffff
+ 
+ #define CRT_HWC_LOCATION                              0x080234
+ #define CRT_HWC_LOCATION_TOP                          BIT(27)
+ #define CRT_HWC_LOCATION_Y_MASK                       (0x7ff<<16)
+ #define CRT_HWC_LOCATION_LEFT                         BIT(11)
+ #define CRT_HWC_LOCATION_X_MASK                       0x7ff
+ 
+ #define CRT_HWC_COLOR_12                              0x080238
+ #define CRT_HWC_COLOR_12_2_RGB565_MASK                (0xffff<<16)
+ #define CRT_HWC_COLOR_12_1_RGB565_MASK                0xffff
+ 
+ #define CRT_HWC_COLOR_3                               0x08023C
+ #define CRT_HWC_COLOR_3_RGB565_MASK                   0xffff
+ 
+ /* This vertical expansion below start at 0x080240 ~ 0x080264 */
+ #define CRT_VERTICAL_EXPANSION                        0x080240
+ #ifndef VALIDATION_CHIP
+     #define CRT_VERTICAL_CENTERING_VALUE_MASK         (0xff<<24)
+ #endif
+ #define CRT_VERTICAL_EXPANSION_COMPARE_VALUE_MASK     (0xff<<16)
+ #define CRT_VERTICAL_EXPANSION_LINE_BUFFER_MASK       (0xf<<12)
+ #define CRT_VERTICAL_EXPANSION_SCALE_FACTOR_MASK      0xfff
+ 
+ /* This horizontal expansion below start at 0x080268 ~ 0x08027C */
+ #define CRT_HORIZONTAL_EXPANSION                      0x080268
+ #ifndef VALIDATION_CHIP
+     #define CRT_HORIZONTAL_CENTERING_VALUE_MASK       (0xff<<24)
+ #endif
+ #define CRT_HORIZONTAL_EXPANSION_COMPARE_VALUE_MASK   (0xff<<16)
+ #define CRT_HORIZONTAL_EXPANSION_SCALE_FACTOR_MASK    0xfff
+ 
+ #ifndef VALIDATION_CHIP
+     /* Auto Centering */
+     #define CRT_AUTO_CENTERING_TL                     0x080280
+     #define CRT_AUTO_CENTERING_TL_TOP_MASK            (0x7ff<<16)
+     #define CRT_AUTO_CENTERING_TL_LEFT_MASK           0x7ff
+ 
+     #define CRT_AUTO_CENTERING_BR                     0x080284
+     #define CRT_AUTO_CENTERING_BR_BOTTOM_MASK         (0x7ff<<16)
+     #define CRT_AUTO_CENTERING_BR_BOTTOM_SHIFT        16
+     #define CRT_AUTO_CENTERING_BR_RIGHT_MASK          0x7ff
+ #endif
+ 
+ /* sm750le new register to control panel output */
+ #define DISPLAY_CONTROL_750LE			      0x80288
+ /* Palette RAM */
+ 
+ /* Panel Palette register starts at 0x080400 ~ 0x0807FC */
+ #define PANEL_PALETTE_RAM                             0x080400
+ 
+ /* Panel Palette register starts at 0x080C00 ~ 0x080FFC */
+ #define CRT_PALETTE_RAM                               0x080C00
+ 
+ /* Color Space Conversion registers. */
+ 
+ #define CSC_Y_SOURCE_BASE                               0x1000C8
+ #define CSC_Y_SOURCE_BASE_EXT                           BIT(27)
+ #define CSC_Y_SOURCE_BASE_CS                            BIT(26)
+ #define CSC_Y_SOURCE_BASE_ADDRESS_MASK                  0x3ffffff
+ 
+ #define CSC_CONSTANTS                                   0x1000CC
+ #define CSC_CONSTANTS_Y_MASK                            (0xff<<24)
+ #define CSC_CONSTANTS_R_MASK                            (0xff<<16)
+ #define CSC_CONSTANTS_G_MASK                            (0xff<<8)
+ #define CSC_CONSTANTS_B_MASK                            0xff
+ 
+ #define CSC_Y_SOURCE_X                                  0x1000D0
+ #define CSC_Y_SOURCE_X_INTEGER_MASK                     (0x7ff<<16)
+ #define CSC_Y_SOURCE_X_FRACTION_MASK                    (0x1fff<<3)
+ 
+ #define CSC_Y_SOURCE_Y                                  0x1000D4
+ #define CSC_Y_SOURCE_Y_INTEGER_MASK                     (0xfff<<16)
+ #define CSC_Y_SOURCE_Y_FRACTION_MASK                    (0x1fff<<3)
+ 
+ #define CSC_U_SOURCE_BASE                               0x1000D8
+ #define CSC_U_SOURCE_BASE_EXT                           BIT(27)
+ #define CSC_U_SOURCE_BASE_CS                            BIT(26)
+ #define CSC_U_SOURCE_BASE_ADDRESS_MASK                  0x3ffffff
+ 
+ #define CSC_V_SOURCE_BASE                               0x1000DC
+ #define CSC_V_SOURCE_BASE_EXT                           BIT(27)
+ #define CSC_V_SOURCE_BASE_CS                            BIT(26)
+ #define CSC_V_SOURCE_BASE_ADDRESS_MASK                  0x3ffffff
+ 
+ #define CSC_SOURCE_DIMENSION                            0x1000E0
+ #define CSC_SOURCE_DIMENSION_X_MASK                     (0xffff<<16)
+ #define CSC_SOURCE_DIMENSION_Y_MASK                     0xffff
+ 
+ #define CSC_SOURCE_PITCH                                0x1000E4
+ #define CSC_SOURCE_PITCH_Y_MASK                         (0xffff<<16)
+ #define CSC_SOURCE_PITCH_UV_MASK                        0xffff
+ 
+ #define CSC_DESTINATION                                 0x1000E8
+ #define CSC_DESTINATION_WRAP                            BIT(31)
+ #define CSC_DESTINATION_X_MASK                          (0xfff<<16)
+ #define CSC_DESTINATION_Y_MASK                          0xfff
+ 
+ #define CSC_DESTINATION_DIMENSION                       0x1000EC
+ #define CSC_DESTINATION_DIMENSION_X_MASK                (0xffff<<16)
+ #define CSC_DESTINATION_DIMENSION_Y_MASK                0xffff
+ 
+ #define CSC_DESTINATION_PITCH                           0x1000F0
+ #define CSC_DESTINATION_PITCH_X_MASK                    (0xffff<<16)
+ #define CSC_DESTINATION_PITCH_Y_MASK                    0xffff
+ 
+ #define CSC_SCALE_FACTOR                                0x1000F4
+ #define CSC_SCALE_FACTOR_HORIZONTAL_MASK                (0xffff<<16)
+ #define CSC_SCALE_FACTOR_VERTICAL_MASK                  0xffff
+ 
+ #define CSC_DESTINATION_BASE                            0x1000F8
+ #define CSC_DESTINATION_BASE_EXT                        BIT(27)
+ #define CSC_DESTINATION_BASE_CS                         BIT(26)
+ #define CSC_DESTINATION_BASE_ADDRESS_MASK               0x3ffffff
+ 
+ #define CSC_CONTROL                                     0x1000FC
+ #define CSC_CONTROL_STATUS                              BIT(31)
+ #define CSC_CONTROL_SOURCE_FORMAT_MASK                  (0x7<<28)
+ #define CSC_CONTROL_SOURCE_FORMAT_YUV422                (0x0<<28)
+ #define CSC_CONTROL_SOURCE_FORMAT_YUV420I               (0x1<<28)
+ #define CSC_CONTROL_SOURCE_FORMAT_YUV420                (0x2<<28)
+ #define CSC_CONTROL_SOURCE_FORMAT_YVU9                  (0x3<<28)
+ #define CSC_CONTROL_SOURCE_FORMAT_IYU1                  (0x4<<28)
+ #define CSC_CONTROL_SOURCE_FORMAT_IYU2                  (0x5<<28)
+ #define CSC_CONTROL_SOURCE_FORMAT_RGB565                (0x6<<28)
+ #define CSC_CONTROL_SOURCE_FORMAT_RGB8888               (0x7<<28)
+ #define CSC_CONTROL_DESTINATION_FORMAT_MASK             (0x3<<26)
+ #define CSC_CONTROL_DESTINATION_FORMAT_RGB565           (0x0<<26)
+ #define CSC_CONTROL_DESTINATION_FORMAT_RGB8888          (0x1<<26)
+ #define CSC_CONTROL_HORIZONTAL_FILTER                   BIT(25)
+ #define CSC_CONTROL_VERTICAL_FILTER                     BIT(24)
+ #define CSC_CONTROL_BYTE_ORDER                          BIT(23)
+ 
+ #define DE_DATA_PORT                                    0x110000
+ 
+ #define I2C_BYTE_COUNT                                  0x010040
+ #define I2C_BYTE_COUNT_COUNT_MASK                       0xf
+ 
+ #define I2C_CTRL                                        0x010041
+ #define I2C_CTRL_INT                                    BIT(4)
+ #define I2C_CTRL_DIR                                    BIT(3)
+ #define I2C_CTRL_CTRL                                   BIT(2)
+ #define I2C_CTRL_MODE                                   BIT(1)
+ #define I2C_CTRL_EN                                     BIT(0)
+ 
+ #define I2C_STATUS                                      0x010042
+ #define I2C_STATUS_TX                                   BIT(3)
+ #define I2C_STATUS_ERR                                  BIT(2)
+ #define I2C_STATUS_ACK                                  BIT(1)
+ #define I2C_STATUS_BSY                                  BIT(0)
+ 
+ #define I2C_RESET                                       0x010042
+ #define I2C_RESET_BUS_ERROR                             BIT(2)
+ 
+ #define I2C_SLAVE_ADDRESS                               0x010043
+ #define I2C_SLAVE_ADDRESS_ADDRESS_MASK                  (0x7f<<1)
+ #define I2C_SLAVE_ADDRESS_RW                            BIT(0)
+ 
+ #define I2C_DATA0                                       0x010044
+ #define I2C_DATA1                                       0x010045
+ #define I2C_DATA2                                       0x010046
+ #define I2C_DATA3                                       0x010047
+ #define I2C_DATA4                                       0x010048
+ #define I2C_DATA5                                       0x010049
+ #define I2C_DATA6                                       0x01004A
+ #define I2C_DATA7                                       0x01004B
+ #define I2C_DATA8                                       0x01004C
+ #define I2C_DATA9                                       0x01004D
+ #define I2C_DATA10                                      0x01004E
+ #define I2C_DATA11                                      0x01004F
+ #define I2C_DATA12                                      0x010050
+ #define I2C_DATA13                                      0x010051
+ #define I2C_DATA14                                      0x010052
+ #define I2C_DATA15                                      0x010053
+ 
+ 
+ #define ZV0_CAPTURE_CTRL                                0x090000
+ #define ZV0_CAPTURE_CTRL_FIELD_INPUT                    BIT(27)
+ #define ZV0_CAPTURE_CTRL_SCAN                           BIT(26)
+ #define ZV0_CAPTURE_CTRL_CURRENT_BUFFER                 BIT(25)
+ #define ZV0_CAPTURE_CTRL_VERTICAL_SYNC                  BIT(24)
+ #define ZV0_CAPTURE_CTRL_ADJ                            BIT(19)
+ #define ZV0_CAPTURE_CTRL_HA                             BIT(18)
+ #define ZV0_CAPTURE_CTRL_VSK                            BIT(17)
+ #define ZV0_CAPTURE_CTRL_HSK                            BIT(16)
+ #define ZV0_CAPTURE_CTRL_FD                             BIT(15)
+ #define ZV0_CAPTURE_CTRL_VP                             BIT(14)
+ #define ZV0_CAPTURE_CTRL_HP                             BIT(13)
+ #define ZV0_CAPTURE_CTRL_CP                             BIT(12)
+ #define ZV0_CAPTURE_CTRL_UVS                            BIT(11)
+ #define ZV0_CAPTURE_CTRL_BS                             BIT(10)
+ #define ZV0_CAPTURE_CTRL_CS                             BIT(9)
+ #define ZV0_CAPTURE_CTRL_CF                             BIT(8)
+ #define ZV0_CAPTURE_CTRL_FS                             BIT(7)
+ #define ZV0_CAPTURE_CTRL_WEAVE                          BIT(6)
+ #define ZV0_CAPTURE_CTRL_BOB                            BIT(5)
+ #define ZV0_CAPTURE_CTRL_DB                             BIT(4)
+ #define ZV0_CAPTURE_CTRL_CC                             BIT(3)
+ #define ZV0_CAPTURE_CTRL_RGB                            BIT(2)
+ #define ZV0_CAPTURE_CTRL_656                            BIT(1)
+ #define ZV0_CAPTURE_CTRL_CAP                            BIT(0)
+ 
+ #define ZV0_CAPTURE_CLIP                                0x090004
+ #define ZV0_CAPTURE_CLIP_EYCLIP_MASK                    (0x3ff<<16)
+ #define ZV0_CAPTURE_CLIP_XCLIP_MASK                     0x3ff
+ 
+ #define ZV0_CAPTURE_SIZE                                0x090008
+ #define ZV0_CAPTURE_SIZE_HEIGHT_MASK                    (0x7ff<<16)
+ #define ZV0_CAPTURE_SIZE_WIDTH_MASK                     0x7ff
+ 
+ #define ZV0_CAPTURE_BUF0_ADDRESS                        0x09000C
+ #define ZV0_CAPTURE_BUF0_ADDRESS_STATUS                 BIT(31)
+ #define ZV0_CAPTURE_BUF0_ADDRESS_EXT                    BIT(27)
+ #define ZV0_CAPTURE_BUF0_ADDRESS_CS                     BIT(26)
+ #define ZV0_CAPTURE_BUF0_ADDRESS_ADDRESS_MASK           0x3ffffff
+ 
+ #define ZV0_CAPTURE_BUF1_ADDRESS                        0x090010
+ #define ZV0_CAPTURE_BUF1_ADDRESS_STATUS                 BIT(31)
+ #define ZV0_CAPTURE_BUF1_ADDRESS_EXT                    BIT(27)
+ #define ZV0_CAPTURE_BUF1_ADDRESS_CS                     BIT(26)
+ #define ZV0_CAPTURE_BUF1_ADDRESS_ADDRESS_MASK           0x3ffffff
+ 
+ #define ZV0_CAPTURE_BUF_OFFSET                          0x090014
+ #ifndef VALIDATION_CHIP
+     #define ZV0_CAPTURE_BUF_OFFSET_YCLIP_ODD_FIELD      (0x3ff<<16)
+ #endif
+ #define ZV0_CAPTURE_BUF_OFFSET_OFFSET_MASK              0xffff
+ 
+ #define ZV0_CAPTURE_FIFO_CTRL                           0x090018
+ #define ZV0_CAPTURE_FIFO_CTRL_FIFO_MASK                 0x7
+ #define ZV0_CAPTURE_FIFO_CTRL_FIFO_0                    0
+ #define ZV0_CAPTURE_FIFO_CTRL_FIFO_1                    1
+ #define ZV0_CAPTURE_FIFO_CTRL_FIFO_2                    2
+ #define ZV0_CAPTURE_FIFO_CTRL_FIFO_3                    3
+ #define ZV0_CAPTURE_FIFO_CTRL_FIFO_4                    4
+ #define ZV0_CAPTURE_FIFO_CTRL_FIFO_5                    5
+ #define ZV0_CAPTURE_FIFO_CTRL_FIFO_6                    6
+ #define ZV0_CAPTURE_FIFO_CTRL_FIFO_7                    7
+ 
+ #define ZV0_CAPTURE_YRGB_CONST                          0x09001C
+ #define ZV0_CAPTURE_YRGB_CONST_Y_MASK                   (0xff<<24)
+ #define ZV0_CAPTURE_YRGB_CONST_R_MASK                   (0xff<<16)
+ #define ZV0_CAPTURE_YRGB_CONST_G_MASK                   (0xff<<8)
+ #define ZV0_CAPTURE_YRGB_CONST_B_MASK                   0xff
+ 
+ #define ZV0_CAPTURE_LINE_COMP                           0x090020
+ #define ZV0_CAPTURE_LINE_COMP_LC_MASK                   0x7ff
+ 
+ /* ZV1 */
+ 
+ #define ZV1_CAPTURE_CTRL                                0x098000
+ #define ZV1_CAPTURE_CTRL_FIELD_INPUT                    BIT(27)
+ #define ZV1_CAPTURE_CTRL_SCAN                           BIT(26)
+ #define ZV1_CAPTURE_CTRL_CURRENT_BUFFER                 BIT(25)
+ #define ZV1_CAPTURE_CTRL_VERTICAL_SYNC                  BIT(24)
+ #define ZV1_CAPTURE_CTRL_PANEL                          BIT(20)
+ #define ZV1_CAPTURE_CTRL_ADJ                            BIT(19)
+ #define ZV1_CAPTURE_CTRL_HA                             BIT(18)
+ #define ZV1_CAPTURE_CTRL_VSK                            BIT(17)
+ #define ZV1_CAPTURE_CTRL_HSK                            BIT(16)
+ #define ZV1_CAPTURE_CTRL_FD                             BIT(15)
+ #define ZV1_CAPTURE_CTRL_VP                             BIT(14)
+ #define ZV1_CAPTURE_CTRL_HP                             BIT(13)
+ #define ZV1_CAPTURE_CTRL_CP                             BIT(12)
+ #define ZV1_CAPTURE_CTRL_UVS                            BIT(11)
+ #define ZV1_CAPTURE_CTRL_BS                             BIT(10)
+ #define ZV1_CAPTURE_CTRL_CS                             BIT(9)
+ #define ZV1_CAPTURE_CTRL_CF                             BIT(8)
+ #define ZV1_CAPTURE_CTRL_FS                             BIT(7)
+ #define ZV1_CAPTURE_CTRL_WEAVE                          BIT(6)
+ #define ZV1_CAPTURE_CTRL_BOB                            BIT(5)
+ #define ZV1_CAPTURE_CTRL_DB                             BIT(4)
+ #define ZV1_CAPTURE_CTRL_CC                             BIT(3)
+ #define ZV1_CAPTURE_CTRL_RGB                            BIT(2)
+ #define ZV1_CAPTURE_CTRL_656                            BIT(1)
+ #define ZV1_CAPTURE_CTRL_CAP                            BIT(0)
+ 
+ #define ZV1_CAPTURE_CLIP                                0x098004
+ #define ZV1_CAPTURE_CLIP_YCLIP_MASK                     (0x3ff<<16)
+ #define ZV1_CAPTURE_CLIP_XCLIP_MASK                     0x3ff
+ 
+ #define ZV1_CAPTURE_SIZE                                0x098008
+ #define ZV1_CAPTURE_SIZE_HEIGHT_MASK                    (0x7ff<<16)
+ #define ZV1_CAPTURE_SIZE_WIDTH_MASK                     0x7ff
+ 
+ #define ZV1_CAPTURE_BUF0_ADDRESS                        0x09800C
+ #define ZV1_CAPTURE_BUF0_ADDRESS_STATUS                 BIT(31)
+ #define ZV1_CAPTURE_BUF0_ADDRESS_EXT                    BIT(27)
+ #define ZV1_CAPTURE_BUF0_ADDRESS_CS                     BIT(26)
+ #define ZV1_CAPTURE_BUF0_ADDRESS_ADDRESS_MASK           0x3ffffff
+ 
+ #define ZV1_CAPTURE_BUF1_ADDRESS                        0x098010
+ #define ZV1_CAPTURE_BUF1_ADDRESS_STATUS                 BIT(31)
+ #define ZV1_CAPTURE_BUF1_ADDRESS_EXT                    BIT(27)
+ #define ZV1_CAPTURE_BUF1_ADDRESS_CS                     BIT(26)
+ #define ZV1_CAPTURE_BUF1_ADDRESS_ADDRESS_MASK           0x3ffffff
+ 
+ #define ZV1_CAPTURE_BUF_OFFSET                          0x098014
+ #define ZV1_CAPTURE_BUF_OFFSET_OFFSET_MASK              0xffff
+ 
+ #define ZV1_CAPTURE_FIFO_CTRL                           0x098018
+ #define ZV1_CAPTURE_FIFO_CTRL_FIFO_MASK                 0x7
+ #define ZV1_CAPTURE_FIFO_CTRL_FIFO_0                    0
+ #define ZV1_CAPTURE_FIFO_CTRL_FIFO_1                    1
+ #define ZV1_CAPTURE_FIFO_CTRL_FIFO_2                    2
+ #define ZV1_CAPTURE_FIFO_CTRL_FIFO_3                    3
+ #define ZV1_CAPTURE_FIFO_CTRL_FIFO_4                    4
+ #define ZV1_CAPTURE_FIFO_CTRL_FIFO_5                    5
+ #define ZV1_CAPTURE_FIFO_CTRL_FIFO_6                    6
+ #define ZV1_CAPTURE_FIFO_CTRL_FIFO_7                    7
+ 
+ #define ZV1_CAPTURE_YRGB_CONST                          0x09801C
+ #define ZV1_CAPTURE_YRGB_CONST_Y_MASK                   (0xff<<24)
+ #define ZV1_CAPTURE_YRGB_CONST_R_MASK                   (0xff<<16)
+ #define ZV1_CAPTURE_YRGB_CONST_G_MASK                   (0xff<<8)
+ #define ZV1_CAPTURE_YRGB_CONST_B_MASK                   0xff
+ 
+ #define DMA_1_SOURCE                                    0x0D0010
+ #define DMA_1_SOURCE_ADDRESS_EXT                        BIT(27)
+ #define DMA_1_SOURCE_ADDRESS_CS                         BIT(26)
+ #define DMA_1_SOURCE_ADDRESS_MASK                       0x3ffffff
+ 
+ #define DMA_1_DESTINATION                               0x0D0014
+ #define DMA_1_DESTINATION_ADDRESS_EXT                   BIT(27)
+ #define DMA_1_DESTINATION_ADDRESS_CS                    BIT(26)
+ #define DMA_1_DESTINATION_ADDRESS_MASK                  0x3ffffff
+ 
+ #define DMA_1_SIZE_CONTROL                              0x0D0018
+ #define DMA_1_SIZE_CONTROL_STATUS                       BIT(31)
+ #define DMA_1_SIZE_CONTROL_SIZE_MASK                    0xffffff
+ 
+ #define DMA_ABORT_INTERRUPT                             0x0D0020
+ #define DMA_ABORT_INTERRUPT_ABORT_1                     BIT(5)
+ #define DMA_ABORT_INTERRUPT_ABORT_0                     BIT(4)
+ #define DMA_ABORT_INTERRUPT_INT_1                       BIT(1)
+ #define DMA_ABORT_INTERRUPT_INT_0                       BIT(0)
+ 
+ /* Default i2c CLK and Data GPIO. These are the default i2c pins */
+ #define DEFAULT_I2C_SCL                     30
+ #define DEFAULT_I2C_SDA                     31
+ 
+ 
+ #define GPIO_DATA_SM750LE                               0x020018
+ #define GPIO_DATA_SM750LE_1                             BIT(1)
+ #define GPIO_DATA_SM750LE_0                             BIT(0)
+ 
+ #define GPIO_DATA_DIRECTION_SM750LE                     0x02001C
+ #define GPIO_DATA_DIRECTION_SM750LE_1                   BIT(1)
+ #define GPIO_DATA_DIRECTION_SM750LE_0                   BIT(0)
+ 
+ 
+ #endif
diff -rcNP linux-4.4.24/drivers/staging/sm750fb/sii164.c linux-4.4.24-baikal/drivers/staging/sm750fb/sii164.c
*** linux-4.4.24/drivers/staging/sm750fb/sii164.c	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/drivers/staging/sm750fb/sii164.c	2016-11-11 14:49:54.000000000 +0300
***************
*** 0 ****
--- 1,387 ----
+ #include <linux/printk.h>
+ 
+ #include "sii164.h"
+ 
+ #define SII164_I2C_ADDRESS 0x70	/* I2C Address of each SII164 chip, to merge with dvo_intel in future */
+ 
+ #ifdef USE_HW_I2C
+ #  include "hwi2c.h"
+ #  define sil164_write hw_i2c_write_reg
+ #  define sil164_read  hw_i2c_read_reg
+ #else
+ #  include "swi2c.h"
+ #  define sil164_write sw_i2c_write_reg
+ #  define sil164_read  sw_i2c_read_reg
+ #endif
+ 
+ #ifdef DEBUG
+ static void
+ sil164_set_power_state(bool on) {
+     uint8_t control0 = sil164_read(SII164_I2C_ADDRESS, SIL164_CONTROL0);
+ 
+     if (on)
+ 	control0 |= SIL164_CONTROL0_POWER_ON;
+     else
+ 	control0 &= ~SIL164_CONTROL0_POWER_ON;
+ 
+     sil164_write(SII164_I2C_ADDRESS, SIL164_CONTROL0, control0);
+ }
+ #endif
+ 
+ /* SII164 Vendor and Device ID */
+ #define SII164_VENDOR_ID                    0x0001
+ #define SII164_DEVICE_ID                    0x0006
+ 
+ #ifdef SII164_FULL_FUNCTIONS
+ 
+ static char *gDviCtrlChipName = "Silicon Image SiI 164";	/* Name of the DVI Controller chip */
+ 
+ #endif
+ 
+ /*
+  *  sii164GetVendorID
+  *      This function gets the vendor ID of the DVI controller chip.
+  *
+  *  Output:
+  *      Vendor ID
+  */
+ unsigned short sii164GetVendorID(void)
+ {
+     unsigned short vendorID;
+ 
+ 
+     vendorID = ((unsigned short) sil164_read(SII164_I2C_ADDRESS, SII164_VENDOR_ID_HIGH)<<8)|(unsigned short) sil164_read(SII164_I2C_ADDRESS, SII164_VENDOR_ID_LOW);
+     return vendorID;
+ }
+ 
+ /*
+  *  sii164GetDeviceID
+  *      This function gets the device ID of the DVI controller chip.
+  *
+  *  Output:
+  *      Device ID
+  */
+ unsigned short sii164GetDeviceID(void)
+ {
+     unsigned short deviceID;
+ 
+     deviceID = ((unsigned short) sil164_read(SII164_I2C_ADDRESS, SII164_DEVICE_ID_HIGH)<<8)|(unsigned short) sil164_read(SII164_I2C_ADDRESS, SII164_DEVICE_ID_LOW);
+     return deviceID;
+ }
+ 
+ 
+ /* DVI.C will handle all SiI164 chip stuffs and try it best to make code minimal and useful */
+ 
+ /*
+  *  sii164InitChip
+  *      This function initialize and detect the DVI controller chip.
+  *
+  *  Input:
+  *      edgeSelect          - Edge Select:
+  *                              0 = Input data is falling edge latched (falling edge
+  *                                  latched first in dual edge mode)
+  *                              1 = Input data is rising edge latched (rising edge
+  *                                  latched first in dual edge mode)
+  *      busSelect           - Input Bus Select:
+  *                              0 = Input data bus is 12-bits wide
+  *                              1 = Input data bus is 24-bits wide
+  *      dualEdgeClkSelect   - Dual Edge Clock Select
+  *                              0 = Input data is single edge latched
+  *                              1 = Input data is dual edge latched
+  *      hsyncEnable         - Horizontal Sync Enable:
+  *                              0 = HSYNC input is transmitted as fixed LOW
+  *                              1 = HSYNC input is transmitted as is
+  *      vsyncEnable         - Vertical Sync Enable:
+  *                              0 = VSYNC input is transmitted as fixed LOW
+  *                              1 = VSYNC input is transmitted as is
+  *      deskewEnable        - De-skewing Enable:
+  *                              0 = De-skew disabled
+  *                              1 = De-skew enabled
+  *      deskewSetting       - De-skewing Setting (increment of 260psec)
+  *                              0 = 1 step --> minimum setup/maximum hold
+  *                              1 = 2 step
+  *                              2 = 3 step
+  *                              3 = 4 step
+  *                              4 = 5 step
+  *                              5 = 6 step
+  *                              6 = 7 step
+  *                              7 = 8 step --> maximum setup/minimum hold
+  *      continuousSyncEnable- SYNC Continuous:
+  *                              0 = Disable
+  *                              1 = Enable
+  *      pllFilterEnable     - PLL Filter Enable
+  *                              0 = Disable PLL Filter
+  *                              1 = Enable PLL Filter
+  *      pllFilterValue      - PLL Filter characteristics:
+  *                              0~7 (recommended value is 4)
+  *
+  *  Output:
+  *      0   - Success
+  *     -1   - Fail.
+  */
+ 
+ /* TODO:
+ sm750_enable_dvo {
+     u32 temp = SM750_READ(dvo_reg);
+ 
+     dev_ops->mode_set(&intel_dvo->dev, &crtc->config->base.mode, &crtc->config->base.adjusted_mode);
+ 
+     SM750_WRITE(dvo_reg, temp|DVO_ENABLE);
+     SM750_READ(dvo_reg);
+ 
+     dev.dev_ops->dpms(&intel_dvo->dev, true);
+ }*/
+ 
+ // sil164_init_state
+ long sii164InitChip(unsigned char edgeSelect, unsigned char busSelect, unsigned char dualEdgeClkSelect, unsigned char hsyncEnable, unsigned char vsyncEnable, unsigned char deskewEnable, unsigned char deskewSetting, unsigned char continuousSyncEnable, unsigned char pllFilterEnable, unsigned char pllFilterValue) {
+     unsigned char config;
+ 
+     /* Initialize the i2c bus */
+ #ifdef USE_HW_I2C
+     hw_i2c_init(1);											/* Use fast mode. */
+ #else
+     sw_i2c_init(DEFAULT_I2C_SCL, DEFAULT_I2C_SDA);
+ #endif
+     if ((sii164GetVendorID() == SII164_VENDOR_ID) && (sii164GetDeviceID() == SII164_DEVICE_ID)) {	/* Check if SII164 Chip exists */
+ /*#ifdef DEBUG
+ 	sii164PrintRegisterValues();
+ #endif*/
+ 	/* Initialize SII164 controller chip. */
+ 	/* Select the edge */
+ 	if (edgeSelect == 0)
+ 	    config = SII164_CONFIGURATION_LATCH_FALLING;
+ 	else
+ 	    config = SII164_CONFIGURATION_LATCH_RISING;
+ 	/* Select bus wide */
+ 	if (busSelect == 0)
+ 	    config |= SII164_CONFIGURATION_BUS_12BITS;
+ 	else
+ 	    config |= SII164_CONFIGURATION_BUS_24BITS;
+ 	/* Select Dual/Single Edge Clock */
+ 	if (dualEdgeClkSelect == 0)
+ 	    config |= SII164_CONFIGURATION_CLOCK_SINGLE;
+ 	else
+ 	    config |= SII164_CONFIGURATION_CLOCK_DUAL;
+ 	/* Select HSync Enable */
+ 	if (hsyncEnable == 0)
+ 	    config |= SII164_CONFIGURATION_HSYNC_FORCE_LOW;
+ 	else
+ 	    config |= SII164_CONFIGURATION_HSYNC_AS_IS;
+ 	/* Select VSync Enable */
+ 	if (vsyncEnable == 0)
+ 	    config |= SII164_CONFIGURATION_VSYNC_FORCE_LOW;
+ 	else
+ 	    config |= SII164_CONFIGURATION_VSYNC_AS_IS;
+ 	sil164_write(SII164_I2C_ADDRESS, SII164_CONFIGURATION, config);
+ 
+ 	/* De-skew enabled with default 111b value. This will fix some artifacts problem in some mode on board 2.2. Somehow this fix does not affect board 2.1. */
+ 	if (deskewEnable == 0)
+ 	    config = SII164_DESKEW_DISABLE;
+ 	else
+ 	    config = SII164_DESKEW_ENABLE;
+ 	switch (deskewSetting) {
+ 	case 0:
+ 	    config |= SII164_DESKEW_1_STEP;
+ 	    break;
+ 	case 1:
+ 	    config |= SII164_DESKEW_2_STEP;
+ 	    break;
+ 	case 2:
+ 	    config |= SII164_DESKEW_3_STEP;
+ 	    break;
+ 	case 3:
+ 	    config |= SII164_DESKEW_4_STEP;
+ 	    break;
+ 	case 4:
+ 	    config |= SII164_DESKEW_5_STEP;
+ 	    break;
+ 	case 5:
+ 	    config |= SII164_DESKEW_6_STEP;
+ 	    break;
+ 	case 6:
+ 	    config |= SII164_DESKEW_7_STEP;
+ 	    break;
+ 	case 7:
+ 	    config |= SII164_DESKEW_8_STEP;
+ 	    break;
+ 	}
+ 	sil164_write(SII164_I2C_ADDRESS, SII164_DESKEW, config);
+ 
+ 	/* Enable/Disable Continuous Sync. */
+ 	if (continuousSyncEnable == 0)
+ 	    config = SII164_PLL_FILTER_SYNC_CONTINUOUS_DISABLE;
+ 	else
+ 	    config = SII164_PLL_FILTER_SYNC_CONTINUOUS_ENABLE;
+ 	/* Enable/Disable PLL Filter */
+ 	if (pllFilterEnable == 0)
+ 	    config |= SII164_PLL_FILTER_DISABLE;
+ 	else
+ 	    config |= SII164_PLL_FILTER_ENABLE;
+ 	/* Set the PLL Filter value */
+ 	config |= ((pllFilterValue&0x07)<<1);
+ 	sil164_write(SII164_I2C_ADDRESS, SII164_PLL, config);
+ 
+ 	/* Recover from Power Down and enable output. */
+ 	config = sil164_read(SII164_I2C_ADDRESS, SII164_CONFIGURATION);
+ 	config |= SII164_CONFIGURATION_POWER_NORMAL;
+ 	sil164_write(SII164_I2C_ADDRESS, SII164_CONFIGURATION, config);
+ /*#ifdef DEBUG
+ 	sii164PrintRegisterValues();
+ #endif*/
+ 	return 0;
+     }
+     return -1;
+ }
+ 
+ /* below sii164 function is not necessary */
+ 
+ #ifdef SII164_FULL_FUNCTIONS
+ 
+ /*
+  *  sii164ResetChip
+  *      This function resets the DVI Controller Chip.
+  */
+ void sii164ResetChip(void)
+ {
+     /* Power down */
+     sii164SetPower(0);
+     sii164SetPower(1);
+ }
+ 
+ 
+ /*
+  * sii164GetChipString
+  *      This function returns a char string name of the current DVI Controller chip. It's convenient for application need to display the chip name.
+  */
+ char *sii164GetChipString(void)
+ {
+     return gDviCtrlChipName;
+ }
+ 
+ 
+ /*
+  *  sii164SetPower
+  *      This function sets the power configuration of the DVI Controller Chip.
+  *
+  *  Input:
+  *      powerUp - Flag to set the power down or up
+  */
+ void sii164SetPower(unsigned char powerUp) {
+     unsigned char config;
+ 
+     config = sil164_read(SII164_I2C_ADDRESS, SII164_CONFIGURATION);
+     if (powerUp == 1) {
+ 	/* Power up the chip */
+ 	config &= ~SII164_CONFIGURATION_POWER_MASK;
+ 	config |= SII164_CONFIGURATION_POWER_NORMAL;
+ 	sil164_write(SII164_I2C_ADDRESS, SII164_CONFIGURATION, config);
+     } else {
+ 	/* Power down the chip */
+ 	config &= ~SII164_CONFIGURATION_POWER_MASK;
+ 	config |= SII164_CONFIGURATION_POWER_DOWN;
+ 	sil164_write(SII164_I2C_ADDRESS, SII164_CONFIGURATION, config);
+     }
+ }
+ 
+ 
+ /*
+  *  sii164SelectHotPlugDetectionMode
+  *      This function selects the mode of the hot plug detection.
+  */
+ static void sii164SelectHotPlugDetectionMode(sii164_hot_plug_mode_t hotPlugMode)
+ {
+     unsigned char detectReg;
+ 
+     detectReg = sil164_read(SII164_I2C_ADDRESS, SII164_DETECT)&~SII164_DETECT_MONITOR_SENSE_OUTPUT_FLAG;
+     switch (hotPlugMode) {
+     case SII164_HOTPLUG_DISABLE:
+ 	detectReg |= SII164_DETECT_MONITOR_SENSE_OUTPUT_HIGH;
+ 	break;
+     case SII164_HOTPLUG_USE_MDI:
+ 	detectReg &= ~SII164_DETECT_INTERRUPT_MASK;
+ 	detectReg |= SII164_DETECT_INTERRUPT_BY_HTPLG_PIN;
+ 	detectReg |= SII164_DETECT_MONITOR_SENSE_OUTPUT_MDI;
+ 	break;
+     case SII164_HOTPLUG_USE_RSEN:
+ 	detectReg |= SII164_DETECT_MONITOR_SENSE_OUTPUT_RSEN;
+ 	break;
+     case SII164_HOTPLUG_USE_HTPLG:
+ 	detectReg |= SII164_DETECT_MONITOR_SENSE_OUTPUT_HTPLG;
+ 	break;
+     }
+     sil164_write(SII164_I2C_ADDRESS, SII164_DETECT, detectReg);
+ }
+ 
+ /*
+  *  sii164EnableHotPlugDetection
+  *      This function enables the Hot Plug detection.
+  *
+  *  enableHotPlug   - Enable (=1)/disable (=0) Hot Plug detection
+  */
+ void sii164EnableHotPlugDetection(unsigned char enableHotPlug)
+ {
+     unsigned char detectReg;
+ 
+     detectReg = sil164_read(SII164_I2C_ADDRESS, SII164_DETECT);
+ 
+     /* Depending on each DVI controller, need to enable the hot plug based on each individual chip design. */
+     if (enableHotPlug != 0)
+ 	sii164SelectHotPlugDetectionMode(SII164_HOTPLUG_USE_MDI);
+     else
+ 	sii164SelectHotPlugDetectionMode(SII164_HOTPLUG_DISABLE);
+ }
+ 
+ /*
+  *  sii164IsConnected
+  *      Check if the DVI Monitor is connected.
+  *
+  *  Output:
+  *      0   - Not Connected
+  *      1   - Connected
+  */
+ unsigned char sii164IsConnected(void)
+ {
+     unsigned char hotPlugValue;
+ 
+     hotPlugValue = sil164_read(SII164_I2C_ADDRESS, SII164_DETECT)&SII164_DETECT_HOT_PLUG_STATUS_MASK;
+     if (hotPlugValue == SII164_DETECT_HOT_PLUG_STATUS_ON)
+ 	return 1;
+     else
+ 	return 0;
+ }
+ 
+ /*
+  *  sii164CheckInterrupt
+  *      Checks if interrupt has occurred.
+  *
+  *  Output:
+  *      0   - No interrupt
+  *      1   - Interrupt occurs
+  */
+ unsigned char sii164CheckInterrupt(void)
+ {
+     unsigned char detectReg;
+ 
+     detectReg = sil164_read(SII164_I2C_ADDRESS, SII164_DETECT)&SII164_DETECT_MONITOR_STATE_MASK;
+     if (detectReg == SII164_DETECT_MONITOR_STATE_CHANGE)
+ 	return 1;
+     else
+ 	return 0;
+ }
+ 
+ /*
+  *  sii164ClearInterrupt
+  *      Clear the hot plug interrupt.
+  */
+ void sii164ClearInterrupt(void)
+ {
+     unsigned char detectReg;
+ 
+     /* Clear the MDI interrupt */
+     detectReg = sil164_read(SII164_I2C_ADDRESS, SII164_DETECT);
+     sil164_write(SII164_I2C_ADDRESS, SII164_DETECT, detectReg|SII164_DETECT_MONITOR_STATE_CLEAR);
+ }
+ 
+ #endif
+ 
+ 
diff -rcNP linux-4.4.24/drivers/staging/sm750fb/sii164.h linux-4.4.24-baikal/drivers/staging/sm750fb/sii164.h
*** linux-4.4.24/drivers/staging/sm750fb/sii164.h	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/drivers/staging/sm750fb/sii164.h	2016-11-11 14:49:54.000000000 +0300
***************
*** 0 ****
--- 1,161 ----
+ #ifndef SII164_H__
+ #define SII164_H__
+ 
+ /* Hot Plug detection mode structure */
+ typedef enum _sii164_hot_plug_mode_t {
+     SII164_HOTPLUG_DISABLE = 0,         /* Disable Hot Plug output bit (always high). */
+     SII164_HOTPLUG_USE_MDI,             /* Use Monitor Detect Interrupt bit. */
+     SII164_HOTPLUG_USE_RSEN,            /* Use Receiver Sense detect bit. */
+     SII164_HOTPLUG_USE_HTPLG            /* Use Hot Plug detect bit. */
+ } sii164_hot_plug_mode_t;
+ 
+ 
+ /* Silicon Image SiI164 chip prototype */
+ long sii164InitChip(unsigned char edgeSelect, unsigned char busSelect, unsigned char dualEdgeClkSelect, unsigned char hsyncEnable, unsigned char vsyncEnable, unsigned char deskewEnable, unsigned char deskewSetting, unsigned char continuousSyncEnable, unsigned char pllFilterEnable, unsigned char pllFilterValue);
+ 
+ unsigned short sii164GetVendorID(void);
+ unsigned short sii164GetDeviceID(void);
+ 
+ 
+ #ifdef SII164_FULL_FUNCTIONS
+ void sii164ResetChip(void);
+ char *sii164GetChipString(void);
+ void sii164SetPower(unsigned char powerUp);
+ void sii164EnableHotPlugDetection(unsigned char enableHotPlug);
+ unsigned char sii164IsConnected(void);
+ unsigned char sii164CheckInterrupt(void);
+ void sii164ClearInterrupt(void);
+ #endif
+ /*
+  * below register definition is used for
+  * Silicon Image SiI164 DVI controller chip
+  */
+ /*
+  * Vendor ID registers
+  */
+ #define SII164_VENDOR_ID_LOW                        0x00
+ #define SII164_VENDOR_ID_HIGH                       0x01
+ 
+ /*
+  * Device ID registers
+  */
+ #define SII164_DEVICE_ID_LOW                        0x02
+ #define SII164_DEVICE_ID_HIGH                       0x03
+ 
+ /*
+  * Device Revision
+  */
+ #define SII164_DEVICE_REVISION                      0x04
+ 
+ /*
+  * Frequency Limitation registers
+  */
+ #define SII164_FREQUENCY_LIMIT_LOW                  0x06
+ #define SII164_FREQUENCY_LIMIT_HIGH                 0x07
+ 
+ /*
+  * Power Down and Input Signal Configuration registers
+  */
+ #define SII164_CONFIGURATION                        0x08
+ 
+ /* Power down (PD) */
+ #define SII164_CONFIGURATION_POWER_DOWN             0x00
+ #define SII164_CONFIGURATION_POWER_NORMAL           0x01
+ #define SII164_CONFIGURATION_POWER_MASK             0x01
+ 
+ /* Input Edge Latch Select (EDGE) */
+ #define SII164_CONFIGURATION_LATCH_FALLING          0x00
+ #define SII164_CONFIGURATION_LATCH_RISING           0x02
+ 
+ /* Bus Select (BSEL) */
+ #define SII164_CONFIGURATION_BUS_12BITS             0x00
+ #define SII164_CONFIGURATION_BUS_24BITS             0x04
+ 
+ /* Dual Edge Clock Select (DSEL) */
+ #define SII164_CONFIGURATION_CLOCK_SINGLE           0x00
+ #define SII164_CONFIGURATION_CLOCK_DUAL             0x08
+ 
+ /* Horizontal Sync Enable (HEN) */
+ #define SII164_CONFIGURATION_HSYNC_FORCE_LOW        0x00
+ #define SII164_CONFIGURATION_HSYNC_AS_IS            0x10
+ 
+ /* Vertical Sync Enable (VEN) */
+ #define SII164_CONFIGURATION_VSYNC_FORCE_LOW        0x00
+ #define SII164_CONFIGURATION_VSYNC_AS_IS            0x20
+ 
+ /*
+  * Detection registers
+  */
+ #define SII164_DETECT                               0x09
+ 
+ /* Monitor Detect Interrupt (MDI) */
+ #define SII164_DETECT_MONITOR_STATE_CHANGE          0x00
+ #define SII164_DETECT_MONITOR_STATE_NO_CHANGE       0x01
+ #define SII164_DETECT_MONITOR_STATE_CLEAR           0x01
+ #define SII164_DETECT_MONITOR_STATE_MASK            0x01
+ 
+ /* Hot Plug detect Input (HTPLG) */
+ #define SII164_DETECT_HOT_PLUG_STATUS_OFF           0x00
+ #define SII164_DETECT_HOT_PLUG_STATUS_ON            0x02
+ #define SII164_DETECT_HOT_PLUG_STATUS_MASK          0x02
+ 
+ /* Receiver Sense (RSEN) */
+ #define SII164_DETECT_RECEIVER_SENSE_NOT_DETECTED   0x00
+ #define SII164_DETECT_RECEIVER_SENSE_DETECTED       0x04
+ 
+ /* Interrupt Generation Method (TSEL) */
+ #define SII164_DETECT_INTERRUPT_BY_RSEN_PIN         0x00
+ #define SII164_DETECT_INTERRUPT_BY_HTPLG_PIN        0x08
+ #define SII164_DETECT_INTERRUPT_MASK                0x08
+ 
+ /* Monitor Sense Output (MSEN) */
+ #define SII164_DETECT_MONITOR_SENSE_OUTPUT_HIGH     0x00
+ #define SII164_DETECT_MONITOR_SENSE_OUTPUT_MDI      0x10
+ #define SII164_DETECT_MONITOR_SENSE_OUTPUT_RSEN     0x20
+ #define SII164_DETECT_MONITOR_SENSE_OUTPUT_HTPLG    0x30
+ #define SII164_DETECT_MONITOR_SENSE_OUTPUT_FLAG     0x30
+ 
+ /*
+  * Skewing registers
+  */
+ #define SII164_DESKEW                               0x0A
+ 
+ /* General Purpose Input (CTL[3:1]) */
+ #define SII164_DESKEW_GENERAL_PURPOSE_INPUT_MASK    0x0E
+ 
+ /* De-skewing Enable bit (DKEN) */
+ #define SII164_DESKEW_DISABLE                       0x00
+ #define SII164_DESKEW_ENABLE                        0x10
+ 
+ /* De-skewing Setting (DK[3:1])*/
+ #define SII164_DESKEW_1_STEP                        0x00
+ #define SII164_DESKEW_2_STEP                        0x20
+ #define SII164_DESKEW_3_STEP                        0x40
+ #define SII164_DESKEW_4_STEP                        0x60
+ #define SII164_DESKEW_5_STEP                        0x80
+ #define SII164_DESKEW_6_STEP                        0xA0
+ #define SII164_DESKEW_7_STEP                        0xC0
+ #define SII164_DESKEW_8_STEP                        0xE0
+ 
+ /*
+  * User Configuration Data registers (CFG 7:0)
+  */
+ #define SII164_USER_CONFIGURATION                   0x0B
+ 
+ /*
+  * PLL registers
+  */
+ #define SII164_PLL                                  0x0C
+ 
+ /* PLL Filter Value (PLLF) */
+ #define SII164_PLL_FILTER_VALUE_MASK                0x0E
+ 
+ /* PLL Filter Enable (PFEN) */
+ #define SII164_PLL_FILTER_DISABLE                   0x00
+ #define SII164_PLL_FILTER_ENABLE                    0x01
+ 
+ /* Sync Continuous (SCNT) */
+ #define SII164_PLL_FILTER_SYNC_CONTINUOUS_DISABLE   0x00
+ #define SII164_PLL_FILTER_SYNC_CONTINUOUS_ENABLE    0x80
+ 
+ #endif
diff -rcNP linux-4.4.24/drivers/staging/sm750fb/sm750_accel.c linux-4.4.24-baikal/drivers/staging/sm750fb/sm750_accel.c
*** linux-4.4.24/drivers/staging/sm750fb/sm750_accel.c	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/staging/sm750fb/sm750_accel.c	1970-01-01 03:00:00.000000000 +0300
***************
*** 1,396 ****
- #include <linux/module.h>
- #include <linux/kernel.h>
- #include <linux/errno.h>
- #include <linux/string.h>
- #include <linux/mm.h>
- #include <linux/slab.h>
- #include <linux/delay.h>
- #include <linux/fb.h>
- #include <linux/ioport.h>
- #include <linux/init.h>
- #include <linux/pci.h>
- #include <linux/vmalloc.h>
- #include <linux/pagemap.h>
- #include <linux/console.h>
- #include <linux/platform_device.h>
- #include <linux/screen_info.h>
- 
- #include "sm750.h"
- #include "sm750_accel.h"
- #include "sm750_help.h"
- static inline void write_dpr(struct lynx_accel *accel, int offset, u32 regValue)
- {
- 	writel(regValue, accel->dprBase + offset);
- }
- 
- static inline u32 read_dpr(struct lynx_accel *accel, int offset)
- {
- 	return readl(accel->dprBase + offset);
- }
- 
- static inline void write_dpPort(struct lynx_accel *accel, u32 data)
- {
- 	writel(data, accel->dpPortBase);
- }
- 
- void hw_de_init(struct lynx_accel *accel)
- {
- 	/* setup 2d engine registers */
- 	u32 reg, clr;
- 
- 	write_dpr(accel, DE_MASKS, 0xFFFFFFFF);
- 
- 	/* dpr1c */
- 	reg = FIELD_SET(0, DE_STRETCH_FORMAT, PATTERN_XY, NORMAL)|
- 		FIELD_VALUE(0, DE_STRETCH_FORMAT, PATTERN_Y, 0)|
- 		FIELD_VALUE(0, DE_STRETCH_FORMAT, PATTERN_X, 0)|
- 		FIELD_SET(0, DE_STRETCH_FORMAT, ADDRESSING, XY)|
- 		FIELD_VALUE(0, DE_STRETCH_FORMAT, SOURCE_HEIGHT, 3);
- 
- 	clr = FIELD_CLEAR(DE_STRETCH_FORMAT, PATTERN_XY)&
- 		FIELD_CLEAR(DE_STRETCH_FORMAT, PATTERN_Y)&
- 		FIELD_CLEAR(DE_STRETCH_FORMAT, PATTERN_X)&
- 		FIELD_CLEAR(DE_STRETCH_FORMAT, ADDRESSING)&
- 		FIELD_CLEAR(DE_STRETCH_FORMAT, SOURCE_HEIGHT);
- 
- 	/* DE_STRETCH bpp format need be initilized in setMode routine */
- 	write_dpr(accel, DE_STRETCH_FORMAT, (read_dpr(accel, DE_STRETCH_FORMAT) & clr) | reg);
- 
- 	/* disable clipping and transparent */
- 	write_dpr(accel, DE_CLIP_TL, 0); /* dpr2c */
- 	write_dpr(accel, DE_CLIP_BR, 0); /* dpr30 */
- 
- 	write_dpr(accel, DE_COLOR_COMPARE_MASK, 0); /* dpr24 */
- 	write_dpr(accel, DE_COLOR_COMPARE, 0);
- 
- 	reg = FIELD_SET(0, DE_CONTROL, TRANSPARENCY, DISABLE)|
- 		FIELD_SET(0, DE_CONTROL, TRANSPARENCY_MATCH, OPAQUE)|
- 		FIELD_SET(0, DE_CONTROL, TRANSPARENCY_SELECT, SOURCE);
- 
- 	clr = FIELD_CLEAR(DE_CONTROL, TRANSPARENCY)&
- 		FIELD_CLEAR(DE_CONTROL, TRANSPARENCY_MATCH)&
- 		FIELD_CLEAR(DE_CONTROL, TRANSPARENCY_SELECT);
- 
- 	/* dpr0c */
- 	write_dpr(accel, DE_CONTROL, (read_dpr(accel, DE_CONTROL)&clr)|reg);
- }
- 
- /* set2dformat only be called from setmode functions
-  * but if you need dual framebuffer driver,need call set2dformat
-  * every time you use 2d function */
- 
- void hw_set2dformat(struct lynx_accel *accel, int fmt)
- {
- 	u32 reg;
- 
- 	/* fmt=0,1,2 for 8,16,32,bpp on sm718/750/502 */
- 	reg = read_dpr(accel, DE_STRETCH_FORMAT);
- 	reg = FIELD_VALUE(reg, DE_STRETCH_FORMAT, PIXEL_FORMAT, fmt);
- 	write_dpr(accel, DE_STRETCH_FORMAT, reg);
- }
- 
- int hw_fillrect(struct lynx_accel *accel,
- 				u32 base, u32 pitch, u32 Bpp,
- 				u32 x, u32 y, u32 width, u32 height,
- 				u32 color, u32 rop)
- {
- 	u32 deCtrl;
- 
- 	if (accel->de_wait() != 0) {
- 		/* int time wait and always busy,seems hardware
- 		 * got something error */
- 		pr_debug("De engine always busy\n");
- 		return -1;
- 	}
- 
- 	write_dpr(accel, DE_WINDOW_DESTINATION_BASE, base); /* dpr40 */
- 	write_dpr(accel, DE_PITCH,
- 			FIELD_VALUE(0, DE_PITCH, DESTINATION, pitch/Bpp)|
- 			FIELD_VALUE(0, DE_PITCH, SOURCE, pitch/Bpp)); /* dpr10 */
- 
- 	write_dpr(accel, DE_WINDOW_WIDTH,
- 			FIELD_VALUE(0, DE_WINDOW_WIDTH, DESTINATION, pitch/Bpp)|
- 			FIELD_VALUE(0, DE_WINDOW_WIDTH, SOURCE, pitch/Bpp)); /* dpr44 */
- 
- 	write_dpr(accel, DE_FOREGROUND, color); /* DPR14 */
- 
- 	write_dpr(accel, DE_DESTINATION,
- 			FIELD_SET(0, DE_DESTINATION, WRAP, DISABLE)|
- 			FIELD_VALUE(0, DE_DESTINATION, X, x)|
- 			FIELD_VALUE(0, DE_DESTINATION, Y, y)); /* dpr4 */
- 
- 	write_dpr(accel, DE_DIMENSION,
- 			FIELD_VALUE(0, DE_DIMENSION, X, width)|
- 			FIELD_VALUE(0, DE_DIMENSION, Y_ET, height)); /* dpr8 */
- 
- 	deCtrl =
- 		FIELD_SET(0, DE_CONTROL, STATUS, START)|
- 		FIELD_SET(0, DE_CONTROL, DIRECTION, LEFT_TO_RIGHT)|
- 		FIELD_SET(0, DE_CONTROL, LAST_PIXEL, ON)|
- 		FIELD_SET(0, DE_CONTROL, COMMAND, RECTANGLE_FILL)|
- 		FIELD_SET(0, DE_CONTROL, ROP_SELECT, ROP2)|
- 		FIELD_VALUE(0, DE_CONTROL, ROP, rop); /* dpr0xc */
- 
- 	write_dpr(accel, DE_CONTROL, deCtrl);
- 	return 0;
- }
- 
- int hw_copyarea(
- struct lynx_accel *accel,
- unsigned int sBase,  /* Address of source: offset in frame buffer */
- unsigned int sPitch, /* Pitch value of source surface in BYTE */
- unsigned int sx,
- unsigned int sy,     /* Starting coordinate of source surface */
- unsigned int dBase,  /* Address of destination: offset in frame buffer */
- unsigned int dPitch, /* Pitch value of destination surface in BYTE */
- unsigned int Bpp,    /* Color depth of destination surface */
- unsigned int dx,
- unsigned int dy,     /* Starting coordinate of destination surface */
- unsigned int width,
- unsigned int height, /* width and height of rectangle in pixel value */
- unsigned int rop2)   /* ROP value */
- {
- 	unsigned int nDirection, de_ctrl;
- 	int opSign;
- 
- 	nDirection = LEFT_TO_RIGHT;
- 	/* Direction of ROP2 operation: 1 = Left to Right, (-1) = Right to Left */
- 	opSign = 1;
- 	de_ctrl = 0;
- 
- 	/* If source and destination are the same surface, need to check for overlay cases */
- 	if (sBase == dBase && sPitch == dPitch) {
- 		/* Determine direction of operation */
- 		if (sy < dy) {
- 			/* +----------+
- 			   |S         |
- 			   |   +----------+
- 			   |   |      |   |
- 			   |   |      |   |
- 			   +---|------+   |
- 			   |         D|
- 			   +----------+ */
- 
- 			nDirection = BOTTOM_TO_TOP;
- 		} else if (sy > dy) {
- 			/* +----------+
- 			   |D         |
- 			   |   +----------+
- 			   |   |      |   |
- 			   |   |      |   |
- 			   +---|------+   |
- 			   |         S|
- 			   +----------+ */
- 
- 			nDirection = TOP_TO_BOTTOM;
- 		} else {
- 			/* sy == dy */
- 
- 			if (sx <= dx) {
- 				/* +------+---+------+
- 				   |S     |   |     D|
- 				   |      |   |      |
- 				   |      |   |      |
- 				   |      |   |      |
- 				   +------+---+------+ */
- 
- 				nDirection = RIGHT_TO_LEFT;
- 			} else {
- 			/* sx > dx */
- 
- 				/* +------+---+------+
- 				   |D     |   |     S|
- 				   |      |   |      |
- 				   |      |   |      |
- 				   |      |   |      |
- 				   +------+---+------+ */
- 
- 				nDirection = LEFT_TO_RIGHT;
- 			}
- 		}
- 	}
- 
- 	if ((nDirection == BOTTOM_TO_TOP) || (nDirection == RIGHT_TO_LEFT)) {
- 		sx += width - 1;
- 		sy += height - 1;
- 		dx += width - 1;
- 		dy += height - 1;
- 		opSign = (-1);
- 	}
- 
- 	/* Note:
- 	   DE_FOREGROUND are DE_BACKGROUND are don't care.
- 	  DE_COLOR_COMPARE and DE_COLOR_COMPARE_MAKS are set by set deSetTransparency().
- 	 */
- 
- 	/* 2D Source Base.
- 	 It is an address offset (128 bit aligned) from the beginning of frame buffer.
- 	 */
- 	write_dpr(accel, DE_WINDOW_SOURCE_BASE, sBase); /* dpr40 */
- 
- 	/* 2D Destination Base.
- 	 It is an address offset (128 bit aligned) from the beginning of frame buffer.
- 	 */
- 	write_dpr(accel, DE_WINDOW_DESTINATION_BASE, dBase); /* dpr44 */
- 
-     /* Program pitch (distance between the 1st points of two adjacent lines).
-        Note that input pitch is BYTE value, but the 2D Pitch register uses
-        pixel values. Need Byte to pixel conversion.
-     */
- 	{
- 		write_dpr(accel, DE_PITCH,
- 				FIELD_VALUE(0, DE_PITCH, DESTINATION, (dPitch/Bpp)) |
- 				FIELD_VALUE(0, DE_PITCH, SOURCE,      (sPitch/Bpp))); /* dpr10 */
- 	}
- 
-     /* Screen Window width in Pixels.
-        2D engine uses this value to calculate the linear address in frame buffer for a given point.
-     */
- 	write_dpr(accel, DE_WINDOW_WIDTH,
- 	FIELD_VALUE(0, DE_WINDOW_WIDTH, DESTINATION, (dPitch/Bpp)) |
- 	FIELD_VALUE(0, DE_WINDOW_WIDTH, SOURCE,      (sPitch/Bpp))); /* dpr3c */
- 
- 	if (accel->de_wait() != 0)
- 		return -1;
- 
- 	{
- 
- 	write_dpr(accel, DE_SOURCE,
- 		  FIELD_SET(0, DE_SOURCE, WRAP, DISABLE) |
- 		  FIELD_VALUE(0, DE_SOURCE, X_K1, sx)   |
- 		  FIELD_VALUE(0, DE_SOURCE, Y_K2, sy)); /* dpr0 */
- 	write_dpr(accel, DE_DESTINATION,
- 		  FIELD_SET(0, DE_DESTINATION, WRAP, DISABLE) |
- 		  FIELD_VALUE(0, DE_DESTINATION, X,    dx)  |
- 		  FIELD_VALUE(0, DE_DESTINATION, Y,    dy)); /* dpr04 */
- 	write_dpr(accel, DE_DIMENSION,
- 		  FIELD_VALUE(0, DE_DIMENSION, X,    width) |
- 		  FIELD_VALUE(0, DE_DIMENSION, Y_ET, height)); /* dpr08 */
- 
- 	de_ctrl = FIELD_VALUE(0, DE_CONTROL, ROP, rop2) |
- 		  FIELD_SET(0, DE_CONTROL, ROP_SELECT, ROP2) |
- 		  FIELD_SET(0, DE_CONTROL, COMMAND, BITBLT) |
- 		  ((nDirection == RIGHT_TO_LEFT) ?
- 		  FIELD_SET(0, DE_CONTROL, DIRECTION, RIGHT_TO_LEFT)
- 		  : FIELD_SET(0, DE_CONTROL, DIRECTION, LEFT_TO_RIGHT)) |
- 		  FIELD_SET(0, DE_CONTROL, STATUS, START);
- 	write_dpr(accel, DE_CONTROL, de_ctrl); /* dpr0c */
- 
- 	}
- 
- 	return 0;
- }
- 
- static unsigned int deGetTransparency(struct lynx_accel *accel)
- {
- 	unsigned int de_ctrl;
- 
- 	de_ctrl = read_dpr(accel, DE_CONTROL);
- 
- 	de_ctrl &=
- 		   FIELD_MASK(DE_CONTROL_TRANSPARENCY_MATCH) |
- 		   FIELD_MASK(DE_CONTROL_TRANSPARENCY_SELECT)|
- 		   FIELD_MASK(DE_CONTROL_TRANSPARENCY);
- 
- 	return de_ctrl;
- }
- 
- int hw_imageblit(struct lynx_accel *accel,
- 		 const char *pSrcbuf, /* pointer to start of source buffer in system memory */
- 		 u32 srcDelta,          /* Pitch value (in bytes) of the source buffer, +ive means top down and -ive mean button up */
- 		 u32 startBit, /* Mono data can start at any bit in a byte, this value should be 0 to 7 */
- 		 u32 dBase,    /* Address of destination: offset in frame buffer */
- 		 u32 dPitch,   /* Pitch value of destination surface in BYTE */
- 		 u32 bytePerPixel,      /* Color depth of destination surface */
- 		 u32 dx,
- 		 u32 dy,       /* Starting coordinate of destination surface */
- 		 u32 width,
- 		 u32 height,   /* width and height of rectange in pixel value */
- 		 u32 fColor,   /* Foreground color (corresponding to a 1 in the monochrome data */
- 		 u32 bColor,   /* Background color (corresponding to a 0 in the monochrome data */
- 		 u32 rop2)     /* ROP value */
- {
- 	unsigned int ulBytesPerScan;
- 	unsigned int ul4BytesPerScan;
- 	unsigned int ulBytesRemain;
- 	unsigned int de_ctrl = 0;
- 	unsigned char ajRemain[4];
- 	int i, j;
- 
- 	startBit &= 7; /* Just make sure the start bit is within legal range */
- 	ulBytesPerScan = (width + startBit + 7) / 8;
- 	ul4BytesPerScan = ulBytesPerScan & ~3;
- 	ulBytesRemain = ulBytesPerScan & 3;
- 
- 	if (accel->de_wait() != 0)
- 		return -1;
- 
- 	/* 2D Source Base.
- 	 Use 0 for HOST Blt.
- 	 */
- 	write_dpr(accel, DE_WINDOW_SOURCE_BASE, 0);
- 
- 	/* 2D Destination Base.
- 	 It is an address offset (128 bit aligned) from the beginning of frame buffer.
- 	 */
- 	write_dpr(accel, DE_WINDOW_DESTINATION_BASE, dBase);
-     /* Program pitch (distance between the 1st points of two adjacent lines).
-        Note that input pitch is BYTE value, but the 2D Pitch register uses
-        pixel values. Need Byte to pixel conversion.
-     */
- 	{
- 		write_dpr(accel, DE_PITCH,
- 				FIELD_VALUE(0, DE_PITCH, DESTINATION, dPitch/bytePerPixel) |
- 				FIELD_VALUE(0, DE_PITCH, SOURCE,      dPitch/bytePerPixel)); /* dpr10 */
- 	}
- 
- 	/* Screen Window width in Pixels.
- 	 2D engine uses this value to calculate the linear address in frame buffer for a given point.
- 	 */
- 	write_dpr(accel, DE_WINDOW_WIDTH,
- 		  FIELD_VALUE(0, DE_WINDOW_WIDTH, DESTINATION, (dPitch/bytePerPixel)) |
- 		  FIELD_VALUE(0, DE_WINDOW_WIDTH, SOURCE,      (dPitch/bytePerPixel)));
- 
- 	 /* Note: For 2D Source in Host Write, only X_K1_MONO field is needed, and Y_K2 field is not used.
- 	    For mono bitmap, use startBit for X_K1. */
- 	write_dpr(accel, DE_SOURCE,
- 		  FIELD_SET(0, DE_SOURCE, WRAP, DISABLE)       |
- 		  FIELD_VALUE(0, DE_SOURCE, X_K1_MONO, startBit)); /* dpr00 */
- 
- 	write_dpr(accel, DE_DESTINATION,
- 		  FIELD_SET(0, DE_DESTINATION, WRAP, DISABLE) |
- 		  FIELD_VALUE(0, DE_DESTINATION, X,    dx)    |
- 		  FIELD_VALUE(0, DE_DESTINATION, Y,    dy)); /* dpr04 */
- 
- 	write_dpr(accel, DE_DIMENSION,
- 		  FIELD_VALUE(0, DE_DIMENSION, X,    width) |
- 		  FIELD_VALUE(0, DE_DIMENSION, Y_ET, height)); /* dpr08 */
- 
- 	write_dpr(accel, DE_FOREGROUND, fColor);
- 	write_dpr(accel, DE_BACKGROUND, bColor);
- 
- 	de_ctrl = FIELD_VALUE(0, DE_CONTROL, ROP, rop2)         |
- 		FIELD_SET(0, DE_CONTROL, ROP_SELECT, ROP2)    |
- 		FIELD_SET(0, DE_CONTROL, COMMAND, HOST_WRITE) |
- 		FIELD_SET(0, DE_CONTROL, HOST, MONO)          |
- 		FIELD_SET(0, DE_CONTROL, STATUS, START);
- 
- 	write_dpr(accel, DE_CONTROL, de_ctrl | deGetTransparency(accel));
- 
- 	/* Write MONO data (line by line) to 2D Engine data port */
- 	for (i = 0; i < height; i++) {
- 		/* For each line, send the data in chunks of 4 bytes */
- 		for (j = 0; j < (ul4BytesPerScan/4); j++)
- 			write_dpPort(accel, *(unsigned int *)(pSrcbuf + (j * 4)));
- 
- 		if (ulBytesRemain) {
- 			memcpy(ajRemain, pSrcbuf+ul4BytesPerScan, ulBytesRemain);
- 			write_dpPort(accel, *(unsigned int *)ajRemain);
- 		}
- 
- 		pSrcbuf += srcDelta;
- 	}
- 
- 	    return 0;
- }
- 
--- 0 ----
diff -rcNP linux-4.4.24/drivers/staging/sm750fb/sm750_accel.h linux-4.4.24-baikal/drivers/staging/sm750fb/sm750_accel.h
*** linux-4.4.24/drivers/staging/sm750fb/sm750_accel.h	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/staging/sm750fb/sm750_accel.h	1970-01-01 03:00:00.000000000 +0300
***************
*** 1,275 ****
- #ifndef ACCEL_H__
- #define ACCEL_H__
- 
- #define HW_ROP2_COPY 0xc
- #define HW_ROP2_XOR 0x6
- 
- /* notes: below address are the offset value from de_base_address (0x100000)*/
- 
- /* for sm718/750/502 de_base is at mmreg_1mb*/
- #define DE_BASE_ADDR_TYPE1 0x100000
- /* for sm712,de_base is at mmreg_32kb */
- #define DE_BASE_ADDR_TYPE2  0x8000
- /* for sm722,de_base is at mmreg_0 */
- #define DE_BASE_ADDR_TYPE3 0
- 
- /* type1 data port address is at mmreg_0x110000*/
- #define DE_PORT_ADDR_TYPE1 0x110000
- /* for sm712,data port address is at mmreg_0 */
- #define DE_PORT_ADDR_TYPE2 0x100000
- /* for sm722,data port address is at mmreg_1mb */
- #define DE_PORT_ADDR_TYPE3 0x100000
- 
- #define DE_SOURCE                                       0x0
- #define DE_SOURCE_WRAP                                  31:31
- #define DE_SOURCE_WRAP_DISABLE                          0
- #define DE_SOURCE_WRAP_ENABLE                           1
- #define DE_SOURCE_X_K1                                  29:16
- #define DE_SOURCE_Y_K2                                  15:0
- #define DE_SOURCE_X_K1_MONO				20:16
- 
- #define DE_DESTINATION                                  0x4
- #define DE_DESTINATION_WRAP                             31:31
- #define DE_DESTINATION_WRAP_DISABLE                     0
- #define DE_DESTINATION_WRAP_ENABLE                      1
- #define DE_DESTINATION_X                                28:16
- #define DE_DESTINATION_Y                                15:0
- 
- #define DE_DIMENSION                                    0x8
- #define DE_DIMENSION_X                                  28:16
- #define DE_DIMENSION_Y_ET                               15:0
- 
- #define DE_CONTROL                                      0xC
- #define DE_CONTROL_STATUS                               31:31
- #define DE_CONTROL_STATUS_STOP                          0
- #define DE_CONTROL_STATUS_START                         1
- #define DE_CONTROL_PATTERN                              30:30
- #define DE_CONTROL_PATTERN_MONO                         0
- #define DE_CONTROL_PATTERN_COLOR                        1
- #define DE_CONTROL_UPDATE_DESTINATION_X                 29:29
- #define DE_CONTROL_UPDATE_DESTINATION_X_DISABLE         0
- #define DE_CONTROL_UPDATE_DESTINATION_X_ENABLE          1
- #define DE_CONTROL_QUICK_START                          28:28
- #define DE_CONTROL_QUICK_START_DISABLE                  0
- #define DE_CONTROL_QUICK_START_ENABLE                   1
- #define DE_CONTROL_DIRECTION                            27:27
- #define DE_CONTROL_DIRECTION_LEFT_TO_RIGHT              0
- #define DE_CONTROL_DIRECTION_RIGHT_TO_LEFT              1
- #define DE_CONTROL_MAJOR                                26:26
- #define DE_CONTROL_MAJOR_X                              0
- #define DE_CONTROL_MAJOR_Y                              1
- #define DE_CONTROL_STEP_X                               25:25
- #define DE_CONTROL_STEP_X_POSITIVE                      1
- #define DE_CONTROL_STEP_X_NEGATIVE                      0
- #define DE_CONTROL_STEP_Y                               24:24
- #define DE_CONTROL_STEP_Y_POSITIVE                      1
- #define DE_CONTROL_STEP_Y_NEGATIVE                      0
- #define DE_CONTROL_STRETCH                              23:23
- #define DE_CONTROL_STRETCH_DISABLE                      0
- #define DE_CONTROL_STRETCH_ENABLE                       1
- #define DE_CONTROL_HOST                                 22:22
- #define DE_CONTROL_HOST_COLOR                           0
- #define DE_CONTROL_HOST_MONO                            1
- #define DE_CONTROL_LAST_PIXEL                           21:21
- #define DE_CONTROL_LAST_PIXEL_OFF                       0
- #define DE_CONTROL_LAST_PIXEL_ON                        1
- #define DE_CONTROL_COMMAND                              20:16
- #define DE_CONTROL_COMMAND_BITBLT                       0
- #define DE_CONTROL_COMMAND_RECTANGLE_FILL               1
- #define DE_CONTROL_COMMAND_DE_TILE                      2
- #define DE_CONTROL_COMMAND_TRAPEZOID_FILL               3
- #define DE_CONTROL_COMMAND_ALPHA_BLEND                  4
- #define DE_CONTROL_COMMAND_RLE_STRIP                    5
- #define DE_CONTROL_COMMAND_SHORT_STROKE                 6
- #define DE_CONTROL_COMMAND_LINE_DRAW                    7
- #define DE_CONTROL_COMMAND_HOST_WRITE                   8
- #define DE_CONTROL_COMMAND_HOST_READ                    9
- #define DE_CONTROL_COMMAND_HOST_WRITE_BOTTOM_UP         10
- #define DE_CONTROL_COMMAND_ROTATE                       11
- #define DE_CONTROL_COMMAND_FONT                         12
- #define DE_CONTROL_COMMAND_TEXTURE_LOAD                 15
- #define DE_CONTROL_ROP_SELECT                           15:15
- #define DE_CONTROL_ROP_SELECT_ROP3                      0
- #define DE_CONTROL_ROP_SELECT_ROP2                      1
- #define DE_CONTROL_ROP2_SOURCE                          14:14
- #define DE_CONTROL_ROP2_SOURCE_BITMAP                   0
- #define DE_CONTROL_ROP2_SOURCE_PATTERN                  1
- #define DE_CONTROL_MONO_DATA                            13:12
- #define DE_CONTROL_MONO_DATA_NOT_PACKED                 0
- #define DE_CONTROL_MONO_DATA_8_PACKED                   1
- #define DE_CONTROL_MONO_DATA_16_PACKED                  2
- #define DE_CONTROL_MONO_DATA_32_PACKED                  3
- #define DE_CONTROL_REPEAT_ROTATE                        11:11
- #define DE_CONTROL_REPEAT_ROTATE_DISABLE                0
- #define DE_CONTROL_REPEAT_ROTATE_ENABLE                 1
- #define DE_CONTROL_TRANSPARENCY_MATCH                   10:10
- #define DE_CONTROL_TRANSPARENCY_MATCH_OPAQUE            0
- #define DE_CONTROL_TRANSPARENCY_MATCH_TRANSPARENT       1
- #define DE_CONTROL_TRANSPARENCY_SELECT                  9:9
- #define DE_CONTROL_TRANSPARENCY_SELECT_SOURCE           0
- #define DE_CONTROL_TRANSPARENCY_SELECT_DESTINATION      1
- #define DE_CONTROL_TRANSPARENCY                         8:8
- #define DE_CONTROL_TRANSPARENCY_DISABLE                 0
- #define DE_CONTROL_TRANSPARENCY_ENABLE                  1
- #define DE_CONTROL_ROP                                  7:0
- 
- /* Pseudo fields. */
- 
- #define DE_CONTROL_SHORT_STROKE_DIR                     27:24
- #define DE_CONTROL_SHORT_STROKE_DIR_225                 0
- #define DE_CONTROL_SHORT_STROKE_DIR_135                 1
- #define DE_CONTROL_SHORT_STROKE_DIR_315                 2
- #define DE_CONTROL_SHORT_STROKE_DIR_45                  3
- #define DE_CONTROL_SHORT_STROKE_DIR_270                 4
- #define DE_CONTROL_SHORT_STROKE_DIR_90                  5
- #define DE_CONTROL_SHORT_STROKE_DIR_180                 8
- #define DE_CONTROL_SHORT_STROKE_DIR_0                   10
- #define DE_CONTROL_ROTATION                             25:24
- #define DE_CONTROL_ROTATION_0                           0
- #define DE_CONTROL_ROTATION_270                         1
- #define DE_CONTROL_ROTATION_90                          2
- #define DE_CONTROL_ROTATION_180                         3
- 
- #define DE_PITCH                                        0x000010
- #define DE_PITCH_DESTINATION                            28:16
- #define DE_PITCH_SOURCE                                 12:0
- 
- #define DE_FOREGROUND                                   0x000014
- #define DE_FOREGROUND_COLOR                             31:0
- 
- #define DE_BACKGROUND                                   0x000018
- #define DE_BACKGROUND_COLOR                             31:0
- 
- #define DE_STRETCH_FORMAT                               0x00001C
- #define DE_STRETCH_FORMAT_PATTERN_XY                    30:30
- #define DE_STRETCH_FORMAT_PATTERN_XY_NORMAL             0
- #define DE_STRETCH_FORMAT_PATTERN_XY_OVERWRITE          1
- #define DE_STRETCH_FORMAT_PATTERN_Y                     29:27
- #define DE_STRETCH_FORMAT_PATTERN_X                     25:23
- #define DE_STRETCH_FORMAT_PIXEL_FORMAT                  21:20
- #define DE_STRETCH_FORMAT_PIXEL_FORMAT_8                0
- #define DE_STRETCH_FORMAT_PIXEL_FORMAT_16               1
- #define DE_STRETCH_FORMAT_PIXEL_FORMAT_32               2
- #define DE_STRETCH_FORMAT_PIXEL_FORMAT_24               3
- 
- #define DE_STRETCH_FORMAT_ADDRESSING                    19:16
- #define DE_STRETCH_FORMAT_ADDRESSING_XY                 0
- #define DE_STRETCH_FORMAT_ADDRESSING_LINEAR             15
- #define DE_STRETCH_FORMAT_SOURCE_HEIGHT                 11:0
- 
- #define DE_COLOR_COMPARE                                0x000020
- #define DE_COLOR_COMPARE_COLOR                          23:0
- 
- #define DE_COLOR_COMPARE_MASK                           0x000024
- #define DE_COLOR_COMPARE_MASK_MASKS                     23:0
- 
- #define DE_MASKS                                        0x000028
- #define DE_MASKS_BYTE_MASK                              31:16
- #define DE_MASKS_BIT_MASK                               15:0
- 
- #define DE_CLIP_TL                                      0x00002C
- #define DE_CLIP_TL_TOP                                  31:16
- #define DE_CLIP_TL_STATUS                               13:13
- #define DE_CLIP_TL_STATUS_DISABLE                       0
- #define DE_CLIP_TL_STATUS_ENABLE                        1
- #define DE_CLIP_TL_INHIBIT                              12:12
- #define DE_CLIP_TL_INHIBIT_OUTSIDE                      0
- #define DE_CLIP_TL_INHIBIT_INSIDE                       1
- #define DE_CLIP_TL_LEFT                                 11:0
- 
- #define DE_CLIP_BR                                      0x000030
- #define DE_CLIP_BR_BOTTOM                               31:16
- #define DE_CLIP_BR_RIGHT                                12:0
- 
- #define DE_MONO_PATTERN_LOW                             0x000034
- #define DE_MONO_PATTERN_LOW_PATTERN                     31:0
- 
- #define DE_MONO_PATTERN_HIGH                            0x000038
- #define DE_MONO_PATTERN_HIGH_PATTERN                    31:0
- 
- #define DE_WINDOW_WIDTH                                 0x00003C
- #define DE_WINDOW_WIDTH_DESTINATION                     28:16
- #define DE_WINDOW_WIDTH_SOURCE                          12:0
- 
- #define DE_WINDOW_SOURCE_BASE                           0x000040
- #define DE_WINDOW_SOURCE_BASE_EXT                       27:27
- #define DE_WINDOW_SOURCE_BASE_EXT_LOCAL                 0
- #define DE_WINDOW_SOURCE_BASE_EXT_EXTERNAL              1
- #define DE_WINDOW_SOURCE_BASE_CS                        26:26
- #define DE_WINDOW_SOURCE_BASE_CS_0                      0
- #define DE_WINDOW_SOURCE_BASE_CS_1                      1
- #define DE_WINDOW_SOURCE_BASE_ADDRESS                   25:0
- 
- #define DE_WINDOW_DESTINATION_BASE                      0x000044
- #define DE_WINDOW_DESTINATION_BASE_EXT                  27:27
- #define DE_WINDOW_DESTINATION_BASE_EXT_LOCAL            0
- #define DE_WINDOW_DESTINATION_BASE_EXT_EXTERNAL         1
- #define DE_WINDOW_DESTINATION_BASE_CS                   26:26
- #define DE_WINDOW_DESTINATION_BASE_CS_0                 0
- #define DE_WINDOW_DESTINATION_BASE_CS_1                 1
- #define DE_WINDOW_DESTINATION_BASE_ADDRESS              25:0
- 
- #define DE_ALPHA                                        0x000048
- #define DE_ALPHA_VALUE                                  7:0
- 
- #define DE_WRAP                                         0x00004C
- #define DE_WRAP_X                                       31:16
- #define DE_WRAP_Y                                       15:0
- 
- #define DE_STATUS                                       0x000050
- #define DE_STATUS_CSC                                   1:1
- #define DE_STATUS_CSC_CLEAR                             0
- #define DE_STATUS_CSC_NOT_ACTIVE                        0
- #define DE_STATUS_CSC_ACTIVE                            1
- #define DE_STATUS_2D                                    0:0
- #define DE_STATUS_2D_CLEAR                              0
- #define DE_STATUS_2D_NOT_ACTIVE                         0
- #define DE_STATUS_2D_ACTIVE                             1
- 
- 
- 
- /* blt direction */
- #define TOP_TO_BOTTOM 0
- #define LEFT_TO_RIGHT 0
- #define BOTTOM_TO_TOP 1
- #define RIGHT_TO_LEFT 1
- 
- void hw_set2dformat(struct lynx_accel *accel, int fmt);
- 
- void hw_de_init(struct lynx_accel *accel);
- 
- int hw_fillrect(struct lynx_accel *accel,
- 				u32 base, u32 pitch, u32 Bpp,
- 				u32 x, u32 y, u32 width, u32 height,
- 				u32 color, u32 rop);
- 
- int hw_copyarea(
- struct lynx_accel *accel,
- unsigned int sBase,  /* Address of source: offset in frame buffer */
- unsigned int sPitch, /* Pitch value of source surface in BYTE */
- unsigned int sx,
- unsigned int sy,     /* Starting coordinate of source surface */
- unsigned int dBase,  /* Address of destination: offset in frame buffer */
- unsigned int dPitch, /* Pitch value of destination surface in BYTE */
- unsigned int bpp,    /* Color depth of destination surface */
- unsigned int dx,
- unsigned int dy,     /* Starting coordinate of destination surface */
- unsigned int width,
- unsigned int height, /* width and height of rectangle in pixel value */
- unsigned int rop2);
- 
- int hw_imageblit(struct lynx_accel *accel,
- 		 const char *pSrcbuf, /* pointer to start of source buffer in system memory */
- 		 u32 srcDelta,          /* Pitch value (in bytes) of the source buffer, +ive means top down and -ive mean button up */
- 		 u32 startBit, /* Mono data can start at any bit in a byte, this value should be 0 to 7 */
- 		 u32 dBase,    /* Address of destination: offset in frame buffer */
- 		 u32 dPitch,   /* Pitch value of destination surface in BYTE */
- 		 u32 bytePerPixel,      /* Color depth of destination surface */
- 		 u32 dx,
- 		 u32 dy,       /* Starting coordinate of destination surface */
- 		 u32 width,
- 		 u32 height,   /* width and height of rectange in pixel value */
- 		 u32 fColor,   /* Foreground color (corresponding to a 1 in the monochrome data */
- 		 u32 bColor,   /* Background color (corresponding to a 0 in the monochrome data */
- 		 u32 rop2);
- #endif
--- 0 ----
diff -rcNP linux-4.4.24/drivers/staging/sm750fb/sm750.c linux-4.4.24-baikal/drivers/staging/sm750fb/sm750.c
*** linux-4.4.24/drivers/staging/sm750fb/sm750.c	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/staging/sm750fb/sm750.c	1970-01-01 03:00:00.000000000 +0300
***************
*** 1,1278 ****
- #include <linux/kernel.h>
- #include <linux/module.h>
- #include <linux/errno.h>
- #include <linux/string.h>
- #include <linux/mm.h>
- #include <linux/slab.h>
- #include <linux/delay.h>
- #include <linux/fb.h>
- #include <linux/ioport.h>
- #include <linux/init.h>
- #include <linux/pci.h>
- #include <linux/mm_types.h>
- #include <linux/vmalloc.h>
- #include <linux/pagemap.h>
- #include <linux/screen_info.h>
- #include <linux/vmalloc.h>
- #include <linux/pagemap.h>
- #include <linux/console.h>
- #include <asm/fb.h>
- #include "sm750.h"
- #include "sm750_accel.h"
- #include "sm750_cursor.h"
- 
- #include "modedb.h"
- 
- /*
-  * #ifdef __BIG_ENDIAN
-  * ssize_t lynxfb_ops_write(struct fb_info *info, const char __user *buf,
-  * size_t count, loff_t *ppos);
-  * ssize_t lynxfb_ops_read(struct fb_info *info, char __user *buf,
-  * size_t count, loff_t *ppos);
-  * #endif
-  */
- 
- /* common var for all device */
- static int g_hwcursor = 1;
- static int g_noaccel;
- static int g_nomtrr;
- static const char *g_fbmode[] = {NULL, NULL};
- static const char *g_def_fbmode = "800x600-16@60";
- static char *g_settings;
- static int g_dualview;
- static char *g_option;
- 
- static const struct fb_videomode lynx750_ext[] = {
- 	/*	1024x600-60 VESA	[1.71:1] */
- 	{NULL,  60, 1024, 600, 20423, 144,  40, 18, 1, 104, 3,
- 	 FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
- 	 FB_VMODE_NONINTERLACED},
- 
- 	/*	1024x600-70 VESA */
- 	{NULL,  70, 1024, 600, 17211, 152,  48, 21, 1, 104, 3,
- 	 FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
- 	 FB_VMODE_NONINTERLACED},
- 
- 	/*	1024x600-75 VESA */
- 	{NULL,  75, 1024, 600, 15822, 160,  56, 23, 1, 104, 3,
- 	 FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
- 	 FB_VMODE_NONINTERLACED},
- 
- 	/*	1024x600-85 VESA */
- 	{NULL,  85, 1024, 600, 13730, 168,  56, 26, 1, 112, 3,
- 	 FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
- 	 FB_VMODE_NONINTERLACED},
- 
- 	/*	720x480	*/
- 	{NULL, 60,  720,  480,  37427, 88,   16, 13, 1,   72,  3,
- 	 FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
- 	 FB_VMODE_NONINTERLACED},
- 
- 	/*	1280x720		[1.78:1]	*/
- 	{NULL, 60,  1280,  720,  13426, 162, 86, 22, 1,  136, 3,
- 	 FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
- 	 FB_VMODE_NONINTERLACED},
- 
- 	/*	1280x768@60 */
- 	{NULL, 60, 1280, 768, 12579, 192, 64, 20, 3, 128, 7,
- 	 FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
- 	 FB_VMODE_NONINTERLACED},
- 
- 	/*	1360 x 768	[1.77083:1]	*/
- 	{NULL,  60, 1360, 768, 11804, 208,  64, 23, 1, 144, 3,
- 	 FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
- 	 FB_VMODE_NONINTERLACED},
- 
- 	/*	1368 x 768      [1.78:1]	*/
- 	{NULL, 60,  1368,  768,  11647, 216, 72, 23, 1,  144, 3,
- 	 FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
- 	 FB_VMODE_NONINTERLACED},
- 
- 	/*	1440 x 900		[16:10]	*/
- 	{NULL, 60, 1440, 900, 9392, 232, 80, 28, 1, 152, 3,
- 	 FB_SYNC_VERT_HIGH_ACT,
- 	 FB_VMODE_NONINTERLACED},
- 
- 	/*	1440x960		[15:10]	*/
- 	{NULL, 60, 1440, 960, 8733, 240, 88, 30, 1, 152, 3,
- 	 FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
- 	 FB_VMODE_NONINTERLACED},
- 
- 	/*	1920x1080	[16:9]	*/
- 	{NULL, 60, 1920, 1080, 6734, 148, 88, 41, 1, 44, 3,
- 	 FB_SYNC_VERT_HIGH_ACT,
- 	 FB_VMODE_NONINTERLACED},
- };
- 
- 
- /* no hardware cursor supported under version 2.6.10, kernel bug */
- static int lynxfb_ops_cursor(struct fb_info *info, struct fb_cursor *fbcursor)
- {
- 	struct lynxfb_par *par;
- 	struct lynxfb_crtc *crtc;
- 	struct lynx_cursor *cursor;
- 
- 	par = info->par;
- 	crtc = &par->crtc;
- 	cursor = &crtc->cursor;
- 
- 	if (fbcursor->image.width > cursor->maxW ||
- 	   fbcursor->image.height > cursor->maxH ||
- 	   fbcursor->image.depth > 1) {
- 		return -ENXIO;
- 	}
- 
- 	hw_cursor_disable(cursor);
- 	if (fbcursor->set & FB_CUR_SETSIZE)
- 		hw_cursor_setSize(cursor,
- 				  fbcursor->image.width,
- 				  fbcursor->image.height);
- 
- 	if (fbcursor->set & FB_CUR_SETPOS)
- 		hw_cursor_setPos(cursor,
- 				 fbcursor->image.dx - info->var.xoffset,
- 				 fbcursor->image.dy - info->var.yoffset);
- 
- 	if (fbcursor->set & FB_CUR_SETCMAP) {
- 		/* get the 16bit color of kernel means */
- 		u16 fg, bg;
- 
- 		fg = ((info->cmap.red[fbcursor->image.fg_color] & 0xf800)) |
- 		      ((info->cmap.green[fbcursor->image.fg_color] & 0xfc00) >> 5) |
- 		      ((info->cmap.blue[fbcursor->image.fg_color] & 0xf800) >> 11);
- 
- 		bg = ((info->cmap.red[fbcursor->image.bg_color] & 0xf800)) |
- 		      ((info->cmap.green[fbcursor->image.bg_color] & 0xfc00) >> 5) |
- 		      ((info->cmap.blue[fbcursor->image.bg_color] & 0xf800) >> 11);
- 
- 		hw_cursor_setColor(cursor, fg, bg);
- 	}
- 
- 	if (fbcursor->set & (FB_CUR_SETSHAPE | FB_CUR_SETIMAGE)) {
- 		hw_cursor_setData(cursor,
- 				  fbcursor->rop,
- 				  fbcursor->image.data,
- 				  fbcursor->mask);
- 	}
- 
- 	if (fbcursor->enable)
- 		hw_cursor_enable(cursor);
- 
- 	return 0;
- }
- 
- static void lynxfb_ops_fillrect(struct fb_info *info,
- 				const struct fb_fillrect *region)
- {
- 	struct lynxfb_par *par;
- 	struct sm750_dev *sm750_dev;
- 	unsigned int base, pitch, Bpp, rop;
- 	u32 color;
- 
- 	if (info->state != FBINFO_STATE_RUNNING)
- 		return;
- 
- 	par = info->par;
- 	sm750_dev = par->dev;
- 
- 	/*
- 	 * each time 2d function begin to work,below three variable always need
- 	 * be set, seems we can put them together in some place
- 	 */
- 	base = par->crtc.oScreen;
- 	pitch = info->fix.line_length;
- 	Bpp = info->var.bits_per_pixel >> 3;
- 
- 	color = (Bpp == 1) ? region->color :
- 		((u32 *)info->pseudo_palette)[region->color];
- 	rop = (region->rop != ROP_COPY) ? HW_ROP2_XOR : HW_ROP2_COPY;
- 
- 	/*
- 	 * If not use spin_lock,system will die if user load driver
- 	 * and immediately unload driver frequently (dual)
- 	 */
- 	if (sm750_dev->dual)
- 		spin_lock(&sm750_dev->slock);
- 
- 	sm750_dev->accel.de_fillrect(&sm750_dev->accel,
- 				     base, pitch, Bpp,
- 				     region->dx, region->dy,
- 				     region->width, region->height,
- 				     color, rop);
- 	if (sm750_dev->dual)
- 		spin_unlock(&sm750_dev->slock);
- }
- 
- static void lynxfb_ops_copyarea(struct fb_info *info,
- 				const struct fb_copyarea *region)
- {
- 	struct lynxfb_par *par;
- 	struct sm750_dev *sm750_dev;
- 	unsigned int base, pitch, Bpp;
- 
- 	par = info->par;
- 	sm750_dev = par->dev;
- 
- 	/*
- 	 * each time 2d function begin to work,below three variable always need
- 	 * be set, seems we can put them together in some place
- 	 */
- 	base = par->crtc.oScreen;
- 	pitch = info->fix.line_length;
- 	Bpp = info->var.bits_per_pixel >> 3;
- 
- 	/*
- 	 * If not use spin_lock, system will die if user load driver
- 	 * and immediately unload driver frequently (dual)
- 	 */
- 	if (sm750_dev->dual)
- 		spin_lock(&sm750_dev->slock);
- 
- 	sm750_dev->accel.de_copyarea(&sm750_dev->accel,
- 				     base, pitch, region->sx, region->sy,
- 				     base, pitch, Bpp, region->dx, region->dy,
- 				     region->width, region->height,
- 				     HW_ROP2_COPY);
- 	if (sm750_dev->dual)
- 		spin_unlock(&sm750_dev->slock);
- }
- 
- static void lynxfb_ops_imageblit(struct fb_info *info,
- 				 const struct fb_image *image)
- {
- 	unsigned int base, pitch, Bpp;
- 	unsigned int fgcol, bgcol;
- 	struct lynxfb_par *par;
- 	struct sm750_dev *sm750_dev;
- 
- 	par = info->par;
- 	sm750_dev = par->dev;
- 	/*
- 	 * each time 2d function begin to work,below three variable always need
- 	 * be set, seems we can put them together in some place
- 	 */
- 	base = par->crtc.oScreen;
- 	pitch = info->fix.line_length;
- 	Bpp = info->var.bits_per_pixel >> 3;
- 
- 	/* TODO: Implement hardware acceleration for image->depth > 1 */
- 	if (image->depth != 1) {
- 		cfb_imageblit(info, image);
- 		return;
- 	}
- 
- 	if (info->fix.visual == FB_VISUAL_TRUECOLOR ||
- 	    info->fix.visual == FB_VISUAL_DIRECTCOLOR) {
- 		fgcol = ((u32 *)info->pseudo_palette)[image->fg_color];
- 		bgcol = ((u32 *)info->pseudo_palette)[image->bg_color];
- 	} else {
- 		fgcol = image->fg_color;
- 		bgcol = image->bg_color;
- 	}
- 
- 	/*
- 	 * If not use spin_lock, system will die if user load driver
- 	 * and immediately unload driver frequently (dual)
- 	 */
- 	if (sm750_dev->dual)
- 		spin_lock(&sm750_dev->slock);
- 
- 	sm750_dev->accel.de_imageblit(&sm750_dev->accel,
- 				      image->data, image->width >> 3, 0,
- 				      base, pitch, Bpp,
- 				      image->dx, image->dy,
- 				      image->width, image->height,
- 				      fgcol, bgcol, HW_ROP2_COPY);
- 	if (sm750_dev->dual)
- 		spin_unlock(&sm750_dev->slock);
- }
- 
- static int lynxfb_ops_pan_display(struct fb_var_screeninfo *var,
- 				  struct fb_info *info)
- {
- 	struct lynxfb_par *par;
- 	struct lynxfb_crtc *crtc;
- 
- 	if (!info)
- 		return -EINVAL;
- 
- 	par = info->par;
- 	crtc = &par->crtc;
- 	return hw_sm750_pan_display(crtc, var, info);
- }
- 
- static int lynxfb_ops_set_par(struct fb_info *info)
- {
- 	struct lynxfb_par *par;
- 	struct lynxfb_crtc *crtc;
- 	struct lynxfb_output *output;
- 	struct fb_var_screeninfo *var;
- 	struct fb_fix_screeninfo *fix;
- 	int ret;
- 	unsigned int line_length;
- 
- 	if (!info)
- 		return -EINVAL;
- 
- 	ret = 0;
- 	par = info->par;
- 	crtc = &par->crtc;
- 	output = &par->output;
- 	var = &info->var;
- 	fix = &info->fix;
- 
- 	/* fix structur is not so FIX ... */
- 	line_length = var->xres_virtual * var->bits_per_pixel / 8;
- 	line_length = ALIGN(line_length, crtc->line_pad);
- 	fix->line_length = line_length;
- 	pr_info("fix->line_length = %d\n", fix->line_length);
- 
- 	/*
- 	 * var->red,green,blue,transp are need to be set by driver
- 	 * and these data should be set before setcolreg routine
- 	 */
- 
- 	switch (var->bits_per_pixel) {
- 	case 8:
- 		fix->visual = FB_VISUAL_PSEUDOCOLOR;
- 		var->red.offset = 0;
- 		var->red.length = 8;
- 		var->green.offset = 0;
- 		var->green.length = 8;
- 		var->blue.offset = 0;
- 		var->blue.length = 8;
- 		var->transp.length = 0;
- 		var->transp.offset = 0;
- 		break;
- 	case 16:
- 		var->red.offset = 11;
- 		var->red.length = 5;
- 		var->green.offset = 5;
- 		var->green.length = 6;
- 		var->blue.offset = 0;
- 		var->blue.length = 5;
- 		var->transp.length = 0;
- 		var->transp.offset = 0;
- 		fix->visual = FB_VISUAL_TRUECOLOR;
- 		break;
- 	case 24:
- 	case 32:
- 		var->red.offset = 16;
- 		var->red.length = 8;
- 		var->green.offset = 8;
- 		var->green.length = 8;
- 		var->blue.offset = 0;
- 		var->blue.length = 8;
- 		fix->visual = FB_VISUAL_TRUECOLOR;
- 		break;
- 	default:
- 		ret = -EINVAL;
- 		break;
- 	}
- 	var->height = var->width = -1;
- 	var->accel_flags = 0;/*FB_ACCELF_TEXT;*/
- 
- 	if (ret) {
- 		pr_err("pixel bpp format not satisfied\n.");
- 		return ret;
- 	}
- 	ret = hw_sm750_crtc_setMode(crtc, var, fix);
- 	if (!ret)
- 		ret = hw_sm750_output_setMode(output, var, fix);
- 	return ret;
- }
- 
- static inline unsigned int chan_to_field(unsigned int chan,
- 					 struct fb_bitfield *bf)
- {
- 	chan &= 0xffff;
- 	chan >>= 16 - bf->length;
- 	return chan << bf->offset;
- }
- 
- #ifdef CONFIG_PM
- static int lynxfb_suspend(struct pci_dev *pdev, pm_message_t mesg)
- {
- 	struct fb_info *info;
- 	struct sm750_dev *sm750_dev;
- 	int ret;
- 
- 	if (mesg.event == pdev->dev.power.power_state.event)
- 		return 0;
- 
- 	ret = 0;
- 	sm750_dev = pci_get_drvdata(pdev);
- 	switch (mesg.event) {
- 	case PM_EVENT_FREEZE:
- 	case PM_EVENT_PRETHAW:
- 		pdev->dev.power.power_state = mesg;
- 		return 0;
- 	}
- 
- 	console_lock();
- 	if (mesg.event & PM_EVENT_SLEEP) {
- 		info = sm750_dev->fbinfo[0];
- 		if (info)
- 			/* 1 means do suspend */
- 			fb_set_suspend(info, 1);
- 		info = sm750_dev->fbinfo[1];
- 		if (info)
- 			/* 1 means do suspend */
- 			fb_set_suspend(info, 1);
- 
- 		ret = pci_save_state(pdev);
- 		if (ret) {
- 			pr_err("error:%d occurred in pci_save_state\n", ret);
- 			return ret;
- 		}
- 
- 		pci_disable_device(pdev);
- 		ret = pci_set_power_state(pdev, pci_choose_state(pdev, mesg));
- 		if (ret) {
- 			pr_err("error:%d occurred in pci_set_power_state\n", ret);
- 			return ret;
- 		}
- 	}
- 
- 	pdev->dev.power.power_state = mesg;
- 	console_unlock();
- 	return ret;
- }
- 
- static int lynxfb_resume(struct pci_dev *pdev)
- {
- 	struct fb_info *info;
- 	struct sm750_dev *sm750_dev;
- 
- 	struct lynxfb_par *par;
- 	struct lynxfb_crtc *crtc;
- 	struct lynx_cursor *cursor;
- 
- 	int ret;
- 
- 	ret = 0;
- 	sm750_dev = pci_get_drvdata(pdev);
- 
- 	console_lock();
- 
- 	ret = pci_set_power_state(pdev, PCI_D0);
- 	if (ret) {
- 		pr_err("error:%d occurred in pci_set_power_state\n", ret);
- 		return ret;
- 	}
- 
- 	if (pdev->dev.power.power_state.event != PM_EVENT_FREEZE) {
- 		pci_restore_state(pdev);
- 		ret = pci_enable_device(pdev);
- 		if (ret) {
- 			pr_err("error:%d occurred in pci_enable_device\n", ret);
- 			return ret;
- 		}
- 		pci_set_master(pdev);
- 	}
- 
- 	hw_sm750_inithw(sm750_dev, pdev);
- 
- 	info = sm750_dev->fbinfo[0];
- 
- 	if (info) {
- 		par = info->par;
- 		crtc = &par->crtc;
- 		cursor = &crtc->cursor;
- 		memset_io(cursor->vstart, 0x0, cursor->size);
- 		memset_io(crtc->vScreen, 0x0, crtc->vidmem_size);
- 		lynxfb_ops_set_par(info);
- 		fb_set_suspend(info, 0);
- 	}
- 
- 	info = sm750_dev->fbinfo[1];
- 
- 	if (info) {
- 		par = info->par;
- 		crtc = &par->crtc;
- 		cursor = &crtc->cursor;
- 		memset_io(cursor->vstart, 0x0, cursor->size);
- 		memset_io(crtc->vScreen, 0x0, crtc->vidmem_size);
- 		lynxfb_ops_set_par(info);
- 		fb_set_suspend(info, 0);
- 	}
- 
- 	pdev->dev.power.power_state.event = PM_EVENT_RESUME;
- 	console_unlock();
- 	return ret;
- }
- #endif
- 
- static int lynxfb_ops_check_var(struct fb_var_screeninfo *var,
- 				struct fb_info *info)
- {
- 	struct lynxfb_par *par;
- 	struct lynxfb_crtc *crtc;
- 	struct lynxfb_output *output;
- 	resource_size_t request;
- 
- 	par = info->par;
- 	crtc = &par->crtc;
- 	output = &par->output;
- 
- 	pr_debug("check var:%dx%d-%d\n",
- 		 var->xres,
- 		 var->yres,
- 		 var->bits_per_pixel);
- 
- 	switch (var->bits_per_pixel) {
- 	case 8:
- 		info->fix.visual = FB_VISUAL_PSEUDOCOLOR;
- 		var->red.offset = 0;
- 		var->red.length = 8;
- 		var->green.offset = 0;
- 		var->green.length = 8;
- 		var->blue.offset = 0;
- 		var->blue.length = 8;
- 		var->transp.length = 0;
- 		var->transp.offset = 0;
- 		break;
- 	case 16:
- 		var->red.offset = 11;
- 		var->red.length = 5;
- 		var->green.offset = 5;
- 		var->green.length = 6;
- 		var->blue.offset = 0;
- 		var->blue.length = 5;
- 		var->transp.length = 0;
- 		var->transp.offset = 0;
- 		info->fix.visual = FB_VISUAL_TRUECOLOR;
- 		break;
- 	case 24:
- 	case 32:
- 		var->red.offset = 16;
- 		var->red.length = 8;
- 		var->green.offset = 8;
- 		var->green.length = 8;
- 		var->blue.offset = 0;
- 		var->blue.length = 8;
- 		info->fix.visual = FB_VISUAL_TRUECOLOR;
- 		break;
- 	default:
- 		pr_err("bpp %d not supported\n", var->bits_per_pixel);
- 		return -EINVAL;
- 	}
- 	var->height = var->width = -1;
- 	var->accel_flags = 0;/* FB_ACCELF_TEXT; */
- 
- 	/* check if current fb's video memory big enought to hold the onscreen*/
- 	request = var->xres_virtual * (var->bits_per_pixel >> 3);
- 	/* defaulty crtc->channel go with par->index */
- 
- 	request = ALIGN(request, crtc->line_pad);
- 	request = request * var->yres_virtual;
- 	if (crtc->vidmem_size < request) {
- 		pr_err("not enough video memory for mode\n");
- 		return -ENOMEM;
- 	}
- 
- 	return hw_sm750_crtc_checkMode(crtc, var);
- }
- 
- static int lynxfb_ops_setcolreg(unsigned regno,
- 				unsigned red,
- 				unsigned green,
- 				unsigned blue,
- 				unsigned transp,
- 				struct fb_info *info)
- {
- 	struct lynxfb_par *par;
- 	struct lynxfb_crtc *crtc;
- 	struct fb_var_screeninfo *var;
- 	int ret;
- 
- 	par = info->par;
- 	crtc = &par->crtc;
- 	var = &info->var;
- 	ret = 0;
- 
- 	if (regno > 256) {
- 		pr_err("regno = %d\n", regno);
- 		return -EINVAL;
- 	}
- 
- 	if (info->var.grayscale)
- 		red = green = blue = (red * 77 + green * 151 + blue * 28) >> 8;
- 
- 	if (var->bits_per_pixel == 8 &&
- 	    info->fix.visual == FB_VISUAL_PSEUDOCOLOR) {
- 		red >>= 8;
- 		green >>= 8;
- 		blue >>= 8;
- 		ret = hw_sm750_setColReg(crtc, regno, red, green, blue);
- 		goto exit;
- 	}
- 
- 	if (info->fix.visual == FB_VISUAL_TRUECOLOR && regno < 256) {
- 		u32 val;
- 
- 		if (var->bits_per_pixel == 16 ||
- 		    var->bits_per_pixel == 32 ||
- 		    var->bits_per_pixel == 24) {
- 			val = chan_to_field(red, &var->red);
- 			val |= chan_to_field(green, &var->green);
- 			val |= chan_to_field(blue, &var->blue);
- 			par->pseudo_palette[regno] = val;
- 			goto exit;
- 		}
- 	}
- 
- 	ret = -EINVAL;
- 
- exit:
- 	return ret;
- }
- 
- static int lynxfb_ops_blank(int blank, struct fb_info *info)
- {
- 	struct lynxfb_par *par;
- 	struct lynxfb_output *output;
- 
- 	pr_debug("blank = %d.\n", blank);
- 	par = info->par;
- 	output = &par->output;
- 	return output->proc_setBLANK(output, blank);
- }
- 
- static int sm750fb_set_drv(struct lynxfb_par *par)
- {
- 	int ret;
- 	struct sm750_dev *sm750_dev;
- 	struct lynxfb_output *output;
- 	struct lynxfb_crtc *crtc;
- 
- 	ret = 0;
- 
- 	sm750_dev = par->dev;
- 	output = &par->output;
- 	crtc = &par->crtc;
- 
- 	crtc->vidmem_size = (sm750_dev->dual) ? sm750_dev->vidmem_size >> 1 :
- 			     sm750_dev->vidmem_size;
- 	/* setup crtc and output member */
- 	sm750_dev->hwCursor = g_hwcursor;
- 
- 	crtc->line_pad = 16;
- 	crtc->xpanstep = 8;
- 	crtc->ypanstep = 1;
- 	crtc->ywrapstep = 0;
- 
- 	output->proc_setBLANK = (sm750_dev->revid == SM750LE_REVISION_ID) ?
- 				 hw_sm750le_setBLANK : hw_sm750_setBLANK;
- 	/* chip specific phase */
- 	sm750_dev->accel.de_wait = (sm750_dev->revid == SM750LE_REVISION_ID) ?
- 				    hw_sm750le_deWait : hw_sm750_deWait;
- 	switch (sm750_dev->dataflow) {
- 	case sm750_simul_pri:
- 		output->paths = sm750_pnc;
- 		crtc->channel = sm750_primary;
- 		crtc->oScreen = 0;
- 		crtc->vScreen = sm750_dev->pvMem;
- 		pr_info("use simul primary mode\n");
- 		break;
- 	case sm750_simul_sec:
- 		output->paths = sm750_pnc;
- 		crtc->channel = sm750_secondary;
- 		crtc->oScreen = 0;
- 		crtc->vScreen = sm750_dev->pvMem;
- 		break;
- 	case sm750_dual_normal:
- 		if (par->index == 0) {
- 			output->paths = sm750_panel;
- 			crtc->channel = sm750_primary;
- 			crtc->oScreen = 0;
- 			crtc->vScreen = sm750_dev->pvMem;
- 		} else {
- 			output->paths = sm750_crt;
- 			crtc->channel = sm750_secondary;
- 			/* not consider of padding stuffs for oScreen,need fix */
- 			crtc->oScreen = (sm750_dev->vidmem_size >> 1);
- 			crtc->vScreen = sm750_dev->pvMem + crtc->oScreen;
- 		}
- 		break;
- 	case sm750_dual_swap:
- 		if (par->index == 0) {
- 			output->paths = sm750_panel;
- 			crtc->channel = sm750_secondary;
- 			crtc->oScreen = 0;
- 			crtc->vScreen = sm750_dev->pvMem;
- 		} else {
- 			output->paths = sm750_crt;
- 			crtc->channel = sm750_primary;
- 			/* not consider of padding stuffs for oScreen,need fix */
- 			crtc->oScreen = (sm750_dev->vidmem_size >> 1);
- 			crtc->vScreen = sm750_dev->pvMem + crtc->oScreen;
- 		}
- 		break;
- 	default:
- 		ret = -EINVAL;
- 	}
- 
- 	return ret;
- }
- 
- static struct fb_ops lynxfb_ops = {
- 	.owner = THIS_MODULE,
- 	.fb_check_var =  lynxfb_ops_check_var,
- 	.fb_set_par = lynxfb_ops_set_par,
- 	.fb_setcolreg = lynxfb_ops_setcolreg,
- 	.fb_blank = lynxfb_ops_blank,
- 	.fb_fillrect = cfb_fillrect,
- 	.fb_imageblit = cfb_imageblit,
- 	.fb_copyarea = cfb_copyarea,
- 	/* cursor */
- 	.fb_cursor = lynxfb_ops_cursor,
- };
- 
- static int lynxfb_set_fbinfo(struct fb_info *info, int index)
- {
- 	int i;
- 	struct lynxfb_par *par;
- 	struct sm750_dev *sm750_dev;
- 	struct lynxfb_crtc *crtc;
- 	struct lynxfb_output *output;
- 	struct fb_var_screeninfo *var;
- 	struct fb_fix_screeninfo *fix;
- 
- 	const struct fb_videomode *pdb[] = {
- 		lynx750_ext, NULL, vesa_modes,
- 	};
- 	int cdb[] = {ARRAY_SIZE(lynx750_ext), 0, VESA_MODEDB_SIZE};
- 	static const char *mdb_desc[] = {
- 		"driver prepared modes",
- 		"kernel prepared default modedb",
- 		"kernel HELPERS prepared vesa_modes",
- 	};
- 
- 	static const char *fixId[2] = {
- 		"sm750_fb1", "sm750_fb2",
- 	};
- 
- 	int ret, line_length;
- 
- 	ret = 0;
- 	par = (struct lynxfb_par *)info->par;
- 	sm750_dev = par->dev;
- 	crtc = &par->crtc;
- 	output = &par->output;
- 	var = &info->var;
- 	fix = &info->fix;
- 
- 	/* set index */
- 	par->index = index;
- 	output->channel = &crtc->channel;
- 	sm750fb_set_drv(par);
- 	lynxfb_ops.fb_pan_display = lynxfb_ops_pan_display;
- 
- 	/*
- 	 * set current cursor variable and proc pointer,
- 	 * must be set after crtc member initialized
- 	 */
- 	crtc->cursor.offset = crtc->oScreen + crtc->vidmem_size - 1024;
- 	crtc->cursor.mmio = sm750_dev->pvReg +
- 		0x800f0 + (int)crtc->channel * 0x140;
- 
- 	pr_info("crtc->cursor.mmio = %p\n", crtc->cursor.mmio);
- 	crtc->cursor.maxH = crtc->cursor.maxW = 64;
- 	crtc->cursor.size = crtc->cursor.maxH * crtc->cursor.maxW * 2 / 8;
- 	crtc->cursor.vstart = sm750_dev->pvMem + crtc->cursor.offset;
- 
- 	memset_io(crtc->cursor.vstart, 0, crtc->cursor.size);
- 	if (!g_hwcursor) {
- 		lynxfb_ops.fb_cursor = NULL;
- 		hw_cursor_disable(&crtc->cursor);
- 	}
- 
- 	/* set info->fbops, must be set before fb_find_mode */
- 	if (!sm750_dev->accel_off) {
- 		/* use 2d acceleration */
- 		lynxfb_ops.fb_fillrect = lynxfb_ops_fillrect;
- 		lynxfb_ops.fb_copyarea = lynxfb_ops_copyarea;
- 		lynxfb_ops.fb_imageblit = lynxfb_ops_imageblit;
- 	}
- 	info->fbops = &lynxfb_ops;
- 
- 	if (!g_fbmode[index]) {
- 		g_fbmode[index] = g_def_fbmode;
- 		if (index)
- 			g_fbmode[index] = g_fbmode[0];
- 	}
- 
- 	for (i = 0; i < 3; i++) {
- 
- 		ret = fb_find_mode(var, info, g_fbmode[index],
- 				   pdb[i], cdb[i], NULL, 8);
- 
- 		if (ret == 1) {
- 			pr_info("success! use specified mode:%s in %s\n",
- 				g_fbmode[index],
- 				mdb_desc[i]);
- 			break;
- 		} else if (ret == 2) {
- 			pr_warn("use specified mode:%s in %s,with an ignored refresh rate\n",
- 				g_fbmode[index],
- 				mdb_desc[i]);
- 			break;
- 		} else if (ret == 3) {
- 			pr_warn("wanna use default mode\n");
- 			/*break;*/
- 		} else if (ret == 4) {
- 			pr_warn("fall back to any valid mode\n");
- 		} else {
- 			pr_warn("ret = %d,fb_find_mode failed,with %s\n",
- 				ret,
- 				mdb_desc[i]);
- 		}
- 	}
- 
- 	/* some member of info->var had been set by fb_find_mode */
- 
- 	pr_info("Member of info->var is :\n\
- 		xres=%d\n\
- 		yres=%d\n\
- 		xres_virtual=%d\n\
- 		yres_virtual=%d\n\
- 		xoffset=%d\n\
- 		yoffset=%d\n\
- 		bits_per_pixel=%d\n \
- 		...\n",
- 		var->xres,
- 		var->yres,
- 		var->xres_virtual,
- 		var->yres_virtual,
- 		var->xoffset,
- 		var->yoffset,
- 		var->bits_per_pixel);
- 
- 	/* set par */
- 	par->info = info;
- 
- 	/* set info */
- 	line_length = ALIGN((var->xres_virtual * var->bits_per_pixel / 8),
- 			    crtc->line_pad);
- 
- 	info->pseudo_palette = &par->pseudo_palette[0];
- 	info->screen_base = crtc->vScreen;
- 	pr_debug("screen_base vaddr = %p\n", info->screen_base);
- 	info->screen_size = line_length * var->yres_virtual;
- 	info->flags = FBINFO_FLAG_DEFAULT | 0;
- 
- 	/* set info->fix */
- 	fix->type = FB_TYPE_PACKED_PIXELS;
- 	fix->type_aux = 0;
- 	fix->xpanstep = crtc->xpanstep;
- 	fix->ypanstep = crtc->ypanstep;
- 	fix->ywrapstep = crtc->ywrapstep;
- 	fix->accel = FB_ACCEL_SMI;
- 
- 	strlcpy(fix->id, fixId[index], sizeof(fix->id));
- 
- 	fix->smem_start = crtc->oScreen + sm750_dev->vidmem_start;
- 	pr_info("fix->smem_start = %lx\n", fix->smem_start);
- 	/*
- 	 * according to mmap experiment from user space application,
- 	 * fix->mmio_len should not larger than virtual size
- 	 * (xres_virtual x yres_virtual x ByPP)
- 	 * Below line maybe buggy when user mmap fb dev node and write
- 	 * data into the bound over virtual size
- 	 */
- 	fix->smem_len = crtc->vidmem_size;
- 	pr_info("fix->smem_len = %x\n", fix->smem_len);
- 	info->screen_size = fix->smem_len;
- 	fix->line_length = line_length;
- 	fix->mmio_start = sm750_dev->vidreg_start;
- 	pr_info("fix->mmio_start = %lx\n", fix->mmio_start);
- 	fix->mmio_len = sm750_dev->vidreg_size;
- 	pr_info("fix->mmio_len = %x\n", fix->mmio_len);
- 	switch (var->bits_per_pixel) {
- 	case 8:
- 		fix->visual = FB_VISUAL_PSEUDOCOLOR;
- 		break;
- 	case 16:
- 	case 32:
- 		fix->visual = FB_VISUAL_TRUECOLOR;
- 		break;
- 	}
- 
- 	/* set var */
- 	var->activate = FB_ACTIVATE_NOW;
- 	var->accel_flags = 0;
- 	var->vmode = FB_VMODE_NONINTERLACED;
- 
- 	pr_debug("#1 show info->cmap :\nstart=%d,len=%d,red=%p,green=%p,blue=%p,transp=%p\n",
- 		 info->cmap.start, info->cmap.len,
- 		 info->cmap.red, info->cmap.green, info->cmap.blue,
- 		 info->cmap.transp);
- 
- 	ret = fb_alloc_cmap(&info->cmap, 256, 0);
- 	if (ret < 0) {
- 		pr_err("Could not allocate memory for cmap.\n");
- 		goto exit;
- 	}
- 
- 	pr_debug("#2 show info->cmap :\nstart=%d,len=%d,red=%p,green=%p,blue=%p,transp=%p\n",
- 		 info->cmap.start, info->cmap.len,
- 		 info->cmap.red, info->cmap.green, info->cmap.blue,
- 		 info->cmap.transp);
- 
- exit:
- 	lynxfb_ops_check_var(var, info);
- 	return ret;
- }
- 
- /*	chip specific g_option configuration routine */
- static void sm750fb_setup(struct sm750_dev *sm750_dev, char *src)
- {
- 	char *opt;
- 	int swap;
- 
- 	swap = 0;
- 
- 	sm750_dev->initParm.chip_clk = 0;
- 	sm750_dev->initParm.mem_clk = 0;
- 	sm750_dev->initParm.master_clk = 0;
- 	sm750_dev->initParm.powerMode = 0;
- 	sm750_dev->initParm.setAllEngOff = 0;
- 	sm750_dev->initParm.resetMemory = 1;
- 
- 	/* defaultly turn g_hwcursor on for both view */
- 	g_hwcursor = 3;
- 
- 	if (!src || !*src) {
- 		pr_warn("no specific g_option.\n");
- 		goto NO_PARAM;
- 	}
- 
- 	while ((opt = strsep(&src, ":")) != NULL && *opt != 0) {
- 		pr_info("opt=%s\n", opt);
- 		pr_info("src=%s\n", src);
- 
- 		if (!strncmp(opt, "swap", strlen("swap")))
- 			swap = 1;
- 		else if (!strncmp(opt, "nocrt", strlen("nocrt")))
- 			sm750_dev->nocrt = 1;
- 		else if (!strncmp(opt, "36bit", strlen("36bit")))
- 			sm750_dev->pnltype = sm750_doubleTFT;
- 		else if (!strncmp(opt, "18bit", strlen("18bit")))
- 			sm750_dev->pnltype = sm750_dualTFT;
- 		else if (!strncmp(opt, "24bit", strlen("24bit")))
- 			sm750_dev->pnltype = sm750_24TFT;
- 		else if (!strncmp(opt, "nohwc0", strlen("nohwc0")))
- 			g_hwcursor &= ~0x1;
- 		else if (!strncmp(opt, "nohwc1", strlen("nohwc1")))
- 			g_hwcursor &= ~0x2;
- 		else if (!strncmp(opt, "nohwc", strlen("nohwc")))
- 			g_hwcursor = 0;
- 		else {
- 			if (!g_fbmode[0]) {
- 				g_fbmode[0] = opt;
- 				pr_info("find fbmode0 : %s\n", g_fbmode[0]);
- 			} else if (!g_fbmode[1]) {
- 				g_fbmode[1] = opt;
- 				pr_info("find fbmode1 : %s\n", g_fbmode[1]);
- 			} else {
- 				pr_warn("How many view you wann set?\n");
- 			}
- 		}
- 	}
- 
- NO_PARAM:
- 	if (sm750_dev->revid != SM750LE_REVISION_ID) {
- 		if (sm750_dev->dual) {
- 			if (swap)
- 				sm750_dev->dataflow = sm750_dual_swap;
- 			else
- 				sm750_dev->dataflow = sm750_dual_normal;
- 		} else {
- 			if (swap)
- 				sm750_dev->dataflow = sm750_simul_sec;
- 			else
- 				sm750_dev->dataflow = sm750_simul_pri;
- 		}
- 	} else {
- 		/* SM750LE only have one crt channel */
- 		sm750_dev->dataflow = sm750_simul_sec;
- 		/* sm750le do not have complex attributes */
- 		sm750_dev->nocrt = 0;
- 	}
- }
- 
- static int lynxfb_pci_probe(struct pci_dev *pdev,
- 			    const struct pci_device_id *ent)
- {
- 	struct fb_info *info[] = {NULL, NULL};
- 	struct sm750_dev *sm750_dev = NULL;
- 	int fbidx;
- 
- 	/* enable device */
- 	if (pci_enable_device(pdev)) {
- 		pr_err("can not enable device.\n");
- 		goto err_enable;
- 	}
- 
- 	sm750_dev = kzalloc(sizeof(*sm750_dev), GFP_KERNEL);
- 	if (!sm750_dev) {
- 		pr_err("Could not allocate memory for share.\n");
- 		goto err_share;
- 	}
- 
- 	sm750_dev->fbinfo[0] = sm750_dev->fbinfo[1] = NULL;
- 	sm750_dev->devid = pdev->device;
- 	sm750_dev->revid = pdev->revision;
- 
- 	pr_info("share->revid = %02x\n", sm750_dev->revid);
- 	sm750_dev->pdev = pdev;
- 	sm750_dev->mtrr_off = g_nomtrr;
- 	sm750_dev->mtrr.vram = 0;
- 	sm750_dev->accel_off = g_noaccel;
- 	sm750_dev->dual = g_dualview;
- 	spin_lock_init(&sm750_dev->slock);
- 
- 	if (!sm750_dev->accel_off) {
- 		/*
- 		 * hook deInit and 2d routines, notes that below hw_xxx
- 		 * routine can work on most of lynx chips
- 		 * if some chip need specific function,
- 		 * please hook it in smXXX_set_drv routine
- 		 */
- 		sm750_dev->accel.de_init = hw_de_init;
- 		sm750_dev->accel.de_fillrect = hw_fillrect;
- 		sm750_dev->accel.de_copyarea = hw_copyarea;
- 		sm750_dev->accel.de_imageblit = hw_imageblit;
- 		pr_info("enable 2d acceleration\n");
- 	} else {
- 		pr_info("disable 2d acceleration\n");
- 	}
- 
- 	/* call chip specific setup routine  */
- 	sm750fb_setup(sm750_dev, g_settings);
- 
- 	/* call chip specific mmap routine */
- 	if (hw_sm750_map(sm750_dev, pdev)) {
- 		pr_err("Memory map failed\n");
- 		goto err_map;
- 	}
- 
- 	if (!sm750_dev->mtrr_off)
- 		sm750_dev->mtrr.vram = arch_phys_wc_add(sm750_dev->vidmem_start,
- 							sm750_dev->vidmem_size);
- 
- 	memset_io(sm750_dev->pvMem, 0, sm750_dev->vidmem_size);
- 
- 	pr_info("sm%3x mmio address = %p\n", sm750_dev->devid,
- 		sm750_dev->pvReg);
- 
- 	pci_set_drvdata(pdev, sm750_dev);
- 
- 	/* call chipInit routine */
- 	hw_sm750_inithw(sm750_dev, pdev);
- 
- 	/* allocate frame buffer info structor according to g_dualview */
- 	fbidx = 0;
- ALLOC_FB:
- 	info[fbidx] = framebuffer_alloc(sizeof(struct lynxfb_par), &pdev->dev);
- 	if (!info[fbidx]) {
- 		pr_err("Could not allocate framebuffer #%d.\n", fbidx);
- 		if (fbidx == 0)
- 			goto err_info0_alloc;
- 		else
- 			goto err_info1_alloc;
- 	} else {
- 		struct lynxfb_par *par;
- 		int errno;
- 
- 		pr_info("framebuffer #%d alloc okay\n", fbidx);
- 		sm750_dev->fbinfo[fbidx] = info[fbidx];
- 		par = info[fbidx]->par;
- 		par->dev = sm750_dev;
- 
- 		/* set fb_info structure */
- 		if (lynxfb_set_fbinfo(info[fbidx], fbidx)) {
- 			pr_err("Failed to initial fb_info #%d.\n", fbidx);
- 			if (fbidx == 0)
- 				goto err_info0_set;
- 			else
- 				goto err_info1_set;
- 		}
- 
- 		/* register frame buffer */
- 		pr_info("Ready to register framebuffer #%d.\n", fbidx);
- 		errno = register_framebuffer(info[fbidx]);
- 		if (errno < 0) {
- 			pr_err("Failed to register fb_info #%d. err %d\n",
- 			       fbidx,
- 			       errno);
- 			if (fbidx == 0)
- 				goto err_register0;
- 			else
- 				goto err_register1;
- 		}
- 		pr_info("Accomplished register framebuffer #%d.\n", fbidx);
- 	}
- 
- 	/* no dual view by far */
- 	fbidx++;
- 	if (sm750_dev->dual && fbidx < 2)
- 		goto ALLOC_FB;
- 
- 	return 0;
- 
- err_register1:
- err_info1_set:
- 	framebuffer_release(info[1]);
- err_info1_alloc:
- 	unregister_framebuffer(info[0]);
- err_register0:
- err_info0_set:
- 	framebuffer_release(info[0]);
- err_info0_alloc:
- err_map:
- 	kfree(sm750_dev);
- err_share:
- err_enable:
- 	return -ENODEV;
- }
- 
- static void lynxfb_pci_remove(struct pci_dev *pdev)
- {
- 	struct fb_info *info;
- 	struct sm750_dev *sm750_dev;
- 	struct lynxfb_par *par;
- 	int cnt;
- 
- 	cnt = 2;
- 	sm750_dev = pci_get_drvdata(pdev);
- 
- 	while (cnt-- > 0) {
- 		info = sm750_dev->fbinfo[cnt];
- 		if (!info)
- 			continue;
- 		par = info->par;
- 
- 		unregister_framebuffer(info);
- 		/* release frame buffer */
- 		framebuffer_release(info);
- 	}
- 	arch_phys_wc_del(sm750_dev->mtrr.vram);
- 
- 	iounmap(sm750_dev->pvReg);
- 	iounmap(sm750_dev->pvMem);
- 	kfree(g_settings);
- 	kfree(sm750_dev);
- 	pci_set_drvdata(pdev, NULL);
- }
- 
- static int __init lynxfb_setup(char *options)
- {
- 	int len;
- 	char *opt, *tmp;
- 
- 	if (!options || !*options) {
- 		pr_warn("no options.\n");
- 		return 0;
- 	}
- 
- 	pr_info("options:%s\n", options);
- 
- 	len = strlen(options) + 1;
- 	g_settings = kzalloc(len, GFP_KERNEL);
- 	if (!g_settings)
- 		return -ENOMEM;
- 
- 	tmp = g_settings;
- 
- 	/*
- 	 * Notes:
- 	 * char * strsep(char **s,const char * ct);
- 	 * @s: the string to be searched
- 	 * @ct :the characters to search for
- 	 *
- 	 * strsep() updates @options to pointer after the first found token
- 	 * it also returns the pointer ahead the token.
- 	 */
- 	while ((opt = strsep(&options, ":")) != NULL) {
- 		/* options that mean for any lynx chips are configured here */
- 		if (!strncmp(opt, "noaccel", strlen("noaccel")))
- 			g_noaccel = 1;
- 		else if (!strncmp(opt, "nomtrr", strlen("nomtrr")))
- 			g_nomtrr = 1;
- 		else if (!strncmp(opt, "dual", strlen("dual")))
- 			g_dualview = 1;
- 		else {
- 			strcat(tmp, opt);
- 			tmp += strlen(opt);
- 			if (options != NULL)
- 				*tmp++ = ':';
- 			else
- 				*tmp++ = 0;
- 		}
- 	}
- 
- 	/* misc g_settings are transport to chip specific routines */
- 	pr_info("parameter left for chip specific analysis:%s\n", g_settings);
- 	return 0;
- }
- 
- static struct pci_device_id smi_pci_table[] = {
- 	{ PCI_DEVICE(0x126f, 0x0750), },
- 	{0,}
- };
- 
- MODULE_DEVICE_TABLE(pci, smi_pci_table);
- 
- static struct pci_driver lynxfb_driver = {
- 	.name =		"sm750fb",
- 	.id_table =	smi_pci_table,
- 	.probe =	lynxfb_pci_probe,
- 	.remove =	lynxfb_pci_remove,
- #ifdef CONFIG_PM
- 	.suspend = lynxfb_suspend,
- 	.resume = lynxfb_resume,
- #endif
- };
- 
- static int __init lynxfb_init(void)
- {
- 	char *option;
- 	int ret;
- 
- #ifdef MODULE
- 	option = g_option;
- #else
- 	if (fb_get_options("sm750fb", &option))
- 		return -ENODEV;
- #endif
- 
- 	lynxfb_setup(option);
- 	ret = pci_register_driver(&lynxfb_driver);
- 	return ret;
- }
- module_init(lynxfb_init);
- 
- static void __exit lynxfb_exit(void)
- {
- 	pci_unregister_driver(&lynxfb_driver);
- }
- module_exit(lynxfb_exit);
- 
- module_param(g_option, charp, S_IRUGO);
- 
- MODULE_PARM_DESC(g_option,
- 		 "\n\t\tCommon options:\n"
- 		 "\t\tnoaccel:disable 2d capabilities\n"
- 		 "\t\tnomtrr:disable MTRR attribute for video memory\n"
- 		 "\t\tdualview:dual frame buffer feature enabled\n"
- 		 "\t\tnohwc:disable hardware cursor\n"
- 		 "\t\tUsual example:\n"
- 		 "\t\tinsmod ./sm750fb.ko g_option=\"noaccel,nohwc,1280x1024-8@60\"\n"
- 		 );
- 
- MODULE_AUTHOR("monk liu <monk.liu@siliconmotion.com>");
- MODULE_AUTHOR("Sudip Mukherjee <sudip@vectorindia.org>");
- MODULE_DESCRIPTION("Frame buffer driver for SM750 chipset");
- MODULE_LICENSE("GPL v2");
--- 0 ----
diff -rcNP linux-4.4.24/drivers/staging/sm750fb/sm750_cursor.c linux-4.4.24-baikal/drivers/staging/sm750fb/sm750_cursor.c
*** linux-4.4.24/drivers/staging/sm750fb/sm750_cursor.c	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/staging/sm750fb/sm750_cursor.c	1970-01-01 03:00:00.000000000 +0300
***************
*** 1,203 ****
- #include <linux/module.h>
- #include <linux/kernel.h>
- #include <linux/errno.h>
- #include <linux/string.h>
- #include <linux/mm.h>
- #include <linux/slab.h>
- #include <linux/delay.h>
- #include <linux/fb.h>
- #include <linux/ioport.h>
- #include <linux/init.h>
- #include <linux/pci.h>
- #include <linux/vmalloc.h>
- #include <linux/pagemap.h>
- #include <linux/console.h>
- #include <linux/platform_device.h>
- #include <linux/screen_info.h>
- 
- #include "sm750.h"
- #include "sm750_help.h"
- #include "sm750_cursor.h"
- 
- 
- #define PEEK32(addr) \
- readl(cursor->mmio + (addr))
- 
- #define POKE32(addr, data) \
- writel((data), cursor->mmio + (addr))
- 
- /* cursor control for voyager and 718/750*/
- #define HWC_ADDRESS                         0x0
- #define HWC_ADDRESS_ENABLE                  31:31
- #define HWC_ADDRESS_ENABLE_DISABLE          0
- #define HWC_ADDRESS_ENABLE_ENABLE           1
- #define HWC_ADDRESS_EXT                     27:27
- #define HWC_ADDRESS_EXT_LOCAL               0
- #define HWC_ADDRESS_EXT_EXTERNAL            1
- #define HWC_ADDRESS_CS                      26:26
- #define HWC_ADDRESS_CS_0                    0
- #define HWC_ADDRESS_CS_1                    1
- #define HWC_ADDRESS_ADDRESS                 25:0
- 
- #define HWC_LOCATION                        0x4
- #define HWC_LOCATION_TOP                    27:27
- #define HWC_LOCATION_TOP_INSIDE             0
- #define HWC_LOCATION_TOP_OUTSIDE            1
- #define HWC_LOCATION_Y                      26:16
- #define HWC_LOCATION_LEFT                   11:11
- #define HWC_LOCATION_LEFT_INSIDE            0
- #define HWC_LOCATION_LEFT_OUTSIDE           1
- #define HWC_LOCATION_X                      10:0
- 
- #define HWC_COLOR_12                        0x8
- #define HWC_COLOR_12_2_RGB565               31:16
- #define HWC_COLOR_12_1_RGB565               15:0
- 
- #define HWC_COLOR_3                         0xC
- #define HWC_COLOR_3_RGB565                  15:0
- 
- 
- /* hw_cursor_xxx works for voyager,718 and 750 */
- void hw_cursor_enable(struct lynx_cursor *cursor)
- {
- 	u32 reg;
- 
- 	reg = FIELD_VALUE(0, HWC_ADDRESS, ADDRESS, cursor->offset)|
- 			FIELD_SET(0, HWC_ADDRESS, EXT, LOCAL)|
- 			FIELD_SET(0, HWC_ADDRESS, ENABLE, ENABLE);
- 	POKE32(HWC_ADDRESS, reg);
- }
- void hw_cursor_disable(struct lynx_cursor *cursor)
- {
- 	POKE32(HWC_ADDRESS, 0);
- }
- 
- void hw_cursor_setSize(struct lynx_cursor *cursor,
- 						int w, int h)
- {
- 	cursor->w = w;
- 	cursor->h = h;
- }
- void hw_cursor_setPos(struct lynx_cursor *cursor,
- 						int x, int y)
- {
- 	u32 reg;
- 
- 	reg = FIELD_VALUE(0, HWC_LOCATION, Y, y)|
- 			FIELD_VALUE(0, HWC_LOCATION, X, x);
- 	POKE32(HWC_LOCATION, reg);
- }
- void hw_cursor_setColor(struct lynx_cursor *cursor,
- 						u32 fg, u32 bg)
- {
- 	POKE32(HWC_COLOR_12, (fg<<16)|(bg&0xffff));
- 	POKE32(HWC_COLOR_3, 0xffe0);
- }
- 
- void hw_cursor_setData(struct lynx_cursor *cursor,
- 			u16 rop, const u8 *pcol, const u8 *pmsk)
- {
- 	int i, j, count, pitch, offset;
- 	u8 color, mask, opr;
- 	u16 data;
- 	void __iomem *pbuffer, *pstart;
- 
- 	/*  in byte*/
- 	pitch = cursor->w >> 3;
- 
- 	/* in byte	*/
- 	count = pitch * cursor->h;
- 
- 	/* in byte */
- 	offset = cursor->maxW * 2 / 8;
- 
- 	data = 0;
- 	pstart = cursor->vstart;
- 	pbuffer = pstart;
- 
- /*
- 	if(odd &1){
- 		hw_cursor_setData2(cursor,rop,pcol,pmsk);
- 	}
- 	odd++;
- 	if(odd > 0xfffffff0)
- 		odd=0;
- */
- 
- 	for (i = 0; i < count; i++) {
- 		color = *pcol++;
- 		mask = *pmsk++;
- 		data = 0;
- 
- 		for (j = 0; j < 8; j++) {
- 			if (mask & (0x80>>j)) {
- 				if (rop == ROP_XOR)
- 					opr = mask ^ color;
- 				else
- 					opr = mask & color;
- 
- 				/* 2 stands for forecolor and 1 for backcolor */
- 				data |= ((opr & (0x80>>j))?2:1)<<(j*2);
- 			}
- 		}
- 		iowrite16(data, pbuffer);
- 
- 		/* assume pitch is 1,2,4,8,...*/
- 		if ((i+1) % pitch == 0)
- 		{
- 			/* need a return */
- 			pstart += offset;
- 			pbuffer = pstart;
- 		} else {
- 			pbuffer += sizeof(u16);
- 		}
- 
- 	}
- 
- 
- }
- 
- 
- void hw_cursor_setData2(struct lynx_cursor *cursor,
- 			u16 rop, const u8 *pcol, const u8 *pmsk)
- {
- 	int i, j, count, pitch, offset;
- 	u8 color, mask;
- 	u16 data;
- 	void __iomem *pbuffer, *pstart;
- 
- 	/*  in byte*/
- 	pitch = cursor->w >> 3;
- 
- 	/* in byte	*/
- 	count = pitch * cursor->h;
- 
- 	/* in byte */
- 	offset = cursor->maxW * 2 / 8;
- 
- 	data = 0;
- 	pstart = cursor->vstart;
- 	pbuffer = pstart;
- 
- 	for (i = 0; i < count; i++) {
- 		color = *pcol++;
- 		mask = *pmsk++;
- 		data = 0;
- 
- 		for (j = 0; j < 8; j++) {
- 			if (mask & (1<<j))
- 				data |= ((color & (1<<j))?1:2)<<(j*2);
- 		}
- 		iowrite16(data, pbuffer);
- 
- 		/* assume pitch is 1,2,4,8,...*/
- 		if (!(i&(pitch-1))) {
- 			/* need a return */
- 			pstart += offset;
- 			pbuffer = pstart;
- 		} else {
- 			pbuffer += sizeof(u16);
- 		}
- 
- 	}
- }
--- 0 ----
diff -rcNP linux-4.4.24/drivers/staging/sm750fb/sm750_cursor.h linux-4.4.24-baikal/drivers/staging/sm750fb/sm750_cursor.h
*** linux-4.4.24/drivers/staging/sm750fb/sm750_cursor.h	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/staging/sm750fb/sm750_cursor.h	1970-01-01 03:00:00.000000000 +0300
***************
*** 1,17 ****
- #ifndef LYNX_CURSOR_H__
- #define LYNX_CURSOR_H__
- 
- /* hw_cursor_xxx works for voyager,718 and 750 */
- void hw_cursor_enable(struct lynx_cursor *cursor);
- void hw_cursor_disable(struct lynx_cursor *cursor);
- void hw_cursor_setSize(struct lynx_cursor *cursor,
- 						int w, int h);
- void hw_cursor_setPos(struct lynx_cursor *cursor,
- 						int x, int y);
- void hw_cursor_setColor(struct lynx_cursor *cursor,
- 						u32 fg, u32 bg);
- void hw_cursor_setData(struct lynx_cursor *cursor,
- 			u16 rop, const u8 *data, const u8 *mask);
- void hw_cursor_setData2(struct lynx_cursor *cursor,
- 			u16 rop, const u8 *data, const u8 *mask);
- #endif
--- 0 ----
diff -rcNP linux-4.4.24/drivers/staging/sm750fb/sm750.h linux-4.4.24-baikal/drivers/staging/sm750fb/sm750.h
*** linux-4.4.24/drivers/staging/sm750fb/sm750.h	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/staging/sm750fb/sm750.h	1970-01-01 03:00:00.000000000 +0300
***************
*** 1,202 ****
- #ifndef LYNXDRV_H_
- #define LYNXDRV_H_
- 
- #define FB_ACCEL_SMI 0xab
- 
- #define MHZ(x) ((x) * 1000000)
- 
- #define DEFAULT_SM750_CHIP_CLOCK	290
- #define DEFAULT_SM750LE_CHIP_CLOCK	333
- #ifndef SM750LE_REVISION_ID
- #define SM750LE_REVISION_ID ((unsigned char)0xfe)
- #endif
- 
- enum sm750_pnltype {
- 	sm750_24TFT = 0,	/* 24bit tft */
- 	sm750_dualTFT = 2,	/* dual 18 bit tft */
- 	sm750_doubleTFT = 1,	/* 36 bit double pixel tft */
- };
- 
- /* vga channel is not concerned  */
- enum sm750_dataflow {
- 	sm750_simul_pri,	/* primary => all head */
- 	sm750_simul_sec,	/* secondary => all head */
- 	sm750_dual_normal,	/* primary => panel head and secondary => crt */
- 	sm750_dual_swap,	/* primary => crt head and secondary => panel */
- };
- 
- enum sm750_channel {
- 	sm750_primary = 0,
- 	/* enum value equal to the register filed data */
- 	sm750_secondary = 1,
- };
- 
- enum sm750_path {
- 	sm750_panel = 1,
- 	sm750_crt = 2,
- 	sm750_pnc = 3,	/* panel and crt */
- };
- 
- struct init_status {
- 	ushort powerMode;
- 	/* below three clocks are in unit of MHZ*/
- 	ushort chip_clk;
- 	ushort mem_clk;
- 	ushort master_clk;
- 	ushort setAllEngOff;
- 	ushort resetMemory;
- };
- 
- struct lynx_accel {
- 	/* base virtual address of DPR registers */
- 	volatile unsigned char __iomem *dprBase;
- 	/* base virtual address of de data port */
- 	volatile unsigned char __iomem *dpPortBase;
- 
- 	/* function fointers */
- 	void (*de_init)(struct lynx_accel *);
- 
- 	int (*de_wait)(void);/* see if hardware ready to work */
- 
- 	int (*de_fillrect)(struct lynx_accel *, u32, u32, u32, u32,
- 						u32, u32, u32, u32, u32);
- 
- 	int (*de_copyarea)(struct lynx_accel *, u32, u32, u32, u32,
- 						u32, u32, u32, u32,
- 						u32, u32, u32, u32);
- 
- 	int (*de_imageblit)(struct lynx_accel *, const char *, u32, u32, u32, u32,
- 							       u32, u32, u32, u32,
- 							       u32, u32, u32, u32);
- 
- };
- 
- struct sm750_dev {
- 	/* common members */
- 	u16 devid;
- 	u8 revid;
- 	struct pci_dev *pdev;
- 	struct fb_info *fbinfo[2];
- 	struct lynx_accel accel;
- 	int accel_off;
- 	int dual;
- 	int mtrr_off;
- 	struct{
- 		int vram;
- 	} mtrr;
- 	/* all smi graphic adaptor got below attributes */
- 	unsigned long vidmem_start;
- 	unsigned long vidreg_start;
- 	__u32 vidmem_size;
- 	__u32 vidreg_size;
- 	void __iomem *pvReg;
- 	unsigned char __iomem *pvMem;
- 	/* locks*/
- 	spinlock_t slock;
- 
- 	struct init_status initParm;
- 	enum sm750_pnltype pnltype;
- 	enum sm750_dataflow dataflow;
- 	int nocrt;
- 
- 	/*
- 	 * 0: no hardware cursor
- 	 * 1: primary crtc hw cursor enabled,
- 	 * 2: secondary crtc hw cursor enabled
- 	 * 3: both ctrc hw cursor enabled
- 	 */
- 	int hwCursor;
- };
- 
- struct lynx_cursor {
- 	/* cursor width ,height and size */
- 	int w;
- 	int h;
- 	int size;
- 	/* hardware limitation */
- 	int maxW;
- 	int maxH;
- 	/* base virtual address and offset  of cursor image */
- 	char __iomem *vstart;
- 	int offset;
- 	/* mmio addr of hw cursor */
- 	volatile char __iomem *mmio;
- };
- 
- struct lynxfb_crtc {
- 	unsigned char __iomem *vCursor; /* virtual address of cursor */
- 	unsigned char __iomem *vScreen; /* virtual address of on_screen */
- 	int oCursor; /* cursor address offset in vidmem */
- 	int oScreen; /* onscreen address offset in vidmem */
- 	int channel;/* which channel this crtc stands for*/
- 	resource_size_t vidmem_size;/* this view's video memory max size */
- 
- 	/* below attributes belong to info->fix, their value depends on specific adaptor*/
- 	u16 line_pad;/* padding information:0,1,2,4,8,16,... */
- 	u16 xpanstep;
- 	u16 ypanstep;
- 	u16 ywrapstep;
- 
- 	void *priv;
- 
- 	/* cursor information */
- 	struct lynx_cursor cursor;
- };
- 
- struct lynxfb_output {
- 	int dpms;
- 	int paths;
- 	/* which paths(s) this output stands for,for sm750:
- 	   paths=1:means output for panel paths
- 	   paths=2:means output for crt paths
- 	   paths=3:means output for both panel and crt paths
- 	*/
- 
- 	int *channel;
- 	/* which channel these outputs linked with,for sm750:
- 	   *channel=0 means primary channel
- 	   *channel=1 means secondary channel
- 	   output->channel ==> &crtc->channel
- 	*/
- 	void *priv;
- 
- 	int (*proc_setBLANK)(struct lynxfb_output*, int);
- };
- 
- struct lynxfb_par {
- 	/* either 0 or 1 for dual head adaptor,0 is the older one registered */
- 	int index;
- 	unsigned int pseudo_palette[256];
- 	struct lynxfb_crtc crtc;
- 	struct lynxfb_output output;
- 	struct fb_info *info;
- 	struct sm750_dev *dev;
- };
- 
- static inline unsigned long ps_to_hz(unsigned int psvalue)
- {
- 	unsigned long long numerator = 1000*1000*1000*1000ULL;
- 	/* 10^12 / picosecond period gives frequency in Hz */
- 	do_div(numerator, psvalue);
- 	return (unsigned long)numerator;
- }
- 
- int hw_sm750_map(struct sm750_dev *sm750_dev, struct pci_dev *pdev);
- int hw_sm750_inithw(struct sm750_dev*, struct pci_dev *);
- void hw_sm750_initAccel(struct sm750_dev *);
- int hw_sm750_deWait(void);
- int hw_sm750le_deWait(void);
- 
- int hw_sm750_output_setMode(struct lynxfb_output*, struct fb_var_screeninfo*,
- 			    struct fb_fix_screeninfo*);
- int hw_sm750_crtc_checkMode(struct lynxfb_crtc*, struct fb_var_screeninfo*);
- int hw_sm750_crtc_setMode(struct lynxfb_crtc*, struct fb_var_screeninfo*,
- 			  struct fb_fix_screeninfo*);
- int hw_sm750_setColReg(struct lynxfb_crtc*, ushort, ushort, ushort, ushort);
- int hw_sm750_setBLANK(struct lynxfb_output*, int);
- int hw_sm750le_setBLANK(struct lynxfb_output*, int);
- int hw_sm750_pan_display(struct lynxfb_crtc *crtc,
- 			 const struct fb_var_screeninfo *var,
- 			 const struct fb_info *info);
- 
- #endif
--- 0 ----
diff -rcNP linux-4.4.24/drivers/staging/sm750fb/sm750_help.h linux-4.4.24-baikal/drivers/staging/sm750fb/sm750_help.h
*** linux-4.4.24/drivers/staging/sm750fb/sm750_help.h	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/staging/sm750fb/sm750_help.h	1970-01-01 03:00:00.000000000 +0300
***************
*** 1,56 ****
- #ifndef LYNX_HELP_H__
- #define LYNX_HELP_H__
- 
- /* Internal macros */
- #define _F_START(f)             (0 ? f)
- #define _F_END(f)               (1 ? f)
- #define _F_SIZE(f)              (1 + _F_END(f) - _F_START(f))
- #define _F_MASK(f)              (((1 << _F_SIZE(f)) - 1) << _F_START(f))
- #define _F_NORMALIZE(v, f)      (((v) & _F_MASK(f)) >> _F_START(f))
- #define _F_DENORMALIZE(v, f)    (((v) << _F_START(f)) & _F_MASK(f))
- 
- /* Global macros */
- #define FIELD_GET(x, reg, field) \
- ( \
- 	_F_NORMALIZE((x), reg ## _ ## field) \
- )
- 
- #define FIELD_SET(x, reg, field, value) \
- ( \
- 	(x & ~_F_MASK(reg ## _ ## field)) \
- 	| _F_DENORMALIZE(reg ## _ ## field ## _ ## value, reg ## _ ## field) \
- )
- 
- #define FIELD_VALUE(x, reg, field, value) \
- ( \
- 	(x & ~_F_MASK(reg ## _ ## field)) \
- 	| _F_DENORMALIZE(value, reg ## _ ## field) \
- )
- 
- #define FIELD_CLEAR(reg, field) \
- ( \
- 	~_F_MASK(reg ## _ ## field) \
- )
- 
- /* Field Macros */
- #define FIELD_START(field)              (0 ? field)
- #define FIELD_END(field)                (1 ? field)
- #define FIELD_SIZE(field)               (1 + FIELD_END(field) - FIELD_START(field))
- #define FIELD_MASK(field)               (((1 << (FIELD_SIZE(field)-1)) | ((1 << (FIELD_SIZE(field)-1)) - 1)) << FIELD_START(field))
- 
- static inline unsigned int absDiff(unsigned int a, unsigned int b)
- {
- 	if (a < b)
- 		return b-a;
- 	else
- 		return a-b;
- }
- 
- /* n / d + 1 / 2 = (2n + d) / 2d */
- #define roundedDiv(num, denom)	((2 * (num) + (denom)) / (2 * (denom)))
- #define MHz(x) ((x) * 1000000)
- 
- 
- 
- 
- #endif
--- 0 ----
diff -rcNP linux-4.4.24/drivers/staging/sm750fb/sm750_hw.c linux-4.4.24-baikal/drivers/staging/sm750fb/sm750_hw.c
*** linux-4.4.24/drivers/staging/sm750fb/sm750_hw.c	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/staging/sm750fb/sm750_hw.c	1970-01-01 03:00:00.000000000 +0300
***************
*** 1,552 ****
- #include <linux/version.h>
- #include <linux/module.h>
- #include <linux/kernel.h>
- #include <linux/errno.h>
- #include <linux/string.h>
- #include <linux/mm.h>
- #include <linux/slab.h>
- #include <linux/delay.h>
- #include <linux/fb.h>
- #include <linux/ioport.h>
- #include <linux/init.h>
- #include <linux/pci.h>
- #include <linux/vmalloc.h>
- #include <linux/pagemap.h>
- #include <linux/console.h>
- #ifdef CONFIG_MTRR
- #include <asm/mtrr.h>
- #endif
- #include <linux/platform_device.h>
- #include <linux/screen_info.h>
- #include <linux/sizes.h>
- 
- #include "sm750.h"
- #include "ddk750.h"
- #include "sm750_accel.h"
- 
- int hw_sm750_map(struct sm750_dev *sm750_dev, struct pci_dev *pdev)
- {
- 	int ret;
- 
- 	ret = 0;
- 
- 	sm750_dev->vidreg_start  = pci_resource_start(pdev, 1);
- 	sm750_dev->vidreg_size = SZ_2M;
- 
- 	pr_info("mmio phyAddr = %lx\n", sm750_dev->vidreg_start);
- 
- 	/* reserve the vidreg space of smi adaptor
- 	 * if you do this, u need to add release region code
- 	 * in lynxfb_remove, or memory will not be mapped again
- 	 * successfully
- 	 * */
- 	ret = pci_request_region(pdev, 1, "sm750fb");
- 	if (ret) {
- 		pr_err("Can not request PCI regions.\n");
- 		goto exit;
- 	}
- 
- 	/* now map mmio and vidmem*/
- 	sm750_dev->pvReg = ioremap_nocache(sm750_dev->vidreg_start,
- 					   sm750_dev->vidreg_size);
- 	if (!sm750_dev->pvReg) {
- 		pr_err("mmio failed\n");
- 		ret = -EFAULT;
- 		goto exit;
- 	} else {
- 		pr_info("mmio virtual addr = %p\n", sm750_dev->pvReg);
- 	}
- 
- 
- 	sm750_dev->accel.dprBase = sm750_dev->pvReg + DE_BASE_ADDR_TYPE1;
- 	sm750_dev->accel.dpPortBase = sm750_dev->pvReg + DE_PORT_ADDR_TYPE1;
- 
- 	ddk750_set_mmio(sm750_dev->pvReg, sm750_dev->devid, sm750_dev->revid);
- 
- 	sm750_dev->vidmem_start = pci_resource_start(pdev, 0);
- 	/* don't use pdev_resource[x].end - resource[x].start to
- 	 * calculate the resource size,its only the maximum available
- 	 * size but not the actual size,use
- 	 * @ddk750_getVMSize function can be safe.
- 	 * */
- 	sm750_dev->vidmem_size = ddk750_getVMSize();
- 	pr_info("video memory phyAddr = %lx, size = %u bytes\n",
- 		sm750_dev->vidmem_start, sm750_dev->vidmem_size);
- 
- 	/* reserve the vidmem space of smi adaptor */
- 	sm750_dev->pvMem = ioremap_wc(sm750_dev->vidmem_start,
- 				      sm750_dev->vidmem_size);
- 	if (!sm750_dev->pvMem) {
- 		pr_err("Map video memory failed\n");
- 		ret = -EFAULT;
- 		goto exit;
- 	} else {
- 		pr_info("video memory vaddr = %p\n", sm750_dev->pvMem);
- 	}
- exit:
- 	return ret;
- }
- 
- 
- 
- int hw_sm750_inithw(struct sm750_dev *sm750_dev, struct pci_dev *pdev)
- {
- 	struct init_status *parm;
- 
- 	parm = &sm750_dev->initParm;
- 	if (parm->chip_clk == 0)
- 		parm->chip_clk = (getChipType() == SM750LE) ?
- 						DEFAULT_SM750LE_CHIP_CLOCK :
- 						DEFAULT_SM750_CHIP_CLOCK;
- 
- 	if (parm->mem_clk == 0)
- 		parm->mem_clk = parm->chip_clk;
- 	if (parm->master_clk == 0)
- 		parm->master_clk = parm->chip_clk/3;
- 
- 	ddk750_initHw((initchip_param_t *)&sm750_dev->initParm);
- 	/* for sm718,open pci burst */
- 	if (sm750_dev->devid == 0x718) {
- 		POKE32(SYSTEM_CTRL,
- 				FIELD_SET(PEEK32(SYSTEM_CTRL), SYSTEM_CTRL, PCI_BURST, ON));
- 	}
- 
- 	if (getChipType() != SM750LE) {
- 		/* does user need CRT ?*/
- 		if (sm750_dev->nocrt) {
- 			POKE32(MISC_CTRL,
- 					FIELD_SET(PEEK32(MISC_CTRL),
- 					MISC_CTRL,
- 					DAC_POWER, OFF));
- 			/* shut off dpms */
- 			POKE32(SYSTEM_CTRL,
- 					FIELD_SET(PEEK32(SYSTEM_CTRL),
- 					SYSTEM_CTRL,
- 					DPMS, VNHN));
- 		} else {
- 			POKE32(MISC_CTRL,
- 					FIELD_SET(PEEK32(MISC_CTRL),
- 					MISC_CTRL,
- 					DAC_POWER, ON));
- 			/* turn on dpms */
- 			POKE32(SYSTEM_CTRL,
- 					FIELD_SET(PEEK32(SYSTEM_CTRL),
- 					SYSTEM_CTRL,
- 					DPMS, VPHP));
- 		}
- 
- 		switch (sm750_dev->pnltype) {
- 		case sm750_doubleTFT:
- 		case sm750_24TFT:
- 		case sm750_dualTFT:
- 		POKE32(PANEL_DISPLAY_CTRL,
- 			FIELD_VALUE(PEEK32(PANEL_DISPLAY_CTRL),
- 						PANEL_DISPLAY_CTRL,
- 						TFT_DISP,
- 						sm750_dev->pnltype));
- 		break;
- 		}
- 	} else {
- 		/* for 750LE ,no DVI chip initilization makes Monitor no signal */
- 		/* Set up GPIO for software I2C to program DVI chip in the
- 		   Xilinx SP605 board, in order to have video signal.
- 		 */
- 	sm750_sw_i2c_init(0, 1);
- 
- 
- 	/* Customer may NOT use CH7301 DVI chip, which has to be
- 	   initialized differently.
- 	*/
- 	if (sm750_sw_i2c_read_reg(0xec, 0x4a) == 0x95) {
- 		/* The following register values for CH7301 are from
- 		   Chrontel app note and our experiment.
- 		*/
- 			pr_info("yes,CH7301 DVI chip found\n");
- 		sm750_sw_i2c_write_reg(0xec, 0x1d, 0x16);
- 		sm750_sw_i2c_write_reg(0xec, 0x21, 0x9);
- 		sm750_sw_i2c_write_reg(0xec, 0x49, 0xC0);
- 			pr_info("okay,CH7301 DVI chip setup done\n");
- 	}
- 	}
- 
- 	/* init 2d engine */
- 	if (!sm750_dev->accel_off)
- 		hw_sm750_initAccel(sm750_dev);
- 
- 	return 0;
- }
- 
- int hw_sm750_output_setMode(struct lynxfb_output *output,
- 									struct fb_var_screeninfo *var, struct fb_fix_screeninfo *fix)
- {
- 	int ret;
- 	disp_output_t dispSet;
- 	int channel;
- 
- 	ret = 0;
- 	dispSet = 0;
- 	channel = *output->channel;
- 
- 
- 	if (getChipType() != SM750LE) {
- 		if (channel == sm750_primary) {
- 			pr_info("primary channel\n");
- 			if (output->paths & sm750_panel)
- 				dispSet |= do_LCD1_PRI;
- 			if (output->paths & sm750_crt)
- 				dispSet |= do_CRT_PRI;
- 
- 		} else {
- 			pr_info("secondary channel\n");
- 			if (output->paths & sm750_panel)
- 				dispSet |= do_LCD1_SEC;
- 			if (output->paths & sm750_crt)
- 				dispSet |= do_CRT_SEC;
- 
- 		}
- 		ddk750_setLogicalDispOut(dispSet);
- 	} else {
- 		/* just open DISPLAY_CONTROL_750LE register bit 3:0*/
- 		u32 reg;
- 
- 		reg = PEEK32(DISPLAY_CONTROL_750LE);
- 		reg |= 0xf;
- 		POKE32(DISPLAY_CONTROL_750LE, reg);
- 	}
- 
- 	pr_info("ddk setlogicdispout done\n");
- 	return ret;
- }
- 
- int hw_sm750_crtc_checkMode(struct lynxfb_crtc *crtc, struct fb_var_screeninfo *var)
- {
- 	struct sm750_dev *sm750_dev;
- 	struct lynxfb_par *par = container_of(crtc, struct lynxfb_par, crtc);
- 
- 	sm750_dev = par->dev;
- 
- 	switch (var->bits_per_pixel) {
- 	case 8:
- 	case 16:
- 		break;
- 	case 32:
- 		if (sm750_dev->revid == SM750LE_REVISION_ID) {
- 			pr_debug("750le do not support 32bpp\n");
- 			return -EINVAL;
- 		}
- 		break;
- 	default:
- 		return -EINVAL;
- 
- 	}
- 
- 	return 0;
- }
- 
- 
- /*
- 	set the controller's mode for @crtc charged with @var and @fix parameters
- */
- int hw_sm750_crtc_setMode(struct lynxfb_crtc *crtc,
- 								struct fb_var_screeninfo *var,
- 								struct fb_fix_screeninfo *fix)
- {
- 	int ret, fmt;
- 	u32 reg;
- 	mode_parameter_t modparm;
- 	clock_type_t clock;
- 	struct sm750_dev *sm750_dev;
- 	struct lynxfb_par *par;
- 
- 
- 	ret = 0;
- 	par = container_of(crtc, struct lynxfb_par, crtc);
- 	sm750_dev = par->dev;
- 
- 	if (!sm750_dev->accel_off) {
- 		/* set 2d engine pixel format according to mode bpp */
- 		switch (var->bits_per_pixel) {
- 		case 8:
- 			fmt = 0;
- 			break;
- 		case 16:
- 			fmt = 1;
- 			break;
- 		case 32:
- 		default:
- 			fmt = 2;
- 			break;
- 		}
- 		hw_set2dformat(&sm750_dev->accel, fmt);
- 	}
- 
- 	/* set timing */
- 	modparm.pixel_clock = ps_to_hz(var->pixclock);
- 	modparm.vertical_sync_polarity = (var->sync & FB_SYNC_HOR_HIGH_ACT) ? POS:NEG;
- 	modparm.horizontal_sync_polarity = (var->sync & FB_SYNC_VERT_HIGH_ACT) ? POS:NEG;
- 	modparm.clock_phase_polarity = (var->sync & FB_SYNC_COMP_HIGH_ACT) ? POS:NEG;
- 	modparm.horizontal_display_end = var->xres;
- 	modparm.horizontal_sync_width = var->hsync_len;
- 	modparm.horizontal_sync_start = var->xres + var->right_margin;
- 	modparm.horizontal_total = var->xres + var->left_margin + var->right_margin + var->hsync_len;
- 	modparm.vertical_display_end = var->yres;
- 	modparm.vertical_sync_height = var->vsync_len;
- 	modparm.vertical_sync_start = var->yres + var->lower_margin;
- 	modparm.vertical_total = var->yres + var->upper_margin + var->lower_margin + var->vsync_len;
- 
- 	/* choose pll */
- 	if (crtc->channel != sm750_secondary)
- 		clock = PRIMARY_PLL;
- 	else
- 		clock = SECONDARY_PLL;
- 
- 	pr_debug("Request pixel clock = %lu\n", modparm.pixel_clock);
- 	ret = ddk750_setModeTiming(&modparm, clock);
- 	if (ret) {
- 		pr_err("Set mode timing failed\n");
- 		goto exit;
- 	}
- 
- 	if (crtc->channel != sm750_secondary) {
- 		/* set pitch, offset ,width,start address ,etc... */
- 		POKE32(PANEL_FB_ADDRESS,
- 			FIELD_SET(0, PANEL_FB_ADDRESS, STATUS, CURRENT)|
- 			FIELD_SET(0, PANEL_FB_ADDRESS, EXT, LOCAL)|
- 			FIELD_VALUE(0, PANEL_FB_ADDRESS, ADDRESS, crtc->oScreen));
- 
- 		reg = var->xres * (var->bits_per_pixel >> 3);
- 		/* crtc->channel is not equal to par->index on numeric,be aware of that */
- 		reg = ALIGN(reg, crtc->line_pad);
- 
- 		POKE32(PANEL_FB_WIDTH,
- 			FIELD_VALUE(0, PANEL_FB_WIDTH, WIDTH, reg)|
- 			FIELD_VALUE(0, PANEL_FB_WIDTH, OFFSET, fix->line_length));
- 
- 		POKE32(PANEL_WINDOW_WIDTH,
- 			FIELD_VALUE(0, PANEL_WINDOW_WIDTH, WIDTH, var->xres - 1)|
- 			FIELD_VALUE(0, PANEL_WINDOW_WIDTH, X, var->xoffset));
- 
- 		POKE32(PANEL_WINDOW_HEIGHT,
- 			FIELD_VALUE(0, PANEL_WINDOW_HEIGHT, HEIGHT, var->yres_virtual - 1)|
- 			FIELD_VALUE(0, PANEL_WINDOW_HEIGHT, Y, var->yoffset));
- 
- 		POKE32(PANEL_PLANE_TL, 0);
- 
- 		POKE32(PANEL_PLANE_BR,
- 			FIELD_VALUE(0, PANEL_PLANE_BR, BOTTOM, var->yres - 1)|
- 			FIELD_VALUE(0, PANEL_PLANE_BR, RIGHT, var->xres - 1));
- 
- 		/* set pixel format */
- 		reg = PEEK32(PANEL_DISPLAY_CTRL);
- 		POKE32(PANEL_DISPLAY_CTRL,
- 			FIELD_VALUE(reg,
- 			PANEL_DISPLAY_CTRL, FORMAT,
- 			(var->bits_per_pixel >> 4)
- 			));
- 	} else {
- 		/* not implemented now */
- 		POKE32(CRT_FB_ADDRESS, crtc->oScreen);
- 		reg = var->xres * (var->bits_per_pixel >> 3);
- 		/* crtc->channel is not equal to par->index on numeric,be aware of that */
- 		reg = ALIGN(reg, crtc->line_pad);
- 
- 		POKE32(CRT_FB_WIDTH,
- 			FIELD_VALUE(0, CRT_FB_WIDTH, WIDTH, reg)|
- 			FIELD_VALUE(0, CRT_FB_WIDTH, OFFSET, fix->line_length));
- 
- 		/* SET PIXEL FORMAT */
- 		reg = PEEK32(CRT_DISPLAY_CTRL);
- 		reg = FIELD_VALUE(reg, CRT_DISPLAY_CTRL, FORMAT, var->bits_per_pixel >> 4);
- 		POKE32(CRT_DISPLAY_CTRL, reg);
- 
- 	}
- 
- 
- exit:
- 	return ret;
- }
- 
- int hw_sm750_setColReg(struct lynxfb_crtc *crtc, ushort index,
- 								ushort red, ushort green, ushort blue)
- {
- 	static unsigned int add[] = {PANEL_PALETTE_RAM, CRT_PALETTE_RAM};
- 
- 	POKE32(add[crtc->channel] + index*4, (red<<16)|(green<<8)|blue);
- 	return 0;
- }
- 
- int hw_sm750le_setBLANK(struct lynxfb_output *output, int blank)
- {
- 	int dpms, crtdb;
- 
- 	switch (blank) {
- 	case FB_BLANK_UNBLANK:
- 		dpms = CRT_DISPLAY_CTRL_DPMS_0;
- 		crtdb = CRT_DISPLAY_CTRL_BLANK_OFF;
- 		break;
- 	case FB_BLANK_NORMAL:
- 		dpms = CRT_DISPLAY_CTRL_DPMS_0;
- 		crtdb = CRT_DISPLAY_CTRL_BLANK_ON;
- 		break;
- 	case FB_BLANK_VSYNC_SUSPEND:
- 		dpms = CRT_DISPLAY_CTRL_DPMS_2;
- 		crtdb = CRT_DISPLAY_CTRL_BLANK_ON;
- 		break;
- 	case FB_BLANK_HSYNC_SUSPEND:
- 		dpms = CRT_DISPLAY_CTRL_DPMS_1;
- 		crtdb = CRT_DISPLAY_CTRL_BLANK_ON;
- 		break;
- 	case FB_BLANK_POWERDOWN:
- 		dpms = CRT_DISPLAY_CTRL_DPMS_3;
- 		crtdb = CRT_DISPLAY_CTRL_BLANK_ON;
- 		break;
- 	default:
- 		return -EINVAL;
- 	}
- 
- 	if (output->paths & sm750_crt) {
- 		POKE32(CRT_DISPLAY_CTRL, FIELD_VALUE(PEEK32(CRT_DISPLAY_CTRL), CRT_DISPLAY_CTRL, DPMS, dpms));
- 		POKE32(CRT_DISPLAY_CTRL, FIELD_VALUE(PEEK32(CRT_DISPLAY_CTRL), CRT_DISPLAY_CTRL, BLANK, crtdb));
- 	}
- 	return 0;
- }
- 
- int hw_sm750_setBLANK(struct lynxfb_output *output, int blank)
- {
- 	unsigned int dpms, pps, crtdb;
- 
- 	dpms = pps = crtdb = 0;
- 
- 	switch (blank) {
- 	case FB_BLANK_UNBLANK:
- 		pr_info("flag = FB_BLANK_UNBLANK\n");
- 		dpms = SYSTEM_CTRL_DPMS_VPHP;
- 		pps = PANEL_DISPLAY_CTRL_DATA_ENABLE;
- 		crtdb = CRT_DISPLAY_CTRL_BLANK_OFF;
- 		break;
- 	case FB_BLANK_NORMAL:
- 		pr_info("flag = FB_BLANK_NORMAL\n");
- 		dpms = SYSTEM_CTRL_DPMS_VPHP;
- 		pps = PANEL_DISPLAY_CTRL_DATA_DISABLE;
- 		crtdb = CRT_DISPLAY_CTRL_BLANK_ON;
- 		break;
- 	case FB_BLANK_VSYNC_SUSPEND:
- 		dpms = SYSTEM_CTRL_DPMS_VNHP;
- 		pps = PANEL_DISPLAY_CTRL_DATA_DISABLE;
- 		crtdb = CRT_DISPLAY_CTRL_BLANK_ON;
- 		break;
- 	case FB_BLANK_HSYNC_SUSPEND:
- 		dpms = SYSTEM_CTRL_DPMS_VPHN;
- 		pps = PANEL_DISPLAY_CTRL_DATA_DISABLE;
- 		crtdb = CRT_DISPLAY_CTRL_BLANK_ON;
- 		break;
- 	case FB_BLANK_POWERDOWN:
- 		dpms = SYSTEM_CTRL_DPMS_VNHN;
- 		pps = PANEL_DISPLAY_CTRL_DATA_DISABLE;
- 		crtdb = CRT_DISPLAY_CTRL_BLANK_ON;
- 		break;
- 	}
- 
- 	if (output->paths & sm750_crt) {
- 
- 		POKE32(SYSTEM_CTRL, FIELD_VALUE(PEEK32(SYSTEM_CTRL), SYSTEM_CTRL, DPMS, dpms));
- 		POKE32(CRT_DISPLAY_CTRL, FIELD_VALUE(PEEK32(CRT_DISPLAY_CTRL), CRT_DISPLAY_CTRL, BLANK, crtdb));
- 	}
- 
- 	if (output->paths & sm750_panel)
- 		POKE32(PANEL_DISPLAY_CTRL, FIELD_VALUE(PEEK32(PANEL_DISPLAY_CTRL), PANEL_DISPLAY_CTRL, DATA, pps));
- 
- 	return 0;
- }
- 
- 
- void hw_sm750_initAccel(struct sm750_dev *sm750_dev)
- {
- 	u32 reg;
- 
- 	enable2DEngine(1);
- 
- 	if (getChipType() == SM750LE) {
- 		reg = PEEK32(DE_STATE1);
- 		reg = FIELD_SET(reg, DE_STATE1, DE_ABORT, ON);
- 		POKE32(DE_STATE1, reg);
- 
- 		reg = PEEK32(DE_STATE1);
- 		reg = FIELD_SET(reg, DE_STATE1, DE_ABORT, OFF);
- 		POKE32(DE_STATE1, reg);
- 
- 	} else {
- 		/* engine reset */
- 		reg = PEEK32(SYSTEM_CTRL);
- 	    reg = FIELD_SET(reg, SYSTEM_CTRL, DE_ABORT, ON);
- 		POKE32(SYSTEM_CTRL, reg);
- 
- 		reg = PEEK32(SYSTEM_CTRL);
- 		reg = FIELD_SET(reg, SYSTEM_CTRL, DE_ABORT, OFF);
- 		POKE32(SYSTEM_CTRL, reg);
- 	}
- 
- 	/* call 2d init */
- 	sm750_dev->accel.de_init(&sm750_dev->accel);
- }
- 
- int hw_sm750le_deWait(void)
- {
- 	int i = 0x10000000;
- 
- 	while (i--) {
- 		unsigned int dwVal = PEEK32(DE_STATE2);
- 
- 		if ((FIELD_GET(dwVal, DE_STATE2, DE_STATUS) == DE_STATE2_DE_STATUS_IDLE) &&
- 			(FIELD_GET(dwVal, DE_STATE2, DE_FIFO)  == DE_STATE2_DE_FIFO_EMPTY) &&
- 			(FIELD_GET(dwVal, DE_STATE2, DE_MEM_FIFO) == DE_STATE2_DE_MEM_FIFO_EMPTY)) {
- 			return 0;
- 		}
- 	}
- 	/* timeout error */
- 	return -1;
- }
- 
- 
- int hw_sm750_deWait(void)
- {
- 	int i = 0x10000000;
- 
- 	while (i--) {
- 		unsigned int dwVal = PEEK32(SYSTEM_CTRL);
- 
- 		if ((FIELD_GET(dwVal, SYSTEM_CTRL, DE_STATUS) == SYSTEM_CTRL_DE_STATUS_IDLE) &&
- 			(FIELD_GET(dwVal, SYSTEM_CTRL, DE_FIFO)  == SYSTEM_CTRL_DE_FIFO_EMPTY) &&
- 			(FIELD_GET(dwVal, SYSTEM_CTRL, DE_MEM_FIFO) == SYSTEM_CTRL_DE_MEM_FIFO_EMPTY)) {
- 			return 0;
- 		}
- 	}
- 	/* timeout error */
- 	return -1;
- }
- 
- int hw_sm750_pan_display(struct lynxfb_crtc *crtc,
- 	const struct fb_var_screeninfo *var,
- 	const struct fb_info *info)
- {
- 	uint32_t total;
- 	/* check params */
- 	if ((var->xoffset + var->xres > var->xres_virtual) ||
- 	    (var->yoffset + var->yres > var->yres_virtual)) {
- 		return -EINVAL;
- 	}
- 
- 	total = var->yoffset * info->fix.line_length +
- 		((var->xoffset * var->bits_per_pixel) >> 3);
- 	total += crtc->oScreen;
- 	if (crtc->channel == sm750_primary) {
- 		POKE32(PANEL_FB_ADDRESS,
- 			FIELD_VALUE(PEEK32(PANEL_FB_ADDRESS),
- 				PANEL_FB_ADDRESS, ADDRESS, total));
- 	} else {
- 		POKE32(CRT_FB_ADDRESS,
- 			FIELD_VALUE(PEEK32(CRT_FB_ADDRESS),
- 				CRT_FB_ADDRESS, ADDRESS, total));
- 	}
- 	return 0;
- }
--- 0 ----
diff -rcNP linux-4.4.24/drivers/staging/sm750fb/swi2c.c linux-4.4.24-baikal/drivers/staging/sm750fb/swi2c.c
*** linux-4.4.24/drivers/staging/sm750fb/swi2c.c	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/drivers/staging/sm750fb/swi2c.c	2016-11-11 14:49:54.000000000 +0300
***************
*** 0 ****
--- 1,461 ----
+ /*******************************************************************
+ *
+ *         Copyright (c) 2007 by Silicon Motion, Inc. (SMI)
+ *
+ *  All rights are reserved. Reproduction or in part is prohibited
+ *  without the written consent of the copyright owner.
+ *
+ *  swi2c.c --- SM750/SM718 DDK
+ *  This file contains the source code for I2C using software
+ *  implementation.
+ *
+ *******************************************************************/
+ #include "help.h"
+ #include "reg.h"
+ #include "swi2c.h"
+ #include "power.h"
+ 
+ /*******************************************************************
+  * I2C Software Master Driver:
+  * ===========================
+  * Each i2c cycle is split into 4 sections. Each of these section marks
+  * a point in time where the SCL or SDA may be changed.
+  *
+  * 1 Cycle == |  Section I. |  Section 2. |  Section 3. |  Section 4. |
+  *            +-------------+-------------+-------------+-------------+
+  *            | SCL set LOW |SCL no change| SCL set HIGH|SCL no change|
+  *
+  *                                          ____________ _____________
+  * SCL == XXXX _____________ ____________ /
+  *
+  * I.e. the SCL may only be changed in section 1. and section 3. while
+  * the SDA may only be changed in section 2. and section 4. The table
+  * below gives the changes for these 2 lines in the varios sections.
+  *
+  * Section changes Table:
+  * ======================
+  * blank = no change, L = set bit LOW, H = set bit HIGH
+  *
+  *                                | 1.| 2.| 3.| 4.|
+  *                 ---------------+---+---+---+---+
+  *                 Tx Start   SDA |   | H |   | L |
+  *                            SCL | L |   | H |   |
+  *                 ---------------+---+---+---+---+
+  *                 Tx Stop    SDA |   | L |   | H |
+  *                            SCL | L |   | H |   |
+  *                 ---------------+---+---+---+---+
+  *                 Tx bit H   SDA |   | H |   |   |
+  *                            SCL | L |   | H |   |
+  *                 ---------------+---+---+---+---+
+  *                 Tx bit L   SDA |   | L |   |   |
+  *                            SCL | L |   | H |   |
+  *                 ---------------+---+---+---+---+
+  *
+  ******************************************************************/
+ 
+ /* GPIO pins used for this I2C. It ranges from 0 to 63. */
+ static unsigned char sw_i2c_clk_gpio = DEFAULT_I2C_SCL;
+ static unsigned char sw_i2c_data_gpio = DEFAULT_I2C_SDA;
+ 
+ /*
+  *  Below is the variable declaration for the GPIO pin register usage for the i2c Clock and i2c Data.
+  *
+  *  Note:
+  *      Notice that the GPIO usage for the i2c clock and i2c Data are
+  *      separated. This is to make this code flexible enough when
+  *      two separate GPIO pins for the clock and data are located
+  *      in two different GPIO register set (worst case).
+  */
+ 
+ /* i2c Clock GPIO Register usage */
+ static unsigned long sw_i2c_clk_gpio_mux_reg = GPIO_MUX;
+ static unsigned long sw_i2c_clk_gpio_data_reg = GPIO_DATA;
+ static unsigned long sw_i2c_clk_gpio_data_dir_reg = GPIO_DATA_DIRECTION;
+ 
+ /* i2c Data GPIO Register usage */
+ static unsigned long sw_i2c_data_gpio_mux_reg = GPIO_MUX;
+ static unsigned long sw_i2c_data_gpio_data_reg = GPIO_DATA;
+ static unsigned long sw_i2c_data_gpio_data_dir_reg = GPIO_DATA_DIRECTION;
+ 
+ /*
+  *  This function puts a delay between command
+  */
+ static void sw_i2c_wait(void)
+ {
+     /* find a bug:
+      * peekIO method works well before suspend/resume
+      * but after suspend, peekIO(0x3ce,0x61)&0x10
+      * always be non-zero,which makes the while loop
+      * never finish.
+      * use non-ultimate for loop below is safe
+      * */
+ 
+     /* Change wait algorithm to use PCI bus clock, it's more reliable than counter loop .. write 0x61 to 0x3ce and read from 0x3cf */
+     int i, tmp;
+ 
+     for (i = 0; i < 600; i++) {
+ 	tmp = i;
+ 	tmp += i;
+     }
+ }
+ 
+ /*
+  *  This function set/reset the SCL GPIO pin
+  *
+  *  Parameters:
+  *      value    - Bit value to set to the SCL or SDA (0 = low, 1 = high)
+  *
+  *  Notes:
+  *      When setting SCL to high, just set the GPIO as input where the pull up
+  *      resistor will pull the signal up. Do not use software to pull up the
+  *      signal because the i2c will fail when other device try to drive the
+  *      signal due to SM50x will drive the signal to always high.
+  */
+ static void sw_i2c_scl(unsigned char value)
+ {
+     unsigned long gpio_data;
+     unsigned long gpio_dir;
+ 
+     gpio_dir = PEEK32(sw_i2c_clk_gpio_data_dir_reg);
+     if (value) {    /* High */
+ 	gpio_dir &= ~(1<<sw_i2c_clk_gpio);	/* Set direction as input. This will automatically pull the signal up.*/
+ 	POKE32(sw_i2c_clk_gpio_data_dir_reg, gpio_dir);
+     } else {        /* Low */
+ 	gpio_data = PEEK32(sw_i2c_clk_gpio_data_reg);
+ 	gpio_data &= ~(1<<sw_i2c_clk_gpio);	/* Set the signal down */
+ 	POKE32(sw_i2c_clk_gpio_data_reg, gpio_data);
+ 
+ 	gpio_dir |= (1<<sw_i2c_clk_gpio);	/* Set direction as output */
+ 	POKE32(sw_i2c_clk_gpio_data_dir_reg, gpio_dir);
+     }
+ }
+ 
+ /*
+  *  This function set/reset the SDA GPIO pin
+  *
+  *  Parameters:
+  *      value    - Bit value to set to the SCL or SDA (0 = low, 1 = high)
+  *
+  *  Notes:
+  *      When setting SCL to high, just set the GPIO as input where the pull up
+  *      resistor will pull the signal up. Do not use software to pull up the
+  *      signal because the i2c will fail when other device try to drive the
+  *      signal due to SM50x will drive the signal to always high.
+  */
+ static void sw_i2c_sda(unsigned char value)
+ {
+     unsigned long gpio_data;
+     unsigned long gpio_dir;
+ 
+     gpio_dir = PEEK32(sw_i2c_data_gpio_data_dir_reg);
+     if (value) {    /* High */
+ 	gpio_dir &= ~(1<<sw_i2c_data_gpio);		/* Set direction as input. This will automatically pull the signal up. */
+ 	POKE32(sw_i2c_data_gpio_data_dir_reg, gpio_dir);
+     } else {        /* Low */
+ 	gpio_data = PEEK32(sw_i2c_data_gpio_data_reg);
+ 	gpio_data &= ~(1<<sw_i2c_data_gpio);		/* Set the signal down */
+ 	POKE32(sw_i2c_data_gpio_data_reg, gpio_data);
+ 
+ 	gpio_dir |= (1<<sw_i2c_data_gpio);		/* Set direction as output */
+ 	POKE32(sw_i2c_data_gpio_data_dir_reg, gpio_dir);
+     }
+ }
+ 
+ /*
+  *  This function read the data from the SDA GPIO pin
+  *
+  *  Return Value:
+  *      The SDA data bit sent by the Slave
+  */
+ static unsigned char sw_i2c_read_sda(void) {
+     unsigned long gpio_dir;
+     unsigned long gpio_data;
+     unsigned long dir_mask = 1<<sw_i2c_data_gpio;
+ 
+     /* Make sure that the direction is input (High) */
+     gpio_dir = PEEK32(sw_i2c_data_gpio_data_dir_reg);
+     if ((gpio_dir&dir_mask) != ~dir_mask) {
+ 	gpio_dir &= ~(1<<sw_i2c_data_gpio);
+ 	POKE32(sw_i2c_data_gpio_data_dir_reg, gpio_dir);
+     }
+ 
+     /* Now read the SDA line */
+     gpio_data = PEEK32(sw_i2c_data_gpio_data_reg);
+     if (gpio_data&(1<<sw_i2c_data_gpio))
+ 	return 1;
+     else
+ 	return 0;
+ }
+ 
+ /*
+  *  This function sends ACK signal
+  */
+ static void sw_i2c_ack(void)
+ {
+     return;  /* Single byte read is ok without it. */
+ }
+ 
+ /*
+  *  This function sends the start command to the slave device
+  */
+ static void sw_i2c_start(void) {sw_i2c_sda(1);sw_i2c_scl(1);sw_i2c_sda(0);}
+ 
+ /*
+  *  This function sends the stop command to the slave device
+  */
+ static void sw_i2c_stop(void) {sw_i2c_scl(1);sw_i2c_sda(0);sw_i2c_sda(1);}
+ 
+ /*
+  *  This function writes one byte to the slave device
+  *
+  *  Parameters:
+  *      data    - Data to be write to the slave device
+  *
+  *  Return Value:
+  *       0   - Success
+  *      -1   - Fail to write byte
+  */
+ static long sw_i2c_write_byte(unsigned char data)
+ {
+     unsigned char value = data;
+     int i;
+ 
+     /* Sending the data bit by bit */
+     for (i = 0; i < 8; i++) {
+ 	/* Set SCL to low */
+ 	sw_i2c_scl(0);
+ 
+ 	/* Send data bit */
+ 	if ((value&0x80) != 0)
+ 	    sw_i2c_sda(1);
+ 	else
+ 	    sw_i2c_sda(0);
+ 
+ 	sw_i2c_wait();
+ 
+ 	/* Toggle clk line to one */
+ 	sw_i2c_scl(1);
+ 	sw_i2c_wait();
+ 
+ 	/* Shift byte to be sent */
+ 	value = value<<1;
+     }
+ 
+     /* Set the SCL Low and SDA High (prepare to get input) */
+     sw_i2c_scl(0);
+     sw_i2c_sda(1);
+ 
+     /* Set the SCL High for ack */
+     sw_i2c_wait();
+     sw_i2c_scl(1);
+     sw_i2c_wait();
+ 
+     /* Read SDA, until SDA==0 */
+     for (i = 0; i < 0xff; i++) {
+ 	if (!sw_i2c_read_sda())
+ 	    break;
+ 
+ 	sw_i2c_scl(0);
+ 	sw_i2c_wait();
+ 	sw_i2c_scl(1);
+ 	sw_i2c_wait();
+     }
+ 
+     /* Set the SCL Low and SDA High */
+     sw_i2c_scl(0);
+     sw_i2c_sda(1);
+ 
+     if (i < 0xff)
+ 	return 0;
+     else
+ 	return -1;
+ }
+ 
+ /*
+  *  This function reads one byte from the slave device
+  *
+  *  Parameters:
+  *      ack    - Flag to indicate either to send the acknowledge
+  *            message to the slave device or not
+  *
+  *  Return Value:
+  *      One byte data read from the Slave device
+  */
+ static unsigned char sw_i2c_read_byte(unsigned char ack)
+ {
+     int i;
+     unsigned char data = 0;
+ 
+     for (i = 7; i >= 0; i--) {
+ 	/* Set the SCL to Low and SDA to High (Input) */
+ 	sw_i2c_scl(0);
+ 	sw_i2c_sda(1);
+ 	sw_i2c_wait();
+ 
+ 	/* Set the SCL High */
+ 	sw_i2c_scl(1);
+ 	sw_i2c_wait();
+ 
+ 	/* Read data bits from SDA */
+ 	data |= (sw_i2c_read_sda()<<i);
+     }
+ 
+     if (ack)
+ 	sw_i2c_ack();
+ 
+     /* Set the SCL Low and SDA High */
+     sw_i2c_scl(0);
+     sw_i2c_sda(1);
+ 
+     return data;
+ }
+ 
+ /*
+  * This function initializes GPIO port for SW I2C communication.
+  *
+  * Parameters:
+  *      clk_gpio      - The GPIO pin to be used as i2c SCL
+  *      data_gpio     - The GPIO pin to be used as i2c SDA
+  *
+  * Return Value:
+  *      -1   - Fail to initialize the i2c
+  *       0   - Success
+  */
+ static long sm750le_i2c_init(unsigned char clk_gpio, unsigned char data_gpio)
+ {
+     int i;
+ 
+     //pr_info("$ <%s>\n", __func__);
+     /* Initialize the GPIO pin for the i2c Clock Register */
+     sw_i2c_clk_gpio_data_reg = GPIO_DATA_SM750LE;
+     sw_i2c_clk_gpio_data_dir_reg = GPIO_DATA_DIRECTION_SM750LE;
+ 
+     /* Initialize the Clock GPIO Offset */
+     sw_i2c_clk_gpio = clk_gpio;
+ 
+     /* Initialize the GPIO pin for the i2c Data Register */
+     sw_i2c_data_gpio_data_reg = GPIO_DATA_SM750LE;
+     sw_i2c_data_gpio_data_dir_reg = GPIO_DATA_DIRECTION_SM750LE;
+ 
+     /* Initialize the Data GPIO Offset */
+     sw_i2c_data_gpio = data_gpio;
+ 
+     /* Note that SM750LE don't have GPIO MUX and power is always on */
+ 
+     /* Clear the i2c lines. */
+     for (i = 0; i < 9; i++)
+ 	sw_i2c_stop();
+ 
+     return 0;
+ }
+ 
+ /*
+  * This function initializes the i2c attributes and bus
+  *
+  * Parameters:
+  *      clk_gpio      - The GPIO pin to be used as i2c SCL
+  *      data_gpio     - The GPIO pin to be used as i2c SDA
+  *
+  * Return Value:
+  *      -1   - Fail to initialize the i2c
+  *       0   - Success
+  */
+ long sw_i2c_init(unsigned char clk_gpio, unsigned char data_gpio)
+ {
+     int i;
+ 
+     //pr_info("$ <%s>\n", __func__);
+     /* Return 0 if the GPIO pins to be used is out of range. The range is only from [0..63] */
+     if ((clk_gpio > 31) || (data_gpio > 31))
+ 	return -1;
+ 
+     if (getChipType() == SM750LE)
+ 	return sm750le_i2c_init(clk_gpio, data_gpio);
+ 
+     /* Initialize the GPIO pin for the i2c Clock Register */
+     sw_i2c_clk_gpio_mux_reg = GPIO_MUX;
+     sw_i2c_clk_gpio_data_reg = GPIO_DATA;
+     sw_i2c_clk_gpio_data_dir_reg = GPIO_DATA_DIRECTION;
+ 
+     /* Initialize the Clock GPIO Offset */
+     sw_i2c_clk_gpio = clk_gpio;
+ 
+     /* Initialize the GPIO pin for the i2c Data Register */
+     sw_i2c_data_gpio_mux_reg = GPIO_MUX;
+     sw_i2c_data_gpio_data_reg = GPIO_DATA;
+     sw_i2c_data_gpio_data_dir_reg = GPIO_DATA_DIRECTION;
+ 
+     /* Initialize the Data GPIO Offset */
+     sw_i2c_data_gpio = data_gpio;
+ 
+     /* Enable the GPIO pins for the i2c Clock and Data (GPIO MUX) */
+     POKE32(sw_i2c_clk_gpio_mux_reg, PEEK32(sw_i2c_clk_gpio_mux_reg)&~(1<<sw_i2c_clk_gpio));
+     POKE32(sw_i2c_data_gpio_mux_reg, PEEK32(sw_i2c_data_gpio_mux_reg)&~(1<<sw_i2c_data_gpio));
+ 
+     /* Enable GPIO power */
+     enableGPIO(1);
+ 
+     /* Clear the i2c lines. */
+     for (i = 0; i < 9; i++)
+ 	sw_i2c_stop();
+ 
+ return 0;
+ }
+ 
+ /*
+  *  This function reads the slave device's register
+  *
+  *  Parameters:
+  *      addr   - i2c Slave device address which register
+  *                        to be read from
+  *      reg    - Slave device's register to be read
+  *
+  *  Return Value:
+  *      Register value
+  */
+ unsigned char sw_i2c_read_reg(unsigned char addr, unsigned char reg)
+ {
+     unsigned char data;
+ 
+ 
+     sw_i2c_start();		/* Send the Start signal */
+     sw_i2c_write_byte(addr);	/* Send the device address */
+     sw_i2c_write_byte(reg);	/* Send the register index */
+     /* Get the bus again and get the data from the device read address */
+     sw_i2c_start();
+     sw_i2c_write_byte(addr + 1);
+     data = sw_i2c_read_byte(1);
+     sw_i2c_stop();	/* Stop swI2C and release the bus */
+ 
+     //pr_info("$ %02x:%02x) -> %02x\n", __func__, addr, reg, data);
+     return data;
+ }
+ 
+ /*
+  *  This function writes a value to the slave device's register
+  *
+  *  Parameters:
+  *      addr            - i2c Slave device address which register
+  *                        to be written
+  *      reg             - Slave device's register to be written
+  *      data            - Data to be written to the register
+  *
+  *  Result:
+  *          0   - Success
+  *         -1   - Fail
+  */
+ long sw_i2c_write_reg(unsigned char addr, unsigned char reg, unsigned char data)
+ {
+     long ret = 0;
+ 
+     //pr_info("$ %02x:%02x <- %02x\n", __func__, addr, reg, data);
+     sw_i2c_start();	/* Send the Start signal */
+ 
+     /* Send the device address and read the data. All should return success in order for the writing processed to be successful */
+     if ((sw_i2c_write_byte(addr) != 0) || (sw_i2c_write_byte(reg) != 0) || (sw_i2c_write_byte(data) != 0)) {
+ 	ret = -1;
+     }
+     sw_i2c_stop();	/* Stop i2c and release the bus */
+ 
+     return ret;
+ }
diff -rcNP linux-4.4.24/drivers/staging/sm750fb/swi2c.h linux-4.4.24-baikal/drivers/staging/sm750fb/swi2c.h
*** linux-4.4.24/drivers/staging/sm750fb/swi2c.h	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/drivers/staging/sm750fb/swi2c.h	2016-11-11 14:49:54.000000000 +0300
***************
*** 0 ****
--- 1,61 ----
+ /*******************************************************************
+ *
+ *         Copyright (c) 2007 by Silicon Motion, Inc. (SMI)
+ *
+ *  All rights are reserved. Reproduction or in part is prohibited
+ *  without the written consent of the copyright owner.
+ *
+ *  swi2c.h --- SM750/SM718 DDK
+ *  This file contains the definitions for i2c using software
+ *  implementation.
+ *
+ *******************************************************************/
+ #ifndef _SWI2C_H_
+ #define _SWI2C_H_
+ 
+ /* Default i2c CLK and Data GPIO. These are the default i2c pins */
+ #define DEFAULT_I2C_SCL                     30
+ #define DEFAULT_I2C_SDA                     31
+ 
+ /*
+  * This function initializes the i2c attributes and bus
+  *
+  * Parameters:
+  *      i2cClkGPIO  - The GPIO pin to be used as i2c SCL
+  *      i2cDataGPIO - The GPIO pin to be used as i2c SDA
+  *
+  * Return Value:
+  *      -1   - Fail to initialize the i2c
+  *       0   - Success
+  */
+ long sw_i2c_init(unsigned char clk_gpio, unsigned char data_gpio);
+ 
+ /*
+  *  This function reads the slave device's register
+  *
+  *  Parameters:
+  *      addr   - i2c Slave device address which register
+  *                        to be read from
+  *      reg    - Slave device's register to be read
+  *
+  *  Return Value:
+  *      Register value
+  */
+ unsigned char sw_i2c_read_reg(unsigned char addr, unsigned char reg);
+ 
+ /*
+  *  This function writes a value to the slave device's register
+  *
+  *  Parameters:
+  *      addr            - i2c Slave device address which register
+  *                        to be written
+  *      reg             - Slave device's register to be written
+  *      data            - Data to be written to the register
+  *
+  *  Result:
+  *          0   - Success
+  *         -1   - Fail
+  */
+ long sw_i2c_write_reg(unsigned char addr, unsigned char reg, unsigned char data);
+ 
+ #endif
diff -rcNP linux-4.4.24/drivers/usb/core/quirks.c linux-4.4.24-baikal/drivers/usb/core/quirks.c
*** linux-4.4.24/drivers/usb/core/quirks.c	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/usb/core/quirks.c	2016-11-11 14:49:54.000000000 +0300
***************
*** 198,203 ****
--- 198,206 ----
  	{ USB_DEVICE(0x1908, 0x1315), .driver_info =
  			USB_QUIRK_HONOR_BNUMINTERFACES },
  
+ 	/* USB2422 */
+ 	{ USB_DEVICE(0x0424, 0x2422), .driver_info = USB_QUIRK_RESET_RESUME },
+ 
  	/* Protocol and OTG Electrical Test Device */
  	{ USB_DEVICE(0x1a0a, 0x0200), .driver_info =
  			USB_QUIRK_LINEAR_UFRAME_INTR_BINTERVAL },
diff -rcNP linux-4.4.24/drivers/usb/dwc3/dwc3-baikal.c linux-4.4.24-baikal/drivers/usb/dwc3/dwc3-baikal.c
*** linux-4.4.24/drivers/usb/dwc3/dwc3-baikal.c	1970-01-01 03:00:00.000000000 +0300
--- linux-4.4.24-baikal/drivers/usb/dwc3/dwc3-baikal.c	2016-11-11 14:48:07.000000000 +0300
***************
*** 0 ****
--- 1,124 ----
+ /**
+  * dwc3-baikal.c - Baikal Electronics SoCs Specific Glue layer
+  *
+  * Copyright (C) 2015 Baikal Electronics JSC - http://www.baikalelectronics.ru
+  *
+  * Author: Dmitry Dunaev <dmitry.dunaev@baikalelectronics.ru>
+  *
+  * This program is free software: you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License version 2  of
+  * the License as published by the Free Software Foundation.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  */
+ 
+ #include <linux/clk.h>
+ #include <linux/module.h>
+ #include <linux/kernel.h>
+ #include <linux/interrupt.h>
+ #include <linux/platform_device.h>
+ #include <linux/dma-mapping.h>
+ #include <linux/usb/usb_phy_generic.h>
+ #include <linux/io.h>
+ #include <linux/of_platform.h>
+ 
+ struct dwc3_baikal {
+ 	struct device	*dev;
+ 	struct clk	*clk;
+ };
+ 
+ static int be_dwc3_probe(struct platform_device *pdev)
+ {
+ 	struct device		*dev = &pdev->dev;
+ 	struct device_node	*node = pdev->dev.of_node;
+ 	struct dwc3_baikal	*dwc;
+ 	int			ret;
+ 
+ 	dwc = devm_kzalloc(dev, sizeof(*dwc), GFP_KERNEL);
+ 	if (!dwc)
+ 		return -ENOMEM;
+ 
+ 	ret = dma_coerce_mask_and_coherent(dev, DMA_BIT_MASK(32));
+ 	if (ret)
+ 		return ret;
+ 
+ 	platform_set_drvdata(pdev, dwc);
+ 	dwc->dev = dev;
+ 
+ 	dwc->clk = devm_clk_get(dwc->dev, "usb");
+ 	if (IS_ERR(dwc->clk)) {
+ 		dev_err(dev, "no interface clk specified\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	ret = clk_prepare_enable(dwc->clk);
+ 	if (ret < 0) {
+ 		dev_err(dwc->dev, "unable to enable usb clock\n");
+ 		return ret;
+ 	}
+ 
+ 	if (node) {
+ 			ret = of_platform_populate(node, NULL, NULL, dev);
+ 			if (ret) {
+ 				dev_err(&pdev->dev, "failed to create dwc3 core\n");
+ 				goto __error;
+ 			}
+ 	} else {
+ 		dev_err(dev, "no device node, failed to add dwc3 core\n");
+ 		ret = -ENODEV;
+ 		goto __error;
+ 	}
+ 
+ 	return 0;
+ 
+ __error:
+ 	clk_disable_unprepare(dwc->clk);
+ 
+ 	return ret;
+ }
+ 
+ static int be_dwc3_remove_core(struct device *dev, void *c)
+ {
+ 	struct platform_device *pdev = to_platform_device(dev);
+ 
+ 	platform_device_unregister(pdev);
+ 
+ 	return 0;
+ }
+ 
+ static int be_dwc3_remove(struct platform_device *pdev)
+ {
+ 	struct dwc3_baikal *dwc = platform_get_drvdata(pdev);
+ 
+ 	device_for_each_child(&pdev->dev, NULL, be_dwc3_remove_core);
+ 	clk_disable_unprepare(dwc->clk);
+ 
+ 	platform_set_drvdata(pdev, NULL);
+ 
+ 	return 0;
+ }
+ 
+ static const struct of_device_id be_dwc3_of_match[] = {
+ 	{ .compatible = "be,baikal-dwc3", },
+ 	{},
+ };
+ MODULE_DEVICE_TABLE(of, be_dwc3_of_match);
+ 
+ static struct platform_driver be_dwc3_driver = {
+ 	.probe		= be_dwc3_probe,
+ 	.remove		= be_dwc3_remove,
+ 	.driver		= {
+ 		.name	= "baikal-dwc3",
+ 		.of_match_table	= be_dwc3_of_match,
+ 	},
+ };
+ 
+ module_platform_driver(be_dwc3_driver);
+ 
+ MODULE_ALIAS("platform:baikal-dwc3");
+ MODULE_AUTHOR("Dmitry Dunaev <dmitry.dunaev@baikalelectronics.ru>");
+ MODULE_LICENSE("GPL v2");
+ MODULE_DESCRIPTION("DesignWare USB3 Baikal SoCs Glue Layer");
diff -rcNP linux-4.4.24/drivers/usb/dwc3/Kconfig linux-4.4.24-baikal/drivers/usb/dwc3/Kconfig
*** linux-4.4.24/drivers/usb/dwc3/Kconfig	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/usb/dwc3/Kconfig	2016-11-11 14:49:54.000000000 +0300
***************
*** 104,107 ****
--- 104,136 ----
  	  Recent Qualcomm SoCs ship with one DesignWare Core USB3 IP inside,
  	  say 'Y' or 'M' if you have one such device.
  
+ config USB_DWC3_BAIKAL
+ 	tristate "Baikal Electronics Platforms"
+ 	depends on MIPS_BAIKAL && OF
+ 	default USB_DWC3
+ 	help
+ 	  Baikal Electronics SoCs with one DesignWare Core USB3 IP
+ 	  inside.
+ 	  Say 'Y' or 'M' if you have one such device.
+ 
+ comment "Debugging features"
+ 
+ config USB_DWC3_DEBUG
+ 	bool "Enable Debugging Messages"
+ 	help
+ 	  Say Y here to enable debugging messages on DWC3 Driver.
+ 
+ config USB_DWC3_VERBOSE
+ 	bool "Enable Verbose Debugging Messages"
+ 	depends on USB_DWC3_DEBUG
+ 	help
+ 	  Say Y here to enable verbose debugging messages on DWC3 Driver.
+ 
+ config DWC3_HOST_USB3_LPM_ENABLE
+ 	bool "Enable USB3 LPM Capability"
+ 	depends on USB_DWC3_HOST=y || USB_DWC3_DUAL_ROLE=y
+ 	default n
+ 	help
+ 	  Select this when you want to enable USB3 LPM with dwc3 xhci host.
+ 
  endif
diff -rcNP linux-4.4.24/drivers/usb/dwc3/Makefile linux-4.4.24-baikal/drivers/usb/dwc3/Makefile
*** linux-4.4.24/drivers/usb/dwc3/Makefile	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/drivers/usb/dwc3/Makefile	2016-11-11 14:49:54.000000000 +0300
***************
*** 39,41 ****
--- 39,42 ----
  obj-$(CONFIG_USB_DWC3_KEYSTONE)		+= dwc3-keystone.o
  obj-$(CONFIG_USB_DWC3_QCOM)		+= dwc3-qcom.o
  obj-$(CONFIG_USB_DWC3_ST)		+= dwc3-st.o
+ obj-$(CONFIG_USB_DWC3_BAIKAL)		+= dwc3-baikal.o
diff -rcNP linux-4.4.24/include/linux/irqchip/mips-gic.h linux-4.4.24-baikal/include/linux/irqchip/mips-gic.h
*** linux-4.4.24/include/linux/irqchip/mips-gic.h	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/include/linux/irqchip/mips-gic.h	2016-11-11 14:49:55.000000000 +0300
***************
*** 246,251 ****
--- 246,270 ----
  #define GIC_SHARED_TO_HWIRQ(x)	(GIC_SHARED_HWIRQ_BASE + (x))
  #define GIC_HWIRQ_TO_SHARED(x)	((x) - GIC_SHARED_HWIRQ_BASE)
  
+ #define GIC_WD_CTRL_START_SHFT	0
+ #define GIC_WD_CTRL_START_MSK	(MSK(1) << GIC_WD_CTRL_START_SHFT)
+ #define GIC_WD_CTRL_TYPE_SHFT	1
+ #define GIC_WD_CTRL_TYPE_MSK	(MSK(3) << GIC_WD_CTRL_START_SHFT)
+ #define GIC_WD_CTRL_DBG_SHFT	4
+ #define GIC_WD_CTRL_DBG_MSK		(MSK(1) << GIC_WD_CTRL_DBG_SHFT)
+ #define GIC_WD_CTRL_WAIT_SHFT	5
+ #define GIC_WD_CTRL_WAIT_MSK	(MSK(1) << GIC_WD_CTRL_WAIT_SHFT)
+ #define GIC_WD_CTRL_WDINTR_SHFT	6
+ #define GIC_WD_CTRL_WDINTR_MSK	(MSK(1) << GIC_WD_CTRL_WDINTR_SHFT)
+ #define GIC_WD_CTRL_WDRST_SHFT	7
+ #define GIC_WD_CTRL_WDRST_MSK	(MSK(1) << GIC_WD_CTRL_WDRST_SHFT)
+ #define GIC_WD_CTRL_GEN_SHFT	8
+ #define GIC_WD_CTRL_GEN_MSK		(MSK(1) << GIC_WD_CTRL_GEN_SHFT)
+ 
+ #define GIC_WD_CTRL_TYPE_SC		0
+ #define GIC_WD_CTRL_TYPE_OT		1
+ #define GIC_WD_CTRL_TYPE_PIT	2
+ 
  #ifdef CONFIG_MIPS_GIC
  
  extern unsigned int gic_present;
***************
*** 261,269 ****
--- 280,300 ----
  extern void gic_write_cpu_compare(cycle_t cnt, int cpu);
  extern void gic_start_count(void);
  extern void gic_stop_count(void);
+ extern unsigned int gic_read_wd_ctrl(void);
+ extern void gic_write_wd_ctrl(unsigned int ctrl);
+ extern void gic_write_cpu_wd_ctrl(unsigned int ctrl, int cpu);
+ extern void gic_start_wd(void);
+ extern void gic_start_cpu_wd(int cpu);
+ extern void gic_stop_wd(void);
+ extern void gic_stop_cpu_wd(int cpu);
+ extern unsigned int gic_read_wd_count(void);
+ extern unsigned int gic_read_wd_initial(void);
+ extern void gic_write_wd_initial(unsigned int cnt);
+ extern void gic_write_cpu_wd_initial(unsigned int cnt, int cpu);
  extern void gic_send_ipi(unsigned int intr);
  extern unsigned int plat_ipi_call_int_xlate(unsigned int);
  extern unsigned int plat_ipi_resched_int_xlate(unsigned int);
+ extern int gic_get_c0_wd_int(void);
  extern int gic_get_c0_compare_int(void);
  extern int gic_get_c0_perfcount_int(void);
  extern int gic_get_c0_fdc_int(void);
diff -rcNP linux-4.4.24/include/linux/marvell_phy.h linux-4.4.24-baikal/include/linux/marvell_phy.h
*** linux-4.4.24/include/linux/marvell_phy.h	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/include/linux/marvell_phy.h	2016-11-11 14:49:55.000000000 +0300
***************
*** 18,23 ****
--- 18,25 ----
  #define MARVELL_PHY_ID_88E1510		0x01410dd0
  #define MARVELL_PHY_ID_88E1540		0x01410eb0
  #define MARVELL_PHY_ID_88E3016		0x01410e60
+ #define MARVELL_PHY_ID_88X2222		0x01410f10
+ #define MARVELL_PHY_ID_88X2222R		0x014131b0
  
  /* struct phy_device dev_flags definitions */
  #define MARVELL_PHY_M1145_FLAGS_RESISTANCE	0x00000001
diff -rcNP linux-4.4.24/include/linux/netdev_features.h linux-4.4.24-baikal/include/linux/netdev_features.h
*** linux-4.4.24/include/linux/netdev_features.h	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/include/linux/netdev_features.h	2016-11-11 14:49:56.000000000 +0300
***************
*** 150,155 ****
--- 150,157 ----
  #define NETIF_F_V4_CSUM		(NETIF_F_GEN_CSUM | NETIF_F_IP_CSUM)
  #define NETIF_F_V6_CSUM		(NETIF_F_GEN_CSUM | NETIF_F_IPV6_CSUM)
  #define NETIF_F_ALL_CSUM	(NETIF_F_V4_CSUM | NETIF_F_V6_CSUM)
+ #define NETIF_F_CSUM_MASK	(NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM | \
+ 				 NETIF_F_HW_CSUM)
  
  #define NETIF_F_ALL_TSO 	(NETIF_F_TSO | NETIF_F_TSO6 | NETIF_F_TSO_ECN)
  
diff -rcNP linux-4.4.24/include/linux/stmmac.h linux-4.4.24-baikal/include/linux/stmmac.h
*** linux-4.4.24/include/linux/stmmac.h	2016-10-07 16:23:59.000000000 +0300
--- linux-4.4.24-baikal/include/linux/stmmac.h	2016-11-11 14:49:56.000000000 +0300
***************
*** 90,105 ****
  	int pbl;
  	int fixed_burst;
  	int mixed_burst;
! 	int burst_len;
  };
  
  struct plat_stmmacenet_data {
- 	char *phy_bus_name;
  	int bus_id;
  	int phy_addr;
  	int interface;
  	struct stmmac_mdio_bus_data *mdio_bus_data;
  	struct device_node *phy_node;
  	struct stmmac_dma_cfg *dma_cfg;
  	int clk_csr;
  	int has_gmac;
--- 90,119 ----
  	int pbl;
  	int fixed_burst;
  	int mixed_burst;
! 	bool aal;
! };
! 
! #define AXI_BLEN	7
! struct stmmac_axi {
! 	bool axi_lpi_en;
! 	bool axi_xit_frm;
! 	u32 axi_wr_osr_lmt;
! 	u32 axi_rd_osr_lmt;
! 	bool axi_kbbe;
! 	bool axi_axi_all;
! 	u32 axi_blen[AXI_BLEN];
! 	bool axi_fb;
! 	bool axi_mb;
! 	bool axi_rb;
  };
  
  struct plat_stmmacenet_data {
  	int bus_id;
  	int phy_addr;
  	int interface;
  	struct stmmac_mdio_bus_data *mdio_bus_data;
  	struct device_node *phy_node;
+ 	struct device_node *mdio_node;
  	struct stmmac_dma_cfg *dma_cfg;
  	int clk_csr;
  	int has_gmac;
***************
*** 122,126 ****
--- 136,141 ----
  	int (*init)(struct platform_device *pdev, void *priv);
  	void (*exit)(struct platform_device *pdev, void *priv);
  	void *bsp_priv;
+ 	struct stmmac_axi *axi;
  };
  #endif
